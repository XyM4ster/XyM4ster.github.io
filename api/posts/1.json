{"total":25,"pageSize":12,"pageCount":3,"data":[{"title":"c-foundation","uid":"b0a93238f82a932edf767e45b4ea1889","slug":"c-foundation","date":"2024-01-06T07:19:07.000Z","updated":"2024-01-06T07:19:07.089Z","comments":true,"path":"api/articles/c-foundation.json","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"汇编指令","uid":"0eefe6b6118865b181e289b1081cce4b","slug":"汇编指令","date":"2024-01-06T07:18:53.000Z","updated":"2024-01-06T14:17:05.439Z","comments":true,"path":"api/articles/汇编指令.json","cover":null,"text":"汇编指令Q：PUSHAD (将所有寄存器的值压入栈) PUSHAD &#x2F;&#x2F;是一个x86汇编指令，用于将通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）的值依次压入堆栈中。该指令的作用 &#x2F;&#x2F;是保存这些寄存器的值，以便...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"汇编","slug":"汇编","count":1,"path":"api/tags/汇编.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"巅峰极客","uid":"cdb488d648a90943d7354784532a6374","slug":"巅峰极客","date":"2023-07-31T12:38:30.000Z","updated":"2023-08-01T09:17:46.710Z","comments":true,"path":"api/articles/巅峰极客.json","cover":[],"text":"巅峰极客hellosql 这个题我知道是时间延迟注入，也知道用笛卡尔积，但是我当时的方法就是测不出来 过滤了* if 空格 时间延迟我当时用的是 SELECT A.table_name FROM information_schema.columns A, information_...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"leetcode刷题","uid":"2db13004f026edb4056c7fbb5f3564d1","slug":"leetcode刷题","date":"2023-12-25T02:34:41.000Z","updated":"2023-12-25T14:23:23.164Z","comments":true,"path":"api/articles/leetcode刷题.json","cover":[],"text":"数组二分法思路这里直接用左闭右开的写法，定义target在[left,right)区间内 那么有下面几点： while(left &lt; right)，因为left &#x3D;&#x3D; right是没有意义的 if(nums[middle] &gt; target)，ri...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"cpp-foundation","uid":"30361bdf78f1e8e77dddafcd5ecaa82e","slug":"cpp-foundation","date":"2023-12-05T13:12:59.000Z","updated":"2023-12-05T14:14:50.016Z","comments":true,"path":"api/articles/cpp-foundation.json","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"c++","slug":"c","count":1,"path":"api/tags/c.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"re-engineer-core-principle-03","uid":"449c952c21adaaa0689becdb96065fd3","slug":"re-engineer-core-principle-03","date":"2023-12-05T02:11:20.000Z","updated":"2024-01-07T06:39:34.820Z","comments":true,"path":"api/articles/re-engineer-core-principle-03.json","cover":[],"text":"引言 第三部分冲冲冲 这一部分要把没见过的汇编单独整理到一个文档里 0x21 Windows消息钩取21.1 钩子(Hook)Q：钩子 就是偷看或截取信息所有的手段或者工具 21.2 消息钩子Q：常规Windows信息流 发生键盘输人事件时，WM_KEYDOWN消息被添加到[OS...","link":"","photos":[],"count_time":{"symbolsCount":"49k","symbolsTime":"44 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":3,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"HOPPER-CCS-2023","uid":"ac1f5803919fdd2ccf7eeca40ae91dc2","slug":"HOPPER-CCS-2023","date":"2023-11-14T02:06:39.000Z","updated":"2023-11-16T14:37:40.378Z","comments":true,"path":"api/articles/HOPPER-CCS-2023.json","cover":[],"text":"ABSTRACTQ：现有的fuzz drivers的问题 不能完全覆盖entries in libraries 他们的质量取决于开发人员对于代码的理解 Q：提出的Hopper 可以fuzz libraries 不需要其他的知识去craft fuzz drivers 把fuzz l...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"ODDFUZZ","uid":"9b08663ab6515ce746fcfc5eb13ac547","slug":"ODDFUZZ-SP-2023","date":"2023-11-07T02:18:56.000Z","updated":"2023-11-14T02:05:35.644Z","comments":true,"path":"api/articles/ODDFUZZ-SP-2023.json","cover":[],"text":"ABSTRACTQ：对于Java反序列化漏洞，现有的解决方式 static analysis和fuzz生成POC，用序列化的对象触发漏洞 但是存在有效性和效率的问题 Q：本文方法 提出一个轻量级的static taint analysis去识别调用链 ODDFUZZ尽力locat...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"},{"name":"Fuzz","slug":"Fuzz","count":1,"path":"api/tags/Fuzz.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"re-engineer-core-principle-02","uid":"1e07b60d2029aa2ea6483727894829df","slug":"re-engineer-core-principle-02","date":"2023-10-22T08:39:11.000Z","updated":"2023-12-03T14:13:29.805Z","comments":true,"path":"api/articles/re-engineer-core-principle-02.json","cover":[],"text":"引言 开启《逆向工程核心原理》的第二部分，冲冲冲！ 0x13 PE文件格式13.1 介绍PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。 PE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":3,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"re-engineer-core-principle-01","uid":"e67072c96c2129e60add5b77588d8afa","slug":"re-engineer-core-principle-01","date":"2023-10-22T08:36:19.000Z","updated":"2023-10-22T08:36:50.636Z","comments":true,"path":"api/articles/re-engineer-core-principle-01.json","cover":[],"text":"引言看《逆向工程核心原理》这本书 好久之前看了这本书的一部分，现在决定重新学一下。 感觉逆向十分重要，且我的hxd wd-2711 (https://wd-2711.tech/) ，一直在学逆向，在他的感染下，我也开始学。 0x01 关于逆向工程 静态分析法：并不执行代码，观察代...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":3,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Tai-e-Static-Analysis-Framework-OOPSLA'23","uid":"e225c813c8f4b0b48846cd97578ebb48","slug":"Tai-e-Static-Analysis-Framework-OOPSLA-23","date":"2023-10-17T01:44:12.000Z","updated":"2023-10-18T09:35:53.722Z","comments":true,"path":"api/articles/Tai-e-Static-Analysis-Framework-OOPSLA-23.json","cover":[],"text":"引言 这篇论文是我看谭老师课题组的第二篇文章，因为对于静态分析一直停留在理论，想着要看看代码，自己试试 ABSTRACT静态分析在Bug detection、安全分析、程序解释、优化等方面已经非常成熟。 静态分析在IR生成、confrol flow graph、control f...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Context-Sensitivity-without-Contexts-PLDI23","uid":"39f6a6f9864fa629c2ab8230b6f47fbc","slug":"Context-Sensitivity-without-Contexts-PLDI23","date":"2023-10-08T05:40:18.000Z","updated":"2023-10-18T09:35:51.585Z","comments":true,"path":"api/articles/Context-Sensitivity-without-Contexts-PLDI23.json","cover":[],"text":"引言 学完了南大软件分析的课程，关注了谭老师的个人主页。 想着看一篇论文，能对学的内容有更好的理解。 AbstractQ1：首先说上下文敏感的做法 在不同上下文中分析，分离方法变量，和堆对象，也就是同时应用上下文敏感和堆上下文敏感 Q2：但是这种方法带来了问题： 因为需要clon...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}