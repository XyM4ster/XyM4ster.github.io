{"total":29,"pageSize":12,"pageCount":3,"data":[{"title":"re-engineer-core-principle-07","uid":"ad9b5bba7260fe69f150a16ce9de4386","slug":"re-engineer-core-principle-07","date":"2024-01-30T14:45:03.000Z","updated":"2024-02-28T14:46:10.615Z","comments":true,"path":"api/articles/re-engineer-core-principle-07.json","cover":[],"text":"引言 终于到第七部分了，快看完了 0x50 反调试技术50.1 反调试技术 反调试技术有很强的依赖性。有些反调试技术仅在特定版本的os下工作 本章的大部分技术可以用在Windows XP SP3(32位)和Win7 32位下 50.3 反调试技术分类 根据破解方法分成静态和动态两...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"re-engineer-core-principle-06","uid":"080514f34f3fd257fa211ebeac34b223","slug":"re-engineer-core-principle-06","date":"2024-01-23T03:31:18.000Z","updated":"2024-02-28T14:44:30.192Z","comments":true,"path":"api/articles/re-engineer-core-principle-06.json","cover":[],"text":"引言 快看完了，加油冲冲冲！希望回家前看完 0x45 TLS回调函数 TLS(Thread Local Storage 线程局部存储)回调函数(Callback function)常用于反调试。 TLS回调函数的运行要先于EP代码的执行，因此它可以作为一种反调试技术使用 45.1...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"巅峰极客","uid":"cdb488d648a90943d7354784532a6374","slug":"巅峰极客","date":"2023-07-31T12:38:30.000Z","updated":"2023-08-01T09:17:46.710Z","comments":true,"path":"api/articles/巅峰极客.json","cover":[],"text":"巅峰极客hellosql 这个题我知道是时间延迟注入，也知道用笛卡尔积，但是我当时的方法就是测不出来 过滤了* if 空格 时间延迟我当时用的是 SELECT A.table_name FROM information_schema.columns A, information_...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"re-engineer-core-principle-05","uid":"16f33ed3c99a8cc9a4a675e2c29d6341","slug":"re-engineer-core-principle-05","date":"2024-01-14T14:13:18.000Z","updated":"2024-02-28T14:44:02.915Z","comments":true,"path":"api/articles/re-engineer-core-principle-05.json","cover":[],"text":"引言 上一部分学的很快，集中看了一周就学完了，希望可以快点把这本书看完，然后用起来 0x36 64位计算36.1 64位计算环境Q：操作系统的演化 1985年 Intel 推出了 80386 CPU芯片 1995年 Miscrosoft发布 32位 Windows 95，计算机正...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"re-engineer-core-principle-04","uid":"3a44a24f5a69ff4f99f1bd18acd6c0b5","slug":"re-engineer-core-principle-04","date":"2024-01-07T10:57:34.000Z","updated":"2024-01-23T03:31:38.000Z","comments":true,"path":"api/articles/re-engineer-core-principle-04.json","cover":[],"text":"引言 第三部分学了好久，主要是因为中间参加了两次面试，但是最后也没有去上实习，害！ 还是好好努力学习吧 0x29 API钩取29.1 钩取Q：钩取(Hook)的整个流程如下 使用反汇编器&#x2F;调试器把握程序的结构与工作原理 开发需要的“钩子”代码，用于修改 Bug、改善程序...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"c-foundation","uid":"b0a93238f82a932edf767e45b4ea1889","slug":"c-foundation","date":"2024-01-06T07:19:07.000Z","updated":"2024-01-06T07:19:07.089Z","comments":true,"path":"api/articles/c-foundation.json","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"汇编指令","uid":"0eefe6b6118865b181e289b1081cce4b","slug":"汇编指令","date":"2024-01-06T07:18:53.000Z","updated":"2024-01-06T14:17:05.439Z","comments":true,"path":"api/articles/汇编指令.json","cover":null,"text":"汇编指令Q：PUSHAD (将所有寄存器的值压入栈) PUSHAD &#x2F;&#x2F;是一个x86汇编指令，用于将通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）的值依次压入堆栈中。该指令的作用 &#x2F;&#x2F;是保存这些寄存器的值，以便...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"汇编","slug":"汇编","count":1,"path":"api/tags/汇编.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"leetcode刷题","uid":"2db13004f026edb4056c7fbb5f3564d1","slug":"leetcode刷题","date":"2023-12-25T02:34:41.000Z","updated":"2023-12-25T14:23:23.164Z","comments":true,"path":"api/articles/leetcode刷题.json","cover":[],"text":"数组二分法思路这里直接用左闭右开的写法，定义target在[left,right)区间内 那么有下面几点： while(left &lt; right)，因为left &#x3D;&#x3D; right是没有意义的 if(nums[middle] &gt; target)，ri...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"cpp-foundation","uid":"30361bdf78f1e8e77dddafcd5ecaa82e","slug":"cpp-foundation","date":"2023-12-05T13:12:59.000Z","updated":"2023-12-05T14:14:50.016Z","comments":true,"path":"api/articles/cpp-foundation.json","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"c++","slug":"c","count":1,"path":"api/tags/c.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"re-engineer-core-principle-03","uid":"449c952c21adaaa0689becdb96065fd3","slug":"re-engineer-core-principle-03","date":"2023-12-05T02:11:20.000Z","updated":"2024-01-07T06:39:34.820Z","comments":true,"path":"api/articles/re-engineer-core-principle-03.json","cover":[],"text":"引言 第三部分冲冲冲 这一部分要把没见过的汇编单独整理到一个文档里 0x21 Windows消息钩取21.1 钩子(Hook)Q：钩子 就是偷看或截取信息所有的手段或者工具 21.2 消息钩子Q：常规Windows信息流 发生键盘输人事件时，WM_KEYDOWN消息被添加到[OS...","link":"","photos":[],"count_time":{"symbolsCount":"49k","symbolsTime":"44 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"HOPPER-CCS-2023","uid":"ac1f5803919fdd2ccf7eeca40ae91dc2","slug":"HOPPER-CCS-2023","date":"2023-11-14T02:06:39.000Z","updated":"2023-11-16T14:37:40.378Z","comments":true,"path":"api/articles/HOPPER-CCS-2023.json","cover":[],"text":"ABSTRACTQ：现有的fuzz drivers的问题 不能完全覆盖entries in libraries 他们的质量取决于开发人员对于代码的理解 Q：提出的Hopper 可以fuzz libraries 不需要其他的知识去craft fuzz drivers 把fuzz l...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"ODDFUZZ","uid":"9b08663ab6515ce746fcfc5eb13ac547","slug":"ODDFUZZ-SP-2023","date":"2023-11-07T02:18:56.000Z","updated":"2023-11-14T02:05:35.644Z","comments":true,"path":"api/articles/ODDFUZZ-SP-2023.json","cover":[],"text":"ABSTRACTQ：对于Java反序列化漏洞，现有的解决方式 static analysis和fuzz生成POC，用序列化的对象触发漏洞 但是存在有效性和效率的问题 Q：本文方法 提出一个轻量级的static taint analysis去识别调用链 ODDFUZZ尽力locat...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"},{"name":"Fuzz","slug":"Fuzz","count":1,"path":"api/tags/Fuzz.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}