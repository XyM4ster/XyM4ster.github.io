{"title":"wmctf","uid":"9b333f38efd344acbd675306690f4b47","slug":"wmctf","date":"2023-08-29T05:32:25.000Z","updated":"2023-10-18T09:28:22.561Z","comments":true,"path":"api/articles/wmctf.json","keywords":null,"cover":null,"content":"<ol>\n<li><code>BOOT-INF</code>目录：这个目录通常是在使用Spring Boot框架时出现的。它是用于打包可执行的JAR文件的特殊目录。在这个目录下，通常包含了应用程序的所有依赖项（JAR文件）和应用程序的类文件。<strong>这些类文件可以包括Spring Boot的启动类、配置类以及其他应用程序的自定义类</strong>。</li>\n<li><code>META-INF</code>目录：这个目录是Java项目中的标准目录，用于存放项目的元数据信息。在这个目录下，通常包含了一些重要的配置文件和清单文件。例如，<code>MANIFEST.MF</code>文件通常位于<code>META-INF</code>目录下，其中包含了关于JAR文件的元数据信息，如版本号、作者、依赖关系等。此外，一些框架和库也会在<code>META-INF</code>目录下存放一些特定的配置文件，用于配置其行为和功能。</li>\n<li><code>org</code>目录：<strong>这个目录通常是在Java项目中的包结构下出现的。它是用来组织Java类的包名空间的一部分。在这个目录下，通常包含了项目的Java类文件和包结构</strong>。例如，<code>org.example.app</code>是一个典型的包名，其中<code>org</code>是根包，<code>example</code>是中间包，<code>app</code>是具体的包名。</li>\n</ol>\n","text":" BOOT-INF目录：这个目录通常是在使用Spring Boot框架时出现的。它是用于打包可执行的JAR文件的特殊目录。在这个目录下，通常包含了应用程序的所有依赖项（JAR文件）和应用程序的类文件。这些类文件可以包括Spring Boot的启动类、配置类以及其他应用程序的自定义...","link":"","photos":[],"count_time":{"symbolsCount":462,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"toc":"","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Program-Analysis-03","uid":"6d51a8663bc5dbf1359ee897f7f5225c","slug":"Program-Analysis-03","date":"2023-09-01T14:31:42.000Z","updated":"2023-10-26T15:37:57.261Z","comments":true,"path":"api/articles/Program-Analysis-03.json","keywords":null,"cover":[],"text":"Interprocedural AnalysisMotivation（为什么需要过程间分析呢）问题1：之前学到都是过程内分析，但是肯定会有方法调用，那该怎么办呢？ 之前都是会做最保守的假设，也就是最安全的假设 对于常量分析而言，就假设不是常量 下面的 x y n对于过程内分析(i...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Program-Analysis-02","uid":"b13dd1cbb7113adce1a453324fe7b9f4","slug":"Program-Analysis-02","date":"2023-08-26T15:30:43.000Z","updated":"2023-10-26T15:37:45.041Z","comments":true,"path":"api/articles/Program-Analysis-02.json","keywords":null,"cover":[],"text":"Control Flow Analysis控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。 需要构建Control Flow Graph(CFG) CF...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}