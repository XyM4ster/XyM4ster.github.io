{"title":"汇编指令","uid":"0eefe6b6118865b181e289b1081cce4b","slug":"汇编指令","date":"2024-01-06T07:18:53.000Z","updated":"2024-01-06T14:17:05.439Z","comments":true,"path":"api/articles/汇编指令.json","keywords":null,"cover":null,"content":"<h1 id=\"汇编指令\"><a href=\"#汇编指令\" class=\"headerlink\" title=\"汇编指令\"></a>汇编指令</h1><p><strong>Q：PUSHAD (将所有寄存器的值压入栈)</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">PUSHAD  &#x2F;&#x2F;是一个x86汇编指令，用于将通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）的值依次压入堆栈中。该指令的作用\t\t  \n\t\t&#x2F;&#x2F;是保存这些寄存器的值，以便在稍后的代码中使用或恢复。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>首先使用PUSHAD命令将EAX~EDI寄存器的值保存到栈</li>\n<li>然后分别把第二个节区的起始地址(01011000)与第一个节区的起始地址(01001000)设置到ESI与EDI寄存器。</li>\n</ul>\n<p><strong>Q：LEA指令(加载有效地址)</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">LEA EDI, DWORD PTR DS:[ESI+FFFF0000]\n加载有效地址（Load Effective Address）指令，用于将指定内存地址的有效地址计算结果存储到目标寄存器 EDI 中\n\n&quot;LEA&quot; 是加载有效地址的指令。\n&quot;EDI&quot; 是目标寄存器，表示要将有效地址计算结果存储到 EDI 寄存器中。\n&quot;DWORD PTR&quot; 是一个操作数大小指示符，表示要操作的是一个双字（32位）数据。\n&quot;DS:[ESI+FFFF0000]&quot; 是指定的内存地址，表示要对 DS:ESI+FFFF0000 指向的内存地址进行有效地址计算。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>- </p>\n<p>汇编指令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MOV AL,BYTE PTR DS:[EDX] &#x2F;&#x2F;类型转换为BYTE，是8位，AL是AX(16位寄存器)的低8位\nINC EDX &#x2F;&#x2F;给EDX加1\nDEC EDX &#x2F;&#x2F;给EDX减1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p><strong>Q：JNZ指令</strong></p>\n<p>JNZ是x86汇编指令中的条件跳转指令，它的全称是”Jump if Not Zero”，表示在某个条件下，如果结果不为0，也就是零标志位不被设置时，则执行跳转操作。</p>\n<p>具体解释如下：</p>\n<p>JNZ：是条件跳转指令的助记符，它用于根据零标志位（ZF）的值来进行有条件的跳转。<br>零标志位（ZF）：是一个标志位寄存器中的一个标志位，用于指示上一次运算结果是否为零。如果上一次运算结果为零，ZF被设置为1，否则为0。<br>JNZ指令的操作步骤如下：</p>\n<p>如果ZF为0（上一次运算结果不为零），则执行跳转到指定的目标地址。<br>如果ZF为1（上一次运算结果为零），则不执行跳转，继续顺序执行下一条指令。</p>\n<p><strong>Q：LODS指令</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MOV ESI,10011B0\nLODS DWORD PTR DS:[ESI]  \n\n&#x2F;&#x2F;&quot;LODS&quot; 指令是 &quot;Load String&quot; 的缩写，用于加载字符串或数据块\nDWORD PTR&quot; 用于指定操作数的大小，这里表示操作数是一个双字（32位）\n&quot;DS:[ESI]&quot; 是一个内存引用，表示从段寄存器 DS 所指向的段中，以 ESI 寄存器中的值作为偏移地址来访问内存<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>这两条指令的意思是从10011B0中<strong>加载4字节的数据，保存到EAX中</strong></li>\n</ul>\n<p><strong>Q：REP指令</strong></p>\n<ul>\n<li><p>汇编指令,它会重复执行复制字符串，直到ECX计数器为0</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">REP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]\n\nREP&quot; 是一个前缀指令，用于指示指令重复执行。\n&quot;MOVS&quot; 是 &quot;Move String&quot; 的缩写，用于将字符串或数据块从一个内存位置复制到另一个内存位置。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示每次传送的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据复制到 ES:EDI 指向的内存位置。\n&quot;DS:[ESI]&quot; 是源地址，表示要从 DS:ESI 指向的内存位置读取数据。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p><strong>Q：STOS指令</strong></p>\n<ul>\n<li><p>汇编指令:会把累加器中的数据存储到EDI中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">STOS BYTE PTR ES:[EDI]\n\n&quot;STOS&quot; 是 &quot;Store String&quot; 的缩写，用于将字符串或数据块存储到内存中。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示要存储的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据存储到 ES:EDI 指向的内存位置<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p><strong>&#x3D;&#x3D;问题：为什么已经有了MOVS，还需要LODS和STOPS呢&#x3D;&#x3D;</strong></p>\n<p><strong>Q：XCHG指令</strong></p>\n<p>XCHG DL, BH</p>\n<p>“XCHG” 是 “Exchange” 的缩写，它用于交换两个操作数的值。在这种情况下，指令将 DL 寄存器和 BH 寄存器的值进行交换。</p>\n<p>具体执行的步骤如下：</p>\n<p>将 DL 寄存器的值存储到临时存储区。<br>将 BH 寄存器的值复制到 DL 寄存器中。<br>最后，将之前存储在临时存储区的值复制到 BH 寄存器中。<br>这条指令可以用于在汇编语言中交换两个寄存器的值，以实现数据的重新排列或交换。</p>\n<h1 id=\"Ollydbg常用快捷键\"><a href=\"#Ollydbg常用快捷键\" class=\"headerlink\" title=\"Ollydbg常用快捷键\"></a>Ollydbg常用快捷键</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">Assemble(Space):输入汇编代码\nAnalysis(Ctrl+A):再次分析代码New origin here(Ctrl+Gray*):更改EIP<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n","feature":true,"text":"汇编指令Q：PUSHAD (将所有寄存器的值压入栈) PUSHAD &#x2F;&#x2F;是一个x86汇编指令，用于将通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）的值依次压入堆栈中。该指令的作用 &#x2F;&#x2F;是保存这些寄存器的值，以便...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"汇编","slug":"汇编","count":1,"path":"api/tags/汇编.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">汇编指令</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Ollydbg%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE\"><span class=\"toc-text\">Ollydbg常用快捷键</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"c-foundation","uid":"b0a93238f82a932edf767e45b4ea1889","slug":"c-foundation","date":"2024-01-06T07:19:07.000Z","updated":"2024-01-06T07:19:07.089Z","comments":true,"path":"api/articles/c-foundation.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"巅峰极客","uid":"cdb488d648a90943d7354784532a6374","slug":"巅峰极客","date":"2023-07-31T12:38:30.000Z","updated":"2023-08-01T09:17:46.710Z","comments":true,"path":"api/articles/巅峰极客.json","keywords":null,"cover":[],"text":"巅峰极客hellosql 这个题我知道是时间延迟注入，也知道用笛卡尔积，但是我当时的方法就是测不出来 过滤了* if 空格 时间延迟我当时用的是 SELECT A.table_name FROM information_schema.columns A, information_...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}