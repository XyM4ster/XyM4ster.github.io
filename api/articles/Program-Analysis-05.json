{"title":"Program-Analysis-05","uid":"f34c0862e405e67688bc815c83cfd9aa","slug":"Program-Analysis-05","date":"2023-09-16T13:35:49.000Z","updated":"2023-10-26T15:38:25.329Z","comments":true,"path":"api/articles/Program-Analysis-05.json","keywords":null,"cover":[],"content":"<h1 id=\"CFL-Reachability-and-IFDS\"><a href=\"#CFL-Reachability-and-IFDS\" class=\"headerlink\" title=\"CFL-Reachability and IFDS\"></a>CFL-Reachability and IFDS</h1><p><strong>Infeasible Paths：</strong></p>\n<ul>\n<li>PFG中不会被执行的边</li>\n</ul>\n<p>给定一个path，在静态时无法判断一条path是不是假边</p>\n<p><img src=\"/../Program-Analysis-05/image-20230923170828100.png\" alt=\"image-20230923170828100\"></p>\n<p>根据语义，age是年龄，那就一定大于0，所以右边这条红色的一定不会被执行。这样的path是infeasible path。</p>\n<p><img src=\"/../Program-Analysis-05/image-20230923170842992.png\" alt=\"image-20230923170842992\"></p>\n<ul>\n<li><p>考虑上下文不敏感的情况，那x 和y的结果会有-1。</p>\n</li>\n<li><p>指针分析中最右边走r的路径仍然不可避免。</p>\n</li>\n<li><p>但是因为上下文不敏感导致错误的返回是可以避免的</p>\n</li>\n</ul>\n<h2 id=\"Realizable-Paths\"><a href=\"#Realizable-Paths\" class=\"headerlink\" title=\"Realizable Paths\"></a>Realizable Paths</h2><p><img src=\"/../Program-Analysis-05/image-20230923173422879.png\" alt=\"image-20230923173422879\"></p>\n<p>Realizable Paths：return应该和相应的call匹配</p>\n<ul>\n<li>Realizable path可能不会被执行，但是unealizable path应该一定不能被执行(也就是从1的call进来，不能从2的return出去)</li>\n</ul>\n<p>因此现在的目标就变成了<strong>找到Realizable path</strong></p>\n<p>那如何找呢？</p>\n<p>CFL-Reachability</p>\n<h2 id=\"CFL-Reachability-context-free-language\"><a href=\"#CFL-Reachability-context-free-language\" class=\"headerlink\" title=\"CFL-Reachability(context free language)\"></a>CFL-Reachability(context free language)</h2><h3 id=\"Context-free-grammar-CFG\"><a href=\"#Context-free-grammar-CFG\" class=\"headerlink\" title=\"Context-free grammar(CFG)\"></a>Context-free grammar(CFG)</h3><p>CFG是形式语言的描述方法，CFG 中的产生式规则由两部分组成：一个非终结符和一个由终结符和非终结符组成的符号串</p>\n<p>​\t\t$S-&gt;\\alpha$</p>\n<p>S表示非终结符，$\\alpha$表示终结符或者非终结符，或者空。</p>\n<p><img src=\"/../Program-Analysis-05/image-20230923172708894.png\" alt=\"image-20230923172708894\"></p>\n<h3 id=\"CFL-Reachability\"><a href=\"#CFL-Reachability\" class=\"headerlink\" title=\"CFL-Reachability\"></a>CFL-Reachability</h3><p>用括号匹配的方式完成上面提出的问题，实现每一个call都对应它的return。</p>\n<p><img src=\"/../Program-Analysis-05/image-20230923173819872.png\" alt=\"image-20230923173819872\"></p>\n<p>通过CFL进行括号匹配</p>\n<ul>\n<li>每个右括号都要有一个左括号，但是不是每一个左括号都有一个右括号<ul>\n<li>因为前面表示return要有对应的call，先有了左括号，才会有右括号的事。但是不是有左括号，就一定有右括号，因为可能程序还没有执行到return。</li>\n</ul>\n</li>\n<li>每个call site i，call edge是 (i，return edge 是)i，给每个edge都加了一个Label，也就是括号</li>\n</ul>\n<p><img src=\"/../Program-Analysis-05/image-20231011152614451.png\" alt=\"image-20231011152614451\"></p>\n<p>A path是一个realizable path，如果path的word在Language L中。</p>\n<p>推导这个匹配的过程</p>\n<p>对于realizable</p>\n<ul>\n<li>对于1，realizable -&gt; matched realizable，mathed就是已经匹配的，对应1中的绿色部分</li>\n<li>第一个式子，就是个递归，realizable -&gt; $(_i realizable$,也就可以匹配多个单括号的情况，也就是2</li>\n</ul>\n<p>对于matched：</p>\n<ul>\n<li>matched 可以是一个e，也就是对应3  的情况</li>\n<li>也可以是一个$\\varepsilon$，就是很多很多e</li>\n<li>最后这个matched matched对应4的情况</li>\n</ul>\n<p><img src=\"/../Program-Analysis-05/image-20231011154049504.png\" alt=\"image-20231011154049504\"></p>\n<ul>\n<li>应用上面的规则，左边就是realizable path，右边就不是realizable path</li>\n</ul>\n<h2 id=\"IFDS\"><a href=\"#IFDS\" class=\"headerlink\" title=\"IFDS\"></a>IFDS</h2><p>A Program Analysis Framework via Graph Reachablity</p>\n<ul>\n<li>通过图可达性进行程序分析</li>\n</ul>\n<p><img src=\"/../Program-Analysis-05/image-20231011154726914.png\" alt=\"image-20231011154726914\"></p>\n<p>IFDS是<strong>interprocedural,Finite,Distributive, Subset Problem</strong></p>\n<ul>\n<li><p>interprocedural：全程序分析</p>\n</li>\n<li><p>Finite： domain是finite</p>\n</li>\n<li><p>distributive：分发的</p>\n</li>\n</ul>\n<p>IFDS提供了MRP solution。</p>\n<h3 id=\"Meet-Over-All-Realizable-Paths（MRP）\"><a href=\"#Meet-Over-All-Realizable-Paths（MRP）\" class=\"headerlink\" title=\"Meet-Over-All-Realizable-Paths（MRP）\"></a>Meet-Over-All-Realizable-Paths（MRP）</h3><p><img src=\"/../Program-Analysis-05/image-20231011155237626.png\" alt=\"image-20231011155237626\"></p>\n<ul>\n<li>MOP是所有边都应用transfer function</li>\n<li>MRP是只对realizable path应用transfer funciton</li>\n</ul>\n<h3 id=\"Overview-of-IFDS\"><a href=\"#Overview-of-IFDS\" class=\"headerlink\" title=\"Overview of IFDS\"></a>Overview of IFDS</h3><p><img src=\"/../Program-Analysis-05/image-20231011161625201.png\" alt=\"image-20231011161625201\"></p>\n<p>是一个程序分析框架</p>\n<p>给定一个程序P，和一个分析问题Q</p>\n<ul>\n<li>构建一个supergraph，理解成前面讲的ICFG，并且定义了flow function，也就是图1中蓝色的部分</li>\n<li>构建一个**exploded supergraph **G#，把flow function转换成了representation relations</li>\n<li>最后在G#上遍历，解决Q</li>\n</ul>\n<p>最后，n是一个program point，d属于MRP，如果有一个realizable path在G#中，从S的main方法到n</p>\n<h4 id=\"Supergraph\"><a href=\"#Supergraph\" class=\"headerlink\" title=\"Supergraph\"></a>Supergraph</h4><p><img src=\"/../Program-Analysis-05/image-20231011162148173.png\" alt=\"image-20231011162148173\"></p>\n<p>G*代表supergrah</p>\n<ul>\n<li>G*是一个collection，包括所有的G1,G2</li>\n<li>每个Gp都有一个start node 和一个exit node</li>\n<li>把call方法变成了一个call node 和一个return site node</li>\n</ul>\n<p><img src=\"/../Program-Analysis-05/image-20231011162430640.png\" alt=\"image-20231011162430640\"></p>\n<p>这里有3种边</p>\n<ul>\n<li>intraprocedural call-return edge：紫色部分</li>\n<li>call-to-start edge：绿色边</li>\n<li>exit-to-return edge：蓝色边</li>\n</ul>\n<h4 id=\"Design-Flow-Functions\"><a href=\"#Design-Flow-Functions\" class=\"headerlink\" title=\"Design Flow Functions\"></a>Design Flow Functions</h4><p><strong>$\\lambda$-expressions</strong></p>\n<p><img src=\"/../Program-Analysis-05/image-20231011163115884.png\" alt=\"image-20231011163115884\"></p>\n<ul>\n<li>是一个匿名函数</li>\n<li>$\\lambda e_{pardam}.e_{body}$,第一个是参数，第二个是Body</li>\n<li>($\\lambda x.x+1$)3，表示执行这个函数，输出就是4</li>\n</ul>\n<p><strong>design flow functions</strong></p>\n<p>目标是：判断是否被初始化</p>\n<p>认为未初始化是sound的。都假定未初始化都是1。</p>\n<p><img src=\"/../Program-Analysis-05/image-20231011164842258.png\" alt=\"image-20231011164842258\"></p>\n<ol>\n<li>程序中定义了x,g两个变量</li>\n<li>因为x已经被初始化了，把它从S中除去</li>\n<li>进入方法，所有的x由a替换</li>\n<li>g被初始化</li>\n<li>a-g的结果取决于，a和g两个，如果a和g中有一个没被初始化，a就没被初始化，加到S中，否则被出池化</li>\n<li>程序最后出来减去a</li>\n</ol>\n<p><strong>红框的内容，对应之前学的为什么要有call–&gt;return的边。</strong></p>\n<p><img src=\"/../Program-Analysis-05/image-20231011165547502.png\" alt=\"image-20231011165547502\"></p>\n<ul>\n<li><p>因为要传Local variable，在这里也就是传g</p>\n</li>\n<li><p>如果这里直接是$\\lambda S.S$，它也一定是sound的，你就认为它没初始化</p>\n</li>\n<li><p>为什么要减去g呢？</p>\n<ul>\n<li>首先程序是may analysis，也就是有一条边初始化了，就认为是初始化了，所以merge处是**+**</li>\n<li>那这里减去g就表示现在$\\lambda S.S$里面没有g，那最后有没有g完全由方法p决定，因为结果是+。方法里说定义了就是定义了，没定义就是没定义。</li>\n<li>如果不减，就默认，S中有g，一定会传下去，那就是不准的，因为并不知道会不会传下去。</li>\n</ul>\n<p><strong>关键点在于这个Merge的结果是什么。</strong></p>\n</li>\n</ul>\n<h4 id=\"Build-Exploded-Supergraph\"><a href=\"#Build-Exploded-Supergraph\" class=\"headerlink\" title=\"Build Exploded Supergraph\"></a>Build Exploded Supergraph</h4><h1 id=\"关于must-analysis-和-may-analysis的理解终极版\"><a href=\"#关于must-analysis-和-may-analysis的理解终极版\" class=\"headerlink\" title=\"关于must analysis 和 may analysis的理解终极版\"></a>关于must analysis 和 may analysis的理解终极版</h1><table>\n<thead>\n<tr>\n<th></th>\n<th>Reaching Definitons</th>\n<th>Live avaliable analysis</th>\n<th>avaliable expressions analysis</th>\n<th>变量是否初始化分析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>must&#x2F;may analysis</td>\n<td>may analysis</td>\n<td>may analysis</td>\n<td>must analysis</td>\n<td>may analysis</td>\n</tr>\n<tr>\n<td>unsafe的情况</td>\n<td>所有变量都不能到达</td>\n<td>所有变量都不活跃</td>\n<td>所有表达式都可用</td>\n<td>所有变量都未初始化</td>\n</tr>\n<tr>\n<td>safe but useful</td>\n<td>所有变量均可到达</td>\n<td>所有变量都活跃</td>\n<td>所有表达式都不可用</td>\n<td>所有变量都初始化</td>\n</tr>\n<tr>\n<td>目标</td>\n<td>找到未到达的变量，进行替换</td>\n<td>找到不活跃的变量进行替换</td>\n<td>对可用的表达式进行替换</td>\n<td>对未初始化的变量进行替换</td>\n</tr>\n<tr>\n<td>初始化(对应unsafe)</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>关于sound：</p>\n<p><img src=\"/../Program-Analysis-05/image-20231011212101731.png\" alt=\"image-20231011212101731\"></p>\n<p>大于目标的就是sound，那目标是找到不活跃的变量，所以sound就是所有的都不活跃。</p>\n<p>程序从unsafe也就是sound向safe分析。</p>\n<p><strong>Q1：第一步是判断是must analysis，还是May analysis</strong></p>\n<p>根据定义判断，<strong>有意义和无意义的结果要满足sound，&#x3D;&#x3D;是希望找到尽可能多的safe的结果&#x3D;&#x3D;，根据上面的may analysis view，分析从unsafe –&gt;safe，其实这里可以看出unsafe 就是sound</strong></p>\n<ul>\n<li>Reaching Definitions：定义是判断$D_i$是否有意义。也就是一条路径如果有意义，没有重新definitions，那就是有意义，所以是may analysis，对于Reaching Definitions，</li>\n<li>Live variables：一条路径用了这个变量，那就是有意义    <ul>\n<li>目标是找到不活跃的变量。</li>\n<li>假设所有变量都不活跃。</li>\n</ul>\n</li>\n<li>avaliable expressions：判断表达式是否可以被替换，也就是如果所有路径都算了，那就可以被替换。所以是must analysis</li>\n<li>constant propogate：所有路径都是一样的，才是常量，所以是must analysis</li>\n</ul>\n<p><strong>Q2：根据must(may) analysis，定义merge处是乘法(加法)</strong></p>\n<ul>\n<li>Reaching Definitions：加法</li>\n<li>Live variables：加法</li>\n<li>avaliable expressions：乘法</li>\n<li>constan propogate：乘法</li>\n</ul>\n<p><strong>Q3：关于初始化什么定义成1，什么定义成0</strong></p>\n<p>其实加法，显然应该全部初始化为0，目标是获得1.</p>\n<p>乘法全部初始化为1,目标是获得0。</p>\n<p><img src=\"/../Program-Analysis-05/image-20231011211537719.png\" alt=\"image-20231011211537719\"></p>\n<p><strong>为什么红框处是$\\lambda S.S-{g}$，而不是$\\lambda S.S$？</strong></p>\n<p>首先这个流程的最后结果会得到一个集合$\\lambda S.S$，而该集合是未定义变量的集合。这里和之前的May analysis的分析不太一样，我们之前得到的safe结果是活跃的变量的集合(定义的集合)。</p>\n<ol>\n<li>按照老师的理解：</li>\n</ol>\n<p>由于是may analysis，</p>\n<ul>\n<li>如果call返回的结果是未定义，那么$\\lambda S.S$中就会有g，会流出来，由于call-to-return边没有让g流出来，最后会流到下面。</li>\n<li>如果call返回的结果是定义了，也就是g不会流出来，而call-to-return边没有让g流出来，最后就不会流到下面。</li>\n<li>综上，结果正确。</li>\n</ul>\n<p>而如果该边是$\\lambda S.S$,最后结果无论怎样都认为g是未定义的，显然结果是不准的。</p>\n<ol start=\"2\">\n<li>按照正规我前面总结的表格分析：</li>\n</ol>\n<p>由于是may analysis，目标是让定义的变量尽可能的多，所以该边是$\\lambda S.S-{g}$</p>\n<ol start=\"3\">\n<li>按照我的理解：</li>\n</ol>\n<p>按照正规来说，这里应该定义未初始化的变量为0，初始化的变量为1。</p>\n<p>那么最后获得的集合，其实是一个定义变量的集合。</p>\n<p>也就和上图表示的不一样，上图获得的是一个定义变量的集合。</p>\n<ol start=\"4\">\n<li>按照上图定义1和0：</li>\n</ol>\n<p>如果按照上图来定义，那应该定义未初始化的变量为1，初始化的变量为0，此时最终获得的是未初始化的变量集合。</p>\n","text":"CFL-Reachability and IFDSInfeasible Paths： PFG中不会被执行的边 给定一个path，在静态时无法判断一条path是不是假边 根据语义，age是年龄，那就一定大于0，所以右边这条红色的一定不会被执行。这样的path是infeasible ...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CFL-Reachability-and-IFDS\"><span class=\"toc-text\">CFL-Reachability and IFDS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Realizable-Paths\"><span class=\"toc-text\">Realizable Paths</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CFL-Reachability-context-free-language\"><span class=\"toc-text\">CFL-Reachability(context free language)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-free-grammar-CFG\"><span class=\"toc-text\">Context-free grammar(CFG)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CFL-Reachability\"><span class=\"toc-text\">CFL-Reachability</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IFDS\"><span class=\"toc-text\">IFDS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Meet-Over-All-Realizable-Paths%EF%BC%88MRP%EF%BC%89\"><span class=\"toc-text\">Meet-Over-All-Realizable-Paths（MRP）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Overview-of-IFDS\"><span class=\"toc-text\">Overview of IFDS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Supergraph\"><span class=\"toc-text\">Supergraph</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Design-Flow-Functions\"><span class=\"toc-text\">Design Flow Functions</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Build-Exploded-Supergraph\"><span class=\"toc-text\">Build Exploded Supergraph</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Emust-analysis-%E5%92%8C-may-analysis%E7%9A%84%E7%90%86%E8%A7%A3%E7%BB%88%E6%9E%81%E7%89%88\"><span class=\"toc-text\">关于must analysis 和 may analysis的理解终极版</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"bottomupcs","uid":"280fda85aebd83efe2030df16a32f5ff","slug":"bottomupcs","date":"2023-09-20T08:43:17.000Z","updated":"2023-10-08T05:34:47.890Z","comments":true,"path":"api/articles/bottomupcs.json","keywords":null,"cover":null,"text":" 165d50f05814027fb7fe5e4ae8a088d8cabf1ea2d88ccf0f53dc7b0b289f333341828fd88b2557819d802f94103d3ae533a248f976fe4b8635c776fc2c174c3bf94982f99e8...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Program-Analysis-04","uid":"0c7c1359362e7af148487a65d7d4a6f0","slug":"Program-Analysis-04","date":"2023-09-09T15:34:02.000Z","updated":"2023-10-26T15:38:08.533Z","comments":true,"path":"api/articles/Program-Analysis-04.json","keywords":null,"cover":[],"text":"Static Analysis for securityInformation Flow Security目标 避免不想要的信息流 Access Control vs. Information Flow SecurityAccess Control 检查程序是否有权限 关心信息是...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}