{"title":"Program-Analysis-02","uid":"b13dd1cbb7113adce1a453324fe7b9f4","slug":"Program-Analysis-02","date":"2023-08-26T15:30:43.000Z","updated":"2023-10-26T15:37:45.041Z","comments":true,"path":"api/articles/Program-Analysis-02.json","keywords":null,"cover":[],"content":"<h1 id=\"Control-Flow-Analysis\"><a href=\"#Control-Flow-Analysis\" class=\"headerlink\" title=\"Control Flow Analysis\"></a>Control Flow Analysis</h1><p>控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。</p>\n<ul>\n<li>需要构建Control Flow Graph(CFG)</li>\n<li>CFG的node可以是一个单独的3AC，但是更常见的是一个Basic Blocks</li>\n</ul>\n<h2 id=\"Basic-Blocks\"><a href=\"#Basic-Blocks\" class=\"headerlink\" title=\"Basic Blocks\"></a>Basic Blocks</h2><p>需要满足以下性质：</p>\n<ul>\n<li>只能从块的第一条指令进入</li>\n<li>只能从块的最后一条指令离开</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<ul>\n<li>这个算法逻辑感很强，值得反复考虑</li>\n</ul>\n\n</div>\n<h3 id=\"构建node\"><a href=\"#构建node\" class=\"headerlink\" title=\"构建node\"></a>构建node</h3><ul>\n<li>入口只有一个，就是开始的指令</li>\n<li>出口只有一个，就是结束的指令</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230809111246762.png\" alt=\"image-20230809111246762\"></p>\n<p><img src=\"/../Program-Analysis-02/image-20230809112035790.png\" alt=\"image-20230809112035790\"></p>\n<p>方法：</p>\n<ol>\n<li>决定P的leaders：</li>\n</ol>\n<ul>\n<li><p>程序的第一条指令是leader</p>\n</li>\n<li><p>goto指向的指令是leader</p>\n</li>\n<li><p>跳转指令的后一条指令是leader</p>\n</li>\n</ul>\n<p>例子：</p>\n<ul>\n<li><p>从这个可以看出 因为(3)是(12)的target，所以(3)就不能放到第一个bbs中，否则程序有两个入口</p>\n</li>\n<li><p>(4)接下来有可能跳转到(7)，所以(5)就不能加进来，否则程序有两个出口</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>构建P的基本快</li>\n</ol>\n<ul>\n<li>就是从一个leader开始，到下一个leader的前一条指令</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230811225051270.png\" alt=\"image-20230811225051270\"></p>\n<h3 id=\"构建边\"><a href=\"#构建边\" class=\"headerlink\" title=\"构建边\"></a>构建边</h3><p>块A到块B有一条边当且仅当：</p>\n<ul>\n<li><p>A B之间有跳转，自然要添边</p>\n</li>\n<li><p>AB紧挨着，A块的最后一条指令紧挨着B的第一条指令</p>\n<ul>\n<li>这种AB之间需要一条边</li>\n<li>但是不能是无条件的跳转</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230811225843258.png\" alt=\"image-20230811225843258\"></p>\n</li>\n</ul>\n<p>从上可知</p>\n<ul>\n<li>由j–&gt;i的变化，变成从A—&gt;B的变换，现在变成了粗粒度的，也就是说A B之间指令的变换，也不影响跳转了。(原来假设i  变成i + 1，那 j–&gt; i，也要变成 j –&gt;i + 1)</li>\n</ul>\n<h3 id=\"构建CFG\"><a href=\"#构建CFG\" class=\"headerlink\" title=\"构建CFG\"></a>构建CFG</h3><ul>\n<li>除了构建好的基本块，我们还会额外添加两个结点，「入口（Entry）」和「出口（Exit）」</li>\n<li>这两个结点不对应任何 IR</li>\n<li>如果一个基本块的最后一条指令会让程序离开这段 IR，那么这个基本块就会有一条边指向出口。</li>\n<li>但是可能有个很多return，也就可能有很多出边</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230809115245878.png\" alt=\"image-20230809115245878\"></p>\n<p><img src=\"/../Program-Analysis-02/image-20230809115553127.png\" alt=\"image-20230809115553127\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：compilers 和 static analyzers静态分析器的关系</strong></p>\n<ul>\n<li>编译器的作用是将source code转换成machine code</li>\n<li>该过程中间经过词法分析、语法分析，语义分析，形成IR，静态分析器对IR进行分析。</li>\n</ul>\n<p><strong>Q2：3AC</strong></p>\n<ul>\n<li>3地址码就是中间表示intermediate representation，就是在字节码 和 机器码中间的一种表示</li>\n<li>在soot中，源代码—-&gt;字节码—&gt;jimple（也就是java的IR，Java Intermediate Language）—&gt; 机器码</li>\n</ul>\n<p><strong>Q3：在IR的top中如何构建basic blocks？</strong></p>\n<ul>\n<li>首先一个basic block包含了该部分中最大的3AC，满足只有一个入口，和一个出口</li>\n<li>接着，按照规则构建node，构建边，最后加上Entry和exit，就形成了完整的CFG。</li>\n</ul>\n<h1 id=\"Data-Flow-Analysis\"><a href=\"#Data-Flow-Analysis\" class=\"headerlink\" title=\"Data Flow Analysis\"></a>Data Flow Analysis</h1><h2 id=\"Data-Flow-Analysis-1\"><a href=\"#Data-Flow-Analysis-1\" class=\"headerlink\" title=\"Data Flow Analysis\"></a>Data Flow Analysis</h2><p>数据流分析的核心：How data Flows on CFG？</p>\n<ul>\n<li><p>对数据的抽象( +  - T  unknown等)</p>\n</li>\n<li><p>Flows：根据分析的类型，做出合适的估算，应该是sound的</p>\n</li>\n<li><p>Node：数据如何transfer(转换函数)，比如 + - </p>\n</li>\n<li><p>Edges：控制流如何处理</p>\n</li>\n<li><p>CFG：一个程序</p>\n</li>\n</ul>\n<p>不同的数据流分析，有着不同的data abstraction, flow safe-approximation策略，transfer functions&amp;control-flow handlings。</p>\n<h2 id=\"Preliminaries-of-Data-Flow-Analysis\"><a href=\"#Preliminaries-of-Data-Flow-Analysis\" class=\"headerlink\" title=\"Preliminaries of Data Flow Analysis\"></a>Preliminaries of Data Flow Analysis</h2><h3 id=\"Input-and-Output-States\"><a href=\"#Input-and-Output-States\" class=\"headerlink\" title=\"Input and Output States\"></a>Input and Output States</h3><ul>\n<li>每一条IR的执行，都让状态从<strong>输入状态</strong>变成新的<strong>输出状态</strong></li>\n<li>输入&#x2F;输出状态与语句前&#x2F;后的 <strong>program point</strong> 相关联。</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230811231809896.png\" alt=\"image-20230811231809896\"></p>\n<ul>\n<li>在数据流分析中，我们会把每个程序点关联一个数据值，代表从那一点中可观察到的抽象程序状态</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230811232044640.png\" alt=\"image-20230811232044640\"></p>\n<ul>\n<li>从pp中观察到抽象的状态，并组成一个集合</li>\n</ul>\n<h3 id=\"关于转移方程约束的概念\"><a href=\"#关于转移方程约束的概念\" class=\"headerlink\" title=\"关于转移方程约束的概念\"></a>关于转移方程约束的概念</h3><p><img src=\"/../Program-Analysis-02/image-20230811232328151.png\" alt=\"image-20230811232328151\"></p>\n<h3 id=\"关于控制流约束的概念\"><a href=\"#关于控制流约束的概念\" class=\"headerlink\" title=\"关于控制流约束的概念\"></a>关于控制流约束的概念</h3><p><img src=\"/../Program-Analysis-02/image-20230811232718115.png\" alt=\"image-20230811232718115\"></p>\n<ul>\n<li>B的所有前驱的out的meet构成B的输入</li>\n</ul>\n<h2 id=\"Data-Flow-Analysis-Applications\"><a href=\"#Data-Flow-Analysis-Applications\" class=\"headerlink\" title=\"Data Flow Analysis Applications\"></a>Data Flow Analysis Applications</h2><h3 id=\"不会涉及到的概念\"><a href=\"#不会涉及到的概念\" class=\"headerlink\" title=\"不会涉及到的概念\"></a>不会涉及到的概念</h3><p><img src=\"/../Program-Analysis-02/image-20230811033038211.png\" alt=\"image-20230811033038211\"></p>\n<ul>\n<li>首先不存在方法调用，讲的是函数内部的</li>\n<li>之后讲跨函数的</li>\n<li>变量不涉及引用，也就是没有两个变量指向一个空间，在指针分析中讲</li>\n</ul>\n<h3 id=\"Reaching-Definitions-Analysis\"><a href=\"#Reaching-Definitions-Analysis\" class=\"headerlink\" title=\"Reaching Definitions Analysis\"></a>Reaching Definitions Analysis</h3><p>may analysis: 理解成集合的union</p>\n<p>就是所有情况都得考虑，may be true的都被报出来</p>\n<p>也就是有一个是true就行，所以应该考虑所有的path，所以应该union</p>\n<p>must anaysis：理解成集合的交集^</p>\n<p><img src=\"/../Program-Analysis-02/image-20230810233602698.png\" alt=\"image-20230810233602698\"></p>\n<h4 id=\"Input-and-Output-States-1\"><a href=\"#Input-and-Output-States-1\" class=\"headerlink\" title=\"Input and Output States\"></a>Input and Output States</h4><p><img src=\"/../Program-Analysis-02/image-20230810233921862.png\" alt=\"image-20230810233921862\"></p>\n<p>绿色的是红色的抽象</p>\n<p>domain：值域</p>\n<p>对于程序中所有的in 和 out，找到一个solution,通过解析 safe-approximation中的约束规则，得出的solution 。这些约束规则基于transfer function(转换规则)，基于控制流信息</p>\n<p>通过解这些约束规则，得到solution</p>\n<ul>\n<li>用符号表示transer function</li>\n</ul>\n<h4 id=\"Transer-function\"><a href=\"#Transer-function\" class=\"headerlink\" title=\"Transer function\"></a>Transer function</h4><p><img src=\"/../Program-Analysis-02/image-20230811032034914.png\" alt=\"image-20230811032034914\"></p>\n<p>对bbs中的每个执行f，那么最后得到的结果就是bss的transer function</p>\n<p><img src=\"/../Program-Analysis-02/image-20230811032642576.png\" alt=\"image-20230811032642576\"></p>\n<p>反向的时候先执行 fsn的 transer function，再执行fsn-1，</p>\n<ul>\n<li>上面黄色的代表：B的所有前驱的out的meet构成B的in</li>\n<li>下面粉色的out：B的后继的in的meet</li>\n</ul>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>假定 x 有定值 d (<strong>definition</strong>)，如果存在一个路径，从紧随 d 的点到达某点 p，并且此路径上面没有 x 的其他定值点，则称 x 的定值 d 到达 (<strong>reaching</strong>) p。</li>\n<li>如果这条路径上有x的其他定值，我们就说x的这个定值被kill了</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230811033559511.png\" alt=\"image-20230811033559511\"></p>\n<ul>\n<li><p>到达定值可以用来分析未定义的变量。例如，我们在程序入口为各变量引入一个 dummy 定值。当程序出口的某变量定值依然为 dummy，则我们可以认为该变量未被定义。</p>\n</li>\n<li><p>对于一条赋值语句 D: v &#x3D; x op y，该语句生成了 v 的一个定值 D，并杀死程序中其它对变量 v 定义的定值。</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230812024517653.png\" alt=\"image-20230812024517653\"></p>\n<p><strong>说人话：</strong></p>\n<p><strong>是在分析在程序中的某点，BBS中定义的一条语句是不是有意义的</strong></p>\n<p>对于第一次遍历(红字)</p>\n<ul>\n<li><p>比如对于B1的出口，定义的D1和D2都是有意义的</p>\n</li>\n<li><p>比如对于B2的出口，D1就没有意义，因为D4重新定义了y，所以要被Kill，D2、D3是有意义的。</p>\n<p>算法：</p>\n<ul>\n<li>该算法是检查程序的其他处有没有定义这个变量，如果定义了就kill掉</li>\n<li>因为路径中没经过的BBS，肯定没有定义过，所以是0，kill不kill无所谓</li>\n</ul>\n<p>理解：</p>\n<ul>\n<li>按照理解来说，可以检查这条路径上之前有没有定义过，但是这样可能比较麻烦</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"理解Reaching-Definitions-到达定值\"><a href=\"#理解Reaching-Definitions-到达定值\" class=\"headerlink\" title=\"理解Reaching Definitions(到达定值)\"></a>理解Reaching Definitions(到达定值)</h4><h4 id=\"Abstraction-用Di进行抽象\"><a href=\"#Abstraction-用Di进行抽象\" class=\"headerlink\" title=\"Abstraction(用Di进行抽象)\"></a>Abstraction(用Di进行抽象)</h4><ul>\n<li>程序中所有变量的定值</li>\n<li>能被一个 bit vectors表示</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230811234620667.png\" alt=\"image-20230811234620667\"></p>\n<p>Transer function</p>\n<p><img src=\"/../Program-Analysis-02/image-20230811234832713.png\" alt=\"image-20230811234832713\"></p>\n<ul>\n<li>从入口kill掉其他的定值，并加入新生成的定值</li>\n<li>v &#x3D; x op y，gen v, kill 其它所有的 v</li>\n</ul>\n<h4 id=\"Control-Flow\"><a href=\"#Control-Flow\" class=\"headerlink\" title=\"Control Flow\"></a>Control Flow</h4><p>按照本节最开始讲的一个完整的Data Flow Analysis的结构，需要对transer function的结果进行约束。</p>\n<p><img src=\"/../Program-Analysis-02/image-20230811235332766.png\" alt=\"image-20230811235332766\"></p>\n<h4 id=\"Algorithm-of-Reaching-Definition-Analysis\"><a href=\"#Algorithm-of-Reaching-Definition-Analysis\" class=\"headerlink\" title=\"Algorithm of Reaching Definition Analysis\"></a>Algorithm of Reaching Definition Analysis</h4><p><img src=\"/../Program-Analysis-02/image-20230811042913200.png\" alt=\"image-20230811042913200\"></p>\n<ul>\n<li><p>首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。</p>\n</li>\n<li><p>当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，需要修改各 BB 的 IN 和 OUT。</p>\n</li>\n<li><p>最终结果就是绿色的，例如b5是0011 1011，也就表示D3 D4 D5 D6 D7会流到B5结束的位置</p>\n<p><img src=\"/../Program-Analysis-02/image-20230812024517653.png\" alt=\"image-20230812024517653\"></p>\n</li>\n<li><p>在每个数据流分析中，我们把pp和一个数据流的值相关联，代表可以从这点观察到的所有可能的抽象状态。</p>\n</li>\n<li><p>通过不停的用transer function和control flow，不停的解和算，直到找到一个solution。</p>\n<p><img src=\"/../Program-Analysis-02/image-20230812024739528.png\" alt=\"image-20230812024739528\"></p>\n<p><img src=\"/../Program-Analysis-02/image-20230812024725322.png\" alt=\"image-20230812024725322\"></p>\n</li>\n</ul>\n<p><strong>为什么程序会停止？</strong></p>\n<ul>\n<li><p>程序会继续运行，是因为有的bbs变化了，说明有循环，也就是下面这种情况，一i那位如果程序都是顺序执行，就不会有bbs变化，所以一定会停止</p>\n<p><img src=\"/../Program-Analysis-02/image-20230812030831779.png\" alt=\"image-20230812030831779\"></p>\n</li>\n<li><p>某一点有可能从0 —&gt; 0，有可能从0 —&gt;1，也有可能从1 —-&gt;1，但是不可能从1—&gt;0，所以程序一定会停止</p>\n</li>\n</ul>\n<p><strong>为什么不会从1—&gt;0？</strong></p>\n<p><img src=\"/../Program-Analysis-02/image-20230812031148958.png\" alt=\"image-20230812031148958\"></p>\n<ul>\n<li>假设最终从红色快Di&#x3D;1，流入S，红色框中这一位能是1，说明从S中出来时，这一位就是1，否则不能流到红色框处</li>\n<li>那上次出来是1，说明没有被Kill掉，这次肯定也不会被kill，也可以说，水都流到这了，一定可以流出去</li>\n</ul>\n<h3 id=\"Live-Variables-Analysis（活跃变量分析）\"><a href=\"#Live-Variables-Analysis（活跃变量分析）\" class=\"headerlink\" title=\"Live Variables Analysis（活跃变量分析）\"></a>Live Variables Analysis（活跃变量分析）</h3><ul>\n<li>沿着p有一条路径，活跃变量分析分析p处的v是不是alive</li>\n<li>换句话说：后面use的v是不是我在p处定义的v，如果是，说明p在v处是alive的，也就是是有效的</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<p><strong>活跃变量分析是在分析在该点处定义的变量有没有被使用，是不是废物变量</strong></p>\n<p><img src=\"/../Program-Analysis-02/image-20230812070750920.png\" alt=\"image-20230812070750920\"></p>\n<h4 id=\"Abstraction\"><a href=\"#Abstraction\" class=\"headerlink\" title=\"Abstraction\"></a>Abstraction</h4><ul>\n<li><p>用第i个bit表示vi</p>\n<p><img src=\"/../Program-Analysis-02/image-20230812071415418.png\" alt=\"image-20230812071415418\"></p>\n</li>\n</ul>\n<p><strong>程序应该是forward的还是backward？</strong></p>\n<p>这里想探究的问题是变量是否是live？</p>\n<p>因为想知道在某一点是不是alive的，所以你得走到最后，才能知道，因为你不知道中间是否有重定义</p>\n<ul>\n<li>所以要从后往前来比较方便</li>\n</ul>\n<h4 id=\"Control-flow\"><a href=\"#Control-flow\" class=\"headerlink\" title=\"Control flow\"></a>Control flow</h4><p><img src=\"/../Program-Analysis-02/image-20230812225343496.png\" alt=\"image-20230812225343496\"></p>\n<h4 id=\"Transer-function-1\"><a href=\"#Transer-function-1\" class=\"headerlink\" title=\"Transer function\"></a>Transer function</h4><p><img src=\"/../Program-Analysis-02/image-20230812224629538.png\" alt=\"image-20230812224629538\"></p>\n<p>首先程序是Backward，已知out求in</p>\n<p><strong>问题1 ：这里的out为什么是union</strong></p>\n<ul>\n<li>因为无论s1 use v 还是s2 use v，Out[B]都等于1</li>\n<li>也就是下面有一条路径是活跃的用了v，在B的in处，都是alive的</li>\n</ul>\n<p><strong>问题2：如何求出IN[B]</strong></p>\n<p>我的考虑：</p>\n<ul>\n<li>如果B中对v进行了重新定义，IN[B]就为0</li>\n<li>所以out[b]-kill[b]</li>\n<li>我没有考虑完全所有的情况</li>\n</ul>\n<p>算法：</p>\n<ul>\n<li>首先枚举所有可能的情况</li>\n<li>如果v在B中被重定义了，就应该out[b]-def_b，但是如果在重定义之前，使用了v，in[B]仍然为1，所以将两种情况合并，得到结果</li>\n<li>这里也可以直观的感受为什么程序是backward</li>\n</ul>\n<h4 id=\"Alogrithm-of-live-variables-Analysis\"><a href=\"#Alogrithm-of-live-variables-Analysis\" class=\"headerlink\" title=\"Alogrithm of live variables Analysis\"></a>Alogrithm of live variables Analysis</h4><p><img src=\"/../Program-Analysis-02/image-20230812225519212.png\" alt=\"image-20230812225519212\"></p>\n<p><strong>问题1：为什么初始化为空？</strong></p>\n<ul>\n<li>may analysis初始化一般为空，must analysis初始化为all</li>\n</ul>\n<p>最终结果：</p>\n<p><img src=\"/../Program-Analysis-02/image-20230812232036968.png\" alt=\"image-20230812232036968\"></p>\n<h3 id=\"Available-Expressions-Analysis\"><a href=\"#Available-Expressions-Analysis\" class=\"headerlink\" title=\"Available Expressions Analysis\"></a>Available Expressions Analysis</h3><p>它是must analysis</p>\n<h4 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p><img src=\"/../Program-Analysis-02/image-20230813223059162.png\" alt=\"image-20230813223059162\"></p>\n<p>x op y 在 p 点可用的条件：</p>\n<ul>\n<li>从流图入口结点到达 p 的每条路径都对 x op y 求了值，</li>\n<li>且在最后一次求值之后再没有对 x 或 y 赋值</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<ul>\n<li><p>是在分析表达式(x &#x3D; y+3   表达式是y + 3)有没有意义，是不是白算,看是否所有路径都求了，也就是如果都求了，结果是1，那就可以被替换</p>\n</li>\n<li><p>也就是如果最后一次算y +3，后面还有对y的重新赋值，那你算的y + 3没有意义</p>\n<p><img src=\"/../Program-Analysis-02/image-20230813231942248.png\" alt=\"image-20230813231942248\"></p>\n</li>\n</ul>\n<p>对于程序的最终结果，蓝色部分来说</p>\n<ul>\n<li>表达式p-1就没有意义，因为p在B2处被重定义了</li>\n<li>表达式z&#x2F;5有意义</li>\n<li>表达式2*y没有意义，在B5中y被重定义了</li>\n<li>表达式e7 *x有意义</li>\n<li>表达式y + 3没有意义</li>\n</ul>\n<p>他的最终目的是优化表达式：有意义的可以用同一个变量替换，省的重复计算</p>\n<h4 id=\"Abstraction-1\"><a href=\"#Abstraction-1\" class=\"headerlink\" title=\"Abstraction\"></a>Abstraction</h4><p><img src=\"/../Program-Analysis-02/image-20230813222348767.png\" alt=\"image-20230813222348767\"></p>\n<ul>\n<li>0代表在这一点不是Available</li>\n</ul>\n<h4 id=\"Transer-function-Control-flow\"><a href=\"#Transer-function-Control-flow\" class=\"headerlink\" title=\"Transer function &amp; Control flow\"></a>Transer function &amp; Control flow</h4><p><img src=\"/../Program-Analysis-02/image-20230813223502406.png\" alt=\"image-20230813223502406\"></p>\n<ul>\n<li>生成新的表达式：x op y</li>\n<li>kill掉引用了变量a的表达式{a + b}</li>\n<li>最后得到{x op y}</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230813223436635.png\" alt=\"image-20230813223436635\"></p>\n<p>在黄色这点，该表达式是avaliable的</p>\n<ul>\n<li>可以根据定义判断<ul>\n<li>每一条路径都计算了 e16 * x</li>\n<li>在表达式的最后(last evaluation)y也就是b语句，没有对x重定义</li>\n</ul>\n</li>\n<li>用上面的transerfunction判断<ul>\n<li>到x &#x3D; …处时，e16 * x被kill</li>\n<li>到b处，又生成了e16 * x</li>\n<li>两条路径都有e16 * x，所以是avaliable</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230813223930416.png\" alt=\"image-20230813223930416\"></p>\n<ul>\n<li>因此，上面的可以被优化成全部用t替换</li>\n<li>到整个程序的最后一条语句时，不用再对t进行计算，因为Last evaluation已经计算过了</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230813224059470.png\" alt=\"image-20230813224059470\"></p>\n<p><strong>问题1：为什么是交？</strong></p>\n<ul>\n<li>因为需要所有的path都计算last evaluation，需要取一个最终的结果</li>\n</ul>\n<p>假设有一条path如果是1的话，另一条path是0，那这个表达式是否是avaliable呢？</p>\n<ul>\n<li>因为要safe，所以它有可能是不可达的，所以那就要认为是不可达的</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230813231002042.png\" alt=\"image-20230813231002042\"></p>\n<p><img src=\"/../Program-Analysis-02/image-20230813224456551.png\" alt=\"image-20230813224456551\"></p>\n<ul>\n<li>看这个小绿箭头和绿方框， z &#x2F; 5这个表达式有可能是不avalable的，所以要取交，认为他是0</li>\n</ul>\n<p><strong>问题2：如何理解under approximation？</strong></p>\n<ul>\n<li><p>也就是它可能会有漏报</p>\n<p><img src=\"/../Program-Analysis-02/image-20230813224537845.png\" alt=\"image-20230813224537845\"></p>\n</li>\n<li><p>对于这种情况，按照上面的transer function，到c表达式的In的地方，显然{e16 * x}不是avaliable</p>\n</li>\n<li><p>所以在c处要重新计算</p>\n</li>\n</ul>\n<p>但是有可能上面的x和重定义的x都等于3</p>\n<ul>\n<li>这种情况下，也就是可以把c处进行优化，就是不用再重新计算了</li>\n</ul>\n<p><strong>但是按照transer function，我并没有产生误报，只是没有优化，并不影响程序的执行</strong></p>\n<h4 id=\"Alogrithm-of-Available-Expressions-Analysis\"><a href=\"#Alogrithm-of-Available-Expressions-Analysis\" class=\"headerlink\" title=\"Alogrithm of Available Expressions Analysis\"></a>Alogrithm of Available Expressions Analysis</h4><p><img src=\"/../Program-Analysis-02/image-20230813224942134.png\" alt=\"image-20230813224942134\"></p>\n<p><strong>问题1：为什么OUT[B]的初始化是all(都是1)</strong></p>\n<p>按照现在的理解</p>\n<p><img src=\"/../Program-Analysis-02/image-20230813225518326.png\" alt=\"image-20230813225518326\"></p>\n<ul>\n<li>根据这个图，如果初始化是0的话，也就是此时红色框处的输入就变成了00000，那我上一步做的就没有意义了，p-1此时一定是avaliable的</li>\n<li>因为是交，所以为了保留原来的结果，一定得是11111</li>\n</ul>\n<p>musy analysis 初始化一般都是all</p>\n<p><img src=\"/../Program-Analysis-02/image-20230813231942248.png\" alt=\"image-20230813231942248\"></p>\n<h2 id=\"Analysis-Comparison\"><a href=\"#Analysis-Comparison\" class=\"headerlink\" title=\"Analysis Comparison\"></a>Analysis Comparison</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>Reaching Definitons</th>\n<th>Live Variables</th>\n<th>Avaliable Expressions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Domain</td>\n<td>definitions的集合</td>\n<td>variables的集合</td>\n<td>expressions的集合</td>\n</tr>\n<tr>\n<td>Direction</td>\n<td>forward（会不会path）</td>\n<td>backward(后面有没有use)</td>\n<td>forward（所有的Path有没有evaluation）</td>\n</tr>\n<tr>\n<td>May&#x2F;Must</td>\n<td>May analysis</td>\n<td>May analysis</td>\n<td>Must Analysis</td>\n</tr>\n<tr>\n<td>Boundary（边界）</td>\n<td>out[entry]&#x3D;null</td>\n<td>in[exit]&#x3D;null</td>\n<td>out[entry]&#x3D;null</td>\n</tr>\n<tr>\n<td>Initialization</td>\n<td>out&#x3D;null</td>\n<td>in&#x3D;null</td>\n<td>out&#x3D;all</td>\n</tr>\n<tr>\n<td>Transer function</td>\n<td>out &#x3D; gen U (in - kill)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Meet</td>\n<td>并</td>\n<td>并</td>\n<td>交</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>根据含义去确定Boundary(边界)</p>\n<ul>\n<li>inialization：对于到达性分析，entry都没有定义Di，所以out[entry]一定是null</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<p>Reaching Definitions：</p>\n<ul>\n<li>分析在BBS中写的语句，例如 x &#x3D; y + 3，对于程序中的某点，有没有意义</li>\n<li>初始化时所有的Out都是0，是May analysis，因为有一条路径定义了一个Di，那么对于下一个bbs的输入，他是有意义的</li>\n</ul>\n<p>Live Variables Analysis：</p>\n<ul>\n<li>分析在某点如果定义了这个变量，对程序中的某点，有没有意义。</li>\n<li>初始化所有的in是0，是may analysis</li>\n</ul>\n<p>Available Expressions：</p>\n<ul>\n<li>分析定义的表达式：x &#x3D; y +3中的y + 3，对于程序中的某点，有没有意义</li>\n</ul>\n<p><strong>另一方面的理解</strong></p>\n<ul>\n<li>对于may analysis，是并，也就是有一条路径满足就行，那对于加法操作，初始化一定是0</li>\n<li>对于must analysis，是交，必须所有路径都满足，那对于乘法操作，初始化一定是1</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20231007111124310.png\" alt=\"image-20231007111124310\"></p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：理解三个数据流分析</strong></p>\n<ul>\n<li>首先数据流分析只分析一个函数内部的，不涉及到方法调用，也不涉及到两个变量指向同一个空间</li>\n<li>关于到达定制分析，活跃变量分析，可用表达式分析，看上面那个图的总结</li>\n</ul>\n<p><strong>Q3：理解迭代算法，以及为什么他能终止</strong></p>\n<ul>\n<li>迭代算法由transer function和约束条件组成，程序的结果会从0–&gt;1   1–&gt;1  0—&gt;0，不会从1–&gt;0，所以当所有的块不再改变时，程序就终止了</li>\n</ul>\n<h1 id=\"Data-Flow-Analysis-Foundations\"><a href=\"#Data-Flow-Analysis-Foundations\" class=\"headerlink\" title=\"Data Flow Analysis Foundations\"></a>Data Flow Analysis Foundations</h1><h2 id=\"iterative-algorithms（迭代算法）\"><a href=\"#iterative-algorithms（迭代算法）\" class=\"headerlink\" title=\"iterative algorithms（迭代算法）\"></a>iterative algorithms（迭代算法）</h2><ul>\n<li>对于数据流分析，迭代算法生成了一个solution，也就是01组成的串</li>\n</ul>\n<h3 id=\"view-itrative-algorithm-in-another-way\"><a href=\"#view-itrative-algorithm-in-another-way\" class=\"headerlink\" title=\"view itrative algorithm in another way\"></a>view itrative algorithm in another way</h3><ul>\n<li><p>对于一个有k个nodes的CFG，迭代算法在每次迭代时，更新每个节点的Out</p>\n</li>\n<li><p>假设数据流分析的值域是V，那么可以定义一个K个元素的元组(k-tuple)</p>\n<p>$$(Out[n_1],Out[n_2],…Out[n_k]$$\t</p>\n<p>也就是一个集合$$(V_1*V_2…V_n)$$,定义这个集合为$$V^k$$在每次迭代后，保存新的值</p>\n</li>\n<li><p>每次迭代都是通过应用transer function 和control flow, 把一个map $$V^k$$变成一个新的map$$V^k$$，整个过程可以抽象为：</p>\n<p>$$F : V^k -&gt;V^k$$</p>\n</li>\n<li><p>该算法输出一系列的k-tuples，直到每个node的output不再变化</p>\n</li>\n</ul>\n<h3 id=\"图示形式：\"><a href=\"#图示形式：\" class=\"headerlink\" title=\"图示形式：\"></a><strong>图示形式：</strong></h3><p><img src=\"/../Program-Analysis-02/image-20230814224716717.png\" alt=\"image-20230814224716717\"></p>\n<ul>\n<li>对于这个算法，绿色部分就对应上面的F 函数</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230814224856721.png\" alt=\"image-20230814224856721\"></p>\n<ul>\n<li>也就是初始化时init 都为空，接着进行迭代</li>\n<li>令第一次的结果为$X_0$，$$X_1 &#x3D; F(X_0)$$</li>\n<li>最终不变时，达到的结果是$$X_i &#x3D; F(X_i)$$</li>\n<li>此时程序输入的是$X_i$，输出的也是$X_i$，也就是这个iterative algorithm达到了一个不动点(fixed point)</li>\n</ul>\n<h3 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h3><p>这个iterative alogrithm 是对于data flow analysis生成一个solution</p>\n<p><img src=\"/../Program-Analysis-02/image-20230814225526811.png\" alt=\"image-20230814225526811\"></p>\n<ul>\n<li>这个程序一定会达到不动点么？</li>\n<li>如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢</li>\n<li>我们的算法要经过多少步达到不动点</li>\n</ul>\n<h2 id=\"partial-order（偏序）\"><a href=\"#partial-order（偏序）\" class=\"headerlink\" title=\"partial order（偏序）\"></a>partial order（偏序）</h2><p><img src=\"/../Program-Analysis-02/image-20230814230238252.png\" alt=\"image-20230814230238252\"></p>\n<ul>\n<li>定义了一个偏序集(poset)，用pair表示，，P是一个集合，后面的符号(统称为&lt;&#x3D;)是偏序关系，如果集合中的元素满足上面的三条性质(自反性、反对称性、传递性)，就构成P上的偏序集合</li>\n</ul>\n<p><strong>例1：S是一个整数集，符号是小于等于</strong></p>\n<p><img src=\"/../Program-Analysis-02/image-20230814230845398.png\" alt=\"image-20230814230845398\"></p>\n<ul>\n<li>满足三条性质，构成偏序集</li>\n</ul>\n<p><strong>例2：S是一个整数集，符号是小于</strong></p>\n<ul>\n<li>显然不构成 1 &lt; 1 2 &lt; 2是错的</li>\n</ul>\n<p><strong>例3：S是一系列(下图)英文单词的集合，符号表示substring，s1&lt;&#x3D;s2，表示s1是s2的子串</strong></p>\n<p><img src=\"/../Program-Analysis-02/image-20230814231120660.png\" alt=\"image-20230814231120660\"></p>\n<p><strong>例4：S是{a,b,c}的幂集，符号表示子集</strong></p>\n<p><img src=\"/../Program-Analysis-02/image-20230815000131924.png\" alt=\"image-20230815000131924\"></p>\n<p><strong>理解偏序(partial)的含义</strong></p>\n<ul>\n<li>意味着不是集合中的每对元素都要满足给定的关系(符号 &lt;&#x3D;)</li>\n<li>比如上面的 pin 和 sin就不满足</li>\n</ul>\n<h3 id=\"Upper-and-Lower-Bounds-上下界\"><a href=\"#Upper-and-Lower-Bounds-上下界\" class=\"headerlink\" title=\"Upper and Lower Bounds(上下界)\"></a>Upper and Lower Bounds(上下界)</h3><p><img src=\"/../Program-Analysis-02/image-20230814232015644.png\" alt=\"image-20230814232015644\"></p>\n<p>这玩意不就是高中数学</p>\n<ul>\n<li><p>u是S的upper bound，也就是S中的所有元素都$\\subseteq$u</p>\n</li>\n<li><p>l是S的lower bound，也就是l$\\subseteq$S中的所有元素</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230814232727105.png\" alt=\"image-20230814232727105\"></p>\n<ul>\n<li>对于这个集合来说，显然upper是{a,b,c}，lower是{}</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230814234635753.png\" alt=\"image-20230814234635753\">                                            </p>\n<ul>\n<li>最小上界(lub  or  join)：l_lS</li>\n<li>最大下界：(glb or meet)</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230814234811170.png\" alt=\"image-20230814234811170\"></p>\n<p>如果只包含两个元素</p>\n<ul>\n<li>lub：a l_l  b  也就是 a join b，就是a并b</li>\n<li>glb： 也就是a meet b，就是 a 交 b</li>\n</ul>\n<h3 id=\"Some-Properties\"><a href=\"#Some-Properties\" class=\"headerlink\" title=\"Some  Properties\"></a>Some  Properties</h3><ul>\n<li>不是每个偏序集都有glb 或者 lub</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230814235206315.png\" alt=\"image-20230814235206315\"></p>\n<ul>\n<li>如果一个Poset有lub 和 glb，那一定都是唯一的</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230814235220480.png\" alt=\"image-20230814235220480\"></p>\n<h2 id=\"Lattice\"><a href=\"#Lattice\" class=\"headerlink\" title=\"Lattice\"></a>Lattice</h2><p><img src=\"/../Program-Analysis-02/image-20230814235430059.png\" alt=\"image-20230814235430059\"></p>\n<ul>\n<li>偏序集中的每两个元素，都有它的最大下界和最小上界，这个偏序集被称为一个lattice</li>\n</ul>\n<p>上面的例3，显然不构成lattice，pin和sin在集合中找不到最小上界</p>\n<p><img src=\"/../Program-Analysis-02/image-20230815000813488.png\" alt=\"image-20230815000813488\"></p>\n<h3 id=\"Complete-Lattice\"><a href=\"#Complete-Lattice\" class=\"headerlink\" title=\"Complete Lattice\"></a>Complete Lattice</h3><p><img src=\"/../Program-Analysis-02/image-20230815000917322.png\" alt=\"image-20230815000917322\"></p>\n<ul>\n<li>给定一个lattice P和它的任意一个子集S，如果joinS和meet S(S中可能不只两个元素a b)存在，那么P是一个complete lattice</li>\n</ul>\n<p><strong>说人话：一个lattice的所有子集都lub和glb</strong></p>\n<ul>\n<li>lattice是任意两个元素都有glb和lub，complete lattice是任意一个子集</li>\n</ul>\n<p>\t</p>\n<p><img src=\"/../Program-Analysis-02/image-20230815002153942.png\" alt=\"image-20230815002153942\"></p>\n<ul>\n<li>正整数集是无穷的，没有边界，所以不是complete lattice</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230815001747514.png\" alt=\"image-20230815001747514\"></p>\n<ul>\n<li>对于这个幂集，它是complete lattice，假设子集是{a,b}，虽然glb和lub不在subset中，但是在lattice中</li>\n</ul>\n<p><strong>Bounds可以不在subset中，但是要在lattice</strong></p>\n<p><img src=\"/../Program-Analysis-02/image-20230815002015994.png\" alt=\"image-20230815002015994\"></p>\n<ul>\n<li>每一个complete lattice，都有一个top和bottom</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230815002412780.png\" alt=\"image-20230815002412780\"></p>\n<ul>\n<li>每个有穷的lattice都是complete lattice</li>\n</ul>\n<h3 id=\"Product-Lattice\"><a href=\"#Product-Lattice\" class=\"headerlink\" title=\"Product Lattice\"></a>Product Lattice</h3><p><img src=\"/../Program-Analysis-02/image-20230815004328353.png\" alt=\"image-20230815004328353\"></p>\n<ul>\n<li>给定一系列lattice，如果对于每一个偏序集，都有最小上界和最大下届，这些所有的偏序集就构成一个product lattice$$L^n &#x3D; (P,\\subseteq)$$</li>\n</ul>\n<p>这个product lattice被定义为：</p>\n<p><img src=\"/../Program-Analysis-02/image-20230815004340746.png\" alt=\"image-20230815004340746\"></p>\n<ul>\n<li>一个product lattice是一个lattice</li>\n<li>如果构成product lattice的每一个lattice都是complete lattice，那么这个product lattice也是complete lattice</li>\n</ul>\n<h2 id=\"Data-Flow-Analysis-Framework-via-Lattice\"><a href=\"#Data-Flow-Analysis-Framework-via-Lattice\" class=\"headerlink\" title=\"Data Flow Analysis Framework via Lattice\"></a>Data Flow Analysis Framework via Lattice</h2><p><img src=\"/../Program-Analysis-02/image-20230815005117066.png\" alt=\"image-20230815005117066\"></p>\n<ul>\n<li>D：forward还是backward</li>\n<li>L：包括domain和operator</li>\n<li>F：一系列的从V 到V的transfer functions</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230815005323828.png\" alt=\"image-20230815005323828\"></p>\n<ul>\n<li>可以看到，右边的图(may analysis)是从bottom往上走的</li>\n</ul>\n<p><strong>data flow analysis可以看成对lattice的值迭代的使用transfer functions和meet&#x2F;join operations</strong></p>\n<h2 id=\"Monotonicity（单调性）\"><a href=\"#Monotonicity（单调性）\" class=\"headerlink\" title=\"Monotonicity（单调性）\"></a>Monotonicity（单调性）</h2><p><img src=\"/../Program-Analysis-02/image-20230815010435910.png\" alt=\"image-20230815010435910\"></p>\n<ul>\n<li>L是一个lattice，if 任意的x y属于L, $$x \\subseteq y$$，f(x)$\\subseteq$f(y)</li>\n</ul>\n<h3 id=\"Fixed-Point-Theorem-不动点定理\"><a href=\"#Fixed-Point-Theorem-不动点定理\" class=\"headerlink\" title=\"Fixed-Point Theorem(不动点定理)\"></a>Fixed-Point Theorem(不动点定理)</h3><p><img src=\"/../Program-Analysis-02/image-20230815010934815.png\" alt=\"image-20230815010934815\"></p>\n<p>L是单调的，且L是有穷的，那么最小不动点和最大不动点能通过迭代求出来</p>\n<ol>\n<li><p>求最小不动点：第一次用bottom作为输入，得到f(bottom)，再把f(bottom)作为下一次的输入，直到求出一个不动点，这个不动点就是最小不动点</p>\n</li>\n<li><p>求最大不动点：第一次用top作为输入，得到f(top)，再把f(top)作为下一次的输入，直到求出一个不动点，这个不动点就是最大不动点</p>\n</li>\n</ol>\n<h4 id=\"证明不动点\"><a href=\"#证明不动点\" class=\"headerlink\" title=\"证明不动点\"></a>证明不动点</h4><h5 id=\"Existence-of-Fixed-Point\"><a href=\"#Existence-of-Fixed-Point\" class=\"headerlink\" title=\"Existence of Fixed Point\"></a>Existence of Fixed Point</h5><p><img src=\"/../Program-Analysis-02/image-20230815024144513.png\" alt=\"image-20230815024144513\"></p>\n<ul>\n<li>首先定义一个bottom，f(bottom）就是对bottom进行transer funtion变换，可以理解为右下的图，从{}走到了{a}</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230815005323828.png\" alt=\"image-20230815005323828\"></p>\n<ul>\n<li>因为f是单调的，所以 f(bottom)$\\sqsubseteq$f(f((bottom))，一直到$f^i(bottom)$</li>\n<li>那由于L是有穷的(程序最终的111…111)，假设最终值是$f^H(bottom)$，此时再对他进行transer function，就不会变了(因为1不会变成0？)</li>\n<li>从下面gitbook的证明看出来，和我想的一样，但是这个ppt上的证明我属实没看懂</li>\n</ul>\n<p><strong>gitbook的证明：</strong></p>\n<p>根据$\\bot$和f的定义，我们可以得到：$\\bot \\sqsubseteq f(\\bot)$。</p>\n<p>由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\\bot \\sqsubseteq f(\\bot) \\sqsubseteq f^2(\\bot)\\sqsubseteq …\\sqsubseteq f^k(\\bot)\\sqsubseteq f^{k+1}(\\bot) $，且$f^k(\\bot) &#x3D; f^{k+1}(\\bot)$。</p>\n<h5 id=\"Least-Fixed-Point\"><a href=\"#Least-Fixed-Point\" class=\"headerlink\" title=\"Least Fixed Point\"></a>Least Fixed Point</h5><p><strong>gitbook的证明：(通俗易懂，ppt上写的我没看懂)</strong></p>\n<p>假设我们有另一个任意不动点 x，由于 f 是单调的，因此$f(\\bot) \\sqsubseteq f(x), f^2(\\bot) \\sqsubseteq f^2(x),…,f^{Fix} &#x3D; f^k(\\bot)\\sqsubseteq f^k(x) &#x3D; x$</p>\n<p>可知的确$f^{Fix}$是最小不动点。</p>\n<p><strong>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。</strong></p>\n<h1 id=\"Data-Flow-Analysis-Foundations-II\"><a href=\"#Data-Flow-Analysis-Foundations-II\" class=\"headerlink\" title=\"Data Flow Analysis Foundations II\"></a>Data Flow Analysis Foundations II</h1><h2 id=\"Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\"><a href=\"#Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\" class=\"headerlink\" title=\"Relate Iterative Algorithm to Fix-ed Point Theorem\"></a>Relate Iterative Algorithm to Fix-ed Point Theorem</h2><p><img src=\"/../Program-Analysis-02/image-20230816061430910.png\" alt=\"image-20230816061430910\"></p>\n<p><strong>问题1：这两个怎么联系起来呢</strong>？</p>\n<p><img src=\"/../Program-Analysis-02/image-20230816061010705.png\" alt=\"image-20230816061010705\"></p>\n<p><strong>第一步：确定product lattice，且是finite</strong></p>\n<ul>\n<li><p>这里的每一个节点都对应一个Lattice。假设他是reaching definitions，假设有3个变量D1 D2 D3</p>\n</li>\n<li><p>他的domain一定是(0,0,0)  … …. (D1,D2,D3)</p>\n</li>\n<li><p>所以它是lattice</p>\n</li>\n<li><p>每一个lattice都是finite，所以整体也是finite</p>\n</li>\n</ul>\n<p><strong>第二步：确定 f: L -&gt; L 是单调的</strong></p>\n<p>对于iterative algotithm来说，f相当于control flow和transer function</p>\n<ul>\n<li>因为 transer function**(OUT &#x3D; gen U (IN - kill))**的结果一定是从0 到1，不会从1到0 ，所以是单调的</li>\n</ul>\n<p>现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L</p>\n<ul>\n<li>即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $</li>\n</ul>\n<p>单调的定义是：x&lt; y, f(x) &lt; f(y)，这里的meet就相当于f</p>\n<ul>\n<li>根据定义， $y\\sqsubseteq y\\sqcup  z$，因为y meet z是least upper bound </li>\n<li>所以 $x\\sqsubseteq y\\sqcup  z$，这里证明$y\\sqcup  z$是x的上界</li>\n<li>又因为 $x\\sqsubseteq x\\sqcup  z$，且 $x \\sqcup z$是x的least upper bound</li>\n<li>所以 $x \\sqcup z\\sqsubseteq y\\sqcup  z$</li>\n</ul>\n<p>到这里可以把不动点定理应用到iterative algorithm中</p>\n<p><strong>这个证明我现在不是很懂，那是不是说明 x meet y也小于等于 y meet z呢</strong></p>\n<h2 id=\"Review-the-questions\"><a href=\"#Review-the-questions\" class=\"headerlink\" title=\"Review the questions\"></a>Review the questions</h2><p><img src=\"/../Program-Analysis-02/image-20230814225526811.png\" alt=\"image-20230814225526811\"></p>\n<ul>\n<li><p>这个程序一定会达到不动点么？<strong>会，根据不动点定理</strong></p>\n</li>\n<li><p>如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢？<strong>greatest or least fixed point</strong></p>\n</li>\n<li><p>我们的算法要经过多少步达到不动点? </p>\n<p><strong>最坏情况是：h*k</strong></p>\n</li>\n</ul>\n<h2 id=\"When-will-the-algorithm-reach-the-fixed-point？\"><a href=\"#When-will-the-algorithm-reach-the-fixed-point？\" class=\"headerlink\" title=\"When will the algorithm reach the fixed point？\"></a>When will the algorithm reach the fixed point？</h2><ul>\n<li>lattice的高度：lattice中从bottom到top最长的path</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230816063329661.png\" alt=\"image-20230816063329661\"></p>\n<ul>\n<li>假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 $i &#x3D; h \\times k$</li>\n<li>这也回答了上面最后一个问题</li>\n</ul>\n<h2 id=\"May-and-Must-Analysis-a-Lattice-View\"><a href=\"#May-and-Must-Analysis-a-Lattice-View\" class=\"headerlink\" title=\"May and Must Analysis , a Lattice View\"></a>May and Must Analysis , a Lattice View</h2><ul>\n<li>都是从unsafe 向safe 走，</li>\n</ul>\n<h3 id=\"May-Analysis-View\"><a href=\"#May-Analysis-View\" class=\"headerlink\" title=\"May  Analysis View\"></a>May  Analysis View</h3><p>将lattice抽象成一个视图</p>\n<p>例如，对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。</p>\n<p>目标：我们的目标是在程序运行后，找到一个可以替换的变量(优化)，<strong>也就是看最终哪个是0</strong>，如果是0的就可以被替换。</p>\n<p>那么在初始化的时候，用反证法要要求所有的都是0，然后找出不是0的。</p>\n<p>目标是找到可以替换的变量。</p>\n<ul>\n<li>下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换，所有都能替换。**—-&gt;对应sound**</li>\n<li>上界代表 safe but useless 的情绪，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义，也就是所有的都不能替换。</li>\n</ul>\n<p>而因为我们采用了 join 函数，那么我们必然会从 lattice 的最小下界往上走。而越往上走，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。</p>\n<p><img src=\"/../Program-Analysis-02/image-20230816071341859.png\" alt=\"image-20230816071341859\"></p>\n<h3 id=\"Must-Analysis-View\"><a href=\"#Must-Analysis-View\" class=\"headerlink\" title=\"Must Analysis View\"></a>Must Analysis View</h3><p>目标：找到最终表达式结果是1的，是1的就不用重复计算了，可以替换</p>\n<p><strong>那初始化的时候，用反证法，就假设都是1，</strong>意思就是所有的表达式都没有其中的值被重新定义，也就是所有的表达式都可以用原来的值替换，这肯定是Unsafe的。</p>\n<p>反之，所有的表达式都不avaliable,需要重新计算所有的值，肯定是safe，都别优化了</p>\n<p><img src=\"/../Program-Analysis-02/image-20230816073057174.png\" alt=\"image-20230816073057174\"></p>\n<ul>\n<li>下界代表 safe but useless 的情形，因为需要重新计算每个表达式，即确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果</li>\n</ul>\n<p><strong>another view of leaest fixed point</strong></p>\n<p>以may analysis举例</p>\n<ul>\n<li>transer function中 kill 和gen是固定的</li>\n<li>control flow merge 是  union，对于lattice来说union是最小上界</li>\n<li>所以每次都走的是最小的一步，那最后得到的肯定是最小不动点</li>\n</ul>\n<h2 id=\"How-Precise-is-our-Solution\"><a href=\"#How-Precise-is-our-Solution\" class=\"headerlink\" title=\"How Precise is our Solution\"></a>How Precise is our Solution</h2><h3 id=\"Meet-Over-All-Paths-Solution-MOP\"><a href=\"#Meet-Over-All-Paths-Solution-MOP\" class=\"headerlink\" title=\"Meet-Over-All-Paths Solution(MOP)\"></a>Meet-Over-All-Paths Solution(MOP)</h3><ul>\n<li>这里的meet包括(meet&#x2F;join)</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20230816222855029.png\" alt=\"image-20230816222855029\"></p>\n<ul>\n<li>对所有的out应用transer function，再用meet操作符</li>\n<li>MOP在每条路径的结尾计算所有的data-flow的值，应用应用Meet去找到 lub &#x2F; glb</li>\n</ul>\n<p>但是基于上面的表达式可能有些问题</p>\n<p><strong>问题1：有些路径是不可执行的（not executable）</strong></p>\n<ul>\n<li>上面是考虑了所有的路径，但是有写路径可能永远不会被执行</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">x<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">></span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>问题2：not unbounded(没有边界)</strong></p>\n<ul>\n<li>如果有一条path中有循环，循环中定义s1,s2两个变量,也就是这条path上会包含非常多个s1,s2</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\ns1<span class=\"token punctuation\">;</span>\ns2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>问题3：Not enumerable</strong></p>\n<ul>\n<li>可能程序很大，不可枚举</li>\n</ul>\n<h3 id=\"Ours-iterative-Algorithm-vs-MOP\"><a href=\"#Ours-iterative-Algorithm-vs-MOP\" class=\"headerlink\" title=\"Ours(iterative Algorithm) vs MOP\"></a>Ours(iterative Algorithm) vs MOP</h3><p><img src=\"/../Program-Analysis-02/image-20230816223938137.png\" alt=\"image-20230816223938137\"></p>\n<ul>\n<li><p>我们的算法是在每一个merge的时候，join</p>\n</li>\n<li><p>MOP是在最后merge</p>\n</li>\n</ul>\n<p>把黄色的部分用x代替，红色的部分用y代替</p>\n<p>证明一下他俩的关系：</p>\n<p><img src=\"/../Program-Analysis-02/image-20230816230725374.png\" alt=\"image-20230816230725374\"></p>\n<ul>\n<li>这个很好理解，F($x\\sqcup y$)是F(x)和F(y)的upper bound,F(x)和F(y)的最小上界是$F(x)\\sqcup F(y)$</li>\n<li>所以$MOP \\sqsubseteq Ours$</li>\n</ul>\n<p>当F具有可分配性时</p>\n<p><img src=\"/../Program-Analysis-02/image-20230816231036088.png\" alt=\"image-20230816231036088\"></p>\n<p>bit-vector或者Gen&#x2F;kill的transer function(用join &#x2F; meet)都是distributive</p>\n<ul>\n<li>所以我们之前的都和MOP一样准确</li>\n</ul>\n<h2 id=\"关于must-analysis-还是-may-analysis的分析\"><a href=\"#关于must-analysis-还是-may-analysis的分析\" class=\"headerlink\" title=\"关于must analysis 还是 may analysis的分析\"></a>关于must analysis 还是 may analysis的分析</h2><h3 id=\"Reaching-definitons\"><a href=\"#Reaching-definitons\" class=\"headerlink\" title=\"Reaching definitons\"></a><strong>Reaching definitons</strong></h3><ul>\n<li>它的目标是：判断在此处定义的D1 … Di是否有意义，如果每意义，就被优化，1代表有意义，0代表无意义。</li>\n<li>也就是如果有一条路径是1，代表可能有意义，就不能被优化</li>\n<li>所以要 把结果并起来，所以是may analysis</li>\n</ul>\n<h3 id=\"live-avaliables\"><a href=\"#live-avaliables\" class=\"headerlink\" title=\"live avaliables\"></a>live avaliables</h3><ul>\n<li>它的目标是判断变量后面是否被用了，如果是无意义的变量，就把它的空间释放掉，用来存储新的寄存器值</li>\n<li>1代表有意义，0代表无意义</li>\n<li>也就是如果有1条路有意义，就不应该被优化</li>\n<li>所以同上</li>\n</ul>\n<h3 id=\"avaliable-expressions\"><a href=\"#avaliable-expressions\" class=\"headerlink\" title=\"avaliable expressions\"></a>avaliable expressions</h3><ul>\n<li>它的定义说要考虑所有的路径，是否在每一条路径都执行了x op y，如果都执行了，就可以把这个结果用一个新的变量替换</li>\n<li>那如果有一条路劲没计算，显然就不能别替换，输出是0</li>\n<li>所以要把所有的结果取 交集</li>\n</ul>\n<h2 id=\"Constant-Propagation\"><a href=\"#Constant-Propagation\" class=\"headerlink\" title=\"Constant Propagation\"></a>Constant Propagation</h2><p>程序的p点有一个变量x,判断在P点是否可以guaranteed x是一个常量</p>\n<ul>\n<li>要考虑所有的路径上是否定义的值都一样，如果有两条路径是x&#x3D;2，有一条是x&#x3D;3，那显然不行</li>\n<li>所以是must analysis</li>\n</ul>\n<p>从top往bottom走，最下面肯定是最安全的，因为你要考虑的问题(优化的目标)是 是否是constant，最下面是所有的都不是constant，所以肯定是safe</p>\n<p><img src=\"/../Program-Analysis-02/image-20230817210307704.png\" alt=\"image-20230817210307704\"></p>\n<p>考虑所有的meet</p>\n<p>nac：Not a constant</p>\n<p>V：value</p>\n<ul>\n<li><p>nac 和 v肯定是nac</p>\n</li>\n<li><p>undef 和 v是 v</p>\n<p>但是这里有一种情况是，假设程序走了Undefined的路径，表示没有这个常量，但是输出结果是有一个常量，那在程序获取undefined三，少了一个值。</p>\n<p>解释：在constant propagation（常量传播）中，只考虑常量传播，不focus于未定义这种情况</p>\n</li>\n</ul>\n<h3 id=\"Transfer-function\"><a href=\"#Transfer-function\" class=\"headerlink\" title=\"Transfer function\"></a>Transfer function</h3><p><img src=\"/../Program-Analysis-02/image-20230816235426102.png\" alt=\"image-20230816235426102\"></p>\n<p> _表示通配符，无论是啥值，都干掉\t</p>\n<ul>\n<li>x如果是常量，生成的就是x和对应的值</li>\n<li>如果x&#x3D;y，y是一个变量，那就去取y的值，如果是常量就是，不是就不是</li>\n<li>x&#x3D; y op z，就进行计算<ul>\n<li>两个都是常量</li>\n<li>有一个不是常量</li>\n<li>其中有一个是undefi，或者两个都是undef</li>\n</ul>\n</li>\n</ul>\n<p>这里提了一句，如果把undef给了一个值，那transfer function就不单调了。</p>\n<p><strong>我的理解：</strong></p>\n<p>回看定义</p>\n<p><strong>现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L</strong></p>\n<p><strong>即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $</strong></p>\n<ul>\n<li>假设z是undef，那 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $ 这个表达式不一定成立</li>\n</ul>\n<h3 id=\"为什么是Nondistributivity\"><a href=\"#为什么是Nondistributivity\" class=\"headerlink\" title=\"为什么是Nondistributivity\"></a>为什么是Nondistributivity</h3><p><img src=\"/../Program-Analysis-02/image-20230817001140056.png\" alt=\"image-20230817001140056\"></p>\n<ul>\n<li>iterative algorithm的结果是nac</li>\n<li>mop的结果是10</li>\n<li>他俩不相等，所以他就不是distributivity</li>\n<li>实际结果是10，mop准</li>\n</ul>\n<h2 id=\"Worklist-Algorithm\"><a href=\"#Worklist-Algorithm\" class=\"headerlink\" title=\"Worklist Algorithm\"></a>Worklist Algorithm</h2><p>an optimization of iterative algorithm，是iterative algorithm的优化</p>\n<ul>\n<li>实际上用的是Worklist Algorithm</li>\n</ul>\n<p><strong>回顾iterative algorithm</strong></p>\n<p><img src=\"/../Program-Analysis-02/image-20230817001720388.png\" alt=\"image-20230817001720388\"></p>\n<ul>\n<li>有一个变化了，所有的都要重新算，很冗余</li>\n</ul>\n<p><img src=\"/../Program-Analysis-02/image-20231007124507027.png\" alt=\"image-20231007124507027\"></p>\n<p><img src=\"/../Program-Analysis-02/image-20230817011427252.png\" alt=\"image-20230817011427252\"></p>\n<h2 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：理解迭代算法的功能</strong></p>\n<ul>\n<li>包括初始化，bounary，must analysis和may analysis的初始化不一样</li>\n<li>in、out</li>\n</ul>\n<p><strong>Q2：lattice和complete lattice</strong></p>\n<ul>\n<li>lattice表示偏序集中的每两个元素都有最小上界和最大下界</li>\n<li>complete lattice表示偏序集的每个子集都有最小上界和最大下界</li>\n</ul>\n<p><strong>Q3：理解不动点定理</strong></p>\n<ul>\n<li>如果一个lattice是单调的，且有穷的，那可以通过迭代算法得到最小不动点</li>\n</ul>\n<p><strong>Q4：在lattice中总结may analysis和must analysis</strong></p>\n<ul>\n<li>关于Must analysis和may analysis，很重要的一点是要理解程序的目标是什么</li>\n<li>如果他的目标是找1，结果是1的被替换，那就是must analysis</li>\n<li>如果目标是找0，0的被替换，那就是May analysis</li>\n</ul>\n<p><strong>Q5：MOP和迭代算法的关系</strong></p>\n<ul>\n<li>MOP算法走所有的路径，在程序的最后merge</li>\n<li>而迭代算法在有merge的情况下就会merge</li>\n</ul>\n<p><strong>Q6：关于常量传播</strong></p>\n<ul>\n<li>他是Must analysis</li>\n</ul>\n<p><strong>Q7：Worklist 算法</strong></p>\n<ul>\n<li>对迭代算法进行优化，只计算变化的块，后面的指针分析都是worklist算法</li>\n</ul>\n","text":"Control Flow Analysis控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。 需要构建Control Flow Graph(CFG) CF...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Control-Flow-Analysis\"><span class=\"toc-text\">Control Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Basic-Blocks\"><span class=\"toc-text\">Basic Blocks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BAnode\"><span class=\"toc-text\">构建node</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E8%BE%B9\"><span class=\"toc-text\">构建边</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BACFG\"><span class=\"toc-text\">构建CFG</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis\"><span class=\"toc-text\">Data Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-1\"><span class=\"toc-text\">Data Flow Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Preliminaries-of-Data-Flow-Analysis\"><span class=\"toc-text\">Preliminaries of Data Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Input-and-Output-States\"><span class=\"toc-text\">Input and Output States</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">关于转移方程约束的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">关于控制流约束的概念</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Applications\"><span class=\"toc-text\">Data Flow Analysis Applications</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">不会涉及到的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reaching-Definitions-Analysis\"><span class=\"toc-text\">Reaching Definitions Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Input-and-Output-States-1\"><span class=\"toc-text\">Input and Output States</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function\"><span class=\"toc-text\">Transer function</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3Reaching-Definitions-%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC\"><span class=\"toc-text\">理解Reaching Definitions(到达定值)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction-%E7%94%A8Di%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">Abstraction(用Di进行抽象)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Control-Flow\"><span class=\"toc-text\">Control Flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Algorithm-of-Reaching-Definition-Analysis\"><span class=\"toc-text\">Algorithm of Reaching Definition Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Live-Variables-Analysis%EF%BC%88%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%89\"><span class=\"toc-text\">Live Variables Analysis（活跃变量分析）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction\"><span class=\"toc-text\">Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Control-flow\"><span class=\"toc-text\">Control flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function-1\"><span class=\"toc-text\">Transer function</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Alogrithm-of-live-variables-Analysis\"><span class=\"toc-text\">Alogrithm of live variables Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Available-Expressions-Analysis\"><span class=\"toc-text\">Available Expressions Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction-1\"><span class=\"toc-text\">Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function-Control-flow\"><span class=\"toc-text\">Transer function &amp; Control flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Alogrithm-of-Available-Expressions-Analysis\"><span class=\"toc-text\">Alogrithm of Available Expressions Analysis</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Analysis-Comparison\"><span class=\"toc-text\">Analysis Comparison</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Foundations\"><span class=\"toc-text\">Data Flow Analysis Foundations</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iterative-algorithms%EF%BC%88%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">iterative algorithms（迭代算法）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#view-itrative-algorithm-in-another-way\"><span class=\"toc-text\">view itrative algorithm in another way</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%A4%BA%E5%BD%A2%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">图示形式：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%9D%A5%E4%BA%86\"><span class=\"toc-text\">问题来了</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#partial-order%EF%BC%88%E5%81%8F%E5%BA%8F%EF%BC%89\"><span class=\"toc-text\">partial order（偏序）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Upper-and-Lower-Bounds-%E4%B8%8A%E4%B8%8B%E7%95%8C\"><span class=\"toc-text\">Upper and Lower Bounds(上下界)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Some-Properties\"><span class=\"toc-text\">Some  Properties</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lattice\"><span class=\"toc-text\">Lattice</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Complete-Lattice\"><span class=\"toc-text\">Complete Lattice</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Product-Lattice\"><span class=\"toc-text\">Product Lattice</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Framework-via-Lattice\"><span class=\"toc-text\">Data Flow Analysis Framework via Lattice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Monotonicity%EF%BC%88%E5%8D%95%E8%B0%83%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">Monotonicity（单调性）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fixed-Point-Theorem-%E4%B8%8D%E5%8A%A8%E7%82%B9%E5%AE%9A%E7%90%86\"><span class=\"toc-text\">Fixed-Point Theorem(不动点定理)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%81%E6%98%8E%E4%B8%8D%E5%8A%A8%E7%82%B9\"><span class=\"toc-text\">证明不动点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Existence-of-Fixed-Point\"><span class=\"toc-text\">Existence of Fixed Point</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Least-Fixed-Point\"><span class=\"toc-text\">Least Fixed Point</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Foundations-II\"><span class=\"toc-text\">Data Flow Analysis Foundations II</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\"><span class=\"toc-text\">Relate Iterative Algorithm to Fix-ed Point Theorem</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Review-the-questions\"><span class=\"toc-text\">Review the questions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#When-will-the-algorithm-reach-the-fixed-point%EF%BC%9F\"><span class=\"toc-text\">When will the algorithm reach the fixed point？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#May-and-Must-Analysis-a-Lattice-View\"><span class=\"toc-text\">May and Must Analysis , a Lattice View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#May-Analysis-View\"><span class=\"toc-text\">May  Analysis View</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Must-Analysis-View\"><span class=\"toc-text\">Must Analysis View</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-Precise-is-our-Solution\"><span class=\"toc-text\">How Precise is our Solution</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Meet-Over-All-Paths-Solution-MOP\"><span class=\"toc-text\">Meet-Over-All-Paths Solution(MOP)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ours-iterative-Algorithm-vs-MOP\"><span class=\"toc-text\">Ours(iterative Algorithm) vs MOP</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Emust-analysis-%E8%BF%98%E6%98%AF-may-analysis%E7%9A%84%E5%88%86%E6%9E%90\"><span class=\"toc-text\">关于must analysis 还是 may analysis的分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reaching-definitons\"><span class=\"toc-text\">Reaching definitons</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#live-avaliables\"><span class=\"toc-text\">live avaliables</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#avaliable-expressions\"><span class=\"toc-text\">avaliable expressions</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Constant-Propagation\"><span class=\"toc-text\">Constant Propagation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Transfer-function\"><span class=\"toc-text\">Transfer function</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFNondistributivity\"><span class=\"toc-text\">为什么是Nondistributivity</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Worklist-Algorithm\"><span class=\"toc-text\">Worklist Algorithm</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"wmctf","uid":"9b333f38efd344acbd675306690f4b47","slug":"wmctf","date":"2023-08-29T05:32:25.000Z","updated":"2023-10-18T09:28:22.561Z","comments":true,"path":"api/articles/wmctf.json","keywords":null,"cover":null,"text":" BOOT-INF目录：这个目录通常是在使用Spring Boot框架时出现的。它是用于打包可执行的JAR文件的特殊目录。在这个目录下，通常包含了应用程序的所有依赖项（JAR文件）和应用程序的类文件。这些类文件可以包括Spring Boot的启动类、配置类以及其他应用程序的自定义...","link":"","photos":[],"count_time":{"symbolsCount":462,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Program-Analysis-01","uid":"eee198b3106cda0f3696061d93d628ad","slug":"Program-Analysis-01","date":"2023-08-20T13:29:01.000Z","updated":"2023-10-26T15:30:35.746Z","comments":true,"path":"api/articles/Program-Analysis-01.json","keywords":null,"cover":[],"text":"引言 学这个的起因是想入门一下模糊测试方向，跟着知乎的学习路线，学了这个课程 谭老师和李老师讲的非常非常好 兜兜转转学这个已经很久了，感觉很多地方还是不是理解的很明白 Programming Languages(PL) 在运行程序前，分析程序可能有的问题 静态分析是在编译时，在程...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}