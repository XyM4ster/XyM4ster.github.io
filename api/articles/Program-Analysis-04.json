{"title":"Program-Analysis-04","uid":"0c7c1359362e7af148487a65d7d4a6f0","slug":"Program-Analysis-04","date":"2023-09-09T15:34:02.000Z","updated":"2023-10-26T15:38:08.533Z","comments":true,"path":"api/articles/Program-Analysis-04.json","keywords":null,"cover":[],"content":"<h1 id=\"Static-Analysis-for-security\"><a href=\"#Static-Analysis-for-security\" class=\"headerlink\" title=\"Static Analysis for security\"></a>Static Analysis for security</h1><h2 id=\"Information-Flow-Security\"><a href=\"#Information-Flow-Security\" class=\"headerlink\" title=\"Information Flow Security\"></a>Information Flow Security</h2><p>目标</p>\n<ul>\n<li>避免不想要的信息流</li>\n</ul>\n<h3 id=\"Access-Control-vs-Information-Flow-Security\"><a href=\"#Access-Control-vs-Information-Flow-Security\" class=\"headerlink\" title=\"Access Control vs. Information Flow Security\"></a>Access Control vs. Information Flow Security</h3><p>Access Control</p>\n<ul>\n<li>检查程序是否有权限</li>\n<li>关心信息是如何访问的</li>\n</ul>\n<p>Information flow security</p>\n<ul>\n<li>可以追踪信息的流动</li>\n<li>关心信息是如何传播的</li>\n</ul>\n<h3 id=\"Information-Flow\"><a href=\"#Information-Flow\" class=\"headerlink\" title=\"Information Flow\"></a>Information Flow</h3><p><img src=\"/../Program-Analysis-04/image-20230919141259543.png\" alt=\"image-20230919141259543\"></p>\n<ul>\n<li>和前面学的一样，箭头表示信息的流动</li>\n</ul>\n<h3 id=\"Information-Flow-security\"><a href=\"#Information-Flow-security\" class=\"headerlink\" title=\"Information Flow security\"></a>Information Flow security</h3><ul>\n<li>定义程序中的变量不同的安全等级</li>\n</ul>\n<h4 id=\"Security-Levels\"><a href=\"#Security-Levels\" class=\"headerlink\" title=\"Security Levels\"></a>Security Levels</h4><ul>\n<li>H : 就是hight security，保密信息</li>\n<li>L : 就是low security，公开的可观察到的信息</li>\n</ul>\n<p>安全等级用lattice进行抽象：L&lt;&#x3D; H</p>\n<h3 id=\"Information-Flow-Policy\"><a href=\"#Information-Flow-Policy\" class=\"headerlink\" title=\"Information Flow Policy\"></a>Information Flow Policy</h3><p>下面是**J. A. Goguen and J. Meseguer, “Security policies and security models”. S&amp;P 1982.*论文中提出的policy</p>\n<p>限制信息在不同的security level之间如何流动</p>\n<p>Noninterference policy：非干涉</p>\n<ul>\n<li>high variables 不能影响 low variables的信息</li>\n<li>也就是说不能通过观测low variables的信息来推测出high variables中的信息</li>\n</ul>\n<p><strong>Noninterference policy example</strong></p>\n<p><img src=\"/../Program-Analysis-04/image-20230919143041180.png\" alt=\"image-20230919143041180\"></p>\n<ul>\n<li>上面红色的是不允许的，因为high variables流到了low variables</li>\n</ul>\n<h2 id=\"Confidentiality-and-Integrity（保密性和完整性）\"><a href=\"#Confidentiality-and-Integrity（保密性和完整性）\" class=\"headerlink\" title=\"Confidentiality and Integrity（保密性和完整性）\"></a>Confidentiality and Integrity（保密性和完整性）</h2><p>保密性：防止信息流出去</p>\n<p>完整性：防止其他信息流进来，造成污染，污染了信息就不完整了</p>\n<p><img src=\"/../Program-Analysis-04/image-20230919143432988.png\" alt=\"image-20230919143432988\"></p>\n<h3 id=\"Integrity\"><a href=\"#Integrity\" class=\"headerlink\" title=\"Integrity\"></a>Integrity</h3><p>涉及到了很多外部数据的注入，违反数据的完整性，CTF中常用的方法</p>\n<ul>\n<li>Command injection</li>\n<li>SQL inhecttion</li>\n<li>Xss</li>\n</ul>\n<h3 id=\"Confidentiality-and-Integrity\"><a href=\"#Confidentiality-and-Integrity\" class=\"headerlink\" title=\"Confidentiality and Integrity\"></a>Confidentiality and Integrity</h3><p><img src=\"/../Program-Analysis-04/image-20230919143934943.png\" alt=\"image-20230919143934943\"></p>\n<h3 id=\"Integrity-更广泛的定义\"><a href=\"#Integrity-更广泛的定义\" class=\"headerlink\" title=\"Integrity 更广泛的定义\"></a>Integrity 更广泛的定义</h3><ul>\n<li>准确性：保护数据不被污染</li>\n<li>完全性：对于数据库系统，防止数据丢失</li>\n<li>一致性：对于文件传输系统，发送方和接收方需要是一样的</li>\n</ul>\n<h2 id=\"Explict-Flows-and-Covert-Channels（显示流和隐藏信道）\"><a href=\"#Explict-Flows-and-Covert-Channels（显示流和隐藏信道）\" class=\"headerlink\" title=\"Explict Flows and Covert Channels（显示流和隐藏信道）\"></a>Explict Flows and Covert Channels（显示流和隐藏信道）</h2><p><img src=\"/../Program-Analysis-04/image-20230919145801828.png\" alt=\"image-20230919145801828\"></p>\n<p>前面这种直接赋值的方式就是显示流</p>\n<p><img src=\"/../Program-Analysis-04/image-20230919150255672.png\" alt=\"image-20230919150255672\"></p>\n<p>对于这个程序，我们可以通过public来判断secret是否大于0，这就有了信息的流动，这种就是<strong>implicit flow</strong>隐式流。</p>\n<h3 id=\"Does-Secret-Information-Leak？\"><a href=\"#Does-Secret-Information-Leak？\" class=\"headerlink\" title=\"Does Secret Information Leak？\"></a>Does Secret Information Leak？</h3><p><img src=\"/../Program-Analysis-04/image-20230919150858548.png\" alt=\"image-20230919150858548\"></p>\n<p>第二个可以通过执行时间判断，secret &lt; 0，会稳定的增加程序的执行时间</p>\n<p>最后一个如果secret 小于0，一定会爆出数组越界，所以也是会泄露信息。</p>\n<h3 id=\"Convert-Hidden-Channels\"><a href=\"#Convert-Hidden-Channels\" class=\"headerlink\" title=\"Convert&#x2F;Hidden Channels\"></a>Convert&#x2F;Hidden Channels</h3><ul>\n<li>隐藏信道意思就是他的最初的目的不是为了传递信息，这种叫隐藏信道</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230919151104872.png\" alt=\"image-20230919151104872\"></p>\n<h3 id=\"Explicit-Flows-and-Convert-Channels\"><a href=\"#Explicit-Flows-and-Convert-Channels\" class=\"headerlink\" title=\"Explicit Flows and Convert Channels\"></a>Explicit Flows and Convert Channels</h3><p><img src=\"/../Program-Analysis-04/image-20230919151452535.png\" alt=\"image-20230919151452535\"></p>\n<ul>\n<li>对于显示流，一下子泄露的是32bits的信息，但是对于隐式流，只是泄露1bit的信息</li>\n<li>所以现在集中于如何避免这些不想要的信息流，就是不让他胡乱传播。</li>\n</ul>\n<h2 id=\"Taint-Analysis-污点分析\"><a href=\"#Taint-Analysis-污点分析\" class=\"headerlink\" title=\"Taint Analysis(污点分析)\"></a>Taint Analysis(污点分析)</h2><p>把程序中的数据标记成两种：</p>\n<ul>\n<li>对于感兴趣的数据，给他打上标签，叫做污点数据</li>\n<li>其他的数据，叫非污点的数据</li>\n</ul>\n<p><strong>污点数据的源是source</strong>，实际上，通常污点数据来自于一些方法的返回值</p>\n<p>污点分析就是追踪数据如何流动的，把它<strong>流到的位置叫sink</strong>，实际上sink通常是一些敏感的方法</p>\n<h3 id=\"Taint-Analysis-：Two-Applications\"><a href=\"#Taint-Analysis-：Two-Applications\" class=\"headerlink\" title=\"Taint Analysis ：Two Applications\"></a>Taint Analysis ：Two Applications</h3><p><img src=\"/../Program-Analysis-04/image-20230919152424513.png\" alt=\"image-20230919152424513\"></p>\n<p>保护保密性：</p>\n<ul>\n<li>Source：secret data的source</li>\n<li>Sink：泄露的地方</li>\n<li>针对Information leaks问题</li>\n</ul>\n<p>保护完整性：</p>\n<ul>\n<li>Source：不可信的数据source</li>\n<li>Sink：critical computation(关键计算)</li>\n<li>针对Injection erros</li>\n</ul>\n<h3 id=\"Taint-Analysis-and-Pointer-Analysis-Together\"><a href=\"#Taint-Analysis-and-Pointer-Analysis-Together\" class=\"headerlink\" title=\"Taint Analysis and Pointer Analysis, Together*\"></a>Taint Analysis and Pointer Analysis, Together*</h3><ul>\n<li>污点分析关注的问题是污点数据能否流到sink处？</li>\n<li>换种方式就是，sink的指针是否指向tainted data？</li>\n</ul>\n<p>！！！这不就来了么，这不就和前面学的指针分析非常非常像！</p>\n<details class=\"custom-details\">\n<summary>隐藏内容</summary>\n<p><p>污点分析关注污点数据在程序中如何流动</p>\n<p>指针分析关注抽象的对象在程序中如何流动</p>\n</p>\n</details>\n<p><strong>那怎么做呢，如何结合呢？</strong></p>\n<ul>\n<li>把污点数据当成是特殊的object</li>\n<li>把source当成是allocation sites</li>\n<li>利用指针分析去传播污点数据</li>\n</ul>\n<h3 id=\"Domains-and-Notations\"><a href=\"#Domains-and-Notations\" class=\"headerlink\" title=\"Domains and Notations\"></a>Domains and Notations</h3><p><img src=\"/../Program-Analysis-04/image-20230919155213302.png\" alt=\"image-20230919155213302\"></p>\n<p>这里以C.I.为例，结合指针分析和污点分析</p>\n<ul>\n<li>在域中新加入了Tainted data，污点数据</li>\n<li>ti表示call site i 的tainted data</li>\n</ul>\n<h3 id=\"Taint-Analysis：Inputs-Outputs\"><a href=\"#Taint-Analysis：Inputs-Outputs\" class=\"headerlink\" title=\"Taint Analysis：Inputs &amp; Outputs\"></a>Taint Analysis：Inputs &amp; Outputs</h3><p>Inputs：</p>\n<ul>\n<li>Sources：a set of source methods（调用返回污点数据的方法）</li>\n<li>Sinks：a set of sink methods（污点数据流到的违反了security polices的方法）</li>\n</ul>\n<p>Outputs：</p>\n<ul>\n<li>TaintFlows：一系列污点数据的集合和sink 方法</li>\n</ul>\n<p> 例如&lt;ti,m&gt;属于TaintFlows，表明来自调用点i(source method)的污点数据可能流到sink method m</p>\n<h3 id=\"Rules：Call\"><a href=\"#Rules：Call\" class=\"headerlink\" title=\"Rules：Call\"></a>Rules：Call</h3><p>处理source</p>\n<ul>\n<li>这里的l理解成调用点，m理解成调用的目标方法，如果目标方法是Source，就把tl加到r的指针集中</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230919155237335.png\" alt=\"image-20230919155237335\"></p>\n<h3 id=\"Rules：Same-As-Pointer-Analysis\"><a href=\"#Rules：Same-As-Pointer-Analysis\" class=\"headerlink\" title=\"Rules：Same As Pointer Analysis\"></a>Rules：Same As Pointer Analysis</h3><p>处理传播</p>\n<p><img src=\"/../Program-Analysis-04/image-20230919155357590.png\" alt=\"image-20230919155357590\"></p>\n<h3 id=\"Rules：Call-1\"><a href=\"#Rules：Call-1\" class=\"headerlink\" title=\"Rules：Call\"></a>Rules：Call</h3><p><img src=\"/../Program-Analysis-04/image-20230919155610097.png\" alt=\"image-20230919155610097\"></p>\n<p>处理Sink</p>\n<ul>\n<li>从CAll graph中取出目标方法</li>\n<li>如果目标方法属于Sink，如果参数中有污点数据，就把他加到TaintFlows</li>\n</ul>\n<h3 id=\"An-Example\"><a href=\"#An-Example\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../Program-Analysis-04/image-20230919163312880.png\" alt=\"image-20230919163312880\"></p>\n<ul>\n<li><p>因为认为getPassword是一个Sink，所以根据Rule，会把t3加入到pw的指针集中</p>\n</li>\n<li><p>对于第七行log，因为log是一个sink方法，所以会检查他的参数s,s指向t3，而t3是一个污点的数据，在pw的指针集中。</p>\n</li>\n<li><p>所以把&lt;t3,log(String)&gt;加入到TainfFlows中，表示t3这个污点数据会流到log(String)方法中，会泄露出去。也可以通过PFG发现整个泄露的流程</p>\n<p><strong>但是指针分析也有处理不了的方法，比如这个”+”，append方法，就没法处理</strong></p>\n<p><img src=\"/../Program-Analysis-04/image-20230919163549201.png\" alt=\"image-20230919163549201\"></p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230919163622524.png\" alt=\"image-20230919163622524\"></p>\n<h1 id=\"Datalog-Based-Program-Analysis\"><a href=\"#Datalog-Based-Program-Analysis\" class=\"headerlink\" title=\"Datalog-Based Program Analysis\"></a>Datalog-Based Program Analysis</h1><h2 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h2><h3 id=\"Imperative-vs-Declarative-命名式-vs-声明式\"><a href=\"#Imperative-vs-Declarative-命名式-vs-声明式\" class=\"headerlink\" title=\"Imperative vs Declarative(命名式 vs 声明式)\"></a>Imperative vs Declarative(命名式 vs 声明式)</h3><ul>\n<li><p>Imperative：怎么做，java c++都是声明式语言</p>\n<p><img src=\"/../Program-Analysis-04/image-20230921100616138.png\" alt=\"image-20230921100616138\"></p>\n</li>\n<li><p>Declarative：做什么，SQL</p>\n<p><img src=\"/../Program-Analysis-04/image-20230921100626387.png\" alt=\"image-20230921100626387\"></p>\n</li>\n</ul>\n<h4 id=\"Pointer-Analysis-Imperative-Implementation\"><a href=\"#Pointer-Analysis-Imperative-Implementation\" class=\"headerlink\" title=\"Pointer Analysis Imperative Implementation\"></a>Pointer Analysis Imperative Implementation</h4><p> 如果要用命名式的语言实现指针分析，也就是具体的写一个代码，需要非常多细节的东西。</p>\n<h4 id=\"Pointer-Analysis-Declarative-Implementation\"><a href=\"#Pointer-Analysis-Declarative-Implementation\" class=\"headerlink\" title=\"Pointer Analysis Declarative Implementation\"></a>Pointer Analysis Declarative Implementation</h4><ul>\n<li>如果用datalog，就会很简单</li>\n</ul>\n<h2 id=\"Datalog\"><a href=\"#Datalog\" class=\"headerlink\" title=\"Datalog\"></a>Datalog</h2><ul>\n<li>是一种声明式的逻辑程序语言</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921112032438.png\" alt=\"image-20230921112032438\"></p>\n<ul>\n<li>没有赋值</li>\n<li>没有控制流</li>\n<li>没有函数</li>\n<li>不是图灵完备的</li>\n</ul>\n<h3 id=\"Predicates-Data-谓词\"><a href=\"#Predicates-Data-谓词\" class=\"headerlink\" title=\"Predicates(Data) 谓词\"></a>Predicates(Data) 谓词</h3><ul>\n<li>Datalog中，<strong>Predicates</strong> 位词（也可以叫relation）是一些列陈述的集合</li>\n<li>谓词是a table of data</li>\n<li>一个 <strong>fact</strong> 就是一个table中的一个tuple(元组)，通俗说就是属于这个表中的一条数据</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921112615343.png\" alt=\"image-20230921112615343\"></p>\n<ul>\n<li>显然根据这个例子，Xiaoming,18是一个fact，Abao,23不是一个fact</li>\n</ul>\n<h4 id=\"Atoms（元值，最小不可切分的一部分）\"><a href=\"#Atoms（元值，最小不可切分的一部分）\" class=\"headerlink\" title=\"Atoms（元值，最小不可切分的一部分）\"></a>Atoms（元值，最小不可切分的一部分）</h4><ul>\n<li>Atoms是Datalog中基本的元素，Atoms是Datalog的predicate</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921112906966.png\" alt=\"image-20230921112906966\"></p>\n<ul>\n<li>Terms<ul>\n<li>可以说变量：代表任意一个值 ，Age(person,age)</li>\n<li>也可以是常量 ，Age(“Xiaoming”,18)</li>\n</ul>\n</li>\n</ul>\n<p>P(X1,X2,…,Xn)是relational atom(关系型元词)</p>\n<p>Age(“Xiaoming”,18)就是relational atom(关系型元词)</p>\n<p>除了关系型元词，还有算数型元词</p>\n<ul>\n<li>age &gt;&#x3D; 18</li>\n</ul>\n<h3 id=\"Datalog-Rules-Logic\"><a href=\"#Datalog-Rules-Logic\" class=\"headerlink\" title=\"Datalog Rules(Logic)\"></a>Datalog Rules(Logic)</h3><ul>\n<li><p>Rule是表示逻辑推理的方法</p>\n</li>\n<li><p>Rule也用来具体说明fact是如何推断出来的</p>\n</li>\n<li><p>rule的形式是：</p>\n<p><img src=\"/../Program-Analysis-04/image-20230921114331264.png\" alt=\"image-20230921114331264\"></p>\n</li>\n<li><p>这里意味着从Body推出head，如果body是真的，那么head是真的</p>\n</li>\n<li><p>这里的逗号看成逻辑与</p>\n</li>\n</ul>\n<h3 id=\"Interpretation-of-Datalog-Rules\"><a href=\"#Interpretation-of-Datalog-Rules\" class=\"headerlink\" title=\"Interpretation of Datalog Rules\"></a>Interpretation of Datalog Rules</h3><ul>\n<li>考虑子目标中所有可能的组合</li>\n<li>如果一个组合让所有的subgoals都是true，那这个head astom也是真的</li>\n<li>这个head的predicate包含了所有的true astorm</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921120449099.png\" alt=\"image-20230921120449099\"></p>\n<p>对于一个Datalog program，就是Facts + Rules</p>\n<p><img src=\"/../Program-Analysis-04/image-20230921120748690.png\" alt=\"image-20230921120748690\"></p>\n<p><strong>问题：那最开始的fact咋来的呢？</strong></p>\n<h3 id=\"EDB-and-IDB-Predicates\"><a href=\"#EDB-and-IDB-Predicates\" class=\"headerlink\" title=\"EDB and IDB Predicates\"></a>EDB and IDB Predicates</h3><p>datalog中提供了2种谓词</p>\n<ul>\n<li>EDB（Extensional database 外部数据库）<ul>\n<li>谓词是最开始被定义的</li>\n<li>relations是可以枚举的</li>\n<li>看成是input relations，因为是<strong>输入的</strong>，所以不需要经过推理</li>\n</ul>\n</li>\n<li>IDB（intensional database ）<ul>\n<li>谓词是通过rules建立的</li>\n<li>relations是由规则判断的</li>\n<li>能被看成是<strong>输出的</strong>relations，通过rules推导出来的</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921121713684.png\" alt=\"image-20230921121713684\"></p>\n<h3 id=\"Logical-Or\"><a href=\"#Logical-Or\" class=\"headerlink\" title=\"Logical Or\"></a>Logical Or</h3><p>Datalog中有两种表达Logical or的方式</p>\n<ul>\n<li>在头部写多个Rules</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921122002702.png\" alt=\"image-20230921122002702\"></p>\n<ul>\n<li><p>使用逻辑 or 操作符 分号 ; </p>\n<p><img src=\"/../Program-Analysis-04/image-20230921122028830.png\" alt=\"image-20230921122028830\"></p>\n</li>\n</ul>\n<p>逻辑or的优先级比逻辑与and低</p>\n<h3 id=\"Negation-逻辑非\"><a href=\"#Negation-逻辑非\" class=\"headerlink\" title=\"Negation(逻辑非)\"></a>Negation(逻辑非)</h3><p><img src=\"/../Program-Analysis-04/image-20230921122323659.png\" alt=\"image-20230921122323659\"></p>\n<p><img src=\"/../Program-Analysis-04/image-20230921122330377.png\" alt=\"image-20230921122330377\"></p>\n<ul>\n<li>对于计算补考的学生，就用<code>Student(student),!PassedStd(student)</code></li>\n</ul>\n<h3 id=\"Recursion\"><a href=\"#Recursion\" class=\"headerlink\" title=\"Recursion\"></a>Recursion</h3><ul>\n<li>Datalog支持递归的规则<ul>\n<li>这也就意味着IDB predicate能从它自身推断出来</li>\n</ul>\n</li>\n<li>例如，我们可以通过递归的规则计算图的可达性</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921122908651.png\" alt=\"image-20230921122908651\"></p>\n<ul>\n<li>已知Edge(a,b)是从a到b之间有一条边，Reach(a,b)是从a可以到b</li>\n<li>那么可以推导出Reach(from,to)，从from到node可达，且从node到to之间有一条边，那么从from到to就可达</li>\n</ul>\n<p><strong>有了递归的好处在于</strong></p>\n<ul>\n<li><p>如果没有，就像sql一样，只能表达基本的查询</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token keyword\">from</span>  <span class=\"token keyword\">where</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"Rule-Safety\"><a href=\"#Rule-Safety\" class=\"headerlink\" title=\"Rule Safety\"></a>Rule Safety</h3><p><img src=\"/../Program-Analysis-04/image-20230921124150328.png\" alt=\"image-20230921124150328\"></p>\n<p>对于这两个rules，B(y)可以理解成在B中</p>\n<ul>\n<li>首先左边满足B,且x &gt;y，但是并没有限制x，所以会穷举所有的x，所以是无穷的</li>\n<li>对于右边的，同样是无穷的</li>\n</ul>\n<p>这种情况下，会让A也是无穷的，Datalog一直在计算</p>\n<p><strong>Datalog规定的规则：</strong></p>\n<ul>\n<li>A rule是safe当每个变量至少出现在一个<strong>non-nagated relations atom</strong>中。就是不出现在非中<ul>\n<li>因为非是一个无穷的集合，所以要不出现在非中</li>\n</ul>\n</li>\n<li>上面两个rules是safe</li>\n<li>datalog只允许写下安全的rules</li>\n</ul>\n<h3 id=\"Recursion-and-Negation\"><a href=\"#Recursion-and-Negation\" class=\"headerlink\" title=\"Recursion and Negation\"></a>Recursion and Negation</h3><p><img src=\"/../Program-Analysis-04/image-20230921180244052.png\" alt=\"image-20230921180244052\"></p>\n<p>在这个例子中，如果B(1)是true，</p>\n<ul>\n<li><p>假设A(1)是false，这又推导出A(1)是true。</p>\n</li>\n<li><p>假设A(1)是false, A(1)又是true</p>\n</li>\n</ul>\n<p>所以这互相矛盾。</p>\n<p><strong>因此，Datalog中，递归和一个atom的非必须是分开的。</strong></p>\n<h3 id=\"Execution-of-Datalog-Programs\"><a href=\"#Execution-of-Datalog-Programs\" class=\"headerlink\" title=\"Execution of Datalog Programs\"></a>Execution of Datalog Programs</h3><p><img src=\"/../Program-Analysis-04/image-20230921180047314.png\" alt=\"image-20230921180047314\"></p>\n<ul>\n<li>通过输入EDB和Rules，在datalog engine中，直到没有新的IDB生成</li>\n<li>单调性：只会有越来越多的facts，facts不会被删除</li>\n<li>一定会终止：<ul>\n<li>因为是单调的</li>\n<li>根据rule safety，是不允许它一直递归下去的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pointer-Analysis-via-Datalog\"><a href=\"#Pointer-Analysis-via-Datalog\" class=\"headerlink\" title=\"Pointer Analysis via Datalog\"></a>Pointer Analysis via Datalog</h2><p>EDB：指针分析中的EDB就是指针相关的信息</p>\n<p>IDB：指针分析的结果</p>\n<p>Rules:指针分析的rules</p>\n<p><img src=\"/../Program-Analysis-04/image-20230921205344214.png\" alt=\"image-20230921205344214\"></p>\n<h3 id=\"An-Example-1\"><a href=\"#An-Example-1\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><h4 id=\"形成EDB\"><a href=\"#形成EDB\" class=\"headerlink\" title=\"形成EDB\"></a>形成EDB</h4><ul>\n<li>把程序变成谓词</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921205716360.png\" alt=\"image-20230921205716360\"></p>\n<h4 id=\"Datalog-Rules-for-Pointer-Analysis\"><a href=\"#Datalog-Rules-for-Pointer-Analysis\" class=\"headerlink\" title=\"Datalog Rules for Pointer Analysis\"></a>Datalog Rules for Pointer Analysis</h4><p><img src=\"/../Program-Analysis-04/image-20230921210232986.png\" alt=\"image-20230921210232986\"></p>\n<ul>\n<li>红色表示已知的，蓝色表示推导出的结果</li>\n<li>这就可以看出用datalog实现pointer analysis十分的简洁</li>\n</ul>\n<h4 id=\"具体实现-算法\"><a href=\"#具体实现-算法\" class=\"headerlink\" title=\"具体实现(算法)\"></a>具体实现(算法)</h4><p><img src=\"/../Program-Analysis-04/image-20230921211331632.png\" alt=\"image-20230921211331632\"></p>\n<ul>\n<li>首先判断符合new的语句，枚举表中的所有情况，在varPointsTo中添加，b o1 ,c o3</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921210953424.png\" alt=\"image-20230921210953424\"></p>\n<ul>\n<li>应用assign的规则</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921211009881.png\" alt=\"image-20230921211009881\"></p>\n<ul>\n<li>应用store：</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921211313188.png\" alt=\"image-20230921211313188\"></p>\n<ul>\n<li>应用load</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230921211400383.png\" alt=\"image-20230921211400383\"></p>\n<p>根据已有fact，应用rules，得到更多的fact,实际执行时候是不断迭代的，有新的rules能调用，就调用，并不是上面写的算法的过程。</p>\n<h3 id=\"Handle-method-calls\"><a href=\"#Handle-method-calls\" class=\"headerlink\" title=\"Handle method calls\"></a>Handle method calls</h3><p><img src=\"/../Program-Analysis-04/image-20230922210954500.png\" alt=\"image-20230922210954500\"></p>\n<p>ThisVar：存在是this指针，m就是方法，this就是变量</p>\n<p>由于方法调用是做4件事，这里也是在做4件事，这里用了3个rule</p>\n<p><strong>第一个Rule:Dispatch，传this</strong></p>\n<p><img src=\"/../Program-Analysis-04/image-20230922211113498.png\" alt=\"image-20230922211113498\"></p>\n<p>EDB:</p>\n<ul>\n<li>首先是一个virtucal call，l：表示调用点，也是Label，x是变量，k是方法</li>\n<li>VarPointsTo表示x指向oi</li>\n<li>利用Dispatch表，找到了目标方法m</li>\n<li>根据ThisVar表，得到了this</li>\n</ul>\n<p>IDB：</p>\n<p>根据上面的输入，得到了</p>\n<ul>\n<li>传this，也就是this也指向o</li>\n<li>把m方法加到Reachable中</li>\n</ul>\n<p><strong>第二个Rule：传参数</strong></p>\n<p>Argument：l是调用点,i表示第几个，下标，,a实参</p>\n<p>Parameter：m是放，i表示第几个，下标，p形参</p>\n<p><img src=\"/../Program-Analysis-04/image-20230922210542971.png\" alt=\"image-20230922210542971\"></p>\n<p><strong>第三个Rule：传返回值</strong></p>\n<p><img src=\"/../Program-Analysis-04/image-20230922210734375.png\" alt=\"image-20230922210734375\"></p>\n<ul>\n<li>根据CallGraph获取方法m</li>\n<li>获取m方法的返回值</li>\n<li>获取返回值的指针</li>\n<li>获取接收的方法，把o传给接收的方法</li>\n</ul>\n<p>对于全程序的指针分析</p>\n<ul>\n<li><p>入口方法一定是可达的，所以要加一个EntryMethod</p>\n</li>\n<li><p>对于new，要加一个Reachable，只有方法可达，才处理</p>\n</li>\n</ul>\n<p><strong>那为什么只有new加了Reachable呢？</strong></p>\n<ul>\n<li>因为其他方法都有VarPointsTo，如果方法不可达，那VarPointsTo肯定为假，所以也就不会触发相关的load store语句</li>\n</ul>\n<h2 id=\"Taint-Analysis-via-Datalog\"><a href=\"#Taint-Analysis-via-Datalog\" class=\"headerlink\" title=\"Taint Analysis via Datalog\"></a>Taint Analysis via Datalog</h2><p><img src=\"/../Program-Analysis-04/image-20230922212727819.png\" alt=\"image-20230922212727819\"></p>\n<p>在指针分析的基础上</p>\n<ul>\n<li>需要Source</li>\n<li>需要Sink</li>\n<li>Taint：关联每个call site到污点数据的call site</li>\n</ul>\n<p>IDB predicate</p>\n<ul>\n<li>TaintFlow(t:T, m : M )表示t这个污点数据会流到sink method m处</li>\n</ul>\n<h3 id=\"Handle-Sources-and-Sinks\"><a href=\"#Handle-Sources-and-Sinks\" class=\"headerlink\" title=\"Handle Sources and Sinks\"></a>Handle Sources and Sinks</h3><p><img src=\"/../Program-Analysis-04/image-20230922213020094.png\" alt=\"image-20230922213020094\"></p>\n<p>Handle sources：</p>\n<ul>\n<li>CallGraph：l , m</li>\n<li>现在告诉我m是个Source方法</li>\n<li>接收变量是r</li>\n<li>Taint告诉我现在在l 处产生了一个污点数据t</li>\n<li>因此把r 指向t</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230922213027486.png\" alt=\"image-20230922213027486\"></p>\n<ul>\n<li>取出调用边</li>\n<li>现在m方法的第i个参数是个Sink</li>\n<li>取出第i个的实参</li>\n<li>取出它的指针集</li>\n<li>从Taint中取出它的label  j </li>\n<li>推导出从j处来的可能流到l调用点处的第i个参数中。</li>\n</ul>\n<p><strong>本质上就把EDB理解成表，所以EDB的rules就是在查表，IDB就是通过查表得出来的结论。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>优势：</p>\n<ul>\n<li>代码可读性很强</li>\n<li>隐藏了很多细节，所以很容易实现</li>\n<li>从优化的引擎中可以获益</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>限制了表达逻辑，有些情况不能表达</li>\n<li>不能完全控制，因为中间是个引擎，是个黑盒子</li>\n</ul>\n<p><img src=\"/../Program-Analysis-04/image-20230922214453887.png\" alt=\"image-20230922214453887\"></p>\n","text":"Static Analysis for securityInformation Flow Security目标 避免不想要的信息流 Access Control vs. Information Flow SecurityAccess Control 检查程序是否有权限 关心信息是...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Static-Analysis-for-security\"><span class=\"toc-text\">Static Analysis for security</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Information-Flow-Security\"><span class=\"toc-text\">Information Flow Security</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Access-Control-vs-Information-Flow-Security\"><span class=\"toc-text\">Access Control vs. Information Flow Security</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Information-Flow\"><span class=\"toc-text\">Information Flow</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Information-Flow-security\"><span class=\"toc-text\">Information Flow security</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Security-Levels\"><span class=\"toc-text\">Security Levels</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Information-Flow-Policy\"><span class=\"toc-text\">Information Flow Policy</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Confidentiality-and-Integrity%EF%BC%88%E4%BF%9D%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">Confidentiality and Integrity（保密性和完整性）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Integrity\"><span class=\"toc-text\">Integrity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Confidentiality-and-Integrity\"><span class=\"toc-text\">Confidentiality and Integrity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Integrity-%E6%9B%B4%E5%B9%BF%E6%B3%9B%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">Integrity 更广泛的定义</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Explict-Flows-and-Covert-Channels%EF%BC%88%E6%98%BE%E7%A4%BA%E6%B5%81%E5%92%8C%E9%9A%90%E8%97%8F%E4%BF%A1%E9%81%93%EF%BC%89\"><span class=\"toc-text\">Explict Flows and Covert Channels（显示流和隐藏信道）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Does-Secret-Information-Leak%EF%BC%9F\"><span class=\"toc-text\">Does Secret Information Leak？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Convert-Hidden-Channels\"><span class=\"toc-text\">Convert&#x2F;Hidden Channels</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Explicit-Flows-and-Convert-Channels\"><span class=\"toc-text\">Explicit Flows and Convert Channels</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Taint-Analysis-%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90\"><span class=\"toc-text\">Taint Analysis(污点分析)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Taint-Analysis-%EF%BC%9ATwo-Applications\"><span class=\"toc-text\">Taint Analysis ：Two Applications</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Taint-Analysis-and-Pointer-Analysis-Together\"><span class=\"toc-text\">Taint Analysis and Pointer Analysis, Together*</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Domains-and-Notations\"><span class=\"toc-text\">Domains and Notations</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Taint-Analysis%EF%BC%9AInputs-Outputs\"><span class=\"toc-text\">Taint Analysis：Inputs &amp; Outputs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%9ACall\"><span class=\"toc-text\">Rules：Call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%9ASame-As-Pointer-Analysis\"><span class=\"toc-text\">Rules：Same As Pointer Analysis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%9ACall-1\"><span class=\"toc-text\">Rules：Call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example\"><span class=\"toc-text\">An Example</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Datalog-Based-Program-Analysis\"><span class=\"toc-text\">Datalog-Based Program Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Motivation\"><span class=\"toc-text\">Motivation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Imperative-vs-Declarative-%E5%91%BD%E5%90%8D%E5%BC%8F-vs-%E5%A3%B0%E6%98%8E%E5%BC%8F\"><span class=\"toc-text\">Imperative vs Declarative(命名式 vs 声明式)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Imperative-Implementation\"><span class=\"toc-text\">Pointer Analysis Imperative Implementation</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Declarative-Implementation\"><span class=\"toc-text\">Pointer Analysis Declarative Implementation</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Datalog\"><span class=\"toc-text\">Datalog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Predicates-Data-%E8%B0%93%E8%AF%8D\"><span class=\"toc-text\">Predicates(Data) 谓词</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Atoms%EF%BC%88%E5%85%83%E5%80%BC%EF%BC%8C%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E5%88%87%E5%88%86%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89\"><span class=\"toc-text\">Atoms（元值，最小不可切分的一部分）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Datalog-Rules-Logic\"><span class=\"toc-text\">Datalog Rules(Logic)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interpretation-of-Datalog-Rules\"><span class=\"toc-text\">Interpretation of Datalog Rules</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EDB-and-IDB-Predicates\"><span class=\"toc-text\">EDB and IDB Predicates</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Logical-Or\"><span class=\"toc-text\">Logical Or</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Negation-%E9%80%BB%E8%BE%91%E9%9D%9E\"><span class=\"toc-text\">Negation(逻辑非)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Recursion\"><span class=\"toc-text\">Recursion</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rule-Safety\"><span class=\"toc-text\">Rule Safety</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Recursion-and-Negation\"><span class=\"toc-text\">Recursion and Negation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Execution-of-Datalog-Programs\"><span class=\"toc-text\">Execution of Datalog Programs</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-via-Datalog\"><span class=\"toc-text\">Pointer Analysis via Datalog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-1\"><span class=\"toc-text\">An Example</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BD%A2%E6%88%90EDB\"><span class=\"toc-text\">形成EDB</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Datalog-Rules-for-Pointer-Analysis\"><span class=\"toc-text\">Datalog Rules for Pointer Analysis</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">具体实现(算法)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Handle-method-calls\"><span class=\"toc-text\">Handle method calls</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Taint-Analysis-via-Datalog\"><span class=\"toc-text\">Taint Analysis via Datalog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Handle-Sources-and-Sinks\"><span class=\"toc-text\">Handle Sources and Sinks</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Program-Analysis-05","uid":"f34c0862e405e67688bc815c83cfd9aa","slug":"Program-Analysis-05","date":"2023-09-16T13:35:49.000Z","updated":"2023-10-26T15:38:25.329Z","comments":true,"path":"api/articles/Program-Analysis-05.json","keywords":null,"cover":[],"text":"CFL-Reachability and IFDSInfeasible Paths： PFG中不会被执行的边 给定一个path，在静态时无法判断一条path是不是假边 根据语义，age是年龄，那就一定大于0，所以右边这条红色的一定不会被执行。这样的path是infeasible ...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Scala_LazyList反序列化漏洞利用","uid":"de8b97b3b30ced078cc1db74c65885b4","slug":"Scala-LazyList反序列化漏洞利用","date":"2023-09-04T14:20:44.000Z","updated":"2023-09-05T07:28:19.649Z","comments":true,"path":"api/articles/Scala-LazyList反序列化漏洞利用.json","keywords":null,"cover":[],"text":"引言 Click to see more SCTF的hello java看了大佬们的wp，完全看不懂。最近的WMCTF，发现很多关于java反序列化的知识,决心要好好学一下java反序列化&#x2F;再回头看这道题，搜索到了大佬的复现博客，赶紧膜拜了一下。 参考博客基于LazyL...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","count":1,"path":"api/tags/漏洞分析.json"},{"name":"Scala","slug":"Scala","count":1,"path":"api/tags/Scala.json"},{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}