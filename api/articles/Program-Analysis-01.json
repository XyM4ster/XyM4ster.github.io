{"title":"Program-Analysis-01","uid":"eee198b3106cda0f3696061d93d628ad","slug":"Program-Analysis-01","date":"2023-08-20T13:29:01.000Z","updated":"2023-10-26T15:30:35.746Z","comments":true,"path":"api/articles/Program-Analysis-01.json","keywords":null,"cover":[],"content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>学这个的起因是想入门一下模糊测试方向，跟着知乎的学习路线，学了这个课程</li>\n<li>谭老师和李老师讲的非常非常好</li>\n<li>兜兜转转学这个已经很久了，感觉很多地方还是不是理解的很明白</li>\n</ul>\n<h1 id=\"Programming-Languages-PL\"><a href=\"#Programming-Languages-PL\" class=\"headerlink\" title=\"Programming Languages(PL)\"></a>Programming Languages(PL)</h1><p><img src=\"/../Program-Analysis-01/image-20230806164104535.png\" alt=\"image-20230806164104535\"></p>\n<ul>\n<li><p>在运行程序前，分析程序可能有的问题</p>\n</li>\n<li><p>静态分析是在编译时，在程序运行之前，判断一个程序是否满足一些性质</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-01/image-20230806170110550.png\" alt=\"image-20230806170110550\"></p>\n<ul>\n<li><p>对于这些<code>interesting proverties</code>，比如是否有空指针，是不能直接被给出准确的答案的</p>\n<p><img src=\"/../Program-Analysis-01/image-20230806170455433.png\" alt=\"image-20230806170455433\"></p>\n</li>\n<li><p>sound包括truth</p>\n</li>\n<li><p>complete爆出来的一定是truth</p>\n</li>\n</ul>\n<p>从上面可以发现没有perfect，所以要么妥协<code>soundness</code>，要么妥协<code>completeness</code></p>\n<p>妥协<code>soundness</code>就会产生漏报</p>\n<p>妥协<code>completeness</code>就会产生误报</p>\n<p><img src=\"/../Program-Analysis-01/image-20230806170825386.png\" alt=\"image-20230806170825386\"></p>\n<ul>\n<li><p>所以 几乎所有的静态分析都是<code>sound</code>，意思就是能多报几个，即使里面有误报，也不漏报   </p>\n<p><img src=\"/../Program-Analysis-01/image-20230806171554556.png\" alt=\"image-20230806171554556\"></p>\n</li>\n<li><p>只有分析了 蓝色和 绿色两条路径，才能分析出 它是 not safe，所以要soundness</p>\n<p><img src=\"/../Program-Analysis-01/image-20230806172413490.png\" alt=\"image-20230806172413490\"></p>\n</li>\n<li><p>第一种方法虽然准确度高，但是浪费内存</p>\n<p>确保soundness(准确度)，保证精度和速度的平衡</p>\n<p>第一步：先抽象</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-01/image-20230806212413467.png\" alt=\"image-20230806212413467\"></p>\n<ul>\n<li>没有确定的值，用新的符号表示</li>\n</ul>\n<p>第二步：转换规则</p>\n<p><img src=\"/../Program-Analysis-01/image-20230806212727117.png\" alt=\"image-20230806212727117\"></p>\n<p>第三步：根据上一步确定的规则计算</p>\n<p><img src=\"/../Program-Analysis-01/image-20230806213040551.png\" alt=\"image-20230806213040551\"></p>\n<ul>\n<li>可以看出静态分析是有用的，但是由于是sound，over-approximated，  对于3来说就是误报，因为他是9</li>\n</ul>\n<p><img src=\"/../Program-Analysis-01/image-20230806213435210.png\" alt=\"image-20230806213435210\"></p>\n<ul>\n<li><p>flow merge很重要，因为很难考虑所有情况</p>\n<p><img src=\"/../Program-Analysis-01/image-20230806214553222.png\" alt=\"image-20230806214553222\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：静态分析和动态测试有什么不同？</strong></p>\n<ul>\n<li>静态分析是在程序编译时进行分析</li>\n</ul>\n<p>**Q2：soundness和completeness **</p>\n<ul>\n<li>静态分析不能直接给出准确的答案，要么是soundness，也就是过近似，包括很多结果，但是会误报</li>\n<li>要么是completeness，很精确，但是会漏报</li>\n<li>静态分析都是soundness</li>\n</ul>\n<p><strong>Q3：为什么静态分析需要soundness？</strong></p>\n<ul>\n<li>很显然他需要报出所有可能的结果</li>\n</ul>\n<p><strong>Q4：如何理解抽象和over-approximation？</strong></p>\n<p>如果想在程序运行前判断这个程序，那就需要对程序中的一些运算进行抽象，形成一定的规则来进行判断</p>\n<ul>\n<li>抽象之后的结果是尽可能满足所有情况的，对于特殊情况，就会有错误，所以是over-approximation</li>\n</ul>\n<h1 id=\"intermediate-representation\"><a href=\"#intermediate-representation\" class=\"headerlink\" title=\"intermediate representation\"></a>intermediate representation</h1><p><img src=\"/../Program-Analysis-01/image-20230807155037706.png\" alt=\"image-20230807155037706\"></p>\n<h2 id=\"Compiler\"><a href=\"#Compiler\" class=\"headerlink\" title=\"Compiler\"></a>Compiler</h2><p><img src=\"/../Program-Analysis-01/image-20230807160151499.png\" alt=\"image-20230807160151499\"></p>\n<ul>\n<li><p>词法分析器（Scanner），结合正则表达式，通过词法分析（Lexical Analysis）将 source code 翻译为 token。</p>\n</li>\n<li><p>语法分析器（Parser），结合上下文无关文法（Context-Free Grammar），通过语法分析（Syntax Analysis），将 token 解析为抽象语法树（Abstract Syntax Tree, AST）</p>\n</li>\n<li><p>语义分析器（Type Checker），结合属性文法（Attribute Grammar），通过语义分析（Semantic Analysis），将 AST 解析为 decorated AST</p>\n</li>\n<li><p>Translator，将 decorated AST 翻译为生成三地址码这样的中间表示形式（Intermediate Representation, IR），并<strong>基于 IR 做静态分析</strong>（例如代码优化这样的工作）。</p>\n</li>\n</ul>\n<p>经过前面所有的处理生成 IR ，静态分析器 对 IR进行分析 </p>\n<h3 id=\"AST-vs-IR\"><a href=\"#AST-vs-IR\" class=\"headerlink\" title=\"AST vs IR\"></a>AST vs IR</h3><p><strong>为什么Compiler中用IR而不是AST呢</strong></p>\n<p><img src=\"/../Program-Analysis-01/image-20230807161223246.png\" alt=\"image-20230807161223246\"></p>\n<ul>\n<li>AST是high-level，接近语法结构的</li>\n<li>AST是依赖语言的</li>\n<li>AST适合快速的类型检查</li>\n<li>AST缺少控制流信息，IR中的go to可以轻易的看出控制流信息</li>\n</ul>\n<h2 id=\"IR-3AC\"><a href=\"#IR-3AC\" class=\"headerlink\" title=\"IR:3AC\"></a>IR:3AC</h2><p><img src=\"/../Program-Analysis-01/image-20230807161524280.png\" alt=\"image-20230807161524280\"></p>\n<p><strong>为什么叫3地址码？</strong></p>\n<ul>\n<li>名称： a,b</li>\n<li>常量：3</li>\n<li>编译器生成的临时变量：t1,t2</li>\n</ul>\n<p>常见的 3AC 包括：</p>\n<ul>\n<li>x &#x3D; y bop z：双目运算并赋值，bop &#x3D; binary operator</li>\n<li>x &#x3D; uop z：单目运算并赋值，uop &#x3D; unary operator</li>\n<li>x &#x3D; y：直接赋值</li>\n<li>goto L：无条件跳转，L &#x3D; label</li>\n<li>if x goto L：条件跳转</li>\n<li>if x rop y goto L：包含了关系运算的条件跳转，rop &#x3D; relational operator</li>\n</ul>\n<h3 id=\"3AC-in-real-static-Analyzer-Soot\"><a href=\"#3AC-in-real-static-Analyzer-Soot\" class=\"headerlink\" title=\"3AC in real static Analyzer Soot\"></a>3AC in real static Analyzer Soot</h3><p>Soot是个静态分析的框架，其中的IR是Jimple</p>\n<p><strong>在Soot中，Java源代码首先被编译成Java字节码，然后将字节码转换为Jimple表示形式</strong></p>\n<p>Jimple：(Java Intermediate Language）是一种用于表示Java字节码的中间语言</p>\n<h2 id=\"jvm中的方法调用-（PL）\"><a href=\"#jvm中的方法调用-（PL）\" class=\"headerlink\" title=\"jvm中的方法调用:（PL）\"></a>jvm中的方法调用:（PL）</h2><ul>\n<li><p>invokespecial：call constructor, call superclass method(调用父类方法)，call private methods </p>\n</li>\n<li><p>invokevirtual：call  instance methods（virtual dispatch 动态分配）</p>\n</li>\n<li><p>invokeinterface：call static methods</p>\n</li>\n<li><p>method Signature：包含 class name（方法声明所在的类 ）  return type  method name(parameter1 type,parameter2 type)</p>\n</li>\n</ul>\n<p>下面是一些Jimple和对应的Java程序</p>\n<ol>\n<li><strong>方法调用</strong></li>\n</ol>\n<p><img src=\"/../Program-Analysis-01/image-20230809101253593.png\" alt=\"image-20230809101253593\"></p>\n<ul>\n<li>specialinvoke是在调用StringBuilder的构造器，void 表示没有返回值</li>\n</ul>\n<p><code>specialinvoke $r3.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();</code>  </p>\n<ul>\n<li>$r3表示临时变量，&lt;&gt;中的东西是method Signature, java.lang.StringBuilder就是所在的类, **&lt; init &gt;**是默认的构造函数</li>\n</ul>\n<p><code>$r3 = virtualinvoke $r3.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java, lang.String)&gt;(r1);</code></p>\n<ul>\n<li>是在$r3的基础上调用的方法， <code>$r3</code>是StringBuilder类，返回值是StringBuilder，调用append方法，java, lang.String是参数 类型</li>\n</ul>\n<ol start=\"2\">\n<li><strong>main方法调用</strong></li>\n</ol>\n<p><img src=\"/../Program-Analysis-01/image-20230809102623594.png\" alt=\"image-20230809102623594\"></p>\n<p>如果没给显示的构造函数，就会默认的生成一个构造函数</p>\n<ol start=\"3\">\n<li><strong>静态方法调用</strong></li>\n</ol>\n<p><img src=\"/../Program-Analysis-01/image-20230809105135545.png\" alt=\"image-20230809105135545\"></p>\n<p>clinit：一个类的静态初始化的函数，用于在类记载过程中执行类的初始化</p>\n<p>:::tips</p>\n<p>Java虚拟机加载一个类时，它会首先检查是否存在类的静态初始化代码块（<code>static &#123;&#125;</code>），如果存在，则将这些代码块的内容放入<code>&lt;clinit&gt;</code>方法中。<code>&lt;clinit&gt;</code>方法会在类首次使用之前被调用，确保类的静态初始化在使用之前完成</p>\n<p>:::</p>\n<h2 id=\"Static-Single-Assignment-SSA）静态单赋值\"><a href=\"#Static-Single-Assignment-SSA）静态单赋值\" class=\"headerlink\" title=\"Static Single Assignment(SSA）静态单赋值\"></a>Static Single Assignment(SSA）静态单赋值</h2><p><img src=\"/../Program-Analysis-01/image-20230809105950556.png\" alt=\"image-20230809105950556\"></p>\n<ul>\n<li>也就是每次都用一个最新的变量</li>\n</ul>\n<p><img src=\"/../Program-Analysis-01/image-20230809110000741.png\" alt=\"image-20230809110000741\"></p>\n<ul>\n<li>在merge的时候，会用$phi$，根据控制流的信息决定选择哪个变量</li>\n</ul>\n","text":"引言 学这个的起因是想入门一下模糊测试方向，跟着知乎的学习路线，学了这个课程 谭老师和李老师讲的非常非常好 兜兜转转学这个已经很久了，感觉很多地方还是不是理解的很明白 Programming Languages(PL) 在运行程序前，分析程序可能有的问题 静态分析是在编译时，在程...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Programming-Languages-PL\"><span class=\"toc-text\">Programming Languages(PL)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#intermediate-representation\"><span class=\"toc-text\">intermediate representation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Compiler\"><span class=\"toc-text\">Compiler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AST-vs-IR\"><span class=\"toc-text\">AST vs IR</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IR-3AC\"><span class=\"toc-text\">IR:3AC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3AC-in-real-static-Analyzer-Soot\"><span class=\"toc-text\">3AC in real static Analyzer Soot</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jvm%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%EF%BC%88PL%EF%BC%89\"><span class=\"toc-text\">jvm中的方法调用:（PL）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Static-Single-Assignment-SSA%EF%BC%89%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">Static Single Assignment(SSA）静态单赋值</span></a></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Program-Analysis-02","uid":"b13dd1cbb7113adce1a453324fe7b9f4","slug":"Program-Analysis-02","date":"2023-08-26T15:30:43.000Z","updated":"2023-10-26T15:37:45.041Z","comments":true,"path":"api/articles/Program-Analysis-02.json","keywords":null,"cover":[],"text":"Control Flow Analysis控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。 需要构建Control Flow Graph(CFG) CF...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"reverse","uid":"0294fa813f0b0ba2157b9babe3fad644","slug":"reverse","date":"2023-08-12T13:29:43.000Z","updated":"2023-09-04T14:17:07.296Z","comments":true,"path":"api/articles/reverse.json","keywords":null,"cover":null,"text":"好书推荐 恶意代码分析实战 逆向工程核心原理 加密和解密 ","link":"","photos":[],"count_time":{"symbolsCount":30,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"reverse","slug":"reverse","count":1,"path":"api/tags/reverse.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}