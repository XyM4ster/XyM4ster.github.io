{"title":"re-engineer-core-principle-01","uid":"e67072c96c2129e60add5b77588d8afa","slug":"re-engineer-core-principle-01","date":"2023-10-22T08:36:19.000Z","updated":"2024-02-29T10:45:32.693Z","comments":true,"path":"api/articles/re-engineer-core-principle-01.json","keywords":null,"cover":"/medias/pexels-luis-gomes-546819.jpg","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>看《逆向工程核心原理》这本书</p>\n<ul>\n<li>好久之前看了这本书的一部分，现在决定重新学一下。</li>\n<li>感觉逆向十分重要，且我的hxd wd-2711 (<a href=\"https://wd-2711.tech/\">https://wd-2711.tech/</a>) ，一直在学逆向，在他的感染下，我也开始学。</li>\n</ul>\n<h1 id=\"0x01-关于逆向工程\"><a href=\"#0x01-关于逆向工程\" class=\"headerlink\" title=\"0x01 关于逆向工程\"></a>0x01 关于逆向工程</h1><ol>\n<li>静态分析法：并不执行代码，观察代码文件的外部特征</li>\n</ol>\n<h1 id=\"0x02-逆向分析HelloWorld\"><a href=\"#0x02-逆向分析HelloWorld\" class=\"headerlink\" title=\"0x02 逆向分析HelloWorld\"></a>0x02 逆向分析HelloWorld</h1><h2 id=\"2-2-调试Helloworld-exe\"><a href=\"#2-2-调试Helloworld-exe\" class=\"headerlink\" title=\"2.2 调试Helloworld.exe\"></a>2.2 调试Helloworld.exe</h2><ul>\n<li>首先用ollydbg打开helloworld.exe</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013093429178.png\" alt=\"image-20231013093429178\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013093448005.png\" alt=\"image-20231013093448005\"></p>\n<h3 id=\"2-2-3-入口点\"><a href=\"#2-2-3-入口点\" class=\"headerlink\" title=\"2.2.3 入口点\"></a>2.2.3 入口点</h3><p><img src=\"/../re-engineer-core-principle-01/image-20231013093829285.png\" alt=\"image-20231013093829285\"></p>\n<ul>\n<li>这里是当前程序停止的地方，就是入口点</li>\n</ul>\n<h3 id=\"2-2-4-跟踪函数\"><a href=\"#2-2-4-跟踪函数\" class=\"headerlink\" title=\"2.2.4 跟踪函数\"></a>2.2.4 跟踪函数</h3><p>OllyDbg的基本指令</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013095050105.png\" alt=\"image-20231013095050105\"></p>\n<ul>\n<li>这里是visual C++的启动函数</li>\n<li>这里就是跟着书上一步一步调试，直到找到main函数</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013095146775.png\" alt=\"image-20231013095146775\"></p>\n<h2 id=\"2-3-熟悉调试器\"><a href=\"#2-3-熟悉调试器\" class=\"headerlink\" title=\"2.3 熟悉调试器\"></a>2.3 熟悉调试器</h2><h3 id=\"2-3-1-调试器指令\"><a href=\"#2-3-1-调试器指令\" class=\"headerlink\" title=\"2.3.1 调试器指令\"></a>2.3.1 调试器指令</h3><p><img src=\"/../re-engineer-core-principle-01/image-20231013094042111.png\" alt=\"image-20231013094042111\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013095301706.png\" alt=\"image-20231013095301706\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013163741437.png\" alt=\"image-20231013163741437\"></p>\n<h3 id=\"2-3-2-设置大本营\"><a href=\"#2-3-2-设置大本营\" class=\"headerlink\" title=\"2.3.2 设置大本营\"></a>2.3.2 设置大本营</h3><p>其实也就相当于设置断点</p>\n<p><strong>Goto 命令</strong></p>\n<ul>\n<li>ctrl + G设置地址为40104F</li>\n<li>执行F4就会让程序运行到该处</li>\n</ul>\n<p><strong>设置断点</strong></p>\n<ul>\n<li><p>F2设置断点</p>\n</li>\n<li><p>Ollydbu菜单栏中，选择View-Breakpoints选项，快捷键alt+B，打开Breakpoints对话框</p>\n</li>\n</ul>\n<p><strong>注释</strong></p>\n<ul>\n<li>按键盘上的 ;  可以添加注释</li>\n<li>鼠标右键，可以选择search for-User defined comment</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013100442632.png\" alt=\"image-20231013100442632\"></p>\n<p><strong>标签(label)</strong></p>\n<ul>\n<li>按键盘上的 ：  可以添加标签</li>\n<li>标签也可以按照上面的方法检索</li>\n</ul>\n<h2 id=\"2-4-快速查找指定的代码\"><a href=\"#2-4-快速查找指定的代码\" class=\"headerlink\" title=\"2.4 快速查找指定的代码\"></a>2.4 快速查找指定的代码</h2><p><strong>方法1：代码执行法</strong></p>\n<ul>\n<li>就是从头到尾执行代码，那可以根据程序运行的结果来判断是否找到了指定的代码</li>\n</ul>\n<p><strong>方法2：字符串检索法</strong></p>\n<p>VC++中默认字符串使用Unicode码表示，并且处理字符串中的API函数也都变更为Unicode系列函数。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013102006096.png\" alt=\"image-20231013102006096\"></p>\n<ul>\n<li>鼠标右键-Search for- All referenced text string，可以看到所有代码中引用的字符串</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013101454325.png\" alt=\"image-20231013101454325\"></p>\n<ul>\n<li>这里可以直接定位hello world的位置</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013101805690.png\" alt=\"image-20231013101805690\"></p>\n<ul>\n<li>接着在数据窗口，用goto 定位4092a0，</li>\n<li>找到helloworld。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013102225353.png\" alt=\"image-20231013102225353\"></p>\n<p>这里的4092A0和上面代码区域的401xxx不一样，HelloWorld.exe进程中，409XXX地址空间被用来保存程序使用的数据。</p>\n<p><strong>方法3：API检索法(1）</strong></p>\n<p>鼠标右键-Search for-All intermodular calls</p>\n<p>Ollydbg也可以摘录出程序调用的API函数列表</p>\n<ul>\n<li>我们可以根据程序的功能来大致判断他用的是哪些API,像上面这个弹出窗口的功能，大致是调用了<code>user32.MessageBoxW()</code>API</li>\n</ul>\n<p><strong>方法4：API检索法(2)</strong></p>\n<p>鼠标右键-Search for-Name in all calls</p>\n<p>Ollydbg也不能列出所有的API函数列表，如果使用压缩器&#x2F;保护器对文件压缩后，Ollydbg就无法提取了。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013103008416.png\" alt=\"image-20231013103008416\"></p>\n<p>这就需要向dll代码库中添加断点。</p>\n<p>API是操作系统对用户提供的函数，实现在<code>C:\\Windows\\systems32</code>文件夹中的*.dll文件。</p>\n<p>也就是我们编写的应用程序执行某种操作时，必须用os提供的API向os发送请求，此时<strong>与API对应的系统DLL文件就会被加载到应用程序的进程内存中</strong>。</p>\n<p><code>alt + M</code>打开内存映射窗口，这里可以看到HelloWorld的进程内存，底部的是User32库</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013160644214.png\" alt=\"image-20231013160644214\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013160739225.png\" alt=\"image-20231013160739225\"></p>\n<p>打开name in all moudles，这是.dll文件中提供的所有api，找到<code>messageboxw export</code>&#x2F;</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013170012356.png\" alt=\"image-20231013170012356\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013165912420.png\" alt=\"image-20231013165912420\"></p>\n<p>在40100e处调用了messageBoxW，执行完毕会返回到401014地址</p>\n<h2 id=\"2-5-使用打补丁修改helloworld字符串\"><a href=\"#2-5-使用打补丁修改helloworld字符串\" class=\"headerlink\" title=\"2.5 使用打补丁修改helloworld字符串\"></a>2.5 使用打补丁修改helloworld字符串</h2><h3 id=\"2-5-2修改字符串的两种方法\"><a href=\"#2-5-2修改字符串的两种方法\" class=\"headerlink\" title=\"2.5.2修改字符串的两种方法\"></a>2.5.2修改字符串的两种方法</h3><p><strong>方法1：直接修改字符串缓冲区</strong></p>\n<ul>\n<li>因为helloworld字符串是放在409a20这个地址处的，那我就直接在dump窗口执行Go to命令，进入字符串缓冲区，按<strong>ctrl + E</strong>打开编辑窗口</li>\n<li>unicode编码中用两个字节表示一个罗马字母，Unicode字符串必须以null结束，占据2个字节(添加null时不能直接在unicode文本框中进行，要在Hex中添加)</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013162129385.png\" alt=\"image-20231013162129385\"></p>\n<ul>\n<li>此时按F9继续执行程序，发现输出已经变了</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013162336335.png\" alt=\"image-20231013162336335\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013162414153.png\" alt=\"image-20231013162414153\"></p>\n<ul>\n<li>但是目前的更改只是在当前调试中的更改，如果想永久更改，需要选中字符串，右键copy to executable file，在弹窗的窗口中，右键选择save file</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013162634225.png\" alt=\"image-20231013162634225\"></p>\n<p><strong>方法2：在其他内存区域新建字符串并传递给消息函数</strong></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>应用程序被加载到内存时有一个最小的内存分配大小，一般为1000。 即使程序运行时只占用100 内存，它被加载到内存时仍然会分到1000 左右的内存，这些内存一部 分被程序占用，<strong>其余部分为空余区域，全部被填充为NULL</strong>。</p>\n</p>\n</div>\n<ul>\n<li>根据helloworld的地址是4092a0，向下滑动，发现有Null区域</li>\n<li>在这部分新增字符串‘</li>\n<li>在代码区，按空格修改push的地址</li>\n<li>运行程序，成功更改</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013163336603.png\" alt=\"image-20231013163336603\"></p>\n<p><strong>问题：但是把上面修改完的保存为可执行文件，却并不能正常运行</strong></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231013163631194.png\" alt=\"image-20231013163631194\"></p>\n<p><strong>Q：什么是启动函数</strong></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231014210444525.png\" alt=\"image-20231014210444525\"></p>\n<h1 id=\"0x03-小端序\"><a href=\"#0x03-小端序\" class=\"headerlink\" title=\"0x03 小端序\"></a>0x03 小端序</h1><h2 id=\"3-1-字节序\"><a href=\"#3-1-字节序\" class=\"headerlink\" title=\"3.1 字节序\"></a>3.1 字节序</h2><p>大端序：采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位</p>\n<p>小端序：地址高位存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒。<strong>Inter X86CPU采用小端序</strong></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015113654001.png\" alt=\"image-20231015113654001\"></p>\n<p>最后一行字母e的ASCII码是0x65，字符串最后以null结尾。</p>\n<p><strong>本书之后默认所有数据都采用小端序存储</strong></p>\n<h1 id=\"0x04-IA32寄存器\"><a href=\"#0x04-IA32寄存器\" class=\"headerlink\" title=\"0x04 IA32寄存器\"></a>0x04 IA32寄存器</h1><p>寄存器(Register)是CPU内部用来存放数据的一些小型存储区域，它与我们常说的RAM(Random AccessMemory，随机存储器、内存)略有不同。</p>\n<p>CPU访问(Access)RAM中的数据时要经过较长的物理路径，所以花费的时间要长一些。</p>\n<p>而寄存器集成在CPU内部，拥有非常高的读写速度。</p>\n<h2 id=\"4-2-IA-32寄存器\"><a href=\"#4-2-IA-32寄存器\" class=\"headerlink\" title=\"4.2 IA-32寄存器\"></a>4.2 IA-32寄存器</h2><p>IA-32是inter推出的32位元架构。</p>\n<h3 id=\"基本程序运行寄存器\"><a href=\"#基本程序运行寄存器\" class=\"headerlink\" title=\"基本程序运行寄存器\"></a><strong>基本程序运行寄存器</strong></h3><ul>\n<li>通用寄存器(General Purpose Registers，32位，8个)</li>\n<li>段寄存器(SegmentRegisters，16位，6个)</li>\n<li>程序状态与控制寄存器(Program Status and Control Registers，32位，1个)</li>\n<li>指令指针寄存器(Instruction Pointer，32位，1个)</li>\n</ul>\n<h4 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a><strong>通用寄存器</strong></h4><p>通用寄存器是一种通用型的寄存器，用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。</p>\n<p>IA-32中每个通用寄存器的大小都是32位，即4个字节。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015114535486.png\" alt=\"image-20231015114535486\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>在寄存器名称缩略语之前添加字母E(Extended，扩展)，表示该寄存器在 16位 CPU (IA-16) 时就已经存在，并且其大小在 IA-32 下由原 16位扩展为32 位。</p>\n<p>为了实现对低16位的兼容，各寄存器又可以分为高(H: High)、低(L: Low)几个独立寄存器</p>\n<ul>\n<li>EAX：32位</li>\n<li>AX：EAX的低16位</li>\n<li>AH：AX的高8位</li>\n<li>AL：AX的低8位</li>\n</ul>\n<p>若想全部使用4个字节(32位)，则使用 EAX;若只想使用2个字节(16位)，只要使用EAX的低16位部分AX就可以了。AX又分为高8位的AH与低8位的AL两个独立的寄存器。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015114921260.png\" alt=\"image-20231015114921260\"></p>\n\n</div>\n<ul>\n<li>EAX：(针对操作数和结果数据的)累加器</li>\n<li>EBX：(DS段中的数据指针)基址寄存器</li>\n<li>ECX：(字符串和循环操作的)计数器</li>\n<li>EDX：(IO指针)数据寄存器</li>\n</ul>\n<p>以上4个寄存器主要用在算术运算(ADD、SUB、XOR、OR等)指中，<strong>常常用来保存常量与变量的值</strong>。</p>\n<p>某些汇编指令(MUL、DIV、LODS等)直接用来操作特定寄存器，执行这些命令后，仅改变特定寄存器中的值。<br>此外，ECX与EAX也可以用于特殊用途。</p>\n<ul>\n<li>循环命令 (LOOP) 中，ECX用来循环计数 (loop count)，每执行一次循环，ECX都会减1。</li>\n<li><strong>EAX一般用在函数返回值中，所有Win 32 API函数都会先把返回值保存到EAX再返回。</strong></li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>编写Windows汇编程序时，Win32 ApI函数内部会使用ECX与EDX，所以当这两个寄存器中有值时，应该先保存一下。</p>\n</p>\n</div>\n<p>通用寄存器中的其他几个寄存器名称：</p>\n<ul>\n<li>EBP：(SS段中栈内数据指针)扩展基址指针寄存器</li>\n<li>ESI：(字符串操作源指针) 源变址寄存器口</li>\n<li>EDI：(字符串操作目标指针)目的变址寄存器</li>\n<li>ESP：(SS段中栈指针)栈指针寄存器</li>\n</ul>\n<p>以上4个寄存器主要用作<strong>保存内存地址</strong>的指针。</p>\n<ul>\n<li>ESP指示栈区域的栈顶地址，某些指令(PUSH、POP、CALL、RET)可以直接用来操作。ESP(栈区域管理是程序中相当重要的部分，请不要把ESP用作其他用途)。</li>\n<li>EBP表示栈区域的基地址，函数被调用时保存ESP的值，函数返回时再把值返回ESP，保证栈不会崩溃。</li>\n<li>ESI和EDI与特定指令(LODS、STOS、REP、MOVS等)一起使用，主要用于大存复制。</li>\n</ul>\n<h4 id=\"段寄存器\"><a href=\"#段寄存器\" class=\"headerlink\" title=\"段寄存器\"></a>段寄存器</h4><p>IA-32的保护模式中，段是一种内存保护技术，它把内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等，以保护内存。此外，它还同分页技术(Paging)一起用于将虚拟内存变更为实际物理内存。段内存记录在SDT(Segment Descriptor Table，段描述符表)中，而段寄存器就持有这些SDT的索引 (index)。</p>\n<p>下图描述了保护模式下的内存分段模型。段寄存器总共由6种寄存器组成，分别为CS、SS、DS、ES、FS、GS，<strong>每个寄存器的大小为16位，即2个字节</strong>。另外，每个段寄存器指向的段描述符(Segment Descriptor)与虚拟内存结合，形成一个线性地址(Linear Address)借助分页技术，线性地址最终被转换为实际的物理地址(PhysicalAddress)。</p>\n<ul>\n<li>CS：Code Segment，代码段寄存器</li>\n<li>SS：Stack Segment,栈段寄存器</li>\n<li>DS：Data Segment，数据段寄存器</li>\n<li>ES：Extra ( Data)Segment，附加(数据)段寄存器</li>\n<li>FS：Data Segment，数据段寄存器</li>\n<li>GS：Data Segment，数据段寄存器</li>\n</ul>\n<p>顾名思义，CS寄存器用于存放应用程序码所在段的段基址，SS寄存器用于存放栈段的段基址，DS寄存器用于存放数据段的段基址。ES、FS、GS寄存器用来存放程序使用的附加数据段的段基址，如图4-3所示。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015120247337.png\" alt=\"image-20231015120247337\"></p>\n<p>程序调试中会经常用到FS寄存器，它用于计算SEH(Structured Exception Handler，结构化异常处理机制)，TEB(Thread Environment Block，线程环境块)，PEB (Process Environment Block进程环境块)等地址。</p>\n<h4 id=\"程序状态与控制寄存器\"><a href=\"#程序状态与控制寄存器\" class=\"headerlink\" title=\"程序状态与控制寄存器\"></a>程序状态与控制寄存器</h4><ul>\n<li>EFLAGS：Flag Register 标志寄存器</li>\n</ul>\n<p>IA-32中标志寄存器的名称为EFLAGS，<strong>其大小为4个字节</strong> ( 32位，由原来的16位FLAGS寄存器扩展而来。）如图4-4所示，EFLAGS寄存器的每位都有意义，每位的值或为1或为0，代表On&#x2F;Off或True&#x2F;False。其中有些位由系统直接设定，有些位则根据程序命令的执行结果设置。<br>如上所述，EFLAGS寄存器共有32个位元，掌握每位的含义是相当困难的。学习代码逆向分析技术的初级阶段，只要掌握3个与程序调试相关的标志即可，分别为</p>\n<ul>\n<li>ZF ( Zero Flag，零标志)：若运算结果为0,其值为1。否则为0.</li>\n<li>OF(Overflow Flag，溢出标志)：有符号整数 (signedinteger)溢出时，OF值被置为1。此外，MSB(Most Significant Bit.<br>最高有效位)改变时，其值也被设为1。</li>\n<li>CF(Carry Flag，进位标志)：无符号整数(unsignedinteger)溢出时，其值也被置为1。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>以上3个标志之所以重要，是因为在某些汇编指令，特别是 Jcc(条件跳转) 指令中要检查这3个标志的值，并根据它们的值决定是否执行某个动作。</p>\n\n</div>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015120444276.png\" alt=\"image-20231015120444276\"></p>\n<h4 id=\"指令指针寄存器\"><a href=\"#指令指针寄存器\" class=\"headerlink\" title=\"指令指针寄存器\"></a>指令指针寄存器</h4><ul>\n<li>EIP: Instruction Pointer，指令指针寄存器</li>\n</ul>\n<ol>\n<li>指令指针寄存器保存着CPU要执行的指令地址，其大小为32位 (4个字节，由原16位IP寄存器扩展而来。</li>\n<li>程序运行时，CPU会读取EIP中一条指令的地址，传送指令到指令缓冲区后，EIP寄存器的值自动增加，增加的大小即是读取指令的字节大小。</li>\n<li>这样，CPU每次执行完一条指令，就会通过EIP寄存器读取并执行下一条指令。</li>\n<li>与通用寄存器不同，<strong>我们不能直接修改EIP的值，只能通过其他指令间接修改，这些特定指令包括JMP、Jcc、CALL、RET</strong>。此外，我们还可以通过中断或异常来修改EIP的值。</li>\n</ol>\n<h1 id=\"0x05-栈\"><a href=\"#0x05-栈\" class=\"headerlink\" title=\"0x05 栈\"></a>0x05 栈</h1><p><img src=\"/../re-engineer-core-principle-01/image-20231015223122835.png\" alt=\"image-20231015223122835\"></p>\n<p>栈内存在进程中的作用如下:</p>\n<p>​\t(1)暂时保存函数内的局部变量</p>\n<p>​\t(2)调用函数时传递参数。</p>\n<p>​\t(3)保存函数返回后的地址</p>\n<p>执行push指令后，ESP由16ff78变成了19ff74,把100压入栈，执行Pop后，又恢复为原来的状态。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015211931812.png\" alt=\"image-20231015211931812\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015211916356.png\" alt=\"image-20231015211916356\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015212127881.png\" alt=\"image-20231015212127881\"></p>\n<h1 id=\"0x06-分析abex’-crackme-1\"><a href=\"#0x06-分析abex’-crackme-1\" class=\"headerlink\" title=\"0x06 分析abex’ crackme#1\"></a>0x06 分析abex’ crackme#1</h1><p>可以看到整个代码中就有call MessageboxBoxA，是因为他是用汇编语言编写的可执行文件，反编译之后直接变为反汇编代码。</p>\n<p>而使用VC++等开发工具写的代码，会有一部分启动函数是由编译器添加的，这在反编译之后就会非常复杂。</p>\n<h2 id=\"汇编指令\"><a href=\"#汇编指令\" class=\"headerlink\" title=\"汇编指令\"></a>汇编指令</h2><p><img src=\"/../re-engineer-core-principle-01/image-20231015214115658.png\" alt=\"image-20231015214115658\"></p>\n<h2 id=\"6-2-破解\"><a href=\"#6-2-破解\" class=\"headerlink\" title=\"6.2 破解\"></a>6.2 破解</h2><p><img src=\"/../re-engineer-core-principle-01/image-20231015214805369.png\" alt=\"image-20231015214805369\"></p>\n<ul>\n<li>把这个命令直接改成<code>JMP 40103D</code>，直接跳转</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015215116417.png\" alt=\"image-20231015215116417\"></p>\n<h2 id=\"6-3-将参数压入栈\"><a href=\"#6-3-将参数压入栈\" class=\"headerlink\" title=\"6.3 将参数压入栈\"></a>6.3 将参数压入栈</h2><p>函数调用时的顺序与参数压入栈的顺序相反。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015214348459.png\" alt=\"image-20231015214348459\"></p>\n<p>这是因为在取参数时候，最顶上的会被取出来，那么第一个取出来的就是NULL，刚好和参数的顺序一样。</p>\n<h1 id=\"0x07-栈帧\"><a href=\"#0x07-栈帧\" class=\"headerlink\" title=\"0x07 栈帧\"></a>0x07 栈帧</h1><h2 id=\"7-1-栈帧\"><a href=\"#7-1-栈帧\" class=\"headerlink\" title=\"7.1 栈帧\"></a>7.1 栈帧</h2><ul>\n<li>栈帧就是<strong>利用EBP(栈指针，请注意不是ESP)寄存器访问栈内局部变量、参数函数返回地址</strong>等的手段。</li>\n<li>ESP寄存器承担着栈顶指针的作用，而EBP寄存器则负责行使栈帧指针的职能。</li>\n<li>程序运行中，ESP寄存器的值随时变化，访问栈中函数的局部变量、参数时，若以ESP值为基准编写程序会十分困难，并且也很难使CPU引用到准确的地址。</li>\n<li>所以，调用某函数时，先要把用作基准点(函数起始地址的ESP值保存到EBP.并维持在函数内部。这样，无论ESP的值如何变化，以EBP的值为基准(base)能够安全访问到</li>\n</ul>\n<h2 id=\"7-2-调试Stackframe-exe\"><a href=\"#7-2-调试Stackframe-exe\" class=\"headerlink\" title=\"7.2 调试Stackframe.exe\"></a>7.2 调试Stackframe.exe</h2><h3 id=\"7-2-1-StackFrame-cpp\"><a href=\"#7-2-1-StackFrame-cpp\" class=\"headerlink\" title=\"7.2.1 StackFrame.cpp\"></a>7.2.1 StackFrame.cpp</h3><p><img src=\"/../re-engineer-core-principle-01/image-20231015215500482.png\" alt=\"image-20231015215500482\"></p>\n<h3 id=\"7-2-2-开始执行main函数-生成栈帧\"><a href=\"#7-2-2-开始执行main函数-生成栈帧\" class=\"headerlink\" title=\"7.2.2 开始执行main函数&amp;生成栈帧\"></a>7.2.2 开始执行main函数&amp;生成栈帧</h3><p>main函数的起始地址，ESP的值是19FF30，401250保存在ESP中，也就是栈中，是main函数的返回地址。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015223417475.png\" alt=\"image-20231015223417475\"></p>\n<p>执行Push EBP，保存EBP的值。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015220155521.png\" alt=\"image-20231015220155521\"></p>\n<p>把ESP的值赋值给EBP,因为此时ESP是栈底指针，后续esp的值要一直改变，可以用ebp的值访问局部变量。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015220508559.png\" alt=\"image-20231015220508559\"></p>\n<p>右键，address,relative to ebp，此时可以看到Esp和EBP相同， 都是19ff2c，此处存着是最开始(push ebp)的值，19ff74，401250是之前就push到栈里的函数返回地址。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015221024389.png\" alt=\"image-20231015221024389\"></p>\n<h3 id=\"7-2-3-设置局部变量\"><a href=\"#7-2-3-设置局部变量\" class=\"headerlink\" title=\"7.2.3 设置局部变量\"></a>7.2.3 设置局部变量</h3><p><code>long a = 1, b=2;</code></p>\n<p>首先，esp-8是开辟了8字节的空间，因为long数据每个都是4字节。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016170656222.png\" alt=\"image-20231016170656222\"></p>\n<p>接着是两条赋值语句，这个DWORD是个类型转换，SS是Stack Segment的缩写，表示栈段。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016170946970.png\" alt=\"image-20231016170946970\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016170959484.png\" alt=\"image-20231016170959484\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016170859240.png\" alt=\"image-20231016170859240\"></p>\n<p>执行完之后，1和2就被添加到栈里。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016171112724.png\" alt=\"image-20231016171112724\"></p>\n<h3 id=\"7-2-4-add-函数参数传递与调用\"><a href=\"#7-2-4-add-函数参数传递与调用\" class=\"headerlink\" title=\"7.2.4 add()函数参数传递与调用\"></a>7.2.4 add()函数参数传递与调用</h3><p><code>add(a,b)</code></p>\n<p>首先会把调用add所需要的参数压入栈中，先放b再放a，接着调用add函数。这里看出之前把1,2压入栈中是为了通过ebp获取局部变量，赋值给函数调用的参数。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016171414497.png\" alt=\"image-20231016171414497\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016171542675.png\" alt=\"image-20231016171542675\"></p>\n<p><code>返回地址</code></p>\n<p>执行call命令进入被调用的函数之前，CPU会先把函数的返回地址压入栈中，用作函数执行完之后的返回地址。</p>\n<p>也就是会把，call的下一条指令的地址401041放到栈中。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016171847946.png\" alt=\"image-20231016171847946\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016171918029.png\" alt=\"image-20231016171918029\"></p>\n<h3 id=\"7-2-5-开始执行add-函数-生成栈帧\"><a href=\"#7-2-5-开始执行add-函数-生成栈帧\" class=\"headerlink\" title=\"7.2.5 开始执行add()函数&amp;生成栈帧\"></a>7.2.5 开始执行add()函数&amp;生成栈帧</h3><p><code>long add(long a,long b)&#123; &#125;</code></p>\n<p>函数开始执行时，栈中会单独生成与其对应的栈帧。</p>\n<p>正如前面执行main函数时，会保存main函数栈帧的ebp的地址一样，这里也会先保存ebp的值。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016172358269.png\" alt=\"image-20231016172358269\"></p>\n<p>然后把esp的值给ebp。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016172452520.png\" alt=\"image-20231016172452520\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016172545821.png\" alt=\"image-20231016172545821\"></p>\n<h3 id=\"7-2-6-设置add-函数的局部变量-x-y\"><a href=\"#7-2-6-设置add-函数的局部变量-x-y\" class=\"headerlink\" title=\"7.2.6 设置add()函数的局部变量(x,y)\"></a>7.2.6 设置add()函数的局部变量(x,y)</h3><p><code>long x = a, y = b</code></p>\n<p>这四条语句是开启8字节的空间给x,y，再从栈里取出原来存储的a b，把值赋给x y。</p>\n<p>&#x3D;&#x3D;这里发现函数内部的变量也是掀开偶空间，然后从上向下赋值，和栈增长的方法是相反的&#x3D;&#x3D;</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016172828154.png\" alt=\"image-20231016172828154\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016172946587.png\" alt=\"image-20231016172946587\"></p>\n<h3 id=\"7-2-7-ADD运算\"><a href=\"#7-2-7-ADD运算\" class=\"headerlink\" title=\"7.2.7 ADD运算\"></a>7.2.7 ADD运算</h3><p><code>return (x + y)</code></p>\n<p>首先把ebp-8也就是x&#x3D;1的值给EAX，然后让EAX和EBP-4(也就是x&#x3D;2)的值相加，最后把结果3赋值给EAX，并返回。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016173315433.png\" alt=\"image-20231016173315433\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016173506875.png\" alt=\"image-20231016173506875\"></p>\n<h3 id=\"7-2-8-删除函数add-的栈帧-函数执行完毕\"><a href=\"#7-2-8-删除函数add-的栈帧-函数执行完毕\" class=\"headerlink\" title=\"7.2.8 删除函数add()的栈帧&amp;函数执行完毕\"></a>7.2.8 删除函数add()的栈帧&amp;函数执行完毕</h3><p>对于这条命令，它会把ebp的值给esp，执行完之后，执行完上面的命令后，地址401003处的 SUB ESP8命令就会失效，即函数add的2个局部变量x、y不再有效。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016173615575.png\" alt=\"image-20231016173615575\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016173744525.png\" alt=\"image-20231016173744525\"></p>\n<p>执行pop ebp，之前把ebp的值放入栈中，现在把它Pop出来，让ebp恢复为之前的值19ff2c。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016174215493.png\" alt=\"image-20231016174215493\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016174243011.png\" alt=\"image-20231016174243011\"></p>\n<p><code>RETN</code></p>\n<p>执行return语句，函数返回到调用的下一条地址</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016174600901.png\" alt=\"image-20231016174600901\"></p>\n<h3 id=\"7-2-9-从栈中删除函数add-的参数-整理栈\"><a href=\"#7-2-9-从栈中删除函数add-的参数-整理栈\" class=\"headerlink\" title=\"7.2.9 从栈中删除函数add()的参数(整理栈)\"></a>7.2.9 从栈中删除函数add()的参数(整理栈)</h3><p>这里执行esp+8，因为add函数的参数  a  b不再需要了，所以就把他们去掉，此时栈内的情况如下。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016175651381.png\" alt=\"image-20231016175651381\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016175755922.png\" alt=\"image-20231016175755922\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>被调函数执行完毕后，函数的调用者(Caller)负责清理存储在栈中的参数，这种方式称为 cdecl方式;反之，被调用者(Callee)负责清理保存在栈中的参数，这种方式称为stdcall方式。这些函数调用规则统称为调用约定(Calling Convention)，这在程序开发与分析中是一个非常重要的概念，第 10章将进一步讲解相关内容。</p>\n</p>\n</div>\n<h3 id=\"7-2-10-调用printf-函数\"><a href=\"#7-2-10-调用printf-函数\" class=\"headerlink\" title=\"7.2.10 调用printf()函数\"></a>7.2.10 调用printf()函数</h3><p><code>printf(&quot;%d\\n&quot;,add(a,b))</code>这也是个函数，之前计算的结果存储在EAX中，所以先把EAX放到栈内，再把%d放入栈内，执行add函数。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016180435498.png\" alt=\"image-20231016180435498\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016180615114.png\" alt=\"image-20231016180615114\"></p>\n<p><code>add ESP 8</code></p>\n<p>执行结束后，去掉刚才添加的两个参数，黑色表示ESP的位置</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016180858517.png\" alt=\"image-20231016180858517\"></p>\n<h3 id=\"7-2-11-设置返回值\"><a href=\"#7-2-11-设置返回值\" class=\"headerlink\" title=\"7.2.11 设置返回值\"></a>7.2.11 设置返回值</h3><p><code>return 0</code></p>\n<p>XOR命令用来进行Exclusive OR bit(异或)运算，其特点为“2个相同的值进行XOR运算，结果为0”。XOR命令比<code>MOV EAX 0</code>命令执行速度快，常用于寄存器的初始化操作。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>相同的值连续执行两次变回原值，这个特征被用于编码和解码。</p>\n\n</div>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016181044043.png\" alt=\"image-20231016181044043\"></p>\n<h3 id=\"7-2-12-删除栈帧-main函数终止\"><a href=\"#7-2-12-删除栈帧-main函数终止\" class=\"headerlink\" title=\"7.2.12 删除栈帧&amp;main函数终止\"></a>7.2.12 删除栈帧&amp;main函数终止</h3><p>和前面一样，就是把EBP的值给ESP，相当于直接扔掉当前函数(main函数)内定义的局部变量，如下图的红色箭头所示。</p>\n<p>接着pop ebp，让ebp回到原来的值</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016181752517.png\" alt=\"image-20231016181752517\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016181735684.png\" alt=\"image-20231016181735684\"></p>\n<p>最后执行return ，整个流程结束。</p>\n<h2 id=\"7-3-设置Ollydbg选项\"><a href=\"#7-3-设置Ollydbg选项\" class=\"headerlink\" title=\"7.3 设置Ollydbg选项\"></a>7.3 设置Ollydbg选项</h2><h3 id=\"7-3-1-Disasm选项\"><a href=\"#7-3-1-Disasm选项\" class=\"headerlink\" title=\"7.3.1 Disasm选项\"></a>7.3.1 Disasm选项</h3><p>alt + O,选择Disasm</p>\n<p>分在Debugging options对话框中选择Disasm选项卡后，分别点击“Show default segments“Always show size ofmemory operands”左侧的复选框，取消选择。观察代码窗口可以发现，原来代码中显示的默认段与内存大小都不再显示了。</p>\n<h3 id=\"7-3-2-Analysis-1选项\"><a href=\"#7-3-2-Analysis-1选项\" class=\"headerlink\" title=\"7.3.2 Analysis 1选项\"></a>7.3.2 Analysis 1选项</h3><p>选择Analysis1选项卡，点击“SHOWAPGsand LOCALsin procedures”左侧的复选框，启用该选项。<br>局部变量、参数分别表示成了LOCAL.1、ARG.1的形显示。</p>\n<p>ollyDbg会直接分析函数为栈帧，然后把局部变量的个数、参数的个数等显示在代码窗口。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016182435181.png\" alt=\"image-20231016182435181\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：ESP和EBP指针</strong></p>\n<ul>\n<li>ESP就是栈顶指针，会根据Push pop命令，进行相应的移动</li>\n<li>EBP指针很重要，用来管理局部变量，参数，返回地址等。</li>\n</ul>\n<p><strong>Q2：整个程序执行过程中栈的变化</strong></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231015215500482.png\" alt=\"image-20231015215500482\"></p>\n<ol>\n<li>首先执行main函数，push main函数的返回地址</li>\n<li>push ebp，并把esp的值给ebp</li>\n<li>开辟8字节的空间，先Push a &#x3D; 1，再push b&#x3D;2</li>\n<li>执行add函数<ul>\n<li>为add函数开辟8字节的空间，先push b，再push a</li>\n<li>push函数的返回地址，也就是下一条指令的地址</li>\n<li>push ebp，把esp的值给ebp</li>\n<li>接着再开辟8字节的空间，此时也是先push b 再push a</li>\n<li>利用ebp 取出x y 的值，计算x + y的结果，给EAX寄存器</li>\n</ul>\n</li>\n<li>删除add函数的栈帧，也就是让add函数内定义的变量失效<ul>\n<li>把ebp的值赋给esp</li>\n<li>pop ebp，让ebp恢复成可以访问main函数的地址</li>\n</ul>\n</li>\n<li>删除add的参数a,b，因为不再用了</li>\n<li>执行printf函数<ul>\n<li>先push EAX中的值，再压%d</li>\n<li>执行函数</li>\n</ul>\n</li>\n<li>用XOR EAX EAX计算返回值 return 0</li>\n<li>删除main函数的栈帧<ul>\n<li>把ebp的值给esp</li>\n<li>pop ebp</li>\n</ul>\n</li>\n<li>程序结束</li>\n</ol>\n<h1 id=\"0x08-abex’-crackme-2\"><a href=\"#0x08-abex’-crackme-2\" class=\"headerlink\" title=\"0x08 abex’ crackme #2\"></a>0x08 abex’ crackme #2</h1><p>要调试的abex‘s crackme #2文件由Visual Basic编写而成</p>\n<h2 id=\"8-2-Visual-Basic文件的特征\"><a href=\"#8-2-Visual-Basic文件的特征\" class=\"headerlink\" title=\"8.2 Visual Basic文件的特征\"></a>8.2 Visual Basic文件的特征</h2><h3 id=\"8-2-1-VB专用引擎\"><a href=\"#8-2-1-VB专用引擎\" class=\"headerlink\" title=\"8.2.1 VB专用引擎\"></a>8.2.1 VB专用引擎</h3><p>VB文件使用名为MSVBVM60.dll(Microsoft Visual Basic Virtual Machine60)的VB专用引擎(也称为The Thunder Runtime Engine)。<br>举个使用VB引擎的例子，显示消息框时，VB代码中要调用MsgBox()函数。</p>\n<ul>\n<li>其实，VB编辑器真正调用的是MSVBVM60.dll里的rtcMsgBox()函数</li>\n<li>在该函数内部通过调用user32dIl里的MessageBoxW()函数( Win32 API)来工作</li>\n<li>也可以在VB代码中直接调用user32.dll里的MessageBoxW()。</li>\n</ul>\n<h3 id=\"8-2-2-本地代码和伪代码\"><a href=\"#8-2-2-本地代码和伪代码\" class=\"headerlink\" title=\"8.2.2 本地代码和伪代码\"></a>8.2.2 本地代码和伪代码</h3><p>根据使用的编译选项的不同，VB文件可以编译为本地代码(N code)与伪代码(Pcode)。</p>\n<ul>\n<li>本地代码一般使用易于调试器解析的IA-32指令</li>\n<li>而伪代码是一种解释器(Interpreter)语言，它使用由VB引擎实现虚拟机并可自解析的指令(字节码)。</li>\n<li>因此，若想准确解析VB的伪代码，就需要分析VB引擎并实现模拟器。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>伪代码具有与Java(Java虚拟机)、Python (Python专用引擎)类似的形态结构。使用伪代码的好处是非常方便代码移植(编写&#x2F;发布针对特定平台的引擎，用户代码借助它几乎可以不加任何修改地在指定平台上运行)。</p>\n</p>\n</div>\n<h3 id=\"8-2-3-事件处理程序\"><a href=\"#8-2-3-事件处理程序\" class=\"headerlink\" title=\"8.2.3 事件处理程序\"></a>8.2.3 事件处理程序</h3><p>VB主要用来编写GUI程序，IDE用户界面本身也最适合于GUI编程。由于VB程序采用Windows操作系统的事件驱动方式工作，所以在main()或WinMain()中并不存在用户代码(希望调试的代码)，用户代码存在于各个事件处理程序(event handler)之中。</p>\n<p>就上述abex’crackme#2而言，用户代码在点击Check按钮时触发的事件处理程序内</p>\n<h3 id=\"8-2-4-未文档化的结构体\"><a href=\"#8-2-4-未文档化的结构体\" class=\"headerlink\" title=\"8.2.4 未文档化的结构体\"></a>8.2.4 未文档化的结构体</h3><p>VB中使用的各种信息(Dialog、Control、Form、Module Function等)以结构体形式保存在文件内部。由于微软未正式公开这种结构体信息，所以调试VB文件会难一些。</p>\n<h2 id=\"8-3-开始调试\"><a href=\"#8-3-开始调试\" class=\"headerlink\" title=\"8.3 开始调试\"></a>8.3 开始调试</h2><p><img src=\"/../re-engineer-core-principle-01/image-20231016225055463.png\" alt=\"image-20231016225055463\"></p>\n<p>EP的地址为401238。</p>\n<ul>\n<li>401238地址处的<code>PUSH 401E14</code>命令用来把RT_MainStruct结构体的地址(401E14)压人栈。</li>\n<li>然后40123D地址处的CALL 00401232命令调用401232地址处的JMP DWORDPTR DS:[4010A0]指令。<ul>\n<li>该JMP指令会跳转至VB引擎的主函数ThunRTMain()(前面压人栈的401E14的值作为ThunRTMain0的参数)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-3-1-间接调用\"><a href=\"#8-3-1-间接调用\" class=\"headerlink\" title=\"8.3.1 间接调用\"></a>8.3.1 间接调用</h3><p>40123D地址处的CALL 401232命令用于调用ThunRTMain()函数，这里使用了较为特别的法。</p>\n<p>不是直接转到MSVBVM60.dll里的ThunRTMain()函数，而是通过中间401232地址处的JMP命令跳转。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231016225420659.png\" alt=\"image-20231016225420659\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>4010A0地址是IAT(Import Address Table,导入地址表)区域,包含着MSVBVM60.ThunRTMain()函数的实际地址。第13章将详细讲解IAT。</p>\n\n</div>\n<h3 id=\"8-3-2-RT-MainStruct结构体\"><a href=\"#8-3-2-RT-MainStruct结构体\" class=\"headerlink\" title=\"8.3.2 RT_MainStruct结构体\"></a>8.3.2 RT_MainStruct结构体</h3><p>RT_MainStruct结构体的成员是其他结构体的地址。也就是说，VB引擎通过参数传递过来的RT_MainStruct结构体获取程序运行需要的所有信息。</p>\n<h3 id=\"8-3-3-ThunRTMain-函数\"><a href=\"#8-3-3-ThunRTMain-函数\" class=\"headerlink\" title=\"8.3.3 ThunRTMain()函数\"></a>8.3.3 ThunRTMain()函数</h3><p>它存在于MSVBVM69.dll模块中，这里是VB引擎的代码</p>\n<h2 id=\"8-4-分析crackme\"><a href=\"#8-4-分析crackme\" class=\"headerlink\" title=\"8.4 分析crackme\"></a>8.4 分析crackme</h2><p><img src=\"/../re-engineer-core-principle-01/image-20231018210528823.png\" alt=\"image-20231018210528823\"></p>\n<p>根据显示的信息，用all reference string查找字符串。</p>\n<p>双击后，跳转到下面的地址。</p>\n<p>分析页面，应该是比较name和serial的值，如果相等就执行成功的代码，不相等，就输出serial wrong。</p>\n<p>因此，查看前后的代码，发现跳转指令。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231018211658692.png\" alt=\"image-20231018211658692\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">JE 跳转指令，ZF为1，跳转\n\nTest destination, source &#x2F;&#x2F;按位与，如果结果为零（所有位均为0），则将零标志位（ZF）设置为1；否则，将ZF设置为0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"8-4-2-查找字符串地址\"><a href=\"#8-4-2-查找字符串地址\" class=\"headerlink\" title=\"8.4.2 查找字符串地址\"></a>8.4.2 查找字符串地址</h3><p><img src=\"/../re-engineer-core-principle-01/image-20231019101358033.png\" alt=\"image-20231019101358033\"></p>\n<p>call指令上面的两个Push，是调用该函数的参数。</p>\n<p>猜想40341B地址处的函数__vbaVarTstNe，应该是字符串比较函数。</p>\n<p>调试到该地址处。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">LEA EAX,DWORD PTR SS:[EBP-44] &#x2F;&#x2F; SS表示栈段，EBP-44是栈内的局部地址，LEA是load effective address，加载地址给EAX<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在此状态下查看栈</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231019101513195.png\" alt=\"image-20231019101513195\"></p>\n<p>使用follow in dump，查看在内存中的状态。</p>\n<p>VB中使用的是可变长度的字符串，直接显示的不是字符串，是16字节大小的数据。19F264-19F254刚好是16bytes</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231019135346045.png\" alt=\"image-20231019135346045\"></p>\n<p>在OllyDbg的Dump窗口中选择右键菜单Long-Address with ASCI Idump命令。该命令可以把Dump窗口的查看形式变得与栈窗口一样，特别是针对字符串地址时可以将相应字符串显示出来。</p>\n<p>此时可以猜测19F254处的UNICODE “B6C9DAC9”是实际的serial值。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020204718907.png\" alt=\"image-20231020204718907\"></p>\n<p>再次运行，输入得到正确的结果。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231018214805795.png\" alt=\"image-20231018214805795\"></p>\n<h3 id=\"8-4-3-生成Serial的算法\"><a href=\"#8-4-3-生成Serial的算法\" class=\"headerlink\" title=\"8.4.3 生成Serial的算法\"></a>8.4.3 生成Serial的算法</h3><p>显然当前是一个check的处理函数，那往前找，找到了这个，典型的栈帧代码。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020205330667.png\" alt=\"image-20231020205330667\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>汇编指令NOP(No operation)：不执行任何的指令</p>\n</p>\n</div>\n<h3 id=\"8-4-4-预测代码\"><a href=\"#8-4-4-预测代码\" class=\"headerlink\" title=\"8.4.4 预测代码\"></a>8.4.4 预测代码</h3><p>预测一下生成 serial的方式。</p>\n<p>对于win32 Api来说，</p>\n<ul>\n<li>使用VB引擎的API读取字符串</li>\n<li>启动循环，对字符串加密</li>\n</ul>\n<h3 id=\"8-4-5-读取Name字符串的代码\"><a href=\"#8-4-5-读取Name字符串的代码\" class=\"headerlink\" title=\"8.4.5 读取Name字符串的代码\"></a>8.4.5 读取Name字符串的代码</h3><p>调试到这里</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020205921240.png\" alt=\"image-20231020205921240\"></p>\n<p>这里定义了获取name的逻辑，EBP-88处存着name字符串。</p>\n<p>但是我并没有找到，不知道为什么</p>\n<h3 id=\"8-4-6-加密循环\"><a href=\"#8-4-6-加密循环\" class=\"headerlink\" title=\"8.4.6 加密循环\"></a>8.4.6 加密循环</h3><p><img src=\"/../re-engineer-core-principle-01/image-20231020212331016.png\" alt=\"image-20231020212331016\"></p>\n<p>简单讲解上述循环的动作原理，就像在链表中使用next指针引用下一个元素一样，vbaVarForInit0、vbaVarForNext0可以使逆向分析人员在字符串对象中逐个引用字符。并且设置loopcount(EBX)使其按指定次数运转循环。</p>\n<p><strong>暂时先省略看汇编的部分，因为现在的主要工作也不是这个。</strong></p>\n<h2 id=\"8-5-小结\"><a href=\"#8-5-小结\" class=\"headerlink\" title=\"8.5 小结\"></a>8.5 小结</h2><p><strong>Q1：TEST AX,AX指令的理解</strong></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020213222574.png\" alt=\"image-20231020213222574\"></p>\n<h2 id=\"8-5-总结\"><a href=\"#8-5-总结\" class=\"headerlink\" title=\"8.5 总结\"></a>8.5 总结</h2><ul>\n<li>这一章的crackme的加密部分目前没有看，先整体的把这本书快速看完，总结基础的知识点，等开始刷题的时候再看</li>\n</ul>\n<h1 id=\"0x09-Process-Explorer-优秀的进程管理工具\"><a href=\"#0x09-Process-Explorer-优秀的进程管理工具\" class=\"headerlink\" title=\"0x09 Process Explorer 优秀的进程管理工具\"></a>0x09 Process Explorer 优秀的进程管理工具</h1><h2 id=\"9-1-Process-Explorer\"><a href=\"#9-1-Process-Explorer\" class=\"headerlink\" title=\"9.1 Process Explorer\"></a>9.1 Process Explorer</h2><p>windows操作系统一下一个优秀的进程管理工具</p>\n<h1 id=\"0x10-函数调用约定\"><a href=\"#0x10-函数调用约定\" class=\"headerlink\" title=\"0x10 函数调用约定\"></a>0x10 函数调用约定</h1><h2 id=\"10-1-函数调用约定\"><a href=\"#10-1-函数调用约定\" class=\"headerlink\" title=\"10.1 函数调用约定\"></a>10.1 函数调用约定</h2><p>栈是定义在进程中的一段内存空间，向下(低地址方向)扩展，且其大小被记录在PE头中。</p>\n<p><strong>Q1：函数执行完成后，栈中的参数如何处理</strong></p>\n<p>不用管。前面学的时候，在函数执行完毕，会把EBP的值给ESP，然后Pop ebp。所以其实并没有手动删除，只是在修改指针的位置。</p>\n<ul>\n<li>由于是临时使用的存储在栈中，即使不用了，把它清除掉也会浪费CPU资源</li>\n<li>在有新值时，原有值会被覆盖掉。且栈内存是固定的，不能释放。</li>\n</ul>\n<p><strong>Q2：函数执行完毕后，ESP的值如何变化？</strong></p>\n<ul>\n<li>ESP恢复到函数调用前的状态。</li>\n</ul>\n<p>函数调用后，如何处理ESP是函数调用约定处理的问题。主要的约定是：</p>\n<ul>\n<li>cdecl: C declaration</li>\n<li>stdcall: standard call</li>\n<li>fastcall</li>\n</ul>\n<h3 id=\"10-1-1-cdecl\"><a href=\"#10-1-1-cdecl\" class=\"headerlink\" title=\"10.1.1 cdecl\"></a>10.1.1 cdecl</h3><p>主要是在C语言中使用的方式，所以叫C declaration，调用者(Caller)负责处理栈。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>对于这个代码，在函数执行完毕后，会执行让<code>ADD ESP,8</code>，相当于去掉了刚才压入的参数1 , 2，这是调用者直接清理的，所以是cdecl。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020215155803.png\" alt=\"image-20231020215155803\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020215146580.png\" alt=\"image-20231020215146580\"></p>\n<h3 id=\"10-1-2-stdcall\"><a href=\"#10-1-2-stdcall\" class=\"headerlink\" title=\"10.1.2 stdcall\"></a>10.1.2 stdcall</h3><p>stdcall常用于win32 ApI，该方式是被调用者(callee)清理栈。</p>\n<p>C语言默认是cdecl，使用_stdcall关键字，就可以用stdcall了。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> _stdcall <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里最后直接是RETN 8，也就是<code>RETURN + POP 8</code>，这个40101C本来就是要Pop掉的返回地址，再pop 8，所以此时esp指向了19ff2c</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020215955002.png\" alt=\"image-20231020215955002\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020220008316.png\" alt=\"image-20231020220008316\"></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020220311279.png\" alt=\"image-20231020220311279\"></p>\n<p>这种方式的好处就是不用每次调这个函数都在主代码写一遍 <code>ADD ESP 8</code>。</p>\n<p>虽然Win32API是使用C语言编写的库，但它使用的是stdcall方式</p>\n<h3 id=\"10-1-3-fastcall\"><a href=\"#10-1-3-fastcall\" class=\"headerlink\" title=\"10.1.3 fastcall\"></a>10.1.3 fastcall</h3><p>fastcall方式与stdcall方式基本类似，但该方通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。</p>\n<p>若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。<br>fastcall方式的优势在于可以实现寸函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。</p>\n<p>单从函数调用本来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。</p>\n<p>倘若调用数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。</p>\n<p>此外，如果函数本身很复杂，导要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方</p>\n<h1 id=\"0x11-视频讲座\"><a href=\"#0x11-视频讲座\" class=\"headerlink\" title=\"0x11 视频讲座\"></a>0x11 视频讲座</h1><p>首先整个代码运行会显示这样两个东西，根据提示，那么第一步就是需要去除整个nags，也就是消息框。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022155521343.png\" alt=\"image-20231022155521343\"></p>\n<h2 id=\"11-2-分析\"><a href=\"#11-2-分析\" class=\"headerlink\" title=\"11.2 分析\"></a>11.2 分析</h2><p><strong>S1：预测代码</strong></p>\n<ul>\n<li>VISUAL BASIC中调用消息框的函数是MSVBVM50.rtcMsgBox，也就是需要找到这个API</li>\n<li>在ollydbg中，打开all intermodular calls，找到rtcMsgBox，并给每一个都设置断点</li>\n<li>运行程序，程序运行到402cfe处，向上拖动滚动条找到了显示nag的代码</li>\n</ul>\n<p>这个E8 1DE4FFFF 一共10位，占5个字节，一个字节是8bits，每一个是4bits。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231020225015573.png\" alt=\"image-20231020225015573\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CALL 00401120  &#x2F;&#x2F;32位操作数,在x86架构中，使用32位操作数的call指令占用5个字节<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022155929844.png\" alt=\"image-20231022155929844\"></p>\n<p><strong>S2：去除消息框</strong></p>\n<p><em>尝试方法1：直接在402cfe调用函数处修改</em></p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022160133004.png\" alt=\"image-20231022160133004\"></p>\n<p>也就是不调用原来的函数了，但是需要对栈进行处理，所以用这个对栈进行处理。</p>\n<p>使用Nop填充2个Bytes，保证和call的长度一致。</p>\n<p>但是由于下面的命令中用了EAX寄存器的值，也就是用到了函数返回的值，所以这种方法就不行了。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022160407758.png\" alt=\"image-20231022160407758\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>x86中使用EAX存储函数的返回值。</p>\n\n</div>\n<p><em>尝试方法2：找到函数最开始调用的栈帧，让函数直接返回，不调用该函数</em></p>\n<p>该思想相当于在函数一开始就Return了，也就不会执行下面整个rtcMsgBox()函数了。</p>\n<p>一直想上找，找到函数最开始的栈帧，也就是<code>push ebp mov ebp esp </code>的地方。</p>\n<p>直接修改为</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022160710004.png\" alt=\"image-20231022160710004\"></p>\n<p><strong>Q1：那这里的4是如何确定的呢？</strong></p>\n<p>是根据栈确定的。</p>\n<ul>\n<li>首先让代码运行到push ebp处，此时栈中肯定已经压了函数的返回地址。</li>\n<li>找到函数的返回地址<code>7401E5A9</code>，那么<code>7401E5A7</code>是调用这个函数的地方</li>\n<li>在 执行完<code>MOV EBP,ESP</code>时，观察此时esp的值<code>19fabc</code></li>\n<li>在执行到<code>7401E5A9</code>处时，观察esp的值此时是<code>19fac0</code></li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022152613692.png\" alt=\"image-20231022152613692\"></p>\n<p>执行完之后</p>\n<p>（用结束的esp -  进去之后的esp）&#x2F;4 &#x3D;个数</p>\n<p>个数-2&#x3D; 实际的参数个数  2是ebp加上返回地址</p>\n<p>实际的参数个数*4是最终return的值。</p>\n<p>12&#x2F;4 &#x3D; 3 -2 &#x3D;1 个参数 就return 4。</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022153232441.png\" alt=\"image-20231022153232441\"></p>\n<p>由于是stdcall(callee清理栈)，这里还可以一步一步调试程序，看是哪个程序跳转到了<code>7401e5a9</code></p>\n<p>在402db2处发现了<code>RETN 4</code>这个清理参数的语句，也可以确定是RETN 4</p>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022162808616.png\" alt=\"image-20231022162808616\"></p>\n<p><strong>S3：查找注册码</strong></p>\n<ul>\n<li>在取出了Nag之后，需要找到真正的注册码</li>\n<li>还是在all text string处，先根据提示的语句<code>wrong serial</code>找到具体的位置</li>\n<li>然后上下拖动滚动条，发现一个字符串比较函数<code>__vbaStrCmp</code></li>\n<li>之后猜测上面这个应该就是真正的regiter code</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-01/image-20231022163002596.png\" alt=\"image-20231022163002596\"></p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这一章通过一个例子来描述了整个过程，主要包括三步：</p>\n<ul>\n<li>预测代码，预测可能用到的函数，然后根据Intermodular calls找到代码位置</li>\n<li>修改目标函数，让它的功能不再起作用，有两种方法：<ul>\n<li>直接在目标函数处修改，但要看是不是满足字节大小的匹配</li>\n<li>看目标函数的调用位置，向前寻找它的栈帧，让调用目标函数的函数提前返回，使目标函数不再起作用</li>\n</ul>\n</li>\n<li>找到真正的注册码，根据错误提示信息，上下找，找敏感的函数，和关键的字符串</li>\n</ul>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","text":"引言看《逆向工程核心原理》这本书 好久之前看了这本书的一部分，现在决定重新学一下。 感觉逆向十分重要，且我的hxd wd-2711 (https://wd-2711.tech/) ，一直在学逆向，在他的感染下，我也开始学。 0x01 关于逆向工程 静态分析法：并不执行代码，观察代...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x01-%E5%85%B3%E4%BA%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\">0x01 关于逆向工程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x02-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90HelloWorld\"><span class=\"toc-text\">0x02 逆向分析HelloWorld</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E8%B0%83%E8%AF%95Helloworld-exe\"><span class=\"toc-text\">2.2 调试Helloworld.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-3-%E5%85%A5%E5%8F%A3%E7%82%B9\"><span class=\"toc-text\">2.2.3 入口点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-4-%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2.2.4 跟踪函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E7%86%9F%E6%82%89%E8%B0%83%E8%AF%95%E5%99%A8\"><span class=\"toc-text\">2.3 熟悉调试器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-1-%E8%B0%83%E8%AF%95%E5%99%A8%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">2.3.1 调试器指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-2-%E8%AE%BE%E7%BD%AE%E5%A4%A7%E6%9C%AC%E8%90%A5\"><span class=\"toc-text\">2.3.2 设置大本营</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">2.4 快速查找指定的代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E4%BD%BF%E7%94%A8%E6%89%93%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9helloworld%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">2.5 使用打补丁修改helloworld字符串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-2%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.5.2修改字符串的两种方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x03-%E5%B0%8F%E7%AB%AF%E5%BA%8F\"><span class=\"toc-text\">0x03 小端序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%AD%97%E8%8A%82%E5%BA%8F\"><span class=\"toc-text\">3.1 字节序</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x04-IA32%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">0x04 IA32寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-IA-32%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">4.2 IA-32寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">基本程序运行寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">通用寄存器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">段寄存器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">程序状态与控制寄存器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">指令指针寄存器</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x05-%E6%A0%88\"><span class=\"toc-text\">0x05 栈</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x06-%E5%88%86%E6%9E%90abex%E2%80%99-crackme-1\"><span class=\"toc-text\">0x06 分析abex’ crackme#1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">汇编指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">6.2 破解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E5%B0%86%E5%8F%82%E6%95%B0%E5%8E%8B%E5%85%A5%E6%A0%88\"><span class=\"toc-text\">6.3 将参数压入栈</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x07-%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">0x07 栈帧</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">7.1 栈帧</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E8%B0%83%E8%AF%95Stackframe-exe\"><span class=\"toc-text\">7.2 调试Stackframe.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-1-StackFrame-cpp\"><span class=\"toc-text\">7.2.1 StackFrame.cpp</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-2-%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8Cmain%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">7.2.2 开始执行main函数&amp;生成栈帧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-3-%E8%AE%BE%E7%BD%AE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">7.2.3 设置局部变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-4-add-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">7.2.4 add()函数参数传递与调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-5-%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8Cadd-%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">7.2.5 开始执行add()函数&amp;生成栈帧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-6-%E8%AE%BE%E7%BD%AEadd-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-x-y\"><span class=\"toc-text\">7.2.6 设置add()函数的局部变量(x,y)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-7-ADD%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">7.2.7 ADD运算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-8-%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0add-%E7%9A%84%E6%A0%88%E5%B8%A7-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95\"><span class=\"toc-text\">7.2.8 删除函数add()的栈帧&amp;函数执行完毕</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-9-%E4%BB%8E%E6%A0%88%E4%B8%AD%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0add-%E7%9A%84%E5%8F%82%E6%95%B0-%E6%95%B4%E7%90%86%E6%A0%88\"><span class=\"toc-text\">7.2.9 从栈中删除函数add()的参数(整理栈)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-10-%E8%B0%83%E7%94%A8printf-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">7.2.10 调用printf()函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-11-%E8%AE%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">7.2.11 设置返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-12-%E5%88%A0%E9%99%A4%E6%A0%88%E5%B8%A7-main%E5%87%BD%E6%95%B0%E7%BB%88%E6%AD%A2\"><span class=\"toc-text\">7.2.12 删除栈帧&amp;main函数终止</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-%E8%AE%BE%E7%BD%AEOllydbg%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">7.3 设置Ollydbg选项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-1-Disasm%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">7.3.1 Disasm选项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-2-Analysis-1%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">7.3.2 Analysis 1选项</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x08-abex%E2%80%99-crackme-2\"><span class=\"toc-text\">0x08 abex’ crackme #2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-2-Visual-Basic%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">8.2 Visual Basic文件的特征</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-2-1-VB%E4%B8%93%E7%94%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">8.2.1 VB专用引擎</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-2-2-%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%92%8C%E4%BC%AA%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">8.2.2 本地代码和伪代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-2-3-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">8.2.3 事件处理程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-2-4-%E6%9C%AA%E6%96%87%E6%A1%A3%E5%8C%96%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">8.2.4 未文档化的结构体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-3-%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">8.3 开始调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-1-%E9%97%B4%E6%8E%A5%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">8.3.1 间接调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-2-RT-MainStruct%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">8.3.2 RT_MainStruct结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-3-ThunRTMain-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">8.3.3 ThunRTMain()函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-4-%E5%88%86%E6%9E%90crackme\"><span class=\"toc-text\">8.4 分析crackme</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-2-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">8.4.2 查找字符串地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-3-%E7%94%9F%E6%88%90Serial%E7%9A%84%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">8.4.3 生成Serial的算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-4-%E9%A2%84%E6%B5%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">8.4.4 预测代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-5-%E8%AF%BB%E5%8F%96Name%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">8.4.5 读取Name字符串的代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-6-%E5%8A%A0%E5%AF%86%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">8.4.6 加密循环</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-5-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">8.5 小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">8.5 总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x09-Process-Explorer-%E4%BC%98%E7%A7%80%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">0x09 Process Explorer 优秀的进程管理工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-Process-Explorer\"><span class=\"toc-text\">9.1 Process Explorer</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x10-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">0x10 函数调用约定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-1-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">10.1 函数调用约定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-1-1-cdecl\"><span class=\"toc-text\">10.1.1 cdecl</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-1-2-stdcall\"><span class=\"toc-text\">10.1.2 stdcall</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-1-3-fastcall\"><span class=\"toc-text\">10.1.3 fastcall</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x11-%E8%A7%86%E9%A2%91%E8%AE%B2%E5%BA%A7\"><span class=\"toc-text\">0x11 视频讲座</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-2-%E5%88%86%E6%9E%90\"><span class=\"toc-text\">11.2 分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"re-engineer-core-principle-02","uid":"1e07b60d2029aa2ea6483727894829df","slug":"re-engineer-core-principle-02","date":"2023-10-22T08:39:11.000Z","updated":"2024-02-29T10:45:26.276Z","comments":true,"path":"api/articles/re-engineer-core-principle-02.json","keywords":null,"cover":"/medias/pexels-luis-gomes-546819.jpg","text":"引言 开启《逆向工程核心原理》的第二部分，冲冲冲！ 0x13 PE文件格式13.1 介绍PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。 PE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Tai-e-Static-Analysis-Framework-OOPSLA'23","uid":"e225c813c8f4b0b48846cd97578ebb48","slug":"Tai-e-Static-Analysis-Framework-OOPSLA-23","date":"2023-10-17T01:44:12.000Z","updated":"2023-10-18T09:35:53.722Z","comments":true,"path":"api/articles/Tai-e-Static-Analysis-Framework-OOPSLA-23.json","keywords":null,"cover":[],"text":"引言 这篇论文是我看谭老师课题组的第二篇文章，因为对于静态分析一直停留在理论，想着要看看代码，自己试试 ABSTRACT静态分析在Bug detection、安全分析、程序解释、优化等方面已经非常成熟。 静态分析在IR生成、confrol flow graph、control f...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}