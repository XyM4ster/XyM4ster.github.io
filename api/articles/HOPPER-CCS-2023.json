{"title":"HOPPER-CCS-2023","uid":"ac1f5803919fdd2ccf7eeca40ae91dc2","slug":"HOPPER-CCS-2023","date":"2023-11-14T02:06:39.000Z","updated":"2023-11-16T14:37:40.378Z","comments":true,"path":"api/articles/HOPPER-CCS-2023.json","keywords":null,"cover":[],"content":"<h1 id=\"ABSTRACT\"><a href=\"#ABSTRACT\" class=\"headerlink\" title=\"ABSTRACT\"></a>ABSTRACT</h1><p><strong>Q：现有的fuzz drivers的问题</strong></p>\n<ul>\n<li>不能完全覆盖entries in libraries</li>\n<li>他们的质量取决于开发人员对于代码的理解</li>\n</ul>\n<p><strong>Q：提出的Hopper</strong></p>\n<ul>\n<li>可以fuzz libraries</li>\n<li>不需要其他的知识去craft  fuzz drivers</li>\n<li>把fuzz libraries转换成InTerpreter fuzzing(解释性fuzz)</li>\n<li>链接到被测library的Interpreter 可以解释描述任意API使用的输入</li>\n</ul>\n<p><strong>Q：</strong></p>\n<ul>\n<li>为了给解释器生成semantically correct input(语义正确的)输入,hopper学习library中API内和API间的constraint(约束)，</li>\n<li>Mutate program 通过grammar awareness(语法意识)</li>\n</ul>\n<p><strong>Q：hopper的效果</strong></p>\n<ul>\n<li>作者提出的inter intra API constraint的学习方法可以learn 隐式的constraint</li>\n<li>explore a vast range of API usages</li>\n</ul>\n<p>&#x3D;&#x3D;Q:我理解的对于library的fuzz&#x3D;&#x3D;</p>\n<ul>\n<li>应该是对于Library中的api进行fuzz，看有没有什么漏洞??</li>\n</ul>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p><strong>Q：AFL和LibFuzzer</strong></p>\n<ul>\n<li>是基于coverage的灰盒测试，</li>\n<li>不需要知道程序的input format 或者程序的规范</li>\n</ul>\n<p><strong>Q：Constraint-based gredbox fuzzer</strong></p>\n<ul>\n<li>通过constraint-solving的技术去reach 那些被复杂的constraint保护的code branch</li>\n</ul>\n<p><strong>Q：grey-box fuzzing测试binary programs很有用</strong></p>\n<ul>\n<li>但是测试libray中的API不太行</li>\n</ul>\n<p><strong>Q：为了用当前的针对library的fuzzer</strong></p>\n<ul>\n<li>需要手动的制作一个fuzz driver<ul>\n<li>这个driver使用fuzzer提供的类型无关的input</li>\n<li>并且把byte stream转换成API的参数</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：但是写一个高质量的fuzz driver很费劲</strong></p>\n<ul>\n<li>需要对library有很深入的理解</li>\n<li>现有的fuzz driver也只是覆盖一小部分API</li>\n<li>对于大家用的很少的API，缺乏测试</li>\n<li>因此需要一个out-of-box的library fuzzer</li>\n</ul>\n<p><strong>Q：对于library fuzzing来说</strong></p>\n<ul>\n<li>需要当调用API的时候使用正确的参数类型</li>\n<li>需要满足API内和API间(inter and intra API)的constraints</li>\n<li>否则就会出现crash</li>\n</ul>\n<p><strong>Q：举个例子</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token function\">ares_send</span><span class=\"token punctuation\">(</span>ares_channel channel<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>qbuf<span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">int</span> qlen<span class=\"token punctuation\">,</span> ares_callback callback<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>为了测试这个需要调用<code>ares_init(ares_channel *channelptr) </code>去满足<strong>Inter-API constraint</strong></li>\n<li>qlen是qbuf的长度</li>\n<li>把callback设置成非空，用ares_callback类型，<strong>满足 intra API constraint</strong></li>\n</ul>\n<p><strong>Q：但是为了做到上面这些很难</strong></p>\n<ul>\n<li>因为关于这些constraint在文档中是很scattered分散的，你很难以一个自动化的方式收集他们</li>\n</ul>\n<p><strong>Q：现有的方法中提出learning-based和model-based方法生成fuzz drivers</strong></p>\n<ul>\n<li>列举了一大堆问题</li>\n<li>反正就是有些drivers要么需要大量的人力参与</li>\n<li>或者效果也不好，甚至一些常用的API都没有包括</li>\n</ul>\n<p><strong>Q：hopper</strong></p>\n<ul>\n<li>fuzz API不需要任何的external knowledge</li>\n<li>收到coverage-based fuzzer的启发，learn valid format通过mutate random seeds</li>\n<li>hopper通过mutate API call and arguments（API调用和参数）来学习API的使用</li>\n<li>如果执行的mutate program触发了一个新的路径或者新的crash，hopper基于动态反馈推断API内和API之间的constraint</li>\n</ul>\n<p><strong>Q：为了实现上面的最后一点(动态反馈推断这个)</strong></p>\n<ul>\n<li><p>作者用了DSL（Domain-Specific Language）来描述任意的API使用</p>\n</li>\n<li><p>DSL的输入会被interpreted(解释)，通过一个链接到library under test的轻量级的interpreter</p>\n</li>\n<li><p>因此，就把对于library的fuzz转变成了对于Interpreter的fuzz</p>\n</li>\n</ul>\n<p><strong>Q：具体的执行过程</strong></p>\n<ul>\n<li><p>fuzzer现在负责以DSL形式编码的程序，并把它给interpreter</p>\n</li>\n<li><p>之后这个解释器就会执行程序看是否有Unexpected behaviors发生</p>\n</li>\n<li><p>由于hopper执行grammar-aware的mutation，并且可以推断constraint，因此hopper可以生成有效的输入，去探索API的不同使用，可以减少误报</p>\n</li>\n</ul>\n<h1 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h1><h2 id=\"Library-Fuzzing\"><a href=\"#Library-Fuzzing\" class=\"headerlink\" title=\"Library Fuzzing\"></a>Library Fuzzing</h2><p><strong>Q：测试library中的API来说，目前常用的就是LibFuzzer，用Libfuzzer的步骤</strong></p>\n<ul>\n<li><em>Craft a fuzz drivers</em>：fuzz driver是一个描述library API使用的program，包括一系列API的调用和API的参数。一个高质量的fuzz driver需要提供一个entry去探索库中尽可能多的代码<ul>\n<li>除了要关注这个API的参数，也需要关注相关的API，</li>\n<li>但是枚举API显然很浪费时间，目前的fuzz driver只包括常用的API</li>\n</ul>\n</li>\n<li>*Specify the format of input.*：由于LibFuzzer是盲目的创建字节流，因此它很难创建结构化的输入满足intra-API的constraints。</li>\n</ul>\n<h2 id=\"Fuzzing-Interpreters\"><a href=\"#Fuzzing-Interpreters\" class=\"headerlink\" title=\"Fuzzing Interpreters\"></a>Fuzzing Interpreters</h2><p>Grammar-aware grey-box fuzzings 在program中很成功，它可以解析input，尤其是interpreters。</p>\n<p>fuzzing interpreters的两个关键要素：</p>\n<ul>\n<li>Grammar-aware input mutation：它可以基于encoding grammar(编码语法)把input解析为IR，并且在满足constraings的情况下mutate IR</li>\n<li>Coverage guided fuzzing：通过coverage作为反馈，去触发更deeper branch，找到新的bug。通过和上面<strong>Grammar-aware input mutation</strong>的结合，fuzzer可以合成新的input，cover更多的分支，找到更多的bug</li>\n</ul>\n<p><strong>Q：综上，重要的是</strong></p>\n<ul>\n<li>library的fuzz driver表示为input实现一个解释器，然后对这个解释器进行fuzz</li>\n</ul>\n<p>MCF将type-agnostic(与类型无关的)byte inpus解释为typed values，提供给有限的API序列调用，这只能探索部分libraries</p>\n<h1 id=\"3-Design\"><a href=\"#3-Design\" class=\"headerlink\" title=\"3 Design\"></a>3 Design</h1><h2 id=\"3-1-Overview\"><a href=\"#3-1-Overview\" class=\"headerlink\" title=\"3.1 Overview\"></a>3.1 Overview</h2><p><strong>Q：hopper架构</strong></p>\n<ul>\n<li><p>a grammar-aware fuzzer：生成DSL编码形式的输入</p>\n</li>\n<li><p>a lightweight interpreter：执行输入</p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231114164227824.png\" alt=\"image-20231114164227824\">、</p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231114164348819.png\" alt=\"image-20231114164348819\"></p>\n</li>\n</ul>\n<p><strong>Q：工作流程</strong></p>\n<ul>\n<li><p>fuzzer通过调用library API生成高质量的input，</p>\n<ul>\n<li><p>从library headers中提取出function signatures和type definition，提供了API function和argument type之间的关系</p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231114164513987.png\" alt=\"image-20231114164513987\"></p>\n<ul>\n<li>之前我笔记中的，这个&lt;&gt;里的就是method siganature，理解成方法的定义</li>\n</ul>\n</li>\n<li><p>通过利用上面的信息，hopper通过随机混合API functions和arguments，生成一个API调用的序列</p>\n</li>\n</ul>\n</li>\n<li><p>随着种子突变和代码覆盖率的feedback，就会探索更多的分支</p>\n</li>\n<li><p>hopper执行的是type-aware argument mutation  和learns intra- and inter-API constraints </p>\n</li>\n<li><p>解释器利用input，调用library中的API</p>\n</li>\n<li><p>在编译阶段，library链接到interpreter。‘</p>\n</li>\n<li><p>在链接之前，hopper检测二进制文件捕获执行过程中的内部状态，例如代码覆盖率</p>\n</li>\n<li><p>当新的input到达的时候，interpreter会根据DSL的语法把input解释称statement</p>\n</li>\n</ul>\n<h2 id=\"3-2DSL-and-Input-Interpretation\"><a href=\"#3-2DSL-and-Input-Interpretation\" class=\"headerlink\" title=\"3.2DSL and Input Interpretation\"></a>3.2DSL and Input Interpretation</h2><h3 id=\"3-2-1-DSL\"><a href=\"#3-2-1-DSL\" class=\"headerlink\" title=\"3.2.1 DSL\"></a>3.2.1 DSL</h3><p><strong>Q：</strong></p>\n<ul>\n<li>Hopper中的interpreter会把DSL程序作为Input</li>\n</ul>\n<p><strong>Q：DSL语法</strong></p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231114172600525.png\" alt=\"image-20231114172600525\"></p>\n<ul>\n<li>每个DSL program包含一个statement作为他的基本组成<ul>\n<li>每个statement有一个index，它的后继可以引用</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：很像指针分析中的定义</strong></p>\n<p>在DSL中把在(mcfs)manually crafted fuzzers中的fuzzing behaviors分成5种statements</p>\n<ul>\n<li>load：可以直接把输入数据的类型转换成一种具体的类型</li>\n<li>call </li>\n<li>update</li>\n<li>assert</li>\n<li>file statement</li>\n</ul>\n<p><strong>Q：本文的DSL的特点</strong></p>\n<ul>\n<li>不支持条件表达式</li>\n<li>通过枚举的方式去找到API</li>\n</ul>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231114173559093.png\" alt=\"image-20231114173559093\"></p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231114173608915.png\" alt=\"image-20231114173608915\"></p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231114175846582.png\" alt=\"image-20231114175846582\"></p>\n<h3 id=\"3-2-2-Interpreter\"><a href=\"#3-2-2-Interpreter\" class=\"headerlink\" title=\"3.2.2 Interpreter\"></a>3.2.2 Interpreter</h3><ul>\n<li>interpreter会解析DSL程序，执行里面的statements，监测在执行每个statement之后的状态。</li>\n</ul>\n<p><strong>Q：为了调用library API</strong></p>\n<ul>\n<li>在编译阶段，Hopper会把interpreter和libray链接在一起</li>\n<li>它也构建一个table，对应每个function的名字和它相关的caller，基于library的header files</li>\n<li>程序执行期间，caller会把value转换成需要的参数类型，并且调用这个参数相关的函数</li>\n</ul>\n<p><strong>Q：在链接到interpreter之前</strong></p>\n<ul>\n<li>hopper会用count branch的代码监测library binaries</li>\n<li>hook compare instructions and resource management functions,如malloc open</li>\n<li>之后在运行时收集feedback：<ul>\n<li>Optional Branch Tracking：当一个API以question mask(?)结尾时，对这个call用branch tracking</li>\n<li>Context-sensitive Code Coverage：把每个API的name的hash作为上下文</li>\n<li>Overflow Detection：如果statement加载了一个数组，会给这个数组添加一个金丝雀，来判断数组是否会溢出</li>\n<li>Use-after-free Detection:interpreter包含一系列memory chunk，通过malloc和free。如果一个指针指向的memory chunk被释放了，Interpreter会退出程序，避免释放重引用</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：关于运行时的问题</strong></p>\n<ul>\n<li>libfuzzer使用的fuzz driver在同一个循环中运行</li>\n<li>但是很难生成一个程序在退出前重置所有的资源</li>\n<li>Hopper的interpreter是把每个input在一个单独的进程中运行</li>\n<li>一旦一个DSL程序终止了，操作系统会破坏进程，释放所有分配的资源，</li>\n<li>这就允许interpreter在执行DSL程序时，不需要释放资源</li>\n</ul>\n<h2 id=\"3-3-Grammar-aware-Input\"><a href=\"#3-3-Grammar-aware-Input\" class=\"headerlink\" title=\"3.3 Grammar-aware Input\"></a>3.3 Grammar-aware Input</h2><p><img src=\"/../HOPPER-CCS-2023/image-20231114181439291.png\" alt=\"image-20231114181439291\"></p>\n<p><strong>Q：hopper不同的地方</strong></p>\n<ul>\n<li>其他的fuzzer会基于input grammar遍历所有可能的语义</li>\n<li>Hopper是集中于生成各种有效的API call</li>\n</ul>\n<p><strong>Q：这个过程包括两个阶段，在Fig 4中</strong></p>\n<ul>\n<li>hopper基于在function signature可利用的信息生成input去初始化一个种子池</li>\n<li>从种子池中选择输入，并让他们基于coverage feedback来进行mutate</li>\n</ul>\n<p><em><strong>Pilot phase</strong></em></p>\n<p><strong>Q：在这个阶段要做的事</strong></p>\n<ul>\n<li>Hopper首先draw skeletons of the input 绘制input的轮廓,推断 constraints</li>\n<li>开始时，seed pool中没有input</li>\n<li>因此,hopper 尝试为每个API 基于他们的signature和learn constraints 生成简单的input(具体在3.4)</li>\n<li>为了实现这个，Hopper在库中选择一个API 作为target，给他随机生成一个call statement<ul>\n<li>这包括生成参数和(insert related calls that introduce the necessary context)插入引入必要上下文的相关的调用</li>\n</ul>\n</li>\n<li>这些statements最终会形成一个input，由解释器执行</li>\n</ul>\n<p><strong>Q：之后</strong></p>\n<ul>\n<li>如果input触发了library中没有crash的新的path，hopper把这个input保存到seed pool中，用于之后的mutation。</li>\n<li>为了避免来自其他的call触发不相关的coverage feedback，hopper只会track target的call</li>\n</ul>\n<p><strong>Q：那如何生成call statement呢? 用算法1</strong></p>\n<ul>\n<li><p>每个参数根据在function signature中的type来生成，使用下面三个operator中的一个来生成argument：</p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231115200112006.png\" alt=\"image-20231115200112006\"></p>\n<ul>\n<li>hopper选择一个现有的statement，它的type和这个argument的type相同</li>\n<li>这argument是通过insert a new API 调用获得的。<ul>\n<li>hopper随机选择一个API function,它的return type和这个argument匹配，递归的给它生成一个call statement。</li>\n<li>新的call statement放在当前的前面</li>\n<li>在这个new call statement的后面添加一个表示call statement是否成功运行的assertion statement<ul>\n<li>例如一个 non-null assertion statement被添加到一个pointer-type returned call statement(指针类型的call statement)后面</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用from scratch从头创建的有typed value的load statement</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：hopper的insert other API call</strong></p>\n<ul>\n<li>hopper影响target call的执行通过insert other API call来该百年程序的内部状态</li>\n<li>它确定API的优先级，利用对于target call有重复的non-primitive argument types（非基本参数类型），尽可能重用overlap的argument</li>\n</ul>\n<p>为了避免程序变得过于复杂，hopper会停止生成new call，如果statement的长度超过了临界值，或者递归深度变的太深。</p>\n<p><strong>Q：以Fig 3为例，</strong></p>\n<ul>\n<li>为了生成第13行的program<ul>\n<li>随机选择 line 4的返回值</li>\n<li>生成两个integer的value， line 11 line 12作为arguments</li>\n<li>并且创建一个调用(line 10)，他可能会修改现有的参数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231115145056191.png\" alt=\"image-20231115145056191\"></p>\n<p><em><strong>Evolution Phase</strong></em></p>\n<p>在运行几轮之后，hopper进入到Evolitopn phase(进化阶段)，目的是构建更复杂的程序，基于skeleton inputs。</p>\n<p><strong>Q：为了实现这个</strong></p>\n<ul>\n<li>hopper从seed pool中选择一个input，并基于它的types进行突变</li>\n<li>guided by the execution branch coverage，他就更可能扩展更深的代码，更可能找到bug</li>\n</ul>\n<p><strong>Q：Hopper mutate program statements用下面的5步</strong></p>\n<p><em>Step 1</em></p>\n<ul>\n<li>首先根据优先级从seed pool中选择一个input</li>\n<li>fresh seeds有更高的优先级被选择，一位内他们更可能reach deeper paths</li>\n</ul>\n<p><em>Step 2</em></p>\n<ul>\n<li>hopper从Input中选择statements进行mutate，根据他们的weights</li>\n<li>assert、file、update statements权重是0，不突变，load 和call statemetn的权重由他们的复杂性决定</li>\n</ul>\n<p><em>Step 3</em></p>\n<ul>\n<li>hopper用相应的策略对load statements和call statements进行突变（3.3. 1 和 3.3.2中写了）</li>\n</ul>\n<p><em>Step 4</em></p>\n<ul>\n<li>hopper基于在fuzzing期间学到的constraints，refine(优化) 对于API的input(3.4中写的)</li>\n</ul>\n<p><em>Step 5</em></p>\n<ul>\n<li>hopper minimize input去remove 冗余的statements，这些statements不影响reaching  path，并increase mutation的搜索空间（3.3.3）</li>\n</ul>\n<h3 id=\"3-3-1-Call-statement-Mutation\"><a href=\"#3-3-1-Call-statement-Mutation\" class=\"headerlink\" title=\"3.3.1 Call statement Mutation\"></a>3.3.1 Call statement Mutation</h3><p><img src=\"/../HOPPER-CCS-2023/image-20231114222828336.png\" alt=\"image-20231114222828336\"></p>\n<p><strong>Q：call statement mutation的策略</strong></p>\n<ul>\n<li>取代一个参数用一个和他有同样类型的新的参数(算法1的line4 到line 24)</li>\n<li>在target call之前insert a new call(line 27 to line 29)。这个insert call 可能修改target call参数的values，或者改变library中的global states。Hopper通过branch feedback决定了insert call的有效性，(细节在3.4.2)</li>\n<li>更新call 的返回值。一个update statement被插入到call的后面，用新值重写返回值。</li>\n</ul>\n<h3 id=\"3-3-2-Type-aware-Value-Mutation\"><a href=\"#3-3-2-Type-aware-Value-Mutation\" class=\"headerlink\" title=\"3.3.2 Type-aware Value Mutation\"></a>3.3.2 Type-aware Value Mutation</h3><p><strong>Q：因为Library中的argument type非常多</strong></p>\n<ul>\n<li>所以hopper需要生成合适的类型给这些arguments，当调用相关的API时</li>\n</ul>\n<p><strong>Q：对于value mutation来说，也是上面这样</strong></p>\n<ul>\n<li>根据value的type进行mutation可能更高效的探索新的状态</li>\n</ul>\n<p><strong>Q：为了实现这个</strong></p>\n<ul>\n<li>Hopper递归解析在header files中的type definitions和type aliases</li>\n<li>生成new typed values使用下面的rules：<ul>\n<li><strong>Pimitive Type</strong>。几乎所有的基本类型是数值类型numerical types。hopper生成小范围的均匀分布的numbers。此外，Hopper对原始类型应用四种mutation:<ul>\n<li>设置一个Intersting value(例如 0x80000000 给int)</li>\n<li>flip a bit or a byte</li>\n<li>加或者减一个small number</li>\n<li>如果这个value是操作数中的一个，就设置为从comparison instruction(比较指令)收集的字面量</li>\n</ul>\n</li>\n<li><strong>Array。</strong>基于数组的长度和元素类型，hopper生成元素的序列。如果长度是变量，hopper随机选择一个长度。在mutation期间，hopper在数组中选择一个或者更多的元素，并分别进行突变。此外，hopper可以重新设置数组的大小通过插入或者remove元素，如果长度不固定的话</li>\n<li><strong>Structure</strong>。自定义的structure type（结构类型） 的value通过递归生成他们的fields来创建。当突变自定义的structure values时，hopper 随机在structure中选择一个 field，并根据他的type进行突变。</li>\n<li><strong>Trivial Pointer</strong></li>\n<li><strong>non-trivial pointer</strong></li>\n</ul>\n</li>\n<li>byte array可能包含自己编码的数据，这个在header files中没定义。cJSON_ParseWithOpt in Figure 2 中用Json形式解析byte array，hopper给byte array应用AFL的随机 mutation</li>\n</ul>\n<h3 id=\"3-3-3-input-Minimization\"><a href=\"#3-3-3-input-Minimization\" class=\"headerlink\" title=\"3.3.3 input Minimization\"></a>3.3.3 input Minimization</h3><p><strong>Q：为什么有输入最小化</strong></p>\n<ul>\n<li>因为冗余的statements和values会降低程序的执行速度，并且在Mutate期间扩展搜索空间，让fuzz变得低效</li>\n</ul>\n<p><strong>Q：为了解决上面的问题，hopper应用下面的两个步骤去minimize input</strong></p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231115161420211.png\" alt=\"image-20231115161420211\"></p>\n<ul>\n<li>Minimize inputs after mutation and refinement.在backward input中，hopper检查statement，排除target call statement。如果一个statement不再被其他statement引用，就删除它。</li>\n<li>Minimize inputs that trigger new paths。对于不对exectuion path有影响的call，hopper就移除它，同时也remove在load statement阶段荣誉的值。尽可能的设置pointer values为null或者缩小array的length。如果执行路径仍然不变，hopper保留input中的mutation.</li>\n</ul>\n<h2 id=\"3-4-Constraint-Learning\"><a href=\"#3-4-Constraint-Learning\" class=\"headerlink\" title=\"3.4 Constraint Learning\"></a>3.4 Constraint Learning</h2><p>为了正确的</p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231115203116497.png\" alt=\"image-20231115203116497\"></p>\n<p>就为这个空指针对应的参数添加一个指针非空（NON-NULL）约束，避免对此参数生成空指针。</p>\n<p>考虑到不同库之间上下文的多样性，我们无法对API间的约束给出一个精确的定义，而是换了一种思路：</p>\n<p>如果生成或是变异后的程序恰巧捕捉到了某一种API间的特殊关系（触发了新的代码覆盖），那么就将这个程序保存到我们的语料库中。此外，Hopper还会分析出引入新的代码覆盖的具体API参数，然后针对该参数对程序进行切片，将与该参数相关的所有语句保存在一个“有效参数”(effective argument)的语料库中，以供下一次需要为API生成对应类型的参数时复用。<img src=\"/../HOPPER-CCS-2023/image-20231115203246595.png\" alt=\"image-20231115203246595\"></p>\n<p><img src=\"/../HOPPER-CCS-2023/image-20231115203259709.png\" alt=\"image-20231115203259709\"></p>\n<h1 id=\"4-Implementation\"><a href=\"#4-Implementation\" class=\"headerlink\" title=\"4 Implementation\"></a>4 Implementation</h1><p>从C header file中提取出来的语义来生成input</p>\n<p>用rust的trait和macro(宏)来实现。</p>\n","text":"ABSTRACTQ：现有的fuzz drivers的问题 不能完全覆盖entries in libraries 他们的质量取决于开发人员对于代码的理解 Q：提出的Hopper 可以fuzz libraries 不需要其他的知识去craft fuzz drivers 把fuzz l...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ABSTRACT\"><span class=\"toc-text\">ABSTRACT</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Introduction\"><span class=\"toc-text\">Introduction</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Background\"><span class=\"toc-text\">Background</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Library-Fuzzing\"><span class=\"toc-text\">Library Fuzzing</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Fuzzing-Interpreters\"><span class=\"toc-text\">Fuzzing Interpreters</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Design\"><span class=\"toc-text\">3 Design</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Overview\"><span class=\"toc-text\">3.1 Overview</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2DSL-and-Input-Interpretation\"><span class=\"toc-text\">3.2DSL and Input Interpretation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-DSL\"><span class=\"toc-text\">3.2.1 DSL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-Interpreter\"><span class=\"toc-text\">3.2.2 Interpreter</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Grammar-aware-Input\"><span class=\"toc-text\">3.3 Grammar-aware Input</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-Call-statement-Mutation\"><span class=\"toc-text\">3.3.1 Call statement Mutation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-Type-aware-Value-Mutation\"><span class=\"toc-text\">3.3.2 Type-aware Value Mutation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-3-input-Minimization\"><span class=\"toc-text\">3.3.3 input Minimization</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-Constraint-Learning\"><span class=\"toc-text\">3.4 Constraint Learning</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Implementation\"><span class=\"toc-text\">4 Implementation</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"re-engineer-core-principle-03","uid":"449c952c21adaaa0689becdb96065fd3","slug":"re-engineer-core-principle-03","date":"2023-12-05T02:11:20.000Z","updated":"2024-02-29T10:45:19.161Z","comments":true,"path":"api/articles/re-engineer-core-principle-03.json","keywords":null,"cover":"/medias/pexels-luis-gomes-546819.jpg","text":"引言 第三部分冲冲冲 这一部分要把没见过的汇编单独整理到一个文档里 0x21 Windows消息钩取21.1 钩子(Hook)Q：钩子 就是偷看或截取信息所有的手段或者工具 21.2 消息钩子Q：常规Windows信息流 发生键盘输人事件时，WM_KEYDOWN消息被添加到[OS...","link":"","photos":[],"count_time":{"symbolsCount":"49k","symbolsTime":"44 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"ODDFUZZ","uid":"9b08663ab6515ce746fcfc5eb13ac547","slug":"ODDFUZZ-SP-2023","date":"2023-11-07T02:18:56.000Z","updated":"2023-11-14T02:05:35.644Z","comments":true,"path":"api/articles/ODDFUZZ-SP-2023.json","keywords":null,"cover":[],"text":"ABSTRACTQ：对于Java反序列化漏洞，现有的解决方式 static analysis和fuzz生成POC，用序列化的对象触发漏洞 但是存在有效性和效率的问题 Q：本文方法 提出一个轻量级的static taint analysis去识别调用链 ODDFUZZ尽力locat...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"},{"name":"Fuzz","slug":"Fuzz","count":1,"path":"api/tags/Fuzz.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}