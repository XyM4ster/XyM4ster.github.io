{"title":"re-engineer-core-principle-05","uid":"16f33ed3c99a8cc9a4a675e2c29d6341","slug":"re-engineer-core-principle-05","date":"2024-01-14T14:13:18.000Z","updated":"2024-02-29T10:45:04.769Z","comments":true,"path":"api/articles/re-engineer-core-principle-05.json","keywords":null,"cover":"/medias/pexels-luis-gomes-546819.jpg","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>上一部分学的很快，集中看了一周就学完了，希望可以快点把这本书看完，然后用起来</li>\n</ul>\n<h1 id=\"0x36-64位计算\"><a href=\"#0x36-64位计算\" class=\"headerlink\" title=\"0x36 64位计算\"></a>0x36 64位计算</h1><h2 id=\"36-1-64位计算环境\"><a href=\"#36-1-64位计算环境\" class=\"headerlink\" title=\"36.1 64位计算环境\"></a>36.1 64位计算环境</h2><p><strong>Q：操作系统的演化</strong></p>\n<ul>\n<li>1985年 Intel 推出了 80386 CPU芯片</li>\n<li>1995年 Miscrosoft发布 32位 Windows 95，计算机正式进入32位计算时代<ul>\n<li>它向下兼容16位程序</li>\n</ul>\n</li>\n<li>2000年 OS进入Windows 2000&#x2F; XP时代<ul>\n<li>32位程序成为主流</li>\n</ul>\n</li>\n<li>之后，开始陆续开发64位版本</li>\n</ul>\n<h3 id=\"64位CPU\"><a href=\"#64位CPU\" class=\"headerlink\" title=\"64位CPU\"></a>64位CPU</h3><p><img src=\"/../re-engineer-core-principle-05/image-20240117100453576.png\" alt=\"image-20240117100453576\"></p>\n<h3 id=\"64位OS\"><a href=\"#64位OS\" class=\"headerlink\" title=\"64位OS\"></a>64位OS</h3><p><strong>Q：LLP64数据模型</strong></p>\n<ul>\n<li><p>64位windows中使用LLP64数据模型实现向下兼容，可以将现有的32位Windows数据模型(LLP32)中的指针大小更改为64位，只需要变换一下指针</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117100716554.png\" alt=\"image-20240117100716554\"></p>\n</li>\n<li><p>ILP32：Integer、Long、Pointer 32位</p>\n</li>\n<li><p>LLP：LongLong、Pointer-64位</p>\n</li>\n<li><p>LP64：Long、Pointer-64位</p>\n</li>\n</ul>\n<h3 id=\"Win32-API\"><a href=\"#Win32-API\" class=\"headerlink\" title=\"Win32 API\"></a>Win32 API</h3><ul>\n<li>创建64位的应用程序时，现有的Win32 API可以照搬使用，不需要再另外的一套Win64 API</li>\n</ul>\n<h3 id=\"WOW-64\"><a href=\"#WOW-64\" class=\"headerlink\" title=\"WOW 64\"></a>WOW 64</h3><ul>\n<li>Windows on Windows64是一种可以在64位OS中支持运行现有32位应用程序的机制</li>\n</ul>\n<p><strong>Q：64位Windows中</strong></p>\n<ul>\n<li>32位应用程序和64位应用程序都可以正常运行</li>\n<li>64位应用程序会加载kernel32.dll(64位)和ntdll.dll(64位)，而32位应用程序中会加载kernel32.dll(32位)和ntdll.dll(32位)</li>\n<li>WOW64会在中间把ntdll.dll 32位的请求重定向到ntdll.dll 64位</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117101216125.png\" alt=\"image-20240117101216125\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>WOW64只运行在用户模式下，运行在内核模式种的驱动程序Driver 文件必须编译成64位。</p>\n<p>内核模式中发生内存引用错误时，就会引发BSOD(Blue Screen Of Death)，所以为了保证系统稳定性，WOW64被限制在用户模式下运行。</p>\n</p>\n</div>\n<h4 id=\"文件夹结构\"><a href=\"#文件夹结构\" class=\"headerlink\" title=\"文件夹结构\"></a>文件夹结构</h4><ul>\n<li><p>系统文件夹在64位的环境中的名称也是System32，为了向下兼容32位，单独提供SysWOW64</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117102900495.png\" alt=\"image-20240117102900495\"></p>\n</li>\n<li><p>System32文件夹中存放着64位的系统文件，而SysWOW64文件夹中存放着32位的系统文件。向用户提供的系统文件分别被编译成64位和32位</p>\n</li>\n<li><p>如果我调用Win32 API，如果我在64位中调用GetSystemDirectory，会返回System32文件。</p>\n</li>\n<li><p>如果我在32位中调用，会返回SysWOW64文件夹。是因为WOW64在中间截获了API调用并进行操作后返回的结果。</p>\n<ul>\n<li>参考上面的图，会重定向。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"注册表\"><a href=\"#注册表\" class=\"headerlink\" title=\"注册表\"></a>注册表</h4><p><img src=\"/../re-engineer-core-principle-05/image-20240117102023382.png\" alt=\"image-20240117102023382\"></p>\n<p>32位进程请求访问HKLM\\SOFTWARE下的key时，WOW64会把它重定向到32位的HKLM\\SOFTWARE\\WOW6432Node下的Key</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>与文件系统不同，注册表无法完全分离为 32 位与 64 位两部分，经常出现 32&#x2F;64位共用的情形。</p>\n<p>有时候向 32 位部分写入的值会自动写入 64 位部分。</p>\n<p>所以对运行在WOW64 环境中的程序进行逆向分析时，必须准确知道访问的究竟是注册表的哪一部分(32位还是64位)</p>\n\n</div>\n<h3 id=\"练习WOW64Test\"><a href=\"#练习WOW64Test\" class=\"headerlink\" title=\"练习WOW64Test\"></a>练习WOW64Test</h3><p><strong>Q：运行WOW64Test_x64.exe和WOW64Test_x86.exe</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117102540558.png\" alt=\"image-20240117102540558\"></p>\n<ul>\n<li>以WOW64模式运行的system32文件夹目录识别为system32，但是内容却指向SysWoW64文件夹，通过kernel32.dll可以看出来<ul>\n<li>重定向到SysWow64下的kernel32.dll</li>\n</ul>\n</li>\n<li>注册表也会重定向，实际创建的是HKLM\\SoFTWARE\\WOW6432Nodw\\ReverseCore</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117103039928.png\" alt=\"image-20240117103039928\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117103052791.png\" alt=\"image-20240117103052791\"></p>\n<h2 id=\"36-2-编译64位文件\"><a href=\"#36-2-编译64位文件\" class=\"headerlink\" title=\"36.2 编译64位文件\"></a>36.2 编译64位文件</h2><p><strong>Q：在这节，会编译64位PE文件(PE+或32+)</strong></p>\n<ul>\n<li>32位和64位Windows OS中都可以交叉编译 32位&#x2F;64位PE文件</li>\n<li>安装VC++ 2010 Express Edition和Miscrosoft Windows SDK for Windows 7 and .NET Framework 4</li>\n</ul>\n<h1 id=\"0x37-x64处理器\"><a href=\"#0x37-x64处理器\" class=\"headerlink\" title=\"0x37 x64处理器\"></a>0x37 x64处理器</h1><h2 id=\"37-1-X64新增的项目\"><a href=\"#37-1-X64新增的项目\" class=\"headerlink\" title=\"37.1 X64新增的项目\"></a>37.1 X64新增的项目</h2><ul>\n<li>x64是在原有x86的基础上扩展而来的</li>\n<li>新增的很多，这里只讲和逆向有关的</li>\n</ul>\n<h3 id=\"64位\"><a href=\"#64位\" class=\"headerlink\" title=\"64位\"></a>64位</h3><ul>\n<li>内存地址为64位，VA比原来多了4个字节，寄存器的大小和栈的基本单位也变成了64位</li>\n</ul>\n<h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h3><ul>\n<li>x64系统中进程的虚拟内存的大小为16TB （$10 ^ {12}$）,内核空间和用户空间各占8TB</li>\n<li>和x86的4GB( $10^9$)相比，大小增加了很多</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>64位的数理论上可以表示$2^{64} &#x3D; 16EB &#x3D; 10^{18}$，但是因为这个需要支持16EB的内存寻址，开销巨大，所以不会用这么大的。</p>\n</p>\n</div>\n<h3 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h3><p><strong>Q：通用寄存器的大小</strong></p>\n<ul>\n<li><p>通用寄存器的大小扩展到64位(8 bytes)，数量也增加到了18个，新增了R8 - R15寄存器</p>\n</li>\n<li><p>x64系统下的所有通用寄存器都以字母 R开头。x86以字母E开头</p>\n</li>\n<li><p>为了实现向下兼容，支持访问寄存器的8位、16位、32位(AL、AX、EAX)</p>\n</li>\n<li><p>64位本地模式中不使用段寄存器：CS、DS、ES、SS、FS、GS，仅用于向下兼容32位程序、</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117110437134.png\" alt=\"image-20240117110437134\"></p>\n</li>\n</ul>\n<h3 id=\"CALL-JMP指令\"><a href=\"#CALL-JMP指令\" class=\"headerlink\" title=\"CALL&#x2F;JMP指令\"></a>CALL&#x2F;JMP指令</h3><p><strong>Q：32位的x86系统中 CALL&#x2F;JMP的形式为  地址+ 指令 + CALL&#x2F;JMP</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117110612036.png\" alt=\"image-20240117110612036\"></p>\n<ul>\n<li>FF15xxxxxxxx是用来调用API的。xxxxxxxx是IAT中的某个地址</li>\n</ul>\n<p><strong>Q：x64中解析方法不同</strong></p>\n<ul>\n<li><p>首先地址变成了8个 字节</p>\n</li>\n<li><p>如果和上面一样的话，FF15后面应该跟着8字节的绝对地址，这样指令的长度就增加了</p>\n</li>\n<li><p>为了避免这种情况，仍然后面跟着4字节的地址，但是地址变成了相对地址RVA</p>\n<ul>\n<li><p>也就是3FFA是相对地址，通过下面的方法转换成绝对地址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">00000001&#96;00401000 + 3FFA + 6 &#x3D; 00000001&#96;00405000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>所以相对地址是相对指令结束位置的地址</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117110656027.png\" alt=\"image-20240117110656027\"></p>\n<ul>\n<li>由于00000001<code>00401000 中存储的是00000001</code> 75CE1E2，所以调用的就是CAll 00000001&#96; 75CE1E2</li>\n</ul>\n<h3 id=\"函数调用约定\"><a href=\"#函数调用约定\" class=\"headerlink\" title=\"函数调用约定\"></a>函数调用约定</h3><ul>\n<li><p>32位系统中的函数调用约定包括cdcel、stdcall、fastcall等</p>\n<ul>\n<li>cdcel，caller清理</li>\n<li>stdcall是由callee清理，也就是在函数内部清理</li>\n<li>fastcall在32位中是用寄存器传递2个参数，速度快，因为cpu访问寄存器肯定比访问内存快</li>\n</ul>\n</li>\n<li><p>但是64位中统一变成fastcall，64位中的fastcall最多可以把函数的4个参数存储到寄存器中传递</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117111305321.png\" alt=\"image-20240117111305321\"></p>\n<ul>\n<li><p>参数顺序由寄存器决定，比如第一个参数总是存在RCX中，若函数的参数超过4个，就和栈并用。从第五个参数开始，存入栈中传递</p>\n</li>\n<li><p>函数返回时传递参数过程中所用的栈由<strong>调用者清理</strong>。</p>\n</li>\n<li><p>很像32位系统下的fastcall + cdecl</p>\n</li>\n<li><p>这种方法可以加快函数调用的速度</p>\n</li>\n<li><p>很有意思的是，函数的前4个参数虽然使用寄存器传递，但是栈中仍然给这4个参数预留了空间(32位字节)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"栈-栈帧\"><a href=\"#栈-栈帧\" class=\"headerlink\" title=\"栈 &amp; 栈帧\"></a>栈 &amp; 栈帧</h3><p>Windows 64位OS中栈的大小比函数实际需要的大小要大得多。</p>\n<p>调用子函数 (Sub Function)时，<strong>不再使用PUSH命令来传递参数，而是通过MOV指令操作寄存器</strong>与预定的栈来传递。</p>\n<p>使用VC++创建的x64程序代码中几乎看不到PUSH&#x2F;POP指令。</p>\n<p>并且<strong>创建栈帧时也不再使用RBP寄存器，而是直接使用RSP寄存器来实现</strong>。</p>\n<h3 id=\"Stack32-exe-Stack64-exe\"><a href=\"#Stack32-exe-Stack64-exe\" class=\"headerlink\" title=\"Stack32.exe &amp; Stack64.exe\"></a>Stack32.exe &amp; Stack64.exe</h3><h4 id=\"Stack32-exe\"><a href=\"#Stack32-exe\" class=\"headerlink\" title=\"Stack32.exe\"></a>Stack32.exe</h4><p><strong>Q :Stack32.exe的main()函数特征</strong></p>\n<ul>\n<li><p>不使用栈帧。由于代码比较简单，变量又少，开启编译器的优化选项后，栈帧会被省略。</p>\n</li>\n<li><p>调用子函数(CreateFileA、CloseHandle)时使用栈传递参数。</p>\n</li>\n<li><p>使用PUSH指令压人栈的函数参数不需要main()函数清理。在32位环境中采用stdcall方式调用Win32API时由被调用者(CreateFileA、CloseHandle)清理。</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117162426124.png\" alt=\"image-20240117162426124\"></p>\n</li>\n</ul>\n<p><strong>Q：Stack32.exe的CreateFileA()函数</strong></p>\n<ul>\n<li>可以看到使用了栈帧</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117162748199.png\" alt=\"image-20240117162748199\"></p>\n<ul>\n<li>在调用CreateFileW()之前，用PUSH指令把接收的参数压入栈，因此现在栈内有了2份参数<ul>\n<li>一份是CreateFileA（）的</li>\n<li>一份是CreateFileW()的</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117162914365.png\" alt=\"image-20240117162914365\"></p>\n<h4 id=\"Stack64-exe\"><a href=\"#Stack64-exe\" class=\"headerlink\" title=\"Stack64.exe\"></a>Stack64.exe</h4><p><strong>Q：和之前不一样的地方</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117164632792.png\" alt=\"image-20240117164632792\"></p>\n<ul>\n<li><p>特征一：使用变形的栈帧。在代码起始部分分配48h，72d字节大小的栈，最后在retn前释放。这样大小的栈足够存储局部变量、函数参数。但是栈操作并未使用RBP寄存器，而是直接使用RSP寄存器</p>\n<ul>\n<li>d表示十进制，h表示16进制</li>\n</ul>\n</li>\n<li><p>特征二：几乎没有PUSH&#x2F;POP指令。第一个参数用rcx寄存器，第二个参数用rdx，第三个参数用r8，第四个参数用r9。第5 - 7个参数使用栈。main()函数开始执行时，使用MOV指令将参数放入分配的栈，但是并没有看到caller清理栈。</p>\n<ul>\n<li>原理在于子函数用的是分配给main()函数的栈，子函数本身不会分配到栈。main函数的栈管理由main自身负责，子函数不需要管理通过栈传递的参数</li>\n</ul>\n</li>\n<li><p>特征三：第五个参数之后的参数在栈中存储的位置是第5个位置。虽然1-4参数是用寄存器存的值，但是仍然在栈中预留了空间</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117171510757.png\" alt=\"image-20240117171510757\"></p>\n</li>\n</ul>\n<p><strong>Q：进入CreateFileA() API</strong></p>\n<ul>\n<li>可以看到先是返回地址，之后给1-4参数预留了空间，虽然未在传递参数中使用，但是代码的前3个指令可以看到向该空间赋值的操作</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117171926975.png\" alt=\"image-20240117171926975\"></p>\n<h1 id=\"0x38-PE32\"><a href=\"#0x38-PE32\" class=\"headerlink\" title=\"0x38 PE32+\"></a>0x38 PE32+</h1><p><strong>Q：PE32+是Windows os中使用的可执行文件格式</strong></p>\n<ul>\n<li>64位os中进程的虚拟内存为16TB，其中低位的8TB分给用户模式，高位的8TB分给内核模式</li>\n</ul>\n<h2 id=\"38-1-PE32\"><a href=\"#38-1-PE32\" class=\"headerlink\" title=\"38.1 PE32+\"></a>38.1 PE32+</h2><ul>\n<li>主要是从原来的PE32扩展来的</li>\n</ul>\n<h3 id=\"IMAGE-NT-HEADERS\"><a href=\"#IMAGE-NT-HEADERS\" class=\"headerlink\" title=\"IMAGE_NT_HEADERS\"></a>IMAGE_NT_HEADERS</h3><p><strong>Q：PE32+中使用IMAGE_NT_HEADER64结构体</strong></p>\n<ul>\n<li>和IMAGE_NT_HEADER_32的区别是optionalheader，现在变成了IMAGE_OPTIONAL_HEADER64</li>\n<li>后面的 #ifdef_WIN64预处理部分中，根据系统类型，将64位&#x2F;32位结构体重定义为IMAGE_NT_HEADERS&#x2F;PIMAGE_NT_HEADER</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240117172753859.png\" alt=\"image-20240117172753859\"></p>\n<h3 id=\"IMAGE-FILE-HEADER\"><a href=\"#IMAGE-FILE-HEADER\" class=\"headerlink\" title=\"IMAGE_FILE_HEADER\"></a>IMAGE_FILE_HEADER</h3><p><strong>Q：和之前相比，PE32+中IMAGE_FILE_HEADER的Machine字段值发生变化。</strong></p>\n<ul>\n<li><p>不同Machine值对应的是不同的CPU</p>\n</li>\n<li><p>PE32中Machine的值是014C</p>\n</li>\n<li><p>适用于X64的Machine值是8664</p>\n</li>\n</ul>\n<h3 id=\"IMAGE-OPTIONAL-HEADER\"><a href=\"#IMAGE-OPTIONAL-HEADER\" class=\"headerlink\" title=\"IMAGE_OPTIONAL_HEADER\"></a>IMAGE_OPTIONAL_HEADER</h3><p>这部分变化很大</p>\n<p><strong>Magic</strong></p>\n<ul>\n<li>PE32中Magic值为010B，PE32+中Magic值为020B。</li>\n<li>WindowsPE装载器通过检查该字段值来区分IMAGE_OPTIONAL_HEADER结构体是32位的还是64位的。</li>\n</ul>\n<p><strong>BaseOfData</strong></p>\n<ul>\n<li>PE32文件中该字段用于指示数据节的起始地址(RVA)，而PE32+文件中删除了该字段</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119132002516.png\" alt=\"image-20240119132002516\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119132008201.png\" alt=\"image-20240119132008201\"></p>\n<p><strong>lmageBase</strong></p>\n<ul>\n<li>ImageBase字段(或称成员)的数据类型由原来的双字(DWORD)变为ULONGLONG类型(8个字节)。</li>\n<li>这是为了适应增大的进程虚拟内存。</li>\n<li>借助该字段，PE32+文件能够加载到64位进程的虚拟内存空间(16TB)的任何位置<ul>\n<li>EXE&#x2F;DLL文件被加载到低位的8TB用户区域</li>\n<li>SYS文件被加载到高位的8TB内核区域</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>AddressOfEntryPoint、SizeOflmage等字段大小与原PE32位是一样的都是DWORD大小(4个字节，32位)。</p>\n<p>这些字段的数据类型都是 DWORD，意味着 PE32+格式的文件占用的实际虚拟内存中，各映像的大小最大为4GB(32位)。</p>\n<p>但是由于ImageBase的大小为8个字节 (64位)，程序文件可以加载到进程虚拟内存中的任意地址位置</p>\n<p>加载 PE文件到内存时并非按磁盘文件格式原封不动地进行，而是根据节区头中定义的节区起始地址、节区大小等属性加载。所以磁盘文件中的 PE与内存中的 PE状态是不同的。为了区分，我们将<strong>加载到内存中的PE称为映像</strong>。</p>\n\n</div>\n<p><strong>栈 &amp; 堆</strong></p>\n<ul>\n<li>与栈和堆相关的字段( SizeOfStackReserve、SizeOfStackCommit、Size0HeapReserve、Size0fHeapCommit)的数据类型变为ULONGLONG类型(8个字节)。</li>\n<li>这样做也是为了与增大的进程虚拟内存相适应。</li>\n</ul>\n<h3 id=\"IMAGE-THUNK-DATA\"><a href=\"#IMAGE-THUNK-DATA\" class=\"headerlink\" title=\"IMAGE_THUNK_DATA\"></a>IMAGE_THUNK_DATA</h3><ul>\n<li><p>IMAGE_THUNK_DATA的大小由4字节变成了8字节</p>\n</li>\n<li><p>IMAGE_IMPORT_DESCRIPTOR结构体的OriginalFirstThunk(INT)和FirstThunk(IAT)字段都是指向IMAGE_THUNK_DATA结构体数组的RVA</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119132559337.png\" alt=\"image-20240119132559337\"></p>\n</li>\n</ul>\n<p><strong>Q：在PE文件中INT列表和IAT列表就是由IMAGE_THUNK_DATA构成的结构体数组</strong></p>\n<ul>\n<li>在PE32中，INT、IAT是IMAGE_THUNK_DATA32结构体，在PE32+中是IMAGE_THUNK_DATA64结构体，大小是8字节</li>\n</ul>\n<p>IMAGE_THUNK_DATA<img src=\"/../re-engineer-core-principle-05/image-20240119132748204.png\" alt=\"image-20240119132748204\"></p>\n<ul>\n<li>上图中圆圈部分就是IMAGE_THUNK_DATA结构体数组。os的PE装载器会把真正的API地址写到IAT中。PE32+中大小是8字节</li>\n</ul>\n<h3 id=\"IMAGE-TLS-DIRECTORY\"><a href=\"#IMAGE-TLS-DIRECTORY\" class=\"headerlink\" title=\"IMAGE_TLS_DIRECTORY\"></a>IMAGE_TLS_DIRECTORY</h3><ul>\n<li><p>IMAGE_TLS_DIRECTORY结构体的部分成员是VA，在PE32+中扩展成了8字节</p>\n</li>\n<li><p>IMAGE_TLS_DIRECTORY结构体的StartAddressOfRawData、EndAddressOfRawDataAddressOfIndex、AddressOfCallBacks字段持有的都是VA值。所以它们被扩展为64位OS的地址大小(8个字节)</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119133405813.png\" alt=\"image-20240119133405813\"></p>\n</li>\n</ul>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p>CFF Explorer支持PE32+</p>\n<h1 id=\"0x39-Windbg\"><a href=\"#0x39-Windbg\" class=\"headerlink\" title=\"0x39 Windbg\"></a>0x39 Windbg</h1><ul>\n<li>支持用户模式调试和内核模式调试</li>\n</ul>\n<h2 id=\"运行Windbg\"><a href=\"#运行Windbg\" class=\"headerlink\" title=\"运行Windbg\"></a>运行Windbg</h2><p><strong>Q：符号</strong></p>\n<ul>\n<li>符号(Symbol)指的是调试信息文件( * .pdb)。使用Visual C++编译序时，除了生成PE文件外，还会一起生成*.pdb(Program Data Base，程序数据库)文件</li>\n<li>该文件包含PE文件的各种调试信息(变量&#x2F;函数名、函数地址、源代码行等)。</li>\n</ul>\n<h2 id=\"Windbg基本指令\"><a href=\"#Windbg基本指令\" class=\"headerlink\" title=\"Windbg基本指令\"></a>Windbg基本指令</h2><p><img src=\"/../re-engineer-core-principle-05/image-20240119141141212.png\" alt=\"image-20240119141141212\"></p>\n<h1 id=\"0x40-64位调试\"><a href=\"#0x40-64位调试\" class=\"headerlink\" title=\"0x40 64位调试\"></a>0x40 64位调试</h1><h2 id=\"40-1-x64环境下的调试器\"><a href=\"#40-1-x64环境下的调试器\" class=\"headerlink\" title=\"40.1 x64环境下的调试器\"></a>40.1 x64环境下的调试器</h2><p><strong>Q：x64自诞生之日起就完全支持x86</strong></p>\n<ul>\n<li><p>windows 64 os不仅可以运行pe32+，也向下兼容，可以运行32位进程、</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119133931184.png\" alt=\"image-20240119133931184\"></p>\n</li>\n<li><p>在32位中可以使用ida pro查看pe32+的反汇编代码</p>\n</li>\n</ul>\n<h2 id=\"40-2-64位调试\"><a href=\"#40-2-64位调试\" class=\"headerlink\" title=\"40.2 64位调试\"></a>40.2 64位调试</h2><p><strong>Q：调试WOW64Test</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// WOW64Test.cpp -> WOW64Test.exe</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"stdio.h\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"windows.h\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Shlobj.h\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"tchar.h\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">comment</span><span class=\"token punctuation\">(</span>lib<span class=\"token punctuation\">,</span> </span><span class=\"token string\">\"Shell32.lib\"</span><span class=\"token expression\"><span class=\"token punctuation\">)</span></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">_tmain</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> TCHAR<span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    HKEY    hKey                <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    HANDLE  hFile               <span class=\"token operator\">=</span> INVALID_HANDLE_VALUE<span class=\"token punctuation\">;</span>\n    TCHAR   szPath<span class=\"token punctuation\">[</span>MAX_PATH<span class=\"token punctuation\">]</span>    <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">////////////////</span>\n    <span class=\"token comment\">// system32 folder</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token function\">GetSystemDirectory</span><span class=\"token punctuation\">(</span>szPath<span class=\"token punctuation\">,</span> MAX_PATH<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">_tprintf</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"1) system32 path = %s\\n\"</span><span class=\"token punctuation\">,</span> szPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">////////////////</span>\n    <span class=\"token comment\">// File size</span>\n    <span class=\"token function\">_tcscat_s</span><span class=\"token punctuation\">(</span>szPath<span class=\"token punctuation\">,</span> L<span class=\"token string\">\"\\\\kernel32.dll\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    hFile <span class=\"token operator\">=</span> <span class=\"token function\">CreateFile</span><span class=\"token punctuation\">(</span>szPath<span class=\"token punctuation\">,</span> GENERIC_READ<span class=\"token punctuation\">,</span> FILE_SHARE_READ<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> \n                       OPEN_EXISTING<span class=\"token punctuation\">,</span> FILE_ATTRIBUTE_NORMAL<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> hFile <span class=\"token operator\">!=</span> INVALID_HANDLE_VALUE <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">_tprintf</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"2) File size of \\\"%s\\\" = %d\\n\"</span><span class=\"token punctuation\">,</span> \n        szPath<span class=\"token punctuation\">,</span> <span class=\"token function\">GetFileSize</span><span class=\"token punctuation\">(</span>hFile<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">CloseHandle</span><span class=\"token punctuation\">(</span>hFile<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">////////////////</span>\n    <span class=\"token comment\">// Program Files</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token function\">SHGetSpecialFolderPath</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> szPath<span class=\"token punctuation\">,</span> \n                               CSIDL_PROGRAM_FILES<span class=\"token punctuation\">,</span> FALSE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">_tprintf</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"3) Program Files path = %s\\n\"</span><span class=\"token punctuation\">,</span> szPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">////////////////</span>\n    <span class=\"token comment\">// Registry</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> ERROR_SUCCESS <span class=\"token operator\">==</span> <span class=\"token function\">RegCreateKey</span><span class=\"token punctuation\">(</span>HKEY_LOCAL_MACHINE<span class=\"token punctuation\">,</span> \n                                      L<span class=\"token string\">\"SOFTWARE\\\\ReverseCore\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hKey<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">RegCloseKey</span><span class=\"token punctuation\">(</span>hKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">_tprintf</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"4) Create Registry Key : HKLM\\\\SOFTWARE\\\\ReverseCore\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>上面的代码就是调用了GetSystemDirectory()、CreateFile()、SHGetSpecialFolderPath()、RegCreateKey()这4个API</li>\n<li>win64模式下，x86应用程序通过WOW64模式运行，系统文件夹和注册表会重定向</li>\n</ul>\n<h2 id=\"40-3-PE32：WOW64Test-x86-exe\"><a href=\"#40-3-PE32：WOW64Test-x86-exe\" class=\"headerlink\" title=\"40.3 PE32：WOW64Test_x86.exe\"></a>40.3 PE32：WOW64Test_x86.exe</h2><ul>\n<li>使用VC++ 2010编写的基于控制台的EXE文件中，用户代码一般都存在于代码节区的顶端位置</li>\n</ul>\n<p><strong>Q：EP代码</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119135030138.png\" alt=\"image-20240119135030138\"></p>\n<p><strong>Q：Startup代码</strong></p>\n<ul>\n<li><p>跟踪EP代码处的JMP指令，进入40128F处，出现下面的Startup代码</p>\n</li>\n<li><p>WOW64Test_x86.exe是一个控制台程序，所以<strong>Startup代码内部存在调用main函数的call指令</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119134911962.png\" alt=\"image-20240119134911962\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>刚开始的时候不要进入的太深，深入1-depth查看代码即可</p>\n</p>\n</div>\n<p><strong>Q：查找main函数</strong></p>\n<ul>\n<li>已知信息是<ul>\n<li>WOW64Test_x86.exe是一个基于控制台的应用程序，在调用main函数之前，会先调用GetCommandLine() API。因为在调用main函数之前，需要先把main(int argc, char *  argv[])函数的参数存储到栈中。在x64环境下是存储到寄存器中。<ul>\n<li>也就是我找到GetCommandLinW()的返回地址就是main函数，或者我查看栈也行</li>\n</ul>\n</li>\n<li>调用GetSystemDirectory()、GetFileSize()、CreateFile()等API<ul>\n<li>直接在这些API上设置断点，也能找到main函数</li>\n</ul>\n</li>\n<li>在画面中输出通过上述API获取的信息<ul>\n<li>因为WOW64Test_x86.cpp的代码中有printf的语句，那我直接搜索字符串就行了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：找GetCommandLineW()</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121162705861.png\" alt=\"image-20240121162705861\"></p>\n<ul>\n<li><p>这里可以找到GetCommandLineW()之后，进入函数内部，发现有一个JMP指令，当前栈内存储的返回地址是Call GetCommandLineW()的下一条地址</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121162751666.png\" alt=\"image-20240121162751666\"></p>\n</li>\n<li><p>下面调用的401000处就是main函数</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121162851335.png\" alt=\"image-20240121162851335\"></p>\n</li>\n</ul>\n<p><strong>Q：直接search all referenced strings</strong></p>\n<ul>\n<li><p>可以找到函数的栈帧从401000地址开始</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119140330648.png\" alt=\"image-20240119140330648\"></p>\n</li>\n</ul>\n<h2 id=\"40-4-PE32-：WOW64Test-x64-exe\"><a href=\"#40-4-PE32-：WOW64Test-x64-exe\" class=\"headerlink\" title=\"40.4 PE32+：WOW64Test_x64.exe\"></a>40.4 PE32+：WOW64Test_x64.exe</h2><p><strong>Q：系统断点</strong></p>\n<ul>\n<li><p>使用Windbg打开WOW64Test_x64.exe，程序暂停在系统断点(ntdll.dll)处。</p>\n</li>\n<li><p>由于Windbg没有暂停在进程EP处的宣传，所以需要从暂停位置直接转到EP处</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119141452996.png\" alt=\"image-20240119141452996\"></p>\n</li>\n</ul>\n<p><strong>Q：EP代码</strong></p>\n<ul>\n<li><p>首先获取EP地址，输出显示进程PE文件头的命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token operator\">!</span>dh WOW64Test_x64<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119141704786.png\" alt=\"image-20240119141704786\"></p>\n</li>\n<li><p>EP地址为142C，使用g命令转到该地址处</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">g WOW64Test_x64 + 142C<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>Windbg默认仅显示一行命令，可以使用下列指令增加显示的条数</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">u <span class=\"token operator\">&lt;</span>address<span class=\"token operator\">></span>L<span class=\"token operator\">&lt;</span>Line number<span class=\"token operator\">></span>\n\n也就是\nu eip L10<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119142023828.png\" alt=\"image-20240119142023828\"></p>\n</li>\n<li><p>和上面PE32的EP代码比，发现不使用栈帧，用sub和add</p>\n</li>\n</ul>\n<p><strong>Q：Startup代码</strong></p>\n<ul>\n<li><p>跟踪(t)位于00000001&#96;4001439地址处的JMP指令，增加指令显示的条数，可以看到所有Start up代码</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240119143626498.png\" alt=\"image-20240119143626498\"></p>\n</li>\n</ul>\n<p><strong>Q：main函数</strong></p>\n<ul>\n<li><p>WOW64Test_x64.exe是基于控制台的应用程序，在GetCommandLineWStub()函数处设置断点后，从断点开始跟踪到main()函数处</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bp &lt;address 或模块名称!API名称&gt;\n也就是\nbp kernel32!GetCommandLineWStub<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>按g运行到断点处</p>\n</li>\n<li><p>接着查看此时栈中存储的返回地址，由于当前是jmp指令，相当于已经进入call内部了(参考上面的)，所以此时栈顶存储的就是返回地址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">dq rsp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121163010874.png\" alt=\"image-20240121163010874\"></p>\n</li>\n<li><p>运行到 4001381地址处，40001381地址处的MOV指令是把GetCommandLineW() API的返回值RAX存储到.data节区中</p>\n<ul>\n<li>后面设置main函数的参数到RCX RDX r8中</li>\n<li>400013ea地址处的call指令在调用main函数</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121163659154.png\" alt=\"image-20240121163659154\"></p>\n</li>\n<li><p>运行到400013ea处，显示当前的寄存器状态</p>\n<ul>\n<li>rcx为1，表明参数argc是1，表示无额外的命令参数</li>\n<li>第二个参数为argv数组，数组的起始地址存储在rdx中，值是922c50，该地址中保存着argv[0]的值，也就是第一个命令行字符串的地址</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121164005441.png\" alt=\"image-20240121164005441\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121163938322.png\" alt=\"image-20240121163938322\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121164248245.png\" alt=\"image-20240121164248245\"></p>\n</li>\n<li><p>那r8寄存器也有值，但是实际上main函数只有两个参数，这是为啥？</p>\n<ul>\n<li><p>查看r8寄存器，发现它所指的是一个指针数组，数组的所有元素都指向栈区域</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121164928191.png\" alt=\"image-20240121164928191\"></p>\n</li>\n<li><p>查看第一个元素的值</p>\n<ul>\n<li>这里说明main函数的第三个参数是r8系统环境变量字符串数组的地址，不是用户编写的代码。是VC2010工具编译代码时编译器自动添加的参数</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121165007358.png\" alt=\"image-20240121165007358\"></p>\n</li>\n</ul>\n</li>\n<li><p>最后查看完整的main函数</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121170152756.png\" alt=\"image-20240121170152756\"></p>\n</li>\n</ul>\n<h1 id=\"0x41-ASLR\"><a href=\"#0x41-ASLR\" class=\"headerlink\" title=\"0x41 ASLR\"></a>0x41 ASLR</h1><ul>\n<li><p>ASLR：address Space Layout randomization</p>\n</li>\n<li><p>ASLR是一种针对缓冲区溢出的安全保护技术</p>\n</li>\n</ul>\n<h2 id=\"41-1-Windows内核版本\"><a href=\"#41-1-Windows内核版本\" class=\"headerlink\" title=\"41.1 Windows内核版本\"></a>41.1 Windows内核版本</h2><p><img src=\"/../re-engineer-core-principle-05/image-20240121175058776.png\" alt=\"image-20240121175058776\"></p>\n<h2 id=\"41-2-ASLR\"><a href=\"#41-2-ASLR\" class=\"headerlink\" title=\"41.2 ASLR\"></a>41.2 ASLR</h2><p><strong>Q：ASLR的作用</strong></p>\n<ul>\n<li>PE文件每次加载到内存的起始地址都会随机变化，并且每次运行程序时相应进程的栈以及堆的起始地址也会随机改变。</li>\n<li>也就是说，每次EXE文件运行时加载到进程内存的实际地址都不同，最初加载DLL文件时装载到内存中的实际地址也是不同的。</li>\n</ul>\n<h2 id=\"41-3-Visual-C\"><a href=\"#41-3-Visual-C\" class=\"headerlink\" title=\"41.3 Visual C++\"></a>41.3 Visual C++</h2><ul>\n<li>并不是所有可执行文件都应用ASLR技术，os的内核版本在6以上，且编程工具要支持DYNAMICBASE选项</li>\n<li>如果开启了DYNAMICBASE，那么ASLR就会应用到编译文件中</li>\n<li>如果不想应用ASLR，就需要改成DYNAMICBASE:No</li>\n</ul>\n<h2 id=\"41-4-ASLR-exe\"><a href=\"#41-4-ASLR-exe\" class=\"headerlink\" title=\"41.4 ASLR.exe\"></a>41.4 ASLR.exe</h2><p><strong>Q：打开ASLR.exe</strong></p>\n<ul>\n<li><p>这里我并没有每次运行时地址有变化</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121170955176.png\" alt=\"image-20240121170955176\"></p>\n</li>\n</ul>\n<p><strong>Q：打开ASLR_no.exe</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121173046946.png\" alt=\"image-20240121173046946\"></p>\n<h3 id=\"PE头中和ASLR相关的信息\"><a href=\"#PE头中和ASLR相关的信息\" class=\"headerlink\" title=\"PE头中和ASLR相关的信息\"></a>PE头中和ASLR相关的信息</h3><p><strong>Q：使用peview分别打开这两个文件</strong></p>\n<ul>\n<li>发现ASLR.exe多了一个.reloc节区，一般情况下，普通的exe文件中不存在.reloc节取，该节区只有在应用了ASLR技术的文件中才会出现<ul>\n<li>它是编译时由编译器生成并保留在可执行文件中的</li>\n<li>PE文件被加载到内存时，该节区被用做重定位的参考</li>\n<li>不是exe文件运行的必须部分，可以将其从pe文件中删除。但是由于dll文件总是需要重定位，所以在DLL中不可将其删除</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121173300086.png\" alt=\"image-20240121173300086\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121173215152.png\" alt=\"image-20240121173215152\">，</p>\n<p><strong>Q：IMAGE_FILE_HEADER的Characteristics</strong></p>\n<ul>\n<li>aslr.exeIMAGE_FILE_HEADER的Characteristics中不存在IMAGE_FILE_RELOCS_STRIPPED标志</li>\n<li>因为ASLR.exe多一个节区，所以节区数＋1</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121173717570.png\" alt=\"image-20240121173717570\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121173755927.png\" alt=\"image-20240121173755927\"></p>\n<p><strong>Q：IMAGE_OPTIONAL_HEADER DLL Characteristics</strong></p>\n<ul>\n<li>ASLR.exe中有IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志，如果vc++中开启了&#x2F;DYNAMICBASE选项，就会设置这个标志的值</li>\n</ul>\n<p>​\t<img src=\"/../re-engineer-core-principle-05/image-20240121174205242.png\" alt=\"image-20240121174205242\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121174210873.png\" alt=\"image-20240121174210873\"></p>\n<h2 id=\"41-5-删除ASLR功能\"><a href=\"#41-5-删除ASLR功能\" class=\"headerlink\" title=\"41.5 删除ASLR功能\"></a>41.5 删除ASLR功能</h2><p><strong>Q：删除方法</strong></p>\n<ul>\n<li><p>就删除IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志，把40改成00就行</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121174713035.png\" alt=\"image-20240121174713035\"></p>\n</li>\n<li><p>删除之后，发现此时再运行ASLR.exe和ASLR_no.exe加载到相同的地址</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121174657214.png\" alt=\"image-20240121174657214\"></p>\n</li>\n</ul>\n<h1 id=\"0x42-内核中的会话\"><a href=\"#0x42-内核中的会话\" class=\"headerlink\" title=\"0x42 内核中的会话\"></a>0x42 内核中的会话</h1><ul>\n<li>Windows OS Kernel6(Vista7、8等)开始采用一种新的会话(Session)管理机制</li>\n<li>原来在xp中运行良好的服务程序在7中无法正常运行了。<ul>\n<li>这个程序是以服务形式运行的，比如显示对话框这种。</li>\n<li>运行不了是因为Kernel6 中使用的会话管理机制</li>\n</ul>\n</li>\n<li>原先使用的通过CreateRemoteThread() API进行DLL注入的方法，可能不再使用于Kernel6中的服务进程</li>\n</ul>\n<h2 id=\"42-1-会话\"><a href=\"#42-1-会话\" class=\"headerlink\" title=\"42.1 会话\"></a>42.1 会话</h2><p><strong>Q：会话指的是登录后的用户环境</strong></p>\n<ul>\n<li>大部分os允许多个用户同时登陆，并且每个登录的用户的环境是独立的</li>\n</ul>\n<p><strong>Q：勾选Process Explorer view菜单中的session，可以显示进程所属的会话</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121175649254.png\" alt=\"image-20240121175649254\"></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121175712774.png\" alt=\"image-20240121175712774\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>用户登录系统后，系统默认为相应会话创建csrss.exe，winlogon.exe，explorer.exe进程。</p>\n\n</div>\n<p><strong>Q：Windows7与WindowsXP有1个非常大的不同</strong></p>\n<ul>\n<li>两个操作系统中都登录了2个用户，但Windows7中共有3个会话(0、1、2)，而WindowsXP中只有2个会话(0、1)。</li>\n<li>无论WindowsXP还是Windows 7，系统进程与服务进程都在ID为0的会话(系统会话)中运行。</li>\n<li>二者差别在于，第一个登录的用户的会话ID是不同的。<ul>\n<li>Windows XP中，第一个登录系统的用户的会话ID为0; </li>\n<li>而Windows 7中，第一个登录系统的用户的会话ID为1，非系统会话。</li>\n</ul>\n</li>\n<li>这种细微的差别使在XP系统中可以使用的技术在Widows 7中无法正常使用。</li>\n</ul>\n<h2 id=\"42-2-会话0隔离机制\"><a href=\"#42-2-会话0隔离机制\" class=\"headerlink\" title=\"42.2 会话0隔离机制\"></a>42.2 会话0隔离机制</h2><p><strong>Q：从Windows 6 开始，等一个登录系统的用户会话id被设置为1</strong></p>\n<ul>\n<li>让它和系统会话0区分</li>\n<li>分离系统会话和用户会话就取消了它们之间的相互作用，虽然可能会有向下兼容的问题</li>\n<li>这样增加了安全性</li>\n</ul>\n<h2 id=\"42-3-增强安全性\"><a href=\"#42-3-增强安全性\" class=\"headerlink\" title=\"42.3 增强安全性\"></a>42.3 增强安全性</h2><p><strong>Q：上面虽然使用了ASLR + 会话0隔离机制，但是仍然存在安全问题</strong></p>\n<ul>\n<li><p>由于上面的会话0隔离机制，并没有完全实现分离，所以会话1中的进程(如：Process Explorer)可以强行终止会话0中的进程，</p>\n</li>\n<li><p>ReadProcessMemory()、ReadProcessMemory()、VirtualAllocEx()等调试API也能正常运行，可以绕过ASLR</p>\n</li>\n</ul>\n<h1 id=\"0x43-内核6中的DLL注入\"><a href=\"#0x43-内核6中的DLL注入\" class=\"headerlink\" title=\"0x43 内核6中的DLL注入\"></a>0x43 内核6中的DLL注入</h1><p><strong>Q：原来通过CreateRemoteThread()方法进行DLL注入不行了</strong></p>\n<ul>\n<li>原来的方法只适用于windowsxp、2000</li>\n<li>但是windows7之后就不行， 使用CreateRemoteThread()无法对服务(Service)进程的DLL注入<ul>\n<li>因为windows7的会话管理机制已经发生了变化</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"43-1-DLL注入失败\"><a href=\"#43-1-DLL注入失败\" class=\"headerlink\" title=\"43.1 DLL注入失败\"></a>43.1 DLL注入失败</h1><ul>\n<li>将dummy.dll注入Windows 7 的系统进程时，会出现注入失败</li>\n</ul>\n<p><strong>Q：InjectDll.cpp的源码</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BOOL <span class=\"token function\">InjectDll</span><span class=\"token punctuation\">(</span>DWORD dwPID<span class=\"token punctuation\">,</span> LPCTSTR szDllPath<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    HANDLE hProcess <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> hThread <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    HMODULE hMod <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    LPVOID pRemoteBuf <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    DWORD dwBufSize <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>DWORD<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">_tcslen</span><span class=\"token punctuation\">(</span>szDllPath<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>TCHAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    LPTHREAD_START_ROUTINE pThreadProc<span class=\"token punctuation\">;</span>\n    BOOL bRet <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// #1. 通过dwPID，打开要注入的进程</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>hProcess <span class=\"token operator\">=</span> <span class=\"token function\">OpenProcess</span><span class=\"token punctuation\">(</span>PROCESS_ALL_ACCESS<span class=\"token punctuation\">,</span> FALSE<span class=\"token punctuation\">,</span> dwPID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">_tprintf</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"OpenProcess(%d) failed!!! [%d]\\n\"</span><span class=\"token punctuation\">,</span> dwPID<span class=\"token punctuation\">,</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">// #2. 向要注入的进程中分配存储空间</span>\n    pRemoteBuf <span class=\"token operator\">=</span> <span class=\"token function\">VirtualAllocEx</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> dwBufSize<span class=\"token punctuation\">,</span> MEM_COMMIT<span class=\"token punctuation\">,</span> PAGE_READWRITE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// #3. 将要注入的dll放入空间中</span>\n    <span class=\"token function\">WriteProcessMemory</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> pRemoteBuf<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>LPVOID<span class=\"token punctuation\">)</span>szDllPath<span class=\"token punctuation\">,</span> dwBufSize<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// #4. LoadLibraryA()</span>\n    hMod <span class=\"token operator\">=</span> <span class=\"token function\">GetModuleHandle</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"kernel32.dll\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    pThreadProc <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>LPTHREAD_START_ROUTINE<span class=\"token punctuation\">)</span><span class=\"token function\">GetProcAddress</span><span class=\"token punctuation\">(</span>hMod<span class=\"token punctuation\">,</span> <span class=\"token string\">\"LoadLibraryW\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n    <span class=\"token comment\">// #5. LoadLibraryA(hack.dll)</span>\n    hThread <span class=\"token operator\">=</span> <span class=\"token function\">CreateRemoteThread</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> pThreadProc<span class=\"token punctuation\">,</span> pRemoteBuf<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> hThread <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">_tprintf</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"[ERROR] CreateRemoteThread() failed!!! [%d]\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        bRet <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">goto</span> _ERROR<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token function\">WaitForSingleObject</span><span class=\"token punctuation\">(</span>hThread<span class=\"token punctuation\">,</span> INFINITE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\n\n_ERROR<span class=\"token operator\">:</span>\n    \n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> pRemoteBuf <span class=\"token punctuation\">)</span>\n        <span class=\"token function\">VirtualFreeEx</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> pRemoteBuf<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> MEM_RELEASE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> hThread <span class=\"token punctuation\">)</span>\n        <span class=\"token function\">CloseHandle</span><span class=\"token punctuation\">(</span>hThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> hProcess <span class=\"token punctuation\">)</span>\n        <span class=\"token function\">CloseHandle</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> bRet<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Q：dummy.cpp</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// dummy.cpp -> dummp.dll</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"windows.h\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"tchar.h\"</span></span>\n\nBOOL WINAPI <span class=\"token function\">DllMain</span><span class=\"token punctuation\">(</span>HINSTANCE hinstDLL<span class=\"token punctuation\">,</span> DWORD fdwReason<span class=\"token punctuation\">,</span> LPVOID lpvReserved<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    TCHAR   szPath<span class=\"token punctuation\">[</span>MAX_PATH<span class=\"token punctuation\">]</span>    <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    TCHAR   szMsg<span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span>         <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    TCHAR   <span class=\"token operator\">*</span>p                  <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span> fdwReason <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">case</span> DLL_PROCESS_ATTACH <span class=\"token operator\">:</span> \n            <span class=\"token function\">GetModuleFileName</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> szPath<span class=\"token punctuation\">,</span> MAX_PATH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            p <span class=\"token operator\">=</span> <span class=\"token function\">_tcsrchr</span><span class=\"token punctuation\">(</span>szPath<span class=\"token punctuation\">,</span> L<span class=\"token char\">'\\\\'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 如果注入成功，就输出相关调试信息</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> p <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">_stprintf_s</span><span class=\"token punctuation\">(</span>szMsg<span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span> <span class=\"token operator\">-</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>TCHAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n                            L<span class=\"token string\">\"Injected in %s(%d)\"</span><span class=\"token punctuation\">,</span> \n                            p <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>                          <span class=\"token comment\">// Process Name</span>\n                            <span class=\"token function\">GetCurrentProcessId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// PID</span>\n                <span class=\"token function\">OutputDebugString</span><span class=\"token punctuation\">(</span>szMsg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            \n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> TRUE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>代码很简单，就是如果注入成功了，就会输出调试信息</li>\n</ul>\n<p><strong>Q：注入测试</strong></p>\n<ul>\n<li><p>向属于会话1的notepad.exe中注入dummy.dll，发现成功注入</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121195018801.png\" alt=\"image-20240121195018801\"></p>\n</li>\n<li><p>向属于会话0的svchost注入是失败的，我这里的错误代码是5，书上是8</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121195557883.png\" alt=\"image-20240121195557883\"></p>\n</li>\n</ul>\n<h2 id=\"43-2-原因分析\"><a href=\"#43-2-原因分析\" class=\"headerlink\" title=\"43.2 原因分析\"></a>43.2 原因分析</h2><p><strong>Q：使用Ollydbg打开InjectDll.exe，带上参数</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240121195835935.png\" alt=\"image-20240121195835935\"></p>\n<ul>\n<li><p>这里一定要用管理员模式运行ollydbg，之前我一直不成功，无法调试到CreateRemoteThread处</p>\n</li>\n<li><p>调试到这里后，按F8到下一条指令，此时寄存器窗口会显示LastErr &#x3D; ERROR_NOT_ENOUGH_MEMORY(8)</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122213354996.png\" alt=\"image-20240122213354996\"></p>\n</li>\n</ul>\n<p><strong>Q：重新调试上面的程序</strong></p>\n<ul>\n<li><p>重新运行Ollydbg，让他停在CreateRemoteThread()处</p>\n</li>\n<li><p>查看栈中的CreateRemoteThread() API的参数</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122214650014.png\" alt=\"image-20240122214650014\"></p>\n<ul>\n<li>第一个参数是进程句柄，也就是sychost进程</li>\n<li>第二个参数startAddress是LoadLibraryA() API地址</li>\n<li>第三个是sychost进程内存中分配的缓冲区地址，用于存储dummydll字符串</li>\n</ul>\n</li>\n<li><p>进入CreateRemoteThread() APi，这个API内部调用了<strong>Kernelbase!CreateRemoteThreadEx() API</strong>函数</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122214741713.png\" alt=\"image-20240122214741713\"></p>\n<ul>\n<li>此时这个API的参数和上面CreateRemoteThread()的参数基本是一样的</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>kernelbase.dll是从Vista开始新增的dll文件，负责包装kernel32.dll</p>\n</p>\n</div>\n<ul>\n<li><p>继续进入这个API的内部，发现调用的其实是NtCreateThreadEx()，这个和书上就不太一样，书上说的是ZwCreateThreadEx()</p>\n<ul>\n<li><p>可以看出上面的重要参数传过来了</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122214908316.png\" alt=\"image-20240122214908316\"></p>\n</li>\n</ul>\n</li>\n<li><p>再次进入ZwCreateThreadEx()函数内部，发现它最终通过SYSENTER指令进入内核模式，无法再继续用户模式调试</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122215000242.png\" alt=\"image-20240122215000242\"></p>\n</li>\n</ul>\n<p><strong>Q: 综上</strong></p>\n<ul>\n<li><p>从Vista开始，新增了Kernelbase!CreateRemoteThreadEx()和ntdll!ZwCreateThreadEx() API</p>\n</li>\n<li><p>在xp操作系统中，kernel32!CreateRemoteThread内部会直接调用ZwCreateThreadEx()</p>\n</li>\n<li><p>因此dll注入失败的原因在于系统中这些新增的API，导致向会话0中的服务进程注入DLL操作失败</p>\n</li>\n</ul>\n<p><strong>Q：ntdll!ZwCreateThreadEx()</strong></p>\n<ul>\n<li><p>kernelbase!CreateRemoteThreadEx()只是kernel32!CreateRemoteThread的包装器</p>\n</li>\n<li><p>因此，无法注入的原因可能是因为ntdll!ZwCreateThreadEx()</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122100822934.png\" alt=\"image-20240122100822934\"></p>\n</li>\n<li><p>在windows vista 以后的os中进行dll注入时，直接调用ZwCreateThreadEx()是可以成功注入DLL的。</p>\n<ul>\n<li>直接调用时，CreateSuspended的参数值是False(0)，而上面通过CreateRemoteThread调用ZwCreateThreadEx()时，CreateSuspended的参数值是1</li>\n<li>CreateSuspended的意思是创建已挂起</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>从windows XP开始，CreateRemoteThread()  API内部是实现算法采用了挂起模式，即先创建出线程，再使用恢复运行方法继续执行。CreateSuspended &#x3D; 1</p>\n\n</div>\n<p><strong>综上，无法向win7的系统进程通过CreateRemoteThread进行DLL注入的原因是，API内部采用了创建后挂起的模式。而直接调用ZwCreateThreadEx()时，不会有这种问题。</strong></p>\n<h2 id=\"43-3-使CreateRemoteThread-正常工作\"><a href=\"#43-3-使CreateRemoteThread-正常工作\" class=\"headerlink\" title=\"43.3 使CreateRemoteThread()正常工作\"></a>43.3 使CreateRemoteThread()正常工作</h2><h3 id=\"修改CreateSuspended参数值\"><a href=\"#修改CreateSuspended参数值\" class=\"headerlink\" title=\"修改CreateSuspended参数值\"></a>修改CreateSuspended参数值</h3><ul>\n<li><p>虽然我调试时候最后的API和书上写的不一样，但是上面显示它的第7个参数也是1，所以我大胆猜测也是改这个参数</p>\n</li>\n<li><p>让程序停在ntdll!NtCreateThreadEx()处，修改栈中的参数，ctrl + e</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122215737485.png\" alt=\"image-20240122215737485\"></p>\n</li>\n<li><p>接着用f8运行到ntdll!NtCreateThreadEx()调用的后面</p>\n</li>\n<li><p>这里我发现process exlorer并不能查看系统进程内加载的dll，不知道书上是咋看到的，所以我不知道自己是不是注入成功了</p>\n</li>\n</ul>\n<h3 id=\"操纵条件分支\"><a href=\"#操纵条件分支\" class=\"headerlink\" title=\"操纵条件分支\"></a>操纵条件分支</h3><ul>\n<li>执行到调用之后，也就是BF62地址处，发现此时pThreadHandle被赋值了，也就是被修改了，原来它是作为参数传到NtCreateThreadEx()中的</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122230636118.png\" alt=\"image-20240122230636118\"></p>\n<ul>\n<li>那也就说明成功创建了线程句柄，也就是线程正常创建，也就是调用CreateRemoteThread过程中成功创建了远程线程</li>\n<li>但是仍然无法实现dll注入的原因可能是后面调用ntdll!ZwResumeThread() API时发生了失败，因为现在CreateSuspended &#x3D; 1，线程是以创建后挂起的模式运行的，必须恢复运行才能执行，或者就是无法调用ZwResumeThread()</li>\n<li>再执行CsrClientCallServer API之后，到CMP JL的时候，发现SF !&#x3D; OF，(SF是signal flag，OF是overflow flag)此时就会跳转</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240123110535936.png\" alt=\"image-20240123110535936\"></p>\n<ul>\n<li>程序就会跳转到75EFB50C处，就不会执行下面的NtResumeThread</li>\n</ul>\n<p><strong>Q：所以这里我修改SF的值</strong></p>\n<ul>\n<li><p>使用鼠标双击就可以修改它的值</p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240123110814981.png\" alt=\"image-20240123110814981\"></p>\n</li>\n<li><p>这样应该就可以成功注入dll</p>\n</li>\n</ul>\n<h2 id=\"43-4-总结上面的内容\"><a href=\"#43-4-总结上面的内容\" class=\"headerlink\" title=\"43.4 总结上面的内容\"></a>43.4 总结上面的内容</h2><p><strong>Q：不能通过createRemoteThread向win7的svchost.exe注入dll的原因是</strong></p>\n<ul>\n<li>svchost.exe属于会话0，在创建线程的时候采用创建后挂起的方式，并且不会调用resumethread，恢复运行，直接返回错误</li>\n<li>所以无法进行dll注入</li>\n</ul>\n<p><strong>Q：上面调试的方法</strong></p>\n<ul>\n<li>通过修改createsuspent的参数，让他不创建后挂起</li>\n<li>或者修改寄存器的值，让他调用resumethread</li>\n</ul>\n<h2 id=\"43-5-InjectDll-new-exe\"><a href=\"#43-5-InjectDll-new-exe\" class=\"headerlink\" title=\"43.5 InjectDll_new.exe\"></a>43.5 InjectDll_new.exe</h2><ul>\n<li><p>从上面我们知道，createRemoteThread内部是有一个调用链的，即</p>\n<p>kernel32!createRemoteThread -&gt; kernelbase!CreateRemoteThreadEx() -&gt;ntdll!ZwCreateThreadEx()</p>\n</li>\n<li><p>如果我们直接调用ntdll!ZwCreateThreadEx()，是可以进行注入的</p>\n</li>\n<li><p>所以重新洗一个InjectDll_new.exe,让他能在win7 win8等进行dll注入</p>\n</li>\n</ul>\n<h3 id=\"InjectDll-new-cpp\"><a href=\"#InjectDll-new-cpp\" class=\"headerlink\" title=\"InjectDll_new.cpp\"></a>InjectDll_new.cpp</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"windows.h\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"stdio.h\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"tchar.h\"</span></span>\n\nBOOL <span class=\"token function\">SetPrivilege</span><span class=\"token punctuation\">(</span>LPCTSTR lpszPrivilege<span class=\"token punctuation\">,</span> BOOL bEnablePrivilege<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 定义 ZwCreateThreadEx 函数()</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token function\">DWORD</span> <span class=\"token punctuation\">(</span>WINAPI <span class=\"token operator\">*</span>PFNTCREATETHREADEX<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span> \n    PHANDLE                 ThreadHandle<span class=\"token punctuation\">,</span>\t\n    ACCESS_MASK             DesiredAccess<span class=\"token punctuation\">,</span>\t\n    LPVOID                  ObjectAttributes<span class=\"token punctuation\">,</span>\t\n    HANDLE                  ProcessHandle<span class=\"token punctuation\">,</span>\t\n    LPTHREAD_START_ROUTINE  lpStartAddress<span class=\"token punctuation\">,</span>\t\n    LPVOID                  lpParameter<span class=\"token punctuation\">,</span>\t\n    BOOL\t                CreateSuspended<span class=\"token punctuation\">,</span>\t\n    DWORD                   dwStackSize<span class=\"token punctuation\">,</span>\t\n    DWORD                   dw1<span class=\"token punctuation\">,</span> \n    DWORD                   dw2<span class=\"token punctuation\">,</span> \n    LPVOID                  Unknown \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">// 判断是否是vista</span>\nBOOL <span class=\"token function\">IsVistaOrLater</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    OSVERSIONINFO osvi<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">ZeroMemory</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>osvi<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>OSVERSIONINFO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    osvi<span class=\"token punctuation\">.</span>dwOSVersionInfoSize <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>OSVERSIONINFO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">GetVersionEx</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>osvi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> osvi<span class=\"token punctuation\">.</span>dwMajorVersion <span class=\"token operator\">>=</span> <span class=\"token number\">6</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> TRUE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\nBOOL <span class=\"token function\">MyCreateRemoteThread</span><span class=\"token punctuation\">(</span>HANDLE hProcess<span class=\"token punctuation\">,</span> LPTHREAD_START_ROUTINE pThreadProc<span class=\"token punctuation\">,</span> LPVOID pRemoteBuf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    HANDLE      hThread <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    FARPROC     pFunc <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token function\">IsVistaOrLater</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>    <span class=\"token comment\">// Vista, 7, Server2008</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 直接调用 NtCreateThreadEx</span>\n        pFunc <span class=\"token operator\">=</span> <span class=\"token function\">GetProcAddress</span><span class=\"token punctuation\">(</span><span class=\"token function\">GetModuleHandle</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"ntdll.dll\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"NtCreateThreadEx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> pFunc <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyCreateRemoteThread() : GetProcAddress(\\\"NtCreateThreadEx\\\") failed!!! [%d]\\n\"</span><span class=\"token punctuation\">,</span>\n                   <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>PFNTCREATETHREADEX<span class=\"token punctuation\">)</span>pFunc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>hThread<span class=\"token punctuation\">,</span>\n                                    <span class=\"token number\">0x1FFFFF</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span>\n                                    hProcess<span class=\"token punctuation\">,</span>\n                                    pThreadProc<span class=\"token punctuation\">,</span>\n                                    pRemoteBuf<span class=\"token punctuation\">,</span>\n                                    FALSE<span class=\"token punctuation\">,</span>      <span class=\"token comment\">// 第7各参数设置为0</span>\n                                    <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> hThread <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyCreateRemoteThread() : NtCreateThreadEx() failed!!! [%d]\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">else</span>                    <span class=\"token comment\">// 2000, XP, Server2003</span>\n    <span class=\"token punctuation\">&#123;</span>\n        hThread <span class=\"token operator\">=</span> <span class=\"token function\">CreateRemoteThread</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> \n                                     <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> \n                                     <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> \n                                     pThreadProc<span class=\"token punctuation\">,</span> \n                                     pRemoteBuf<span class=\"token punctuation\">,</span> \n                                     <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> \n                                     <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> hThread <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyCreateRemoteThread() : CreateRemoteThread() failed!!! [%d]\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> WAIT_FAILED <span class=\"token operator\">==</span> <span class=\"token function\">WaitForSingleObject</span><span class=\"token punctuation\">(</span>hThread<span class=\"token punctuation\">,</span> INFINITE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MyCreateRemoteThread() : WaitForSingleObject() failed!!! [%d]\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> TRUE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\nBOOL <span class=\"token function\">InjectDll</span><span class=\"token punctuation\">(</span>DWORD dwPID<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>szDllName<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    HANDLE hProcess <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    LPVOID pRemoteBuf <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    FARPROC pThreadProc <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    DWORD dwBufSize <span class=\"token operator\">=</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>szDllName<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>hProcess <span class=\"token operator\">=</span> <span class=\"token function\">OpenProcess</span><span class=\"token punctuation\">(</span>PROCESS_ALL_ACCESS<span class=\"token punctuation\">,</span> FALSE<span class=\"token punctuation\">,</span> dwPID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[ERROR] OpenProcess(%d) failed!!! [%d]\\n\"</span><span class=\"token punctuation\">,</span> \n        dwPID<span class=\"token punctuation\">,</span> <span class=\"token function\">GetLastError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    pRemoteBuf <span class=\"token operator\">=</span> <span class=\"token function\">VirtualAllocEx</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> dwBufSize<span class=\"token punctuation\">,</span> \n                                MEM_COMMIT<span class=\"token punctuation\">,</span> PAGE_READWRITE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">WriteProcessMemory</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> pRemoteBuf<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>LPVOID<span class=\"token punctuation\">)</span>szDllName<span class=\"token punctuation\">,</span> \n                       dwBufSize<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    pThreadProc <span class=\"token operator\">=</span> <span class=\"token function\">GetProcAddress</span><span class=\"token punctuation\">(</span><span class=\"token function\">GetModuleHandle</span><span class=\"token punctuation\">(</span>L<span class=\"token string\">\"kernel32.dll\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n                                 <span class=\"token string\">\"LoadLibraryA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span><span class=\"token function\">MyCreateRemoteThread</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>LPTHREAD_START_ROUTINE<span class=\"token punctuation\">)</span>pThreadProc<span class=\"token punctuation\">,</span> pRemoteBuf<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[ERROR] MyCreateRemoteThread() failed!!!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> FALSE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token function\">VirtualFreeEx</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">,</span> pRemoteBuf<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> MEM_RELEASE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">CloseHandle</span><span class=\"token punctuation\">(</span>hProcess<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> TRUE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token comment\">// adjust privilege</span>\n    <span class=\"token function\">SetPrivilege</span><span class=\"token punctuation\">(</span>SE_DEBUG_NAME<span class=\"token punctuation\">,</span> TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// InjectDll.exe &lt;PID> &lt;dll_path></span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> argc <span class=\"token operator\">!=</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"usage : %s &lt;PID> &lt;dll_path>\\n\"</span><span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span><span class=\"token function\">InjectDll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>DWORD<span class=\"token punctuation\">)</span><span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"InjectDll() failed!!!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"InjectDll() succeeded!!!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>这个代码挺好理解的，就是操作系统版本高的话就调用NtCreateThreadEx()，低版本的和之前一样</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>这里作者提到：</p>\n<ul>\n<li>用户模式下, ntdll.dll库中的NtCreateThreadEx()与ZwCreateThreadEx(API其实是同一函数(二者起始地址是一样的)。</li>\n<li>而内核模式 (ntoskrnl.exe)中，二者是不同的</li>\n<li>请记住，用户模式下NtXXX()与ZwXXX()是一样的。</li>\n</ul>\n<p>这也印证了我上面调试时候API名字虽然不一样，但是可以直接修改参数</p>\n</p>\n</div>\n<h2 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h2><ul>\n<li>上面的CreateThreadEx()是微软未公开的API，有一天可能他就改了，所以注入时候要小心</li>\n</ul>\n<h1 id=\"0x44-InjDll-exe：DLL注入专用工具\"><a href=\"#0x44-InjDll-exe：DLL注入专用工具\" class=\"headerlink\" title=\"0x44 InjDll.exe：DLL注入专用工具\"></a>0x44 InjDll.exe：DLL注入专用工具</h1><ul>\n<li>InjDll.exe支持Windows 2000以上的os，但是不支持Win 9x系列，支持32位64位os</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>在各平台(32&#x2F;64位)进行 DLL注入时请注意以下几点:</p>\n<ul>\n<li>若目标进程为32位:Injector &amp; DIl一全为32位(PE32格式)。</li>\n<li>若目标进程为64位:Injector&amp;DIl一 全为64位(PE32+格式)。</li>\n</ul>\n<p>由于32&#x2F;64位进程在64位OS中均可运行，所以需要先查看目标进程的 PE文件格式，再选用合适的注入程序(IniDll32&#x2F;InjDll64)和DLL。</p>\n\n</div>\n<p><strong>Q：参数说明</strong></p>\n<p><img src=\"/../re-engineer-core-principle-05/image-20240122105011400.png\" alt=\"image-20240122105011400\"></p>\n<p><strong>Q：注意事项</strong></p>\n<ul>\n<li>由于采用了执行远程线程调用LoadLibrary()的工作方式，所以如果kernel32.dll未加载到目标进程，注入&#x2F;卸载操作将失败。</li>\n<li>向访问权限受限的(受保护的)进程、或应用了反注入技术的进程进行注入&#x2F;卸载操作时可能失败。</li>\n<li>原则上，进行N次注入操作后，必须执行相同次数的卸载操作，才能将相关DLL文件完全卸载。</li>\n<li>注人前先查看目标进程的PE文件格式(32位的PE32 还是64位的PE32+)，然后再选择相应的注人程序(IniDll32.exe&#x2F;InjDll64.exe)DLL文件(32位的PE32、64位的PE32+)。</li>\n</ul>\n","text":"引言 上一部分学的很快，集中看了一周就学完了，希望可以快点把这本书看完，然后用起来 0x36 64位计算36.1 64位计算环境Q：操作系统的演化 1985年 Intel 推出了 80386 CPU芯片 1995年 Miscrosoft发布 32位 Windows 95，计算机正...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x36-64%E4%BD%8D%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">0x36 64位计算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#36-1-64%E4%BD%8D%E8%AE%A1%E7%AE%97%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">36.1 64位计算环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#64%E4%BD%8DCPU\"><span class=\"toc-text\">64位CPU</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#64%E4%BD%8DOS\"><span class=\"toc-text\">64位OS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Win32-API\"><span class=\"toc-text\">Win32 API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#WOW-64\"><span class=\"toc-text\">WOW 64</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%A4%B9%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">文件夹结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E8%A1%A8\"><span class=\"toc-text\">注册表</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0WOW64Test\"><span class=\"toc-text\">练习WOW64Test</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#36-2-%E7%BC%96%E8%AF%9164%E4%BD%8D%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">36.2 编译64位文件</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x37-x64%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">0x37 x64处理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#37-1-X64%E6%96%B0%E5%A2%9E%E7%9A%84%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">37.1 X64新增的项目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#64%E4%BD%8D\"><span class=\"toc-text\">64位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98\"><span class=\"toc-text\">内存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">通用寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CALL-JMP%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">CALL&#x2F;JMP指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A\"><span class=\"toc-text\">函数调用约定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88-%E6%A0%88%E5%B8%A7\"><span class=\"toc-text\">栈 &amp; 栈帧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Stack32-exe-Stack64-exe\"><span class=\"toc-text\">Stack32.exe &amp; Stack64.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Stack32-exe\"><span class=\"toc-text\">Stack32.exe</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Stack64-exe\"><span class=\"toc-text\">Stack64.exe</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x38-PE32\"><span class=\"toc-text\">0x38 PE32+</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#38-1-PE32\"><span class=\"toc-text\">38.1 PE32+</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-NT-HEADERS\"><span class=\"toc-text\">IMAGE_NT_HEADERS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-FILE-HEADER\"><span class=\"toc-text\">IMAGE_FILE_HEADER</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-OPTIONAL-HEADER\"><span class=\"toc-text\">IMAGE_OPTIONAL_HEADER</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-THUNK-DATA\"><span class=\"toc-text\">IMAGE_THUNK_DATA</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-TLS-DIRECTORY\"><span class=\"toc-text\">IMAGE_TLS_DIRECTORY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">工具</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x39-Windbg\"><span class=\"toc-text\">0x39 Windbg</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8CWindbg\"><span class=\"toc-text\">运行Windbg</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Windbg%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">Windbg基本指令</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x40-64%E4%BD%8D%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">0x40 64位调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#40-1-x64%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%B0%83%E8%AF%95%E5%99%A8\"><span class=\"toc-text\">40.1 x64环境下的调试器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#40-2-64%E4%BD%8D%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">40.2 64位调试</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#40-3-PE32%EF%BC%9AWOW64Test-x86-exe\"><span class=\"toc-text\">40.3 PE32：WOW64Test_x86.exe</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#40-4-PE32-%EF%BC%9AWOW64Test-x64-exe\"><span class=\"toc-text\">40.4 PE32+：WOW64Test_x64.exe</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x41-ASLR\"><span class=\"toc-text\">0x41 ASLR</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-1-Windows%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">41.1 Windows内核版本</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-2-ASLR\"><span class=\"toc-text\">41.2 ASLR</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-3-Visual-C\"><span class=\"toc-text\">41.3 Visual C++</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-4-ASLR-exe\"><span class=\"toc-text\">41.4 ASLR.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PE%E5%A4%B4%E4%B8%AD%E5%92%8CASLR%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">PE头中和ASLR相关的信息</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#41-5-%E5%88%A0%E9%99%A4ASLR%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">41.5 删除ASLR功能</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x42-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">0x42 内核中的会话</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#42-1-%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">42.1 会话</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#42-2-%E4%BC%9A%E8%AF%9D0%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">42.2 会话0隔离机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#42-3-%E5%A2%9E%E5%BC%BA%E5%AE%89%E5%85%A8%E6%80%A7\"><span class=\"toc-text\">42.3 增强安全性</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x43-%E5%86%85%E6%A0%B86%E4%B8%AD%E7%9A%84DLL%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">0x43 内核6中的DLL注入</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#43-1-DLL%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5\"><span class=\"toc-text\">43.1 DLL注入失败</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#43-2-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">43.2 原因分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#43-3-%E4%BD%BFCreateRemoteThread-%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">43.3 使CreateRemoteThread()正常工作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9CreateSuspended%E5%8F%82%E6%95%B0%E5%80%BC\"><span class=\"toc-text\">修改CreateSuspended参数值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E7%BA%B5%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF\"><span class=\"toc-text\">操纵条件分支</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#43-4-%E6%80%BB%E7%BB%93%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">43.4 总结上面的内容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#43-5-InjectDll-new-exe\"><span class=\"toc-text\">43.5 InjectDll_new.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#InjectDll-new-cpp\"><span class=\"toc-text\">InjectDll_new.cpp</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9\"><span class=\"toc-text\">注意的点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x44-InjDll-exe%EF%BC%9ADLL%E6%B3%A8%E5%85%A5%E4%B8%93%E7%94%A8%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">0x44 InjDll.exe：DLL注入专用工具</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"re-engineer-core-principle-06","uid":"080514f34f3fd257fa211ebeac34b223","slug":"re-engineer-core-principle-06","date":"2024-01-23T03:31:18.000Z","updated":"2024-02-29T10:51:09.787Z","comments":true,"path":"api/articles/re-engineer-core-principle-06.json","keywords":null,"cover":"/medias/web_security.jpg","text":"引言 快看完了，加油冲冲冲！希望回家前看完 0x45 TLS回调函数 TLS(Thread Local Storage 线程局部存储)回调函数(Callback function)常用于反调试。 TLS回调函数的运行要先于EP代码的执行，因此它可以作为一种反调试技术使用 45.1...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"re-engineer-core-principle-04","uid":"3a44a24f5a69ff4f99f1bd18acd6c0b5","slug":"re-engineer-core-principle-04","date":"2024-01-07T10:57:34.000Z","updated":"2024-02-29T10:45:11.532Z","comments":true,"path":"api/articles/re-engineer-core-principle-04.json","keywords":null,"cover":"/medias/pexels-luis-gomes-546819.jpg","text":"引言 第三部分学了好久，主要是因为中间参加了两次面试，但是最后也没有去上实习，害！ 还是好好努力学习吧 0x29 API钩取29.1 钩取Q：钩取(Hook)的整个流程如下 使用反汇编器&#x2F;调试器把握程序的结构与工作原理 开发需要的“钩子”代码，用于修改 Bug、改善程序...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}