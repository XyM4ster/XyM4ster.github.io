{"title":"ODDFUZZ","uid":"9b08663ab6515ce746fcfc5eb13ac547","slug":"ODDFUZZ-SP-2023","date":"2023-11-07T02:18:56.000Z","updated":"2023-11-14T02:05:35.644Z","comments":true,"path":"api/articles/ODDFUZZ-SP-2023.json","keywords":null,"cover":[],"content":"<h1 id=\"ABSTRACT\"><a href=\"#ABSTRACT\" class=\"headerlink\" title=\"ABSTRACT\"></a>ABSTRACT</h1><p><strong>Q：对于Java反序列化漏洞，现有的解决方式</strong></p>\n<ul>\n<li>static analysis和fuzz生成POC，用序列化的对象触发漏洞</li>\n<li>但是存在有效性和效率的问题</li>\n</ul>\n<p><strong>Q：本文方法</strong></p>\n<ul>\n<li>提出一个轻量级的static taint analysis去识别调用链<ul>\n<li>ODDFUZZ尽力locate所有的漏洞，避免误报</li>\n<li>oddfuzz用 directed greybox fuzzing(DGF)去探索漏洞，然后生成POC测试用例去减少false positives</li>\n</ul>\n</li>\n<li>ODDFUZZ用一个structure-aware seed generation方法去保证测试用例的有效性</li>\n<li>采用混合的feedback和step-forward策略去指导directed fuzzing</li>\n</ul>\n<p><strong>Q：具体实现</strong></p>\n<ul>\n<li>实现了一个ODDFUZZ的prototype，并且在Java deserilization repository <em>ysoserial</em>上进行了评估</li>\n<li>ODDFUZZ可以发现36个调用链中的14个，但是两个其他的state-of-the-art只能发现其中的3个</li>\n<li>作者也在真实的applications中进行评估，发现了6个调用链</li>\n</ul>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p><strong>Q：产生Java反序列化的原因</strong></p>\n<ul>\n<li>因为反序列化时对象的多态，并且有像Java反射这样的技术，让精心制作的序列化对象很容易被注入</li>\n<li>这打破了传统的进程间数据传输的可信边界，增加了攻击面</li>\n</ul>\n<p><strong>Q：Java反序列化的危害例子</strong></p>\n<ul>\n<li>一个最近的0 day漏洞(Spring4Shell)在Spring框架中允许攻击者发送一个构造的Http请求去绕过Http请求解析器中的保护，导致RCE，远程代码执行</li>\n</ul>\n<p><strong>Q：ODD漏洞的根本原因</strong></p>\n<ul>\n<li>反序列化对象可以reach、affect目标应用中的敏感代码<ul>\n<li>reach：in terms of control flow</li>\n<li>affect：in terms of data flow</li>\n<li>sensitive code：sink</li>\n</ul>\n</li>\n<li>根据上面的特点，很显然可以用taint analysis</li>\n</ul>\n<p><strong>Q：但是精度受限</strong></p>\n<ul>\n<li>因为对Java反序列化的特征的支持很少</li>\n<li>导致false-positive（误报）和false-nagetive（漏报）</li>\n<li>因此就需要手工检查报告，这就很浪费时间</li>\n</ul>\n<p><strong>Q：为了解决上面的问题</strong></p>\n<ul>\n<li>SerHybrid[13]采用混合的分析方法</li>\n<li>[15]分析heap access paths去找到affect security-sensitive call site的source object</li>\n<li>使用fuzz生成source injection 对象去验证sink是否会到达</li>\n</ul>\n<p><strong>我理解这里应该是生成的对象是否可以到达sink</strong></p>\n<p><strong>Q：上述方法的问题</strong></p>\n<p>第一：</p>\n<ul>\n<li>由于Java的运行时多态，一条路径上的任何方法都可能被用来去构建调用链</li>\n<li>如果每个方法都测试一下，显然会路径爆炸</li>\n<li>即使用taint analysis，可能有精度问题，或者不能work因为调用链太多</li>\n</ul>\n<p>第二：</p>\n<ul>\n<li>现有的fuzz方法并不高效在生成测试用例上<ul>\n<li>具体原因是因为一个对象的类层次结构可能很复杂，fuzz事先不知道</li>\n</ul>\n</li>\n<li>而且现有的fuzz主要是覆盖率导向，争取覆盖更多的代码，而不是目标导向</li>\n</ul>\n<p><strong>Q：为了解决上述的问题，作者提出了方法</strong></p>\n<ul>\n<li>ODDFUZZ实现了轻量级的taint analysis，在处理Java运行时多态的问题上，实现了precision和recall的平衡</li>\n<li>oddfuzz对调用链的data constraints建模形成一个tree，使用这个tree来进行structure-aware的fuzzing</li>\n<li>oddfuzz通过采取一个直接的fuzz通过step-forward mutation策略和hybrid feedback，去重复的reach candidate 漏洞</li>\n</ul>\n<p><strong>Q：具体实现</strong></p>\n<ul>\n<li>基于一个流行的Java fuzzing框架JQF实现oddfuzz</li>\n<li>利用ysoserial评估它</li>\n</ul>\n<h2 id=\"我的补充\"><a href=\"#我的补充\" class=\"headerlink\" title=\"我的补充\"></a>我的补充</h2><p><strong>Q：Java的运行时多态的例子(有点忘记了)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">makeSound</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Animal is making a sound\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Cat</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">makeSound</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Meow\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Dog</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">makeSound</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Woof\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Animal</span> animal1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Animal</span> animal2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        animal1<span class=\"token punctuation\">.</span><span class=\"token function\">makeSound</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 输出 \"Meow\"，调用的是 Cat 类的 makeSound 方法</span>\n        animal2<span class=\"token punctuation\">.</span><span class=\"token function\">makeSound</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 输出 \"Woof\"，调用的是 Dog 类的 makeSound 方法</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>Java 中的运行时多态是通过方法重写（Method Overriding）和动态绑定（Dynamic Binding）实现的。</li>\n<li>运行时多态允许在编译时无需确定方法的具体实现，而是在运行时根据对象的实际类型来确定调用哪个方法。这使得代码更加灵活，可以通过父类引用来调用子类的方法</li>\n</ul>\n<p><strong>Q：如何理解trade-off between precision and recall</strong></p>\n<ul>\n<li>recall：理解成正确标记为污点的数据</li>\n<li>precision：精度</li>\n</ul>\n<p>如果提高recall，就容易产生false-positive（误报），标记为污点的数据变多了。</p>\n<p>如果提高precison，就容易产生false-nagetive(漏报)。</p>\n<h1 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h1><p><strong>Q：为啥叫ODD(open Dynamic Deserilization)</strong></p>\n<ul>\n<li>open：允许arbitayty objects被反序列化</li>\n<li>dynamic：调用多态方法或者基于反射的行为来探索很多路径</li>\n</ul>\n<p><strong>Q：攻击发起的方式</strong></p>\n<ul>\n<li><p>入口点：任何反序列化数据的地方都可以作为入口</p>\n</li>\n<li><p>攻击者把代码片段链接到一起，形成调用链</p>\n<p><img src=\"/../ODDFUZZ-SP-2023-SP-2023/image-20231102112214802.png\" alt=\"image-20231102112214802\"></p>\n</li>\n<li><p>这里形成了一个调用链，在<code>Apache Commons Collections4</code>library，这会导致远程代码执行</p>\n</li>\n</ul>\n<p><strong>Q：Property-Oriented Programming(POP)</strong></p>\n<ul>\n<li>to chain multilevel objects of specific classes and set certain fields to specific data values</li>\n</ul>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231102112622741.png\" alt=\"image-20231102112622741\"></p>\n<ul>\n<li>首先攻击者设置PriorityQueue的属性comparator为<code>TransformingComparator</code></li>\n<li>设置TransformingComparator的属性<code>transform</code>为<code>InvokerTransformer</code></li>\n<li>这样queue中的Object可以到达sink方法，</li>\n<li>当反序列化调用readObject的时候，就会实现远程代码执行。</li>\n</ul>\n<h2 id=\"Threat-model\"><a href=\"#Threat-model\" class=\"headerlink\" title=\"Threat model\"></a>Threat model</h2><p><img src=\"/../ODDFUZZ-SP-2023/1698909307274.png\" alt=\"1698909307274\"></p>\n<p>暴漏的入口很多，然后就可以注入了。</p>\n<p><strong>Q：由于补一个反序列化的洞，很耗时，一般情况下都是通过whitelist或者Blacklist进行限制</strong></p>\n<ul>\n<li>但是如果发现了一个新的调用链，那么现有的方法就失效了</li>\n</ul>\n<h2 id=\"Directed-Greybox-Fuzzing\"><a href=\"#Directed-Greybox-Fuzzing\" class=\"headerlink\" title=\"Directed Greybox Fuzzing\"></a>Directed Greybox Fuzzing</h2><p><strong>Q：分成两种</strong></p>\n<ul>\n<li>Coverage-guided Greybox Fuzzing (CGF) ：追求代码覆盖率</li>\n<li>Directed Greybox Fuzzing (DGF)：被设计去guide fuzzer到一个具体的程序location，去生成POC 测试用例</li>\n</ul>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231102153035083.png\" alt=\"image-20231102153035083\"></p>\n<p><strong>Q：DGF的工作流程</strong></p>\n<ul>\n<li>静态分析<ul>\n<li>提取call graph和control flow graph进行Inter-procedural，计算inout binary和target之间的distance</li>\n</ul>\n</li>\n<li>fuzzing loop<ul>\n<li>target distance和其他的fitness metric一样，像coverage 和similarity，被当成一种feedback，快速引导fuzzer到target site</li>\n</ul>\n</li>\n<li>之后directed fuzzer根据feedback信息，在种子池中选择closer to target site的seed，接着分配合适的energy为Mutation<ul>\n<li>一个种子的energy决定了多少个新的种子被生成</li>\n</ul>\n</li>\n<li>之后fuzzer采取各种突变策略去控制种子朝着desired target sites进化，</li>\n<li>一个有smaller distance的seed会被保留到下一个loop中</li>\n</ul>\n<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p>实现一个high recall和precision的方案，需要解决下面三个问题</p>\n<h2 id=\"A-challenge-1：Runtime-Polymorphism\"><a href=\"#A-challenge-1：Runtime-Polymorphism\" class=\"headerlink\" title=\"A challenge 1：Runtime Polymorphism\"></a>A challenge 1：Runtime Polymorphism</h2><p><strong>Q：现有的方法用静态分析去检测Java 反序列化漏洞，但是存在问题</strong></p>\n<ul>\n<li>因为Java的运行时多态，他的declared type，并不一定是他的最终类型</li>\n<li>所以很难推断程序运行时的真正路径，导致很高的false-nagative rate（误报率）</li>\n</ul>\n<p><strong>Q：为了解决上面的问题，直接的方式是用CHA</strong></p>\n<ul>\n<li>但是CHA考虑当前类和它的所有子类，这很容易路径爆炸</li>\n</ul>\n<p><strong>Q：GadgetInspector的方法</strong></p>\n<ul>\n<li><p>基于CHA和method overriding hierarchy</p>\n</li>\n<li><p>他考虑data flows从method argument 到 return value 和从method argument 到method invocation</p>\n</li>\n<li><p>是intraprocedural taint analysis</p>\n<ul>\n<li>没有考虑Java的运行时多态</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：FUGIO的方法</strong></p>\n<ul>\n<li>是interprocedural data flow基于构建的 depth-bounded call tree，删除infeasible gadget chains</li>\n<li>但是对于Java来说 所有的依赖和库都在一起，因此call tree很深，很难处理</li>\n</ul>\n<h2 id=\"B-challenge-2：Structured-Input-Construction\"><a href=\"#B-challenge-2：Structured-Input-Construction\" class=\"headerlink\" title=\"B challenge 2：Structured Input Construction\"></a>B challenge 2：Structured Input Construction</h2><p><strong>Q：以Figure1为例，正常构建的时候，我需要构建类，并且给类的属性填上我想给他的值</strong></p>\n<ul>\n<li>那么这就需要<ul>\n<li>了解注入对象的类的层次结构</li>\n<li>需要注入合适的属性</li>\n</ul>\n</li>\n<li>但是传统的fuzz不能对整个调用链进行fuzz，因为很难知道每个injected object后面复杂的结构</li>\n</ul>\n<p><strong>Q：解决嵌套对象结构的一个有效方法是generation-based fuzz</strong></p>\n<ul>\n<li>SerHybrid利用指针分析去生成一个heap access path<ul>\n<li>从heap graph来说，这会满足到达security-sensitive call site的data-flow constraints</li>\n<li>对于没有出现在heap path的field properties，使用fuzz assign random values</li>\n<li>根据他们的type生成有效的注入对象</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：但是很难</strong></p>\n<ul>\n<li>因为对于Comperator来说，你不太可能从众多接口中找到TransformingComparator来传给他</li>\n</ul>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231102171040145.png\" alt=\"image-20231102171040145\"></p>\n<p><strong>Q：FUGIO构建了一个property tree基于调用链</strong></p>\n<p>总结：对于复杂的类的层次结构，需要一种合理的方法感知它的结构，给他注入合理的值。</p>\n<h2 id=\"C-Challenge-3-Target-Directed-Fuzzing\"><a href=\"#C-Challenge-3-Target-Directed-Fuzzing\" class=\"headerlink\" title=\"C Challenge 3:Target-Directed Fuzzing\"></a>C Challenge 3:Target-Directed Fuzzing</h2><p><strong>Q：对于Code-Coverage fuzzing来说，显然不适合现在的情况</strong></p>\n<ul>\n<li>对于下面这段代码，如果是Code-Coverage fuzzing，那么如果comparator是null，它会被当成是Interesting seed，被用到下一轮循环中，因为它触发了新的代码片段</li>\n<li>但是实际上它并没有到达敏感方法的call site</li>\n<li>所以这个其实是无意义的，</li>\n<li>所以code-coverage导向不行</li>\n</ul>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231102172345364.png\" alt=\"image-20231102172345364\"></p>\n<p><strong>Q：DFG</strong></p>\n<ul>\n<li>如果一个seed的exection trace接近目标site，他会提高整个seed的优先级</li>\n</ul>\n<p><strong>Q：State-of-the-art directed fuzzers</strong></p>\n<ul>\n<li>计算seed execution trace中所有basic block的平均距离来选择和调度种子，来快速到达target site</li>\n</ul>\n<p><strong>Q：但是这可能有问题</strong></p>\n<ul>\n<li>即使你找到了一个最短的距离，可能它也不是调用链</li>\n<li>因为不是每个basic block都固定执行你期待的调用链上的方法</li>\n</ul>\n<p>总结：重要的是需要有一种target-directed fuzzing feedback，能够有效评估生成的injection object的质量</p>\n<h1 id=\"ODDFUZZ-DESIGN\"><a href=\"#ODDFUZZ-DESIGN\" class=\"headerlink\" title=\"ODDFUZZ DESIGN\"></a>ODDFUZZ DESIGN</h1><h2 id=\"A-Overview\"><a href=\"#A-Overview\" class=\"headerlink\" title=\"A Overview\"></a>A Overview</h2><p><img src=\"/../ODDFUZZ-SP-2023/image-20231102174843066.png\" alt=\"image-20231102174843066\"></p>\n<p>Input：program under testing的compiled file</p>\n<p>Indetifier：轻量级的污点分析</p>\n<p>Validator：</p>\n<ul>\n<li>基于Identifier生成的调用链，生成一个structure-aware的seed</li>\n</ul>\n<p>fuzzing loop：结合step-forward mutation strategy和hybrid feedback(seed distance and gadget coverage)让fuzzer朝着目标sink去突变，生成Injection object</p>\n<p>当inject object到达sink的时候，暴出调用链</p>\n<h2 id=\"B-Taint-Analysis\"><a href=\"#B-Taint-Analysis\" class=\"headerlink\" title=\"B Taint Analysis\"></a>B Taint Analysis</h2><p><strong>Q：构建调用链的关键</strong></p>\n<ul>\n<li>一个taint object能否从entry point(source)传到security-sensitivie call site(sink)</li>\n<li>也就是有一条从source到sink 的call path</li>\n</ul>\n<p><strong>Q：直接的方法是构建Call graph</strong></p>\n<ul>\n<li>但是由于Java的运行时多态，不能通过declared type确定类型</li>\n</ul>\n<h3 id=\"Method-Summary-Computation\"><a href=\"#Method-Summary-Computation\" class=\"headerlink\" title=\"Method Summary Computation\"></a>Method Summary Computation</h3><p>oddfuzz计算在PUT路径上所有方法的static summaries，之后用这个构建调用链</p>\n<p><strong>Q：具体步骤</strong></p>\n<ul>\n<li><p>对于每个method，提取所有的<em>arguments和this</em>，作为method summary</p>\n</li>\n<li><p>为了追踪在每个方法variable之间信息的传播，集中于四种statements，因为污点分析经常用这四个：</p>\n<ul>\n<li>assign</li>\n<li>load</li>\n<li>store</li>\n<li>call</li>\n</ul>\n<p>（这不是课上讲的么）</p>\n</li>\n<li><p>依赖于方法的argument的数据也算method summary</p>\n</li>\n<li><p>因为上面这些就是攻击者会构造的数据</p>\n</li>\n</ul>\n<h3 id=\"Gadet-Chain-Identification\"><a href=\"#Gadet-Chain-Identification\" class=\"headerlink\" title=\"Gadet Chain Identification\"></a>Gadet Chain Identification</h3><p><strong>Q：调用链的构成</strong></p>\n<ul>\n<li>调用链是一系列方法的调用，从一个magic method到security-sensitive call site</li>\n</ul>\n<p><strong>Q：ODD</strong></p>\n<ul>\n<li>ODD应该specify magic method和security-sensitive call site</li>\n<li>识别调用链基于之前的method summray</li>\n<li>足总和specify了16个magic method和30个security-sensitive call site，在附录A</li>\n</ul>\n<p>&#x3D;&#x3D;那这里的magic method就相当于source，security-sensensitive call site相当于sink？&#x3D;&#x3D;</p>\n<p><strong>Q：采用的算法</strong></p>\n<ul>\n<li>GadgetInspector基于BFS搜索，会跳过infeasible path,即使这个路径上有可能会被利用的方法，因此会导致漏报</li>\n<li>一旦在PUT上发现了一个magic method，oddfuzz会执行DFS，基于之前提到的summary(就是方法的参数)，我觉得其实也就是看变量流到哪，去把可能的链接在一起<ul>\n<li>为了避免这个infinite loop，设置了一个长度的最大值</li>\n</ul>\n</li>\n<li>为了处理Java的多态问题，对call statement用CHA，避免路径爆炸，把所有的路径都处理<ul>\n<li>对于一个方法调用,<code>r = x.k(a,...)</code>，Fig.1中的12行，<code>comparator.compare</code>，如果comparator是污点对象，会把所有compare的重写方法都加入到worklist中。</li>\n</ul>\n</li>\n</ul>\n<p>&#x3D;&#x3D;啥是CG-based taint analyzer&#x3D;&#x3D;</p>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231111120239292.png\" alt=\"image-20231111120239292\"></p>\n<ul>\n<li>当路径长度达到限制的最大值，或者达到sink方法的时候，这个过程就会停止了</li>\n</ul>\n<p><strong>当所有的路径从magic methods 到sensitive call site被分析完之后</strong></p>\n<ul>\n<li><p>会用validator模块进行验证，&#x3D;&#x3D;validator是啥&#x3D;&#x3D;</p>\n</li>\n<li><p>这种方法具有很好的effectiveness和scalability</p>\n</li>\n</ul>\n<h2 id=\"C-Structer-aware-Greybox-Fuzzing\"><a href=\"#C-Structer-aware-Greybox-Fuzzing\" class=\"headerlink\" title=\"C Structer-aware Greybox Fuzzing\"></a>C Structer-aware Greybox Fuzzing</h2><p>对于一个Java application和一个candicate 调用链，oddfuzz构建结构感知的定向灰喝测试，生成注入对象。</p>\n<p>主要的fuzzing loop 是算法1，由下面三部分组成：</p>\n<h3 id=\"Structured-Seed-Genaration\"><a href=\"#Structured-Seed-Genaration\" class=\"headerlink\" title=\"Structured Seed Genaration\"></a>Structured Seed Genaration</h3><p>首先看前面提到的：</p>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231111124533764.png\" alt=\"image-20231111124533764\"></p>\n<ul>\n<li>两个主要的痛点是：<ul>\n<li>需要搞明白类的层次结构</li>\n<li>需要注入合适的sub-object，让他能到达sink</li>\n</ul>\n</li>\n<li>对于复杂的对象结构，需要精心设计属性</li>\n</ul>\n<p>**Q：为了解决上面的问题，作者用了property tree **</p>\n<ul>\n<li><p>root node代表一个class object，可以包含一个或多个调用链</p>\n</li>\n<li><p>leaf node代表class field，包含属性property和名字name</p>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231111125032589.png\" alt=\"image-20231111125032589\"></p>\n</li>\n<li><p>看上面这个图，看一下是如何用反射具体构造对象和他的属性的。</p>\n</li>\n<li><p>两个树merge到一起的条件：</p>\n<ul>\n<li>如果一个property tree的field node的property是一个对象，这个对象属于其他的property tree，并且这个新的property tree是这个链子中的下一个节点，那就把这两个Tree merge到一起。</li>\n<li>在PriorityQueue这个tree中，Comparator是一个接口，并且他被TransformingComparator实现了(参考图1)，这两个tree也会merge，通过链接Comparator和Trasforming Comparator</li>\n</ul>\n</li>\n<li><p>迭代的把调用链上的所有的tree merge到一起，直到不再有孤立的sub tree。</p>\n</li>\n</ul>\n<p><strong>Q：污点分析和property tree的结合(这部分也就是结构感知的内容)</strong></p>\n<ul>\n<li>当用前面的污点分析发现一条调用链之后，就会把他输入给生成器，去构造一个属性的tree</li>\n<li>然后就会找树的各个根节点，把他初始化成一个注入对象用于fuzzing。也就是Fig 7中右边的部分。其他的属性，没有后继节点的(例如Object[] queue)就会被设置成null。<strong>可以看到comparator被设置成了t1</strong></li>\n</ul>\n<h3 id=\"Seed-Prioritization-via-Hybrid-Feedback\"><a href=\"#Seed-Prioritization-via-Hybrid-Feedback\" class=\"headerlink\" title=\"Seed Prioritization via Hybrid Feedback\"></a>Seed Prioritization via Hybrid Feedback</h3><ul>\n<li>利用上面的property tree处理复杂的嵌套，成功构建了可利用的注入对象</li>\n</ul>\n<p>前面提到的关键是：<strong>需要一个目标导向的定向灰盒模糊测试</strong></p>\n<ul>\n<li><p>也就是需要让seed逐渐的接近目标，并且执行距离很短</p>\n</li>\n<li><p>这意味着随机生成并且mutate 一个注入的对象，可能并不会朝着sink去，因为对象的属性非常多</p>\n</li>\n<li><p>这可能导致浪费时间在unreachable path上</p>\n</li>\n<li><p>&#x3D;&#x3D;是因为是动态的，不知道下一个方法在哪么》&#x3D;&#x3D;</p>\n</li>\n</ul>\n<p><strong>Q：为了解决select and schedule种子到达调用链的security-sensitive site的问题</strong></p>\n<p>oddfuzz采用下面两种feedback指标</p>\n<ul>\n<li><p>seed distance：计算seed distance，并优先调度到达目标sink的种子，一个seed s到sink所在的basic block的距离，如下</p>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231111144132618.png\" alt=\"image-20231111144132618\"></p>\n<ul>\n<li>一个在执行路径上的种子s所在的basic block m到目标基本块Tb的距离</li>\n<li>这里并不就算所有 的basic block，而是收集调用链上的block ξ(s)</li>\n</ul>\n</li>\n<li><p>gadget coverage：如果一个seed覆盖了调用链上的更多方法，就提高他的优先级</p>\n<ul>\n<li><p>In the initial fuzzing stage, the gadget coverage aims at guiding the fuzzer to select and prioritize diverse seeds,<br>avoiding getting stuck in local optimum caused by favoring certain seeds with specific execution paths</p>\n<p>gadget 覆盖率是在fuzzing的最初阶段引导fuzzer去选择和优化不同的seed,避免陷入由某些种子执行特定的path而导致的局部最优</p>\n</li>\n<li><p>&#x3D;&#x3D;意思是不图更快到达sink，而是要覆盖链上的更多方法？&#x3D;&#x3D;</p>\n</li>\n</ul>\n</li>\n<li><p>在power scheduling阶段， the gadget coverage attempts to give seeds with the same distance but covering more branches higher chances for mutation.</p>\n</li>\n</ul>\n<p><strong>Q：把上面的工作形式化，具体说明</strong></p>\n<ul>\n<li><p>将所有生成的seed按照升序sort，维持一个two-level的优先级队列</p>\n</li>\n<li><p>一个种子(相同distance但是coverage不同的)会被放到favored-queue，其他的seed放到less favored queue</p>\n</li>\n<li><p>更可能从favored-queue中选择下一个种子进行mutation</p>\n</li>\n<li><p>对于power schedule,使用seed distance和gagdet coverage去给选择的种子一个proper energy</p>\n<ul>\n<li>$\\psi$ (s) 表示一个seed覆盖的分支比例，对于所有的分支来说</li>\n<li>$\\tilde d$ ，min是最小距离</li>\n</ul>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231111145841846.png\" alt=\"image-20231111145841846\"></p>\n</li>\n<li><p>利用上面这个公式，fuzzer可以决定应用到现在的seed的mutation chance的数量，决定是否突变的种子是否是favored</p>\n<ul>\n<li>也就是这个当前种子的覆盖率越高，下一轮依据他再生成新的种子</li>\n</ul>\n<p><img src=\"/../ODDFUZZ-SP-2023/image-20231111124248156.png\" alt=\"image-20231111124248156\"></p>\n</li>\n</ul>\n<h3 id=\"Step-forward-Seed-Mutation\"><a href=\"#Step-forward-Seed-Mutation\" class=\"headerlink\" title=\"Step-forward Seed Mutation\"></a>Step-forward Seed Mutation</h3><p>之前的fuzz通过bit flips(位翻转)来生成新的input</p>\n<p><strong>Q：之前的问题</strong> </p>\n<ul>\n<li>bit-level mutations may lead to invalid syntax(语法无效) when applied to structured inputs</li>\n</ul>\n<p><strong>Q：本文做法</strong></p>\n<ul>\n<li>利用JQF： maps the structured inputs to a sequence of untyped bits (i.e., parameters), to mutate the<br>generated seeds at the bit-level.</li>\n<li>这些在参数上的bit-level的mutation，和在structured injection objects的property-level mutations相关</li>\n<li>之后使用step-forward策略引导seed朝着sensitive call的方向</li>\n</ul>\n<p><strong>Q：具体做法</strong></p>\n<ul>\n<li>首先遍历要注入对象的property tree，检查每个property的type</li>\n<li>对于原始数据类型(如布尔型、int型)，fuzzer使用JQF提出的多个伪随机方法将untyped的bit参数转换为随机的typed value。<ul>\n<li>For the reference data types,(引用类型)，为特定类型定制template</li>\n<li>对于class，利用random.choose随机选择一个sub-class</li>\n<li>对于array，使用random.nextInt()随机设置数组大小，基于element的type，assign随机的值</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：具体的Mutation例子</strong></p>\n<ul>\n<li>对于size的mutation，它是Int类型，会用 random.nextInt() 生成一个随机的整数1</li>\n<li>对于object[]  queue，调用random.choose()从预定义的dictionary中给他assign一个Object实例<ul>\n<li>这个dictionary由一些具体的属性值组成，例如(class object、string object)和在candidate gadget chai那种所有的classes和methods</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：为了引导fuzz朝着目标sink方向前进</strong></p>\n<ul>\n<li>在Bit-level上，逐个mutate注入对象的嵌套子对象<ul>\n<li>使用random.nextBool() i方法在注入对象的参数序列中插入额外的indentifier bytes</li>\n</ul>\n</li>\n<li>当fuzzer在遍历property tree时，遇到一个class object node，添加一个byte作为identifier，标记是否mutate这个嵌套子对象的property value</li>\n<li>当在某个branch卡住的时候，就会设置identifier为true，给参数assign一个随机的值，对这个被卡住的类属性，进行结构化的mutation，产生新的输入</li>\n<li></li>\n</ul>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ul>\n<li>前面黄色部分</li>\n<li><h2 id=\"还有就是它是如何处理Java运行时多态的呢？-是因为他用了前人的方法-特殊的处理么\"><a href=\"#还有就是它是如何处理Java运行时多态的呢？-是因为他用了前人的方法-特殊的处理么\" class=\"headerlink\" title=\"还有就是它是如何处理Java运行时多态的呢？- 是因为他用了前人的方法+特殊的处理么\"></a>还有就是它是如何处理Java运行时多态的呢？<br>- 是因为他用了前人的方法+特殊的处理么</h2></li>\n</ul>\n","text":"ABSTRACTQ：对于Java反序列化漏洞，现有的解决方式 static analysis和fuzz生成POC，用序列化的对象触发漏洞 但是存在有效性和效率的问题 Q：本文方法 提出一个轻量级的static taint analysis去识别调用链 ODDFUZZ尽力locat...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"},{"name":"Fuzz","slug":"Fuzz","count":1,"path":"api/tags/Fuzz.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ABSTRACT\"><span class=\"toc-text\">ABSTRACT</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Introduction\"><span class=\"toc-text\">Introduction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%91%E7%9A%84%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">我的补充</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Background\"><span class=\"toc-text\">Background</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Threat-model\"><span class=\"toc-text\">Threat model</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Directed-Greybox-Fuzzing\"><span class=\"toc-text\">Directed Greybox Fuzzing</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Motivation\"><span class=\"toc-text\">Motivation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#A-challenge-1%EF%BC%9ARuntime-Polymorphism\"><span class=\"toc-text\">A challenge 1：Runtime Polymorphism</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B-challenge-2%EF%BC%9AStructured-Input-Construction\"><span class=\"toc-text\">B challenge 2：Structured Input Construction</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-Challenge-3-Target-Directed-Fuzzing\"><span class=\"toc-text\">C Challenge 3:Target-Directed Fuzzing</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ODDFUZZ-DESIGN\"><span class=\"toc-text\">ODDFUZZ DESIGN</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#A-Overview\"><span class=\"toc-text\">A Overview</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#B-Taint-Analysis\"><span class=\"toc-text\">B Taint Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Method-Summary-Computation\"><span class=\"toc-text\">Method Summary Computation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Gadet-Chain-Identification\"><span class=\"toc-text\">Gadet Chain Identification</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-Structer-aware-Greybox-Fuzzing\"><span class=\"toc-text\">C Structer-aware Greybox Fuzzing</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Structured-Seed-Genaration\"><span class=\"toc-text\">Structured Seed Genaration</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Seed-Prioritization-via-Hybrid-Feedback\"><span class=\"toc-text\">Seed Prioritization via Hybrid Feedback</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Step-forward-Seed-Mutation\"><span class=\"toc-text\">Step-forward Seed Mutation</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%98%E6%9C%89%E5%B0%B1%E6%98%AF%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%91%A2%EF%BC%9F-%E6%98%AF%E5%9B%A0%E4%B8%BA%E4%BB%96%E7%94%A8%E4%BA%86%E5%89%8D%E4%BA%BA%E7%9A%84%E6%96%B9%E6%B3%95-%E7%89%B9%E6%AE%8A%E7%9A%84%E5%A4%84%E7%90%86%E4%B9%88\"><span class=\"toc-text\">还有就是它是如何处理Java运行时多态的呢？- 是因为他用了前人的方法+特殊的处理么</span></a></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"HOPPER-CCS-2023","uid":"ac1f5803919fdd2ccf7eeca40ae91dc2","slug":"HOPPER-CCS-2023","date":"2023-11-14T02:06:39.000Z","updated":"2023-11-16T14:37:40.378Z","comments":true,"path":"api/articles/HOPPER-CCS-2023.json","keywords":null,"cover":[],"text":"ABSTRACTQ：现有的fuzz drivers的问题 不能完全覆盖entries in libraries 他们的质量取决于开发人员对于代码的理解 Q：提出的Hopper 可以fuzz libraries 不需要其他的知识去craft fuzz drivers 把fuzz l...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"re-engineer-core-principle-02","uid":"1e07b60d2029aa2ea6483727894829df","slug":"re-engineer-core-principle-02","date":"2023-10-22T08:39:11.000Z","updated":"2023-12-20T15:01:26.000Z","comments":true,"path":"api/articles/re-engineer-core-principle-02.json","keywords":null,"cover":[],"text":"引言 开启《逆向工程核心原理》的第二部分，冲冲冲！ 0x13 PE文件格式13.1 介绍PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。 PE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}