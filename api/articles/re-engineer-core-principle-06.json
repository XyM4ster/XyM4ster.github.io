{"title":"re-engineer-core-principle-06","uid":"080514f34f3fd257fa211ebeac34b223","slug":"re-engineer-core-principle-06","date":"2024-01-23T03:31:18.000Z","updated":"2024-02-28T14:44:30.192Z","comments":true,"path":"api/articles/re-engineer-core-principle-06.json","keywords":null,"cover":[],"content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>快看完了，加油冲冲冲！希望回家前看完</li>\n</ul>\n<h1 id=\"0x45-TLS回调函数\"><a href=\"#0x45-TLS回调函数\" class=\"headerlink\" title=\"0x45 TLS回调函数\"></a>0x45 TLS回调函数</h1><ul>\n<li>TLS(Thread Local Storage   线程局部存储)回调函数(Callback function)常用于反调试。</li>\n<li>TLS回调函数的运行要先于EP代码的执行，因此它可以作为一种反调试技术使用</li>\n</ul>\n<h2 id=\"45-1-HelloTls-exe\"><a href=\"#45-1-HelloTls-exe\" class=\"headerlink\" title=\"45.1 HelloTls.exe\"></a>45.1 HelloTls.exe</h2><p><strong>Q：运行HelloTls.exe和用ollydbg打开hellotls.exe</strong></p>\n<ul>\n<li><p>运行显示</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122105808263.png\" alt=\"image-20240122105808263\"></p>\n</li>\n<li><p>用ollydbg打开显示，单击确定后，进程终止</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122105750347.png\" alt=\"image-20240122105750347\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122105909430.png\" alt=\"image-20240122105909430\"></p>\n</li>\n<li><p>发现这两个显示的不一样，原因在于：</p>\n<ul>\n<li>TLS回调函数先于EP代码运行，回调函数中含有反调试代码，使程序在被调试时弹出 debugger detected消息对话框</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"45-2-TLS\"><a href=\"#45-2-TLS\" class=\"headerlink\" title=\"45.2 TLS\"></a>45.2 TLS</h2><ul>\n<li>TLS是各线程的独立的数据存储空间。</li>\n<li>使用TLS可以<strong>在线程内部独立使用或修改进程的全局数据或静态数据</strong>，就像对待自身的局部变量一样</li>\n</ul>\n<h3 id=\"IMAGE-DATA-DIRECTORY-9\"><a href=\"#IMAGE-DATA-DIRECTORY-9\" class=\"headerlink\" title=\"IMAGE_DATA_DIRECTORY[9]\"></a>IMAGE_DATA_DIRECTORY[9]</h3><ul>\n<li><p>若编程中启用了TLS功能，PE头文件中就会设置TLS表</p>\n<ul>\n<li>这里显然是没设置，就是看一下它的位置</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122112257088.png\" alt=\"image-20240122112257088\"></p>\n</li>\n<li><p>在第三部分中，重点标注了datadirectory[9]</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122112030403.png\" alt=\"image-20240122112030403\"></p>\n</li>\n</ul>\n<h3 id=\"IMAGE-TLS-DIRECTORY\"><a href=\"#IMAGE-TLS-DIRECTORY\" class=\"headerlink\" title=\"IMAGE_TLS_DIRECTORY\"></a>IMAGE_TLS_DIRECTORY</h3><ul>\n<li><p>这个结构体在第5部分，PE32+中讲过</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122112335836.png\" alt=\"image-20240122112335836\"></p>\n</li>\n<li><p>这个Addres  Of Callbacks比较重要，该值含有TLS回调函数地址(VA)的数组。</p>\n<ul>\n<li>也就是可以向同一程序注册多个TLS回调函数，数组以NULL结束</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122112410620.png\" alt=\"image-20240122112410620\"></p>\n</li>\n</ul>\n<h3 id=\"回调函数地址数组\"><a href=\"#回调函数地址数组\" class=\"headerlink\" title=\"回调函数地址数组\"></a>回调函数地址数组</h3><ul>\n<li>这个数组中存储着TLS回调函数的地址。</li>\n<li>进程启动运行时，在执行EP代码前，系统会逐一调用存储在该数组中的函数</li>\n<li>虽然下面这个只有1个TLS函数，但是实际上可以修改这个地方的值，写多个TLS函数</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122112750242.png\" alt=\"image-20240122112750242\"></p>\n<h2 id=\"45-3-TLS回调函数\"><a href=\"#45-3-TLS回调函数\" class=\"headerlink\" title=\"45.3 TLS回调函数\"></a>45.3 TLS回调函数</h2><p><strong>Q：TLS回调函数的概念</strong></p>\n<ul>\n<li>TLS回调函数是指，每当创建或者终止进程的某线程时，会自动调用执行的函数，调用2次。</li>\n<li>创建进程的主线程时也会自动调用回调函数，且其调用执行先于EP代码。</li>\n<li>反调试技术利用的就是TLS回调函数的这一特征。</li>\n</ul>\n<h3 id=\"IMAGE-TLS-CALLBACK\"><a href=\"#IMAGE-TLS-CALLBACK\" class=\"headerlink\" title=\"IMAGE_TLS_CALLBACK\"></a>IMAGE_TLS_CALLBACK</h3><p><strong>Q：TLS回调函数的定义</strong></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122113152601.png\" alt=\"image-20240122113152601\"></p>\n<ul>\n<li><p>发现这个函数和DllMain很像，之前注入的dll都用了dllMain，比如dummy.dll</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122113330846.png\" alt=\"image-20240122113330846\"></p>\n</li>\n<li><p>他们的参数顺序和含义是一样的。</p>\n<ul>\n<li><p>参数Dllhandle是模块句柄，即加载地址</p>\n</li>\n<li><p>参数Reason表示调用TLS回调函数的原因，具体原因有4种</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122113441395.png\" alt=\"image-20240122113441395\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"45-4-TlsTest-exe\"><a href=\"#45-4-TlsTest-exe\" class=\"headerlink\" title=\"45.4 TlsTest.exe\"></a>45.4 TlsTest.exe</h2><p><strong>Q：TlsTest.exe的源代码</strong></p>\n<ul>\n<li><p>这段代码会注册这2个TLS回调函数TLS_CALLBACK1 TLS_CALLBACK2</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">data_seg</span><span class=\"token punctuation\">(</span></span><span class=\"token string\">\".CRT$XLX\"</span><span class=\"token expression\"><span class=\"token punctuation\">)</span></span></span>\n    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> TLS_CALLBACK1<span class=\"token punctuation\">,</span> TLS_CALLBACK2<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">data_seg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>main函数中创建用户现场ThreadProc后终止</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;windows.h></span></span>\n\n<span class=\"token comment\">// 指示编译器在代码中使用线程局部存储TLS</span>\n<span class=\"token comment\">// TLS是一种机制，允许多线程程序为每个线程分配独立的存储空间</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">comment</span><span class=\"token punctuation\">(</span>linker<span class=\"token punctuation\">,</span> </span><span class=\"token string\">\"/INCLUDE:__tls_used\"</span><span class=\"token expression\"><span class=\"token punctuation\">)</span></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">print_console</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> szMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    HANDLE hStdout <span class=\"token operator\">=</span> <span class=\"token function\">GetStdHandle</span><span class=\"token punctuation\">(</span>STD_OUTPUT_HANDLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">WriteConsoleA</span><span class=\"token punctuation\">(</span>hStdout<span class=\"token punctuation\">,</span> szMsg<span class=\"token punctuation\">,</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>szMsg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span> NTAPI <span class=\"token function\">TLS_CALLBACK1</span><span class=\"token punctuation\">(</span>PVOID DllHandle<span class=\"token punctuation\">,</span> DWORD Reason<span class=\"token punctuation\">,</span> PVOID Reserved<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span> szMsg<span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">wsprintfA</span><span class=\"token punctuation\">(</span>szMsg<span class=\"token punctuation\">,</span> <span class=\"token string\">\"TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n\"</span><span class=\"token punctuation\">,</span> DllHandle<span class=\"token punctuation\">,</span> Reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">print_console</span><span class=\"token punctuation\">(</span>szMsg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">void</span> NTAPI <span class=\"token function\">TLS_CALLBACK2</span><span class=\"token punctuation\">(</span>PVOID DllHandle<span class=\"token punctuation\">,</span> DWORD Reason<span class=\"token punctuation\">,</span> PVOID Reserved<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span> szMsg<span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">wsprintfA</span><span class=\"token punctuation\">(</span>szMsg<span class=\"token punctuation\">,</span> <span class=\"token string\">\"TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n\"</span><span class=\"token punctuation\">,</span> DllHandle<span class=\"token punctuation\">,</span> Reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">print_console</span><span class=\"token punctuation\">(</span>szMsg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 定义TLS数组</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">data_seg</span><span class=\"token punctuation\">(</span></span><span class=\"token string\">\".CRT$XLX\"</span><span class=\"token expression\"><span class=\"token punctuation\">)</span></span></span>\n    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> TLS_CALLBACK1<span class=\"token punctuation\">,</span> TLS_CALLBACK2<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">data_seg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span></span>\n\nDWORD WINAPI <span class=\"token function\">ThreadProc</span><span class=\"token punctuation\">(</span>LPVOID lParam<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">print_console</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ThreadProc() start\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">print_console</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ThreadProc() end\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    HANDLE hThread <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">print_console</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main() start\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    hThread <span class=\"token operator\">=</span> <span class=\"token function\">CreateThread</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ThreadProc<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WaitForSingleObject</span><span class=\"token punctuation\">(</span>hThread<span class=\"token punctuation\">,</span> <span class=\"token number\">60</span><span class=\"token operator\">*</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">CloseHandle</span><span class=\"token punctuation\">(</span>hThread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">print_console</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main() end\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>运行后，显示</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122114648349.png\" alt=\"image-20240122114648349\"></p>\n</li>\n</ul>\n<h3 id=\"DLL-PROCESS-ATTACH\"><a href=\"#DLL-PROCESS-ATTACH\" class=\"headerlink\" title=\"DLL_PROCESS_ATTACH\"></a>DLL_PROCESS_ATTACH</h3><ul>\n<li>进程的主线程调用main()函数前，已经注册的TLS回调函数(TLS_CALLBACK1、TLS_CALLBACK2)会先被调用执行，此时Reason的值为1，DLL_PROCESS_ATTACH<ul>\n<li>main函数开始前，调用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"DLL-THREAD-ATTACH\"><a href=\"#DLL-THREAD-ATTACH\" class=\"headerlink\" title=\"DLL_THREAD_ATTACH\"></a>DLL_THREAD_ATTACH</h3><ul>\n<li>所有TLS回调函数完成调用后，main函数开始调用执行，创建用户线程前，TLS回调函数会被再次调用执行，此时Reason &#x3D; 2 (DLL_THREAD_ATTACH)<ul>\n<li>也就是在CreateThread()之前，会调用一次回调函数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"DLL-THREAD-DETACH\"><a href=\"#DLL-THREAD-DETACH\" class=\"headerlink\" title=\"DLL_THREAD_DETACH\"></a>DLL_THREAD_DETACH</h3><ul>\n<li>TLS回调函数全部执行完毕后，ThreadProc()线程函数开始调用执行。执行完毕后，Reason &#x3D; 3，DLL_THREAD_ATTACH<ul>\n<li>ThrodProc()函数执行完毕了，又会调用一次</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"DLL-PROCESS-DETACH\"><a href=\"#DLL-PROCESS-DETACH\" class=\"headerlink\" title=\"DLL_PROCESS_DETACH\"></a>DLL_PROCESS_DETACH</h3><ul>\n<li>ThreadProc()线程函数执行完毕后，一直在等待线程终止的main函数(主线程也会终止)。此时Reason  &#x3D; 0 DLL_PROCESS_DETACH，再次调用TLS回调函数<ul>\n<li>main函数结束后，再次调用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"45-5-调试TLS回调函数\"><a href=\"#45-5-调试TLS回调函数\" class=\"headerlink\" title=\"45.5 调试TLS回调函数\"></a>45.5 调试TLS回调函数</h2><p><strong>Q：像上面一样，直接用调试器无法打开带有TLS回调函数的程序，因为会先运行TLS回调函数，且含有反调试代码，程序就终止了</strong></p>\n<ul>\n<li><p>所以我们需要修改Ollydbg选项，就可以调试了</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122161239685.png\" alt=\"image-20240122161239685\"></p>\n</li>\n<li><p>ollydbg默认是在ep处暂停，windbg默认是在系统断点处暂停，把ollydbg的改成在system point暂停</p>\n</li>\n<li><p>在ollydbg2.0中，可以设置暂停在 tls callback处</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122161551130.png\" alt=\"image-20240122161551130\"></p>\n</li>\n</ul>\n<p><strong>Q：调试TLS回调函数</strong></p>\n<ul>\n<li>发现这里调用了kernel32!IsDebuggerPresent函数</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122162443850.png\" alt=\"image-20240122162443850\"></p>\n<ul>\n<li>在函数内部发现会判断是否是调试事件，所以这里存在反调试</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122162350172.png\" alt=\"image-20240122162350172\"></p>\n<h2 id=\"45-6-手工添加TLS回调函数\"><a href=\"#45-6-手工添加TLS回调函数\" class=\"headerlink\" title=\"45.6 手工添加TLS回调函数\"></a>45.6 手工添加TLS回调函数</h2><ul>\n<li>本节是直接修改Hello.exe文件，为它添加TLS回调函数</li>\n</ul>\n<h3 id=\"修改原程序\"><a href=\"#修改原程序\" class=\"headerlink\" title=\"修改原程序\"></a>修改原程序</h3><ul>\n<li><p>原来的程序运行之后，会显示</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122162827203.png\" alt=\"image-20240122162827203\"></p>\n</li>\n<li><p>目标是给他添加TLS回调函数</p>\n</li>\n</ul>\n<h3 id=\"增加最后一个节区的大小\"><a href=\"#增加最后一个节区的大小\" class=\"headerlink\" title=\"增加最后一个节区的大小\"></a>增加最后一个节区的大小</h3><ul>\n<li>按照前面讲的，要添加IMAGE_TLS_DIRECTORY结构体和TLS回调函数</li>\n</ul>\n<p><strong>Q：向某PE文件添加代码或者数据时，有3种方法</strong></p>\n<ul>\n<li>第一，添加到节区末尾的空白区域</li>\n<li>增加最后一个节区的大小</li>\n<li>在最后添加新节区</li>\n</ul>\n<p><strong>Q：这里采用第二种方法，像最后一个节区的末尾添加</strong></p>\n<ul>\n<li>File Alignment &#x3D;  200，section alignment 是1000</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122163422640.png\" alt=\"image-20240122163422640\"></p>\n<ul>\n<li><p>我现在用Hxd给它增加200 bytes</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122164002269.png\" alt=\"image-20240122164002269\"></p>\n</li>\n</ul>\n<h3 id=\"编辑PE文件头\"><a href=\"#编辑PE文件头\" class=\"headerlink\" title=\"编辑PE文件头\"></a>编辑PE文件头</h3><p><strong>Q：.rsrc节区头</strong></p>\n<ul>\n<li>首先virtual Size不用改，因为Section Alignment值是1000，现在1B4 + 200 &#x3D; 3B4，仍然小于1000，加载时仍然会按照1000加载到内存中</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122164416195.png\" alt=\"image-20240122164416195\"></p>\n<ul>\n<li><p>改size of raw data为400，向characteristics中增加其他属性</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122164753148.png\" alt=\"image-20240122164753148\"></p>\n</li>\n<li><p>E0 00 00 60的含义是</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122164945724.png\" alt=\"image-20240122164945724\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>由于要在扩展区域内创建IMAGE_TLS_DIRECTORY结构体与TLS回调函数，所以需要向该节区添加IMAGE_SCN_CNT_CODE和IMAGE_SCN_MEM_EXECUTE属性</p>\n<p>此外，还必须向包含IMAGE _TLS_DIRECTORY 结构体的节区添加IMAGE_SCN_MEM_WRITE属性，才能保证正常运行。</p>\n<p>IMAGE_SCN_CNT_CODE：section contains code</p>\n<p>IMAGE_SCN_MEM_EXECUTE：section is executable</p>\n<p>IMAGE_SCN_MEM_WRITE: section is writable</p>\n\n</div>\n<p><strong>Q：IMAGE_DATA_DIRECTORY[9]</strong></p>\n<ul>\n<li><p>新增空白区域的起始地址为9200，RVA就是C200，所以TLS table的地址就是C200, size是18</p>\n</li>\n<li><p>修改后，查看一下</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122165744709.png\" alt=\"image-20240122165744709\"></p>\n</li>\n</ul>\n<h3 id=\"设置IMAGE-TLS-DIRECTORY结构体\"><a href=\"#设置IMAGE-TLS-DIRECTORY结构体\" class=\"headerlink\" title=\"设置IMAGE_TLS_DIRECTORY结构体\"></a>设置IMAGE_TLS_DIRECTORY结构体</h3><ul>\n<li><p>也就是向9200处添加IMAGE_TLS_DIRECTORY结构体，按照这样修改</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122171008237.png\" alt=\"image-20240122171008237\"></p>\n</li>\n<li><p>在上一步修改完IMAGE optional header data direcroty[9]的tls table之后，此时已经可以看到IMAGE_TLS_DIRECTORY</p>\n</li>\n<li><p>Address of callbacks的地址是40C224，它是含有TLS回调函数数组的起始地址，因此把回调函数的起始地址(VA)40C224放入了该位置</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240122170724699.png\" alt=\"image-20240122170724699\"></p>\n</li>\n<li><p>目前在回调函数中写入的是 C2 0C 00 00 ，是RETN 0C命令，也就是在TLS回调函数中不执行任何操作</p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>TLS回调函数的返回指令不是RETN, 而是RETN 0C指令，因为函数有3个参数，大小是0C，所以需要修正栈</p>\n</p>\n</div>\n<h3 id=\"编写TLS回调函数\"><a href=\"#编写TLS回调函数\" class=\"headerlink\" title=\"编写TLS回调函数\"></a>编写TLS回调函数</h3><p><img src=\"/../re-engineer-core-principle-06/image-20240123114259260.png\" alt=\"image-20240123114259260\"></p>\n<ul>\n<li>如果reason是1，比较结果是0，不跳转。也就是主线程开始执行的状态下，即第一步</li>\n<li>判断PEB.BeingDebugged，如果处于调试状态，就弹出消息框。</li>\n<li>上面在写汇编的时候，可以直接写CALL user32.MessageBoxA，CALL Kernel32.ExitProcess，因为IAT中有，已经导入了</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>TLS主要用于反调试，因为它可以先于EP代码执行</li>\n</ul>\n<h1 id=\"0x46-TEB\"><a href=\"#0x46-TEB\" class=\"headerlink\" title=\"0x46 TEB\"></a>0x46 TEB</h1><ul>\n<li>TEB：Thread Environment Block，线程环境块</li>\n</ul>\n<h2 id=\"46-1-TEB\"><a href=\"#46-1-TEB\" class=\"headerlink\" title=\"46.1 TEB\"></a>46.1 TEB</h2><ul>\n<li>TEB指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应一个TEB结构体</li>\n</ul>\n<h3 id=\"TEB结构体的定义\"><a href=\"#TEB结构体的定义\" class=\"headerlink\" title=\"TEB结构体的定义\"></a>TEB结构体的定义</h3><p><img src=\"/../re-engineer-core-principle-06/image-20240123175706363.png\" alt=\"image-20240123175706363\"></p>\n<h3 id=\"TEB结构体成员\"><a href=\"#TEB结构体成员\" class=\"headerlink\" title=\"TEB结构体成员\"></a>TEB结构体成员</h3><ul>\n<li>借助Windbg的符号文件，可以查看TEB结构体的所有成员</li>\n<li>win7下的TEB结构体要比Windows XP下的TEB结构体大</li>\n</ul>\n<h3 id=\"重要成员\"><a href=\"#重要成员\" class=\"headerlink\" title=\"重要成员\"></a>重要成员</h3><p><strong>Q：在用户模式中，起重要作用的成员有2个</strong></p>\n<ul>\n<li>offset 30处的ProcessEnvironmentBolck是指向PEB结构体的指针，PEB是进程环境块</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123175843510.png\" alt=\"image-20240123175843510\"></p>\n<ul>\n<li><p>NtTib：Thread information block 它是线程信息块</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123180037947.png\" alt=\"image-20240123180037947\"></p>\n<ul>\n<li>ExceptionList是指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，用于windows os 的SEH</li>\n<li>Self成员是_NT_TIB的自引用指针，也是TEB结构体的指针，也就是TEB结构体可以用它访问自己的第一个成员 _NT_TIB</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"46-2-TEB访问方法\"><a href=\"#46-2-TEB访问方法\" class=\"headerlink\" title=\"46.2 TEB访问方法\"></a>46.2 TEB访问方法</h2><p><strong>Q：如何在用户模式下访问TEB呢？</strong></p>\n<ul>\n<li>之前是用windbg访问的，windbg是个内核调试器</li>\n<li>通过os提供的相关API访问</li>\n</ul>\n<h3 id=\"Ntdll-NtCurrentTeb\"><a href=\"#Ntdll-NtCurrentTeb\" class=\"headerlink\" title=\"Ntdll.NtCurrentTeb()\"></a>Ntdll.NtCurrentTeb()</h3><ul>\n<li><p>在ollydbg 220中打开notepad.exe，选择ntdll，再search for name，找到ntdll!NtCurrentTeb API</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123183728653.png\" alt=\"image-20240123183728653\"></p>\n</li>\n<li><p>这个EAX中的值，000DFFCC就是当前线程的TEB的地址</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123220035069.png\" alt=\"image-20240123220035069\"></p>\n</li>\n<li><p>发现TEB结构体的地址和FS段寄存器的段内存基址(003C3000)是一样的，所以说明TEB和FS段寄存器之间存在某种关联</p>\n</li>\n</ul>\n<h3 id=\"FS段寄存器\"><a href=\"#FS段寄存器\" class=\"headerlink\" title=\"FS段寄存器\"></a>FS段寄存器</h3><p><strong>Q：SDT</strong></p>\n<ul>\n<li><p>FS在第一部分的笔记中有记录，是16bit，存放附加数据段的段基址</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123221222021.png\" alt=\"image-20240123221222021\"></p>\n</li>\n<li><p>其实FS段寄存器用来指示当前线程的TEB结构体</p>\n</li>\n<li><p>IA32中，进程的虚拟内存大小是4GB，因此需要32位的指针，但是段寄存器大小只有16位，那如何表示进程内存空间中的TEB结构体地址呢？</p>\n<ul>\n<li><p>FS段寄存器并不是直接指向TEB，它持有SDT的索引，而SDT持有实际TEB地址</p>\n</li>\n<li><p>也就是SDT里面存储的是32位的地址，SDT是Segment Descriptor Table</p>\n</li>\n<li><p>所以下面这个图，其实是和上面来自于第一部分的这个图是一样的</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123221449344.png\" alt=\"image-20240123221449344\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>SDT位于内核内存区域，其地址存储在特殊的寄存器 GDTR(Global Descriptor Table Resiger，全局描述符表寄存器)中。</p>\n\n</div>\n<p><strong>Q：由于段寄存器实际存储的是SDT的索引，所以也被称为段选择符(Segment Selector)</strong></p>\n<ul>\n<li><p>上图46-3中，TEB结构体位于FS段选择符所指的段内存的起始地址处</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123222347134.png\" alt=\"image-20240123222347134\"></p>\n</li>\n<li><p>这个时候，我们重新看上面这个图，就可以解释为什么TEB的地址，和FS的起始地址是一样的</p>\n<ul>\n<li>因为图46-3告诉我们TEB结构体的起始地址就和FS的起始地址一样</li>\n<li>TEB的_NT_TIB的self指向自身，所以他的值就是段的起始地址</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123220035069.png\" alt=\"image-20240123220035069\"></p>\n</li>\n</ul>\n<p><strong>Q：FS:[0x30] &#x3D; PEB起始地址</strong></p>\n<ul>\n<li>因为FS:[0x30]&#x3D; PEB:[0x30] &#x3D; ProcesssEnvironmentBlock &#x3D; PEB起始地址</li>\n<li>下图是win7中的TEB</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123223747266.png\" alt=\"image-20240123223747266\"></p>\n<p><strong>Q：FS:[0]  &#x3D; SEH起始地址</strong></p>\n<ul>\n<li>FS:[0]  &#x3D; _NT_TIB[0] &#x3D; exceptionlist &#x3D; address of SEH</li>\n<li>SEH是Windows系统中的结构化异常处理机制，常用于反调试技术</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123223918420.png\" alt=\"image-20240123223918420\"></p>\n<h1 id=\"0x47-PEB\"><a href=\"#0x47-PEB\" class=\"headerlink\" title=\"0x47 PEB\"></a>0x47 PEB</h1><h2 id=\"47-1-PEB\"><a href=\"#47-1-PEB\" class=\"headerlink\" title=\"47.1 PEB\"></a>47.1 PEB</h2><ul>\n<li>PEB：process environment block，进程环境块，是存放进程信息的结构体</li>\n</ul>\n<h3 id=\"PEB访问方法\"><a href=\"#PEB访问方法\" class=\"headerlink\" title=\"PEB访问方法\"></a>PEB访问方法</h3><p><strong>Q：获取PEB结构体</strong></p>\n<ul>\n<li><p>上面知道了TEB位于FS的起始地址，PEB位于FS:[30]处</p>\n</li>\n<li><p>所以可以通过下面2种方法获取</p>\n<ul>\n<li><p>MOV  EAX, DWORD PTR FS:[30]</p>\n</li>\n<li><p>先获取TEB，再通过TEB的ProcessEnvironmentBlock</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MOV EAX , DWORD PTR FS:[18] \nMOV EAX, DWORD PTR DS:[EAX + 30] <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>打开notepad.exe，在ep处输入上面的指令，然后f7执行</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123225023129.png\" alt=\"image-20240123225023129\"></p>\n</li>\n</ul>\n<h3 id=\"PEB结构体的定义\"><a href=\"#PEB结构体的定义\" class=\"headerlink\" title=\"PEB结构体的定义\"></a>PEB结构体的定义</h3><p><img src=\"/../re-engineer-core-principle-06/image-20240123225058657.png\" alt=\"image-20240123225058657\"></p>\n<h2 id=\"47-2-PEB的重要成员\"><a href=\"#47-2-PEB的重要成员\" class=\"headerlink\" title=\"47.2 PEB的重要成员\"></a>47.2 PEB的重要成员</h2><p><img src=\"/../re-engineer-core-principle-06/image-20240124104410450.png\" alt=\"image-20240124104410450\"></p>\n<h3 id=\"PEB-BeingDebugged\"><a href=\"#PEB-BeingDebugged\" class=\"headerlink\" title=\"PEB.BeingDebugged\"></a>PEB.BeingDebugged</h3><ul>\n<li><p>kernel32.dll中有个Kernel32!IsDebuggerPresent()  API，判断是不是进程处于调试状态，并返回结果</p>\n</li>\n<li><p>这个API通过PEB.BeingDebugger来确定是否正在调试进程，是返回1，否则返回0</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240123225611807.png\" alt=\"image-20240123225611807\"></p>\n</li>\n<li><p>这个代码就是先获取了TEb的地址，再获取PEB的地址，使用DS:[EAX + 30]的原因是DS的起始地址是0</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124102638333.png\" alt=\"image-20240124102638333\"></p>\n</li>\n<li><p>此时PEB.BeingDebugged的成员的地址为3C80002，值为1，所以是True，正在调试状态</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124102959676.png\" alt=\"image-20240124102959676\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>Windows7中IsDebuggerPresent()API是在Kernelbase.dll中实现的。</p>\n<p>而在WindowsXP及以前版本的操作系统中，它是在 kernel32.dll中实现的</p>\n</p>\n</div>\n<h3 id=\"PEB-ImageBaseAddress\"><a href=\"#PEB-ImageBaseAddress\" class=\"headerlink\" title=\"PEB.ImageBaseAddress\"></a>PEB.ImageBaseAddress</h3><ul>\n<li><p>PEB.ImageBaseAddress用来表示进程的ImageBase</p>\n</li>\n<li><p>GetModuleHandle()  API用来获取ImageBase</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124103323724.png\" alt=\"image-20240124103323724\"></p>\n</li>\n<li><p>向lpModuleName的参数赋值为Null，调用GetModuleHandle() 函数将返回进程被加载的ImageBase</p>\n<ul>\n<li>这个代码就是获取PEB.ImageBaseAddress的地址</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124103418722.png\" alt=\"image-20240124103418722\"></p>\n</li>\n</ul>\n<h3 id=\"PEB-Ldr\"><a href=\"#PEB-Ldr\" class=\"headerlink\" title=\"PEB.Ldr\"></a>PEB.Ldr</h3><ul>\n<li><p>PEB.Ldr指向_PEB_LDR_DATA结构体</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124103513205.png\" alt=\"image-20240124103513205\"></p>\n</li>\n<li><p>当模块（DLL）被加载到进程后，通过PEB.Ldr可以直接获取该模块的加载基地址</p>\n</li>\n<li><p>_PEB_LDR_DATA结构体有3个 _ LIST_ENTRY类型的成员，该结构体定义如下：</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124103711704.png\" alt=\"image-20240124103711704\"></p>\n</li>\n<li><p>它提供了双向链表的机制，链表中保存着哪些信息呢？</p>\n<ul>\n<li><p>保存了_LDR_DATA_TABLE_ENTRY结构体的信息</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124103959146.png\" alt=\"image-20240124103959146\"></p>\n</li>\n<li><p>每个加载到进程中的DLL模块，都有和他对应的LDR_DATA_TABLE_ENTRY结构体，这些结构体相互连接，最终形成_LIST_ENTRY双向链表</p>\n</li>\n</ul>\n</li>\n<li><p>_PEB_LDA_DATA结构体中存在3种链表，也就是存在多个LDR_DATA_TABLE_ENTRY结构体，并且有3种链接方法</p>\n</li>\n</ul>\n<h3 id=\"PEB-ProcessHeadp-PEB-NtGlobalFlag\"><a href=\"#PEB-ProcessHeadp-PEB-NtGlobalFlag\" class=\"headerlink\" title=\"PEB.ProcessHeadp &amp; PEB.NtGlobalFlag\"></a>PEB.ProcessHeadp &amp; PEB.NtGlobalFlag</h3><ul>\n<li>PEB.ProcessHeap与PEBNtGlobalFlag成员(像PEB BeingDebugged成员一样)应用于反调试技术。</li>\n<li>若进程处于调试状态，则ProcessHeap与NtGlobalFlag成员就持有特定值。</li>\n</ul>\n<h1 id=\"0x48-SEH-Structured-Exception-Handler\"><a href=\"#0x48-SEH-Structured-Exception-Handler\" class=\"headerlink\" title=\"0x48 SEH(Structured Exception Handler)\"></a>0x48 SEH(Structured Exception Handler)</h1><ul>\n<li>SEH是Windows os系统默认的异常处理机制。</li>\n<li>在逆向中，也大量用于反调试程序</li>\n</ul>\n<h2 id=\"48-1-SEH\"><a href=\"#48-1-SEH\" class=\"headerlink\" title=\"48.1 SEH\"></a>48.1 SEH</h2><ul>\n<li>SEH是windows操作系统中提供的异常处理机制，在程序代码中使用 _ <em>try 、</em>_ except、__finally关键字来实现</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>SEH与C++中的 try、catch 异常处理具有不同结构，请各位不要混淆。</p>\n<p>从时间上看与C++的 try、catch 异常处理相比, 微软先创建出了SEH机制, 然后才将它搭载到 VC++中。</p>\n<p>所以SEH是一种从属于VC++开发工具和Windows 操作系统的异常处理机制。</p>\n\n</div>\n<h2 id=\"48-2-SEH练习\"><a href=\"#48-2-SEH练习\" class=\"headerlink\" title=\"48.2 SEH练习\"></a>48.2 SEH练习</h2><ul>\n<li>seh.exe故意触发了内存非法访问(Memory Access Violation)异常，然后通过SEH机制处理该异常</li>\n<li>并且使用PEB信息向程序添加简单的反调试代码</li>\n</ul>\n<h3 id=\"正常运行\"><a href=\"#正常运行\" class=\"headerlink\" title=\"正常运行\"></a>正常运行</h3><p><img src=\"/../re-engineer-core-principle-06/image-20240124105621724.png\" alt=\"image-20240124105621724\"></p>\n<h3 id=\"调试运行\"><a href=\"#调试运行\" class=\"headerlink\" title=\"调试运行\"></a>调试运行</h3><ul>\n<li>按f9后发现因为异常暂停运行，程序停在了401019处</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124105615726.png\" alt=\"image-20240124105615726\"></p>\n<ul>\n<li>地址401019处的指令用来触发异常  MOV DWORD PTR DS:[EAX], 1  当前EAX的值为0，所以这个指令的意义是把1写入内存地址0。</li>\n<li>但试图向尚未分配的内存地址0写入某值时，就会触发内存非法访问异常</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>内存地址0虽然属于seh.exe进程的用户内存区域，<strong>但是由于是未分配的空间，所以无法随意访问</strong>。</p>\n<p>查看Ollydbg的内存映射view memory，就可以看到进程中内存地址0被标识为未分配区域</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124110459761.png\" alt=\"image-20240124110459761\"></p>\n<ul>\n<li><strong>我不知道是不是因为这里没有内存地址0，所以是未分配</strong></li>\n</ul>\n</p>\n</div>\n<p><strong>Q：为什么调试进程发生异常时会暂停</strong></p>\n<ul>\n<li>在异常暂停处，我们发现ollydbg提示向内存0写入出现访问异常。可以使用shift run去把异常抛给程序</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124110647955.png\" alt=\"image-20240124110647955\"></p>\n<p><strong>Q：按shift + f9继续运行</strong></p>\n<ul>\n<li>这里发现现在显示的内容和正常是不一样的</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124110821525.png\" alt=\"image-20240124110821525\"></p>\n<ul>\n<li>程序在正常运行和调试运行下使用的异常处理方式是不同的</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>调试运行练习示例时，有时调试器不会像上图 那样暂停，而会一直正常运行</p>\n<p>这是因为设置了 OllyDbg 的选项，或者安装了某个特定插件。遇到这种情况请参考后面“设置OllyDbg选项”的内容。</p>\n\n</div>\n<h2 id=\"48-3-os的异常处理方法\"><a href=\"#48-3-os的异常处理方法\" class=\"headerlink\" title=\"48.3 os的异常处理方法\"></a>48.3 os的异常处理方法</h2><ul>\n<li>同一程序在正常运行和调试运行时行为不同，是因为windows os的异常处理方法不同</li>\n</ul>\n<h3 id=\"正常运行时的异常处理方法\"><a href=\"#正常运行时的异常处理方法\" class=\"headerlink\" title=\"正常运行时的异常处理方法\"></a>正常运行时的异常处理方法</h3><ul>\n<li><p>进程运行中如果发生异常，os会委托进程处理。</p>\n</li>\n<li><p>若进程中存在具体的异常处理，如SEH异常处理器代码，就能顺利处理相关异常。</p>\n</li>\n<li><p>如果相关异常没法处理，os就会启动默认的异常处理机制，终止进程运行</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124111630061.png\" alt=\"image-20240124111630061\"></p>\n</li>\n</ul>\n<h3 id=\"调试运行时的异常处理方法\"><a href=\"#调试运行时的异常处理方法\" class=\"headerlink\" title=\"调试运行时的异常处理方法\"></a>调试运行时的异常处理方法</h3><ul>\n<li><p>参考第4部分的笔记</p>\n</li>\n<li><p>若调试进程内部发生异常，os会把异常抛给调试进程处理。调试器几乎拥有被调试者的所有权限，可以运行、终止被调试者。还拥有被调试进程的虚拟内存、寄存器的读写权限。</p>\n</li>\n<li><p>被调试者内部发生的所有异常都由调试器处理。所以调试过程中发生的所有异常都先交由调试器管理(被调试者的SEH依据优先顺序推给调试器)</p>\n</li>\n<li><p>被调试者发生异常时，调试器就会暂停运行，采用某种措施处理异常，完成后继续调试。</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124112213459.png\" alt=\"image-20240124112213459\"></p>\n</li>\n</ul>\n<p><strong>Q：当被调试进程遇到异常后，调试器的处理方法</strong></p>\n<ul>\n<li><p>直接修改异常：代码、内存、寄存器</p>\n<ul>\n<li>被调试者发生异常时，会暂停在异常处，调试器可以直接修改</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><ul>\n<li>遇到上面的异常时，可以直接修改<ul>\n<li>因为是EAX的地址错误，所以可以把EAX的地址值改成有效的内存地址</li>\n<li>由于401019地址处的代码发生了异常，可以把它改成NOP指令，让程序继续运行</li>\n<li>直接使用ollydbg的new orign here功能<strong>改变程序的运行路径</strong>，因为不能修改EIP寄存器，可以用这种方法<ul>\n<li>这个相当于跳过异常的代码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>​\t\t:::</p>\n<ul>\n<li>将异常抛给被调试者处理<ul>\n<li>如果被调试者内部存在SEH(异常处理函数)，可以处理异常。那就把异常通知发送给被调试者，让他自己处理。这和程序正常运行时的处理方式一样，让进程自己处理。</li>\n<li>上面使用Ollydbg的shift + f9就是把异常抛给被调试者</li>\n</ul>\n</li>\n<li>os的默认异常处理机制<ul>\n<li>如果调试器和被调试者都无法处理当前发生的异常，那么os的默认异常处理机制会处理它，终止被调试的进程，同时结束调试。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"48-4-异常\"><a href=\"#48-4-异常\" class=\"headerlink\" title=\"48.4 异常\"></a>48.4 异常</h2><ul>\n<li>下面是windows os中定义的异常</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124113513047.png\" alt=\"image-20240124113513047\"></p>\n<h3 id=\"EXCEPITON-ACCESS-VIOLATION-C0000005\"><a href=\"#EXCEPITON-ACCESS-VIOLATION-C0000005\" class=\"headerlink\" title=\"EXCEPITON_ACCESS_VIOLATION(C0000005)\"></a>EXCEPITON_ACCESS_VIOLATION(C0000005)</h3><ul>\n<li><p>试图访问不存在或无访问权限的内存区域时，就会发生这个异常</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124113618150.png\" alt=\"image-20240124113618150\"></p>\n</li>\n</ul>\n<h3 id=\"EXCEPTION-BREAKPOINT\"><a href=\"#EXCEPTION-BREAKPOINT\" class=\"headerlink\" title=\"EXCEPTION_BREAKPOINT\"></a>EXCEPTION_BREAKPOINT</h3><ul>\n<li>在运行代码中设置断点后，CPU尝试执行断点地址处的指令后，就会发生EXCEPTION_BREAKPOINT异常。</li>\n<li>调试器是利用异常来实现断点功能的</li>\n</ul>\n<p><strong>Q：INT3</strong></p>\n<ul>\n<li><p>设置断点的汇编指令为INT3，对应的IA-32指令是0xCC</p>\n</li>\n<li><p>CPU运行过程中，执行到0xCC，就会暂停运行。</p>\n</li>\n<li><p>在Ollydbg设置断点，看是不是真的会变成0xCC</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124114438889.png\" alt=\"image-20240124114438889\"></p>\n</li>\n<li><p>这里发现其实并没有变成CC。这是因为ollydbg中，f2设置的断点是临时断点(User Temporary Break Point)，所以不需要在调试画面中显示。如果显示了，会降低代码的可读性，实际上，在进程的内存中，这里已经把68改成CC了。</p>\n</li>\n<li><p>将进程内存转储后，使用hxd可以看到更改后的0xcc</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124115355159.png\" alt=\"image-20240124115355159\"></p>\n</li>\n<li><p>以上就是断点异常的工作原理，为程序调试带来很大的遍历。我们可以用hxd打开PE文件，修改EP地址对应的文件偏移处的第一个字节为CC，然后运行PE文件时，就会发生EXCEPTION_BREAKPOINT异常，经过os的默认处理机制，就会让它停止运行。如果在系统注册表中将默认调试器设置为Ollydbg，那么发生 这个异常时，就会启动Ollydbg调试器，attach刚才发生异常的进程，交由调试器处理。</p>\n</li>\n</ul>\n<p><strong>Q：关于内存转储，第三部分的笔记</strong></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124115428262.png\" alt=\"image-20240124115428262\"></p>\n<h3 id=\"EXCEPTION-ILLEGAL-INSTRUCTION-C000001D\"><a href=\"#EXCEPTION-ILLEGAL-INSTRUCTION-C000001D\" class=\"headerlink\" title=\"EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)\"></a>EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)</h3><ul>\n<li>CPU遇到无法解析的指令时，会引发这个异常。比如0FFF在x86中未定义，CPU遇到这个指令就会触发EXCEPTION_ILLEGAL_INSTRUCTION</li>\n</ul>\n<h3 id=\"EXCEPTION-INT-DIVIDE-BY-ZERO-C0000094\"><a href=\"#EXCEPTION-INT-DIVIDE-BY-ZERO-C0000094\" class=\"headerlink\" title=\"EXCEPTION_INT_DIVIDE_BY_ZERO(C0000094)\"></a>EXCEPTION_INT_DIVIDE_BY_ZERO(C0000094)</h3><ul>\n<li>INTEGER(整数)除法运算中，若分母为0，就会引发EXCEPTION_INT_DIVIDE_BY_ZERO。</li>\n<li>编写应用程序时偶尔会发生该异常，分母为变量时，分母瞬间变为0，就会触发这个异常。</li>\n</ul>\n<h3 id=\"EXCEPTION-SINGLE-STEP-80000004\"><a href=\"#EXCEPTION-SINGLE-STEP-80000004\" class=\"headerlink\" title=\"EXCEPTION_SINGLE_STEP(80000004)\"></a>EXCEPTION_SINGLE_STEP(80000004)</h3><ul>\n<li>Single Step的含义是执行一条指令，然后暂停</li>\n<li>CPU进入单步模式后，每执行一条指令，都会引发EXCEPTION_SINGLE_STEP异常，暂停运行。</li>\n<li>将EFLAGS寄存器的TF(Trap Flag)位设置为1后，CPU就会进入单步工作模式</li>\n</ul>\n<h2 id=\"48-5-SEH详细说明\"><a href=\"#48-5-SEH详细说明\" class=\"headerlink\" title=\"48.5 SEH详细说明\"></a>48.5 SEH详细说明</h2><h3 id=\"SEH链\"><a href=\"#SEH链\" class=\"headerlink\" title=\"SEH链\"></a>SEH链</h3><ul>\n<li><p>SEH以链的形式存在，第一个异常处理器如果未处理相关异常，就会被传递到下一个异常处理器，直到处理</p>\n</li>\n<li><p>SEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124155053377.png\" alt=\"image-20240124155053377\"></p>\n</li>\n<li><p>Next成员是指向下一个_EXCEPTION_REGISTRATION_RECORD结构体的指针，Handler成员是异常处理函数。若Next的值是FFFFFFFF，则表示它是链表的最后一个节点</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124155140044.png\" alt=\"image-20240124155140044\"></p>\n</li>\n</ul>\n<h3 id=\"异常处理函数的定义\"><a href=\"#异常处理函数的定义\" class=\"headerlink\" title=\"异常处理函数的定义\"></a>异常处理函数的定义</h3><ul>\n<li>也就是Handler的定义</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124155253229.png\" alt=\"image-20240124155253229\"></p>\n<ul>\n<li><p>这个函数接收4个输入，返回名为<strong>EXCEPTION_DISPOSITION</strong>的枚举类型</p>\n</li>\n<li><p>这个异常处理函数由系统调用，是一个回调函数。系统调用时，会给出函数中的4个参数，这4个参数中保存着异常相关的信息</p>\n</li>\n<li><p>第一个参数指向EXCEPTION_RECORD的指针</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124155714042.png\" alt=\"image-20240124155714042\"></p>\n<ul>\n<li>这个结构体中ExceptionCode用来指出异常类型</li>\n<li>ExceptionAddress用来表示发生异常的代码地址</li>\n</ul>\n</li>\n<li><p>第三个参数是指向CONTEXT结构体的指针</p>\n<ul>\n<li>CONTEXT结构体用来保存CPU寄存器的值，在多线程的环境下，每个线程内部都有一个CONTEXT结构体</li>\n<li>当CPU暂时离开当前线程去执行其他线程时，CPU寄存器的值就会保存到当前线程的CONTEXT结构体。</li>\n<li>CPU再次运行该线程时，就会用保存在CONTEXT结构体的值覆盖CPU寄存器的值，然后从暂停的代码处继续运行</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124155816190.png\" alt=\"image-20240124155816190\"></p>\n</li>\n</ul>\n<p>:::tip</p>\n<p>多线程的实现基于 CPU的时间片切分机制(Time-Slicing)。</p>\n<p>这种机制下，CPU 会用一定时间 (时间片) 依次运行各线程，时间片极短，使多个线程看上去就像在同时运行一样(根据线程的优先级,各线程在获取CPU控制权的次数上有差异)。</p>\n</p>\n</div>\n<p><strong>Q：在发生异常的时候，是怎么个流程呢？</strong></p>\n<ul>\n<li><p>执行异常代码的线程就会终止运行，转而运行SEH（异常处理函数）</p>\n</li>\n<li><p>os会把线程中的CONTEXT结构体传递给异常处理函数，CONTEXT结构体在偏移为B9处的参数是Eip。</p>\n</li>\n<li><p>在异常处理函数中，把eip设置成其他地址，函数返回。</p>\n</li>\n<li><p>此时之前暂停的线程就会执行新的EIP地址处的代码</p>\n</li>\n<li><p>下面是异常处理函数的返回值，是EXCEPTION_DISPOSITION</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124160600588.png\" alt=\"image-20240124160600588\"></p>\n<ul>\n<li>如果返回0，就继续执行异常代码。如果返回1，表示当前的异常处理器无法处理，就运行下一个异常处理器处理。</li>\n</ul>\n<h3 id=\"TEB-NtTib-ExceptionList\"><a href=\"#TEB-NtTib-ExceptionList\" class=\"headerlink\" title=\"TEB.NtTib.ExceptionList\"></a>TEB.NtTib.ExceptionList</h3><ul>\n<li><p>在46.1中，我们学过_NT_TIB的第一个成员就是ExceptionList，它是指向_EXCEPTION_REGISTRATION_RECORD结构体的指针，也就是指向SEH链的指针</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124160928859.png\" alt=\"image-20240124160928859\"></p>\n</li>\n<li><p>它的地址是FS:[0]</p>\n</li>\n</ul>\n<h3 id=\"SEH安装方法\"><a href=\"#SEH安装方法\" class=\"headerlink\" title=\"SEH安装方法\"></a>SEH安装方法</h3><ul>\n<li><p>在c中使用 __ try、__ except、__finally就可以向代码中添加SEH</p>\n</li>\n<li><p>汇编中添加SEH的方法是</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124161343333.png\" alt=\"image-20240124161343333\"></p>\n</li>\n<li><p>在程序中安装SEH，就是把自身的异常处理器添加到已有的SEH链中</p>\n</li>\n<li><p>&#x3D;&#x3D;所以上面就是？？？&#x3D;&#x3D;</p>\n</li>\n</ul>\n<h2 id=\"48-6-练习-seh-exe\"><a href=\"#48-6-练习-seh-exe\" class=\"headerlink\" title=\"48.6 练习 seh.exe\"></a>48.6 练习 seh.exe</h2><p><strong>Q：首先运行程序到401000main函数处，接下来的3条指令和代码48-8是一样的</strong></p>\n<ul>\n<li><p>首先push ep</p>\n</li>\n<li><p>接着push FS:[0]，就是exceptionList，这里会在栈中创建_EXCEPTION_REGISTRATION_RECORD结构体</p>\n<ul>\n<li><p>这里知道它的地址是19FF64，在栈中可以看到它的next指针指向的地址是19FFCC，handler异常处理函数的地址是00402730</p>\n</li>\n<li><p>&#x3D;&#x3D;为什么可以在栈中看呢？？&#x3D;&#x3D;</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124163914387.png\" alt=\"image-20240124163914387\"></p>\n</li>\n</ul>\n</li>\n<li><p>找SEH链，当到19FFE4处时，它的next指针是FFFFFFFFF，表明SEH链到了结尾</p>\n</li>\n<li><p>这个异常处理函数在77D992CD，位于ntdll.dll区，是os的默认异常处理器</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124164927448.png\" alt=\"image-20240124164927448\"></p>\n</li>\n<li><p>创建进程时，os自动产生默认的SEH</p>\n</li>\n</ul>\n<h3 id=\"添加SEH\"><a href=\"#添加SEH\" class=\"headerlink\" title=\"添加SEH\"></a>添加SEH</h3><p><strong>Q：在运行完40100C处的指令后，发现生成了新的注释</strong></p>\n<ul>\n<li>next &#x3D; 19FF65，Handler &#x3D; 40105A</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124165242867.png\" alt=\"image-20240124165242867\"></p>\n<ul>\n<li><p>此时发现FS:[0]处也改成了新添加的SEH的地址，说明是往头节点插入的新节点</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124165622332.png\" alt=\"image-20240124165622332\"></p>\n</li>\n<li><p>用一个更形象的图说明上述过程</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">PUSH handler\nPUSH DWORD PTR FS:[0]\nMOV DWORD PTR FS:[0] ESP<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>19FF64是原来的ExceptionList的头节点</li>\n<li>现在向头节点插入了一个新的seh。</li>\n<li>所以头节点指向现在的，现在的指向原来的</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240127115809602.png\" alt=\"image-20240127115809602\"></p>\n</li>\n</ul>\n<p><strong>Q：OllyDbg调试器提供了查看SEH链的功能</strong></p>\n<ul>\n<li><p>View - SEH CHAIN</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124165741222.png\" alt=\"image-20240124165741222\"></p>\n</li>\n</ul>\n<h3 id=\"发生异常\"><a href=\"#发生异常\" class=\"headerlink\" title=\"发生异常\"></a>发生异常</h3><ul>\n<li>运行到401019处，会发生EXCEPTION_ACCESS_VIOLATION异常</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124165916750.png\" alt=\"image-20240124165916750\"></p>\n<ul>\n<li><p>因为处在调试中，所以异常会由调试器处理</p>\n</li>\n<li><p>在40105A处设置断点，按shift + f9，把异常抛给被调试者处理</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124170055144.png\" alt=\"image-20240124170055144\"></p>\n</li>\n<li><p>被调试者就会调用自身的SEH链处理</p>\n</li>\n</ul>\n<h3 id=\"查看异常处理器参数\"><a href=\"#查看异常处理器参数\" class=\"headerlink\" title=\"查看异常处理器参数\"></a>查看异常处理器参数</h3><p><strong>Q：现在程序在40105A地址处</strong></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124170515329.png\" alt=\"image-20240124170515329\"></p>\n<ul>\n<li><p>可以理解成现在在异常处理函数中，此时栈中的参数含义是：</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124170338160.png\" alt=\"image-20240124170338160\"></p>\n<ul>\n<li><p>第一个参数是pRecord，所以ExceptionCode的地址是00000005，ExceptionAddress是00401019</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124170844965.png\" alt=\"image-20240124170844965\"></p>\n</li>\n<li><p>第二个参数是指向EXCEPTION_REGISTRATION_RECORD结构体的指针pframe，它的值是12FF28，也就是上面我添加的SEH的地址</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124171130201.png\" alt=\"image-20240124171130201\"></p>\n</li>\n<li><p>第三个参数是pContext，指向CONTEXT的指针，这个偏移B8处的是EIP的地址</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124171245774.png\" alt=\"image-20240124171245774\"></p>\n</li>\n<li><p>最后一个参数供系统内部使用，可以忽略</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"调试异常处理器\"><a href=\"#调试异常处理器\" class=\"headerlink\" title=\"调试异常处理器\"></a>调试异常处理器</h3><ul>\n<li>40105A地址处的异常处理器，存在着调试器检测代码，也就是反调试代码</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124172410693.png\" alt=\"image-20240124172410693\"></p>\n<ul>\n<li><p>这里的EAX是PEB，EAX + 2是BeingDebuged，如果他是1，说明正在调试</p>\n</li>\n<li><p>接着会把401023给eip。也就是表明在异常处理函数结束之后，会执行401023处的代码。</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124172641788.png\" alt=\"image-20240124172641788\"></p>\n</li>\n<li><p>401023处的字符串是Debugger detected，也就是弹出消息框。在401023处设置一个断点。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124172754041.png\" alt=\"image-20240124172754041\"></p>\n<ul>\n<li><p>接着EAX &#x3D; 0，程序退出。返回值是0代表EXCEPTION_CONTINUE_EXECUTION，表示异常得到处理。相关线程可以继续运行</p>\n</li>\n<li><p>在return之后，控制权返回至ntdll.dll模块中的代码区域，它属于系统区域。</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124173256716.png\" alt=\"image-20240124173256716\"></p>\n</li>\n<li><p>f9继续运行，会运行到401023处</p>\n</li>\n<li><p>再继续运行，就会弹出消息框，接着程序会跳转到删除SEH的代码处。</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124173412030.png\" alt=\"image-20240124173412030\"></p>\n</li>\n</ul>\n<h3 id=\"删除SEH\"><a href=\"#删除SEH\" class=\"headerlink\" title=\"删除SEH\"></a>删除SEH</h3><ul>\n<li>此时的栈中是我上面新添加的SEH</li>\n<li>POP DWORD PTR FS:[0]指令，会读取栈值19FF28，并放入FS:[0]。并从栈中pop掉这个值<ul>\n<li>也就是把当前SEH的next给FS:[0]</li>\n</ul>\n</li>\n<li>之后 ADD ESP 4，把异常处理函数也删除</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124173630321.png\" alt=\"image-20240124173630321\"></p>\n<h2 id=\"48-7-设置Ollydbg选项\"><a href=\"#48-7-设置Ollydbg选项\" class=\"headerlink\" title=\"48.7 设置Ollydbg选项\"></a>48.7 设置Ollydbg选项</h2><p><strong>Q：在上面的原理作用下，程序正常运行和调试运行下的代码不一样，有没有更方便的调试方法？</strong></p>\n<ul>\n<li><p>Ollydbg提供了调试选项，调试中的程序发生异常时，调试器不会暂停，会自动将异常派送给被调试者</p>\n</li>\n<li><p>在Ollydbg菜单栏中选择Options - Debugging options，打开Exceptions选项卡</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124174234141.png\" alt=\"image-20240124174234141\"></p>\n</li>\n</ul>\n<h3 id=\"忽略kernel32中发生的内存非法访问异常\"><a href=\"#忽略kernel32中发生的内存非法访问异常\" class=\"headerlink\" title=\"忽略kernel32中发生的内存非法访问异常\"></a>忽略kernel32中发生的内存非法访问异常</h3><ul>\n<li>默认是选中的</li>\n</ul>\n<h3 id=\"向被调试者派送异常\"><a href=\"#向被调试者派送异常\" class=\"headerlink\" title=\"向被调试者派送异常\"></a>向被调试者派送异常</h3><ul>\n<li>前5个前面都已经介绍过了</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124174353535.png\" alt=\"image-20240124174353535\"></p>\n<ul>\n<li>第6个是ALL FPU exceptions。FPU是Floating Point Unit浮点运算单元，是专门用于浮点数运算的处理器。他有一套专用指令，和普通x86的形态结构不同。</li>\n<li>选上之后，处理FPU指令过程发生异常时，会把异常让被调试者处理。</li>\n</ul>\n<h3 id=\"其他异常处理\"><a href=\"#其他异常处理\" class=\"headerlink\" title=\"其他异常处理\"></a>其他异常处理</h3><ul>\n<li>这个就是可以自定义异常</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124174612846.png\" alt=\"image-20240124174612846\"></p>\n<h3 id=\"简单练习\"><a href=\"#简单练习\" class=\"headerlink\" title=\"简单练习\"></a>简单练习</h3><ul>\n<li><p>还是seh.exe，如果勾选了上面的所  有，直接就会显示下面的内容。</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240124174757749.png\" alt=\"image-20240124174757749\"></p>\n</li>\n<li><p>程序通过SEH，检测是否程序处在调试状态，从而弹出和正常不一样的框</p>\n</li>\n</ul>\n<h1 id=\"0x49-IA-32指令\"><a href=\"#0x49-IA-32指令\" class=\"headerlink\" title=\"0x49 IA-32指令\"></a>0x49 IA-32指令</h1><h2 id=\"49-1-IA-32指令\"><a href=\"#49-1-IA-32指令\" class=\"headerlink\" title=\"49.1 IA-32指令\"></a>49.1 IA-32指令</h2><ul>\n<li><p>指令是指CPU能识别的机器语言，machine language</p>\n</li>\n<li><p>IA-32指令是指IA-32(Intel Architecture 32位)系列CPU使用的指令</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125095733810.png\" alt=\"image-20240125095733810\"></p>\n</li>\n<li><p>红框中的每一条都是指令，E8 CC270000这种就是IA-32指令</p>\n</li>\n<li><p>程序员通过java、python等编写程序，cpu使用机器语言。所以编写的程序通过编译、链接最后转换为CPU可以识别的语言</p>\n<ul>\n<li>也就是我之前在program analysis中学习的那个过程</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"49-2-常用术语\"><a href=\"#49-2-常用术语\" class=\"headerlink\" title=\"49.2 常用术语\"></a>49.2 常用术语</h2><p><img src=\"/../re-engineer-core-principle-06/image-20240125100017313.png\" alt=\"image-20240125100017313\"></p>\n<ul>\n<li>使用C&#x2F;C++创建出PE文件后，源代码就转换成了机器码</li>\n<li>机器码是由 0 1构成的，我们很难读懂它。所以一般把机器码转换成16进制代码。</li>\n<li>再通过调试器内嵌的反汇编器把机器码转换成反汇编代码</li>\n</ul>\n<h3 id=\"反汇编器\"><a href=\"#反汇编器\" class=\"headerlink\" title=\"反汇编器\"></a>反汇编器</h3><ul>\n<li>Ollydbg内嵌有IA-32的反汇编器</li>\n<li>A区域是16进制的IA-32指令，B区域是对应的反汇编代码，C区域是它在内存中的状态</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125100319086.png\" alt=\"image-20240125100319086\"></p>\n<ul>\n<li>反汇编代码由助记符 (Mnemonic)+ 操作数(Operand)构成。PUSH 40B384中的PUSH就是助记符，40B384就是操作数</li>\n<li>内嵌在调试器中的反汇编器会把C区的大段的机器码切分成A区中 的一条条的指令，再把A区中的指令反汇编成B区的反汇编代码。</li>\n</ul>\n<h3 id=\"反编译器\"><a href=\"#反编译器\" class=\"headerlink\" title=\"反编译器\"></a>反编译器</h3><ul>\n<li>反汇编器：把机器码转成反汇编代码</li>\n<li>反编译器：把机器码转成类似于源代码的代码</li>\n</ul>\n<h2 id=\"49-3-IA-32指令格式\"><a href=\"#49-3-IA-32指令格式\" class=\"headerlink\" title=\"49.3 IA-32指令格式\"></a>49.3 IA-32指令格式</h2><ul>\n<li>IA-32由6部分组成，其中操作码是必须的</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125101527188.png\" alt=\"image-20240125101527188\"></p>\n<h3 id=\"指令前缀-Instruction-Prefixes\"><a href=\"#指令前缀-Instruction-Prefixes\" class=\"headerlink\" title=\"指令前缀 Instruction Prefixes\"></a>指令前缀 Instruction Prefixes</h3><ul>\n<li>它是可选的</li>\n<li>前缀项大小为1bytes</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125101950249.png\" alt=\"image-20240125101950249\"></p>\n<h3 id=\"操作码-Operation-Code\"><a href=\"#操作码-Operation-Code\" class=\"headerlink\" title=\"操作码 Operation Code\"></a>操作码 Operation Code</h3><ul>\n<li><p>它用来表示实际的指令</p>\n</li>\n<li><p>长度为1 - 3 bytes，常见的大多数都是1byte。</p>\n</li>\n<li><p>操作码通常都带有操作数(operand)，操作数种类有寄存器、内存地址、常量</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125103441296.png\" alt=\"image-20240125103441296\"></p>\n</li>\n<li><p>操作码种类很多，解析时需要查看Intel用户手册的操作码映射</p>\n</li>\n</ul>\n<h3 id=\"ModR-M\"><a href=\"#ModR-M\" class=\"headerlink\" title=\"ModR&#x2F;M\"></a>ModR&#x2F;M</h3><ul>\n<li><p>ModR&#x2F;M是个可选项，用来辅助说明操作码的操作数(操作数的个数、种类[寄存器、地址、常量])</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125103804531.png\" alt=\"image-20240125103804531\"></p>\n</li>\n<li><p>ModR&#x2F;M项拥有1个字节(8位)长度，分为3部分。各部分含义如下：</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125103840342.png\" alt=\"image-20240125103840342\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125104326075.png\" alt=\"image-20240125104326075\"></p>\n</li>\n</ul>\n<h3 id=\"SIB-Scale-Index-Base\"><a href=\"#SIB-Scale-Index-Base\" class=\"headerlink\" title=\"SIB Scale-Index-Base\"></a>SIB Scale-Index-Base</h3><ul>\n<li><p>也是一个可选项，用来辅助说明ModR&#x2F;M</p>\n</li>\n<li><p>操作码的操作数为内存地址时，需要和ModR&#x2F;M项一起用</p>\n</li>\n<li><p>SIB也拥有1个字节的长度，分成3部分</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125104301171.png\" alt=\"image-20240125104301171\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125104311196.png\" alt=\"image-20240125104311196\"></p>\n</li>\n</ul>\n<h3 id=\"位移-Displacement\"><a href=\"#位移-Displacement\" class=\"headerlink\" title=\"位移 Displacement\"></a>位移 Displacement</h3><ul>\n<li><p>也是可选项</p>\n</li>\n<li><p>操作码的操作数为内存地址时，用来表示位移操作</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125104408583.png\" alt=\"image-20240125104408583\"></p>\n</li>\n<li><p>位移的长度是 1  2  4字节</p>\n</li>\n</ul>\n<h3 id=\"立即数\"><a href=\"#立即数\" class=\"headerlink\" title=\"立即数\"></a>立即数</h3><ul>\n<li><p>立即数也是个可选项，操作码的操作数为常量时，这个常量就称为立即数</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125104501490.png\" alt=\"image-20240125104501490\"></p>\n</li>\n<li><p>立即数的长度是1 2 4字节</p>\n</li>\n</ul>\n<h2 id=\"49-4-打印iA-32指令\"><a href=\"#49-4-打印iA-32指令\" class=\"headerlink\" title=\"49.4 打印iA-32指令\"></a>49.4 打印iA-32指令</h2><ul>\n<li><p>打印intel IA-32指令</p>\n<p><a href=\"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html\">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125110948095.png\" alt=\"image-20240125110948095\"></p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125110957390.png\" alt=\"image-20240125110957390\"></p>\n<h3 id=\"要打印的截图\"><a href=\"#要打印的截图\" class=\"headerlink\" title=\"要打印的截图\"></a>要打印的截图</h3><ul>\n<li>这个Table A-1是用来说明Table A-2中的上标的</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125112712002.png\" alt=\"image-20240125112712002\"></p>\n<ul>\n<li>Table A-2是一字节的操作码</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125112802231.png\" alt=\"image-20240125112802231\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125112813446.png\" alt=\"image-20240125112813446\"></p>\n<ul>\n<li><p>Table A-3</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125162914437.png\" alt=\"image-20240125162914437\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125162924123.png\" alt=\"image-20240125162924123\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125162932651.png\" alt=\"image-20240125162932651\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125162947226.png\" alt=\"image-20240125162947226\"></p>\n</li>\n<li><p>寻址方法，code for addressing method</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125113935005.png\" alt=\"image-20240125113935005\"></p>\n<ul>\n<li>操作数类型</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125114005393.png\" alt=\"image-20240125114005393\"></p>\n<p>- </p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125115558737.png\" alt=\"image-20240125115558737\"></p>\n<ul>\n<li>Table A-6</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125155633673.png\" alt=\"image-20240125155633673\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125155651239.png\" alt=\"image-20240125155651239\"></p>\n<h2 id=\"49-5-指令解析练习\"><a href=\"#49-5-指令解析练习\" class=\"headerlink\" title=\"49.5 指令解析练习\"></a>49.5 指令解析练习</h2><h3 id=\"操作码映射\"><a href=\"#操作码映射\" class=\"headerlink\" title=\"操作码映射\"></a>操作码映射</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">41 INC ECX<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>把这个41拆开变成，4 代表行，1代表列。在Table A-2中查</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125113054959.png\" alt=\"image-20240125113054959\"></p>\n</li>\n<li><p>解析成 INC ECX。</p>\n<ul>\n<li>根据Table A 2-1，i64表示不在75位中用，o64表示只在64位中用。所以操作码选择INC，操作数选择32位中的ECX。要是在64位中就选REX.B</li>\n</ul>\n</li>\n<li><p>对应的IA-32指令格式是</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125114634934.png\" alt=\"image-20240125114634934\"></p>\n</li>\n</ul>\n<h3 id=\"操作数\"><a href=\"#操作数\" class=\"headerlink\" title=\"操作数\"></a>操作数</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">68 A0B44000 PUSH 0040B4A0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125113614528.png\" alt=\"image-20240125113614528\"></p>\n<ul>\n<li><p>解析成 PUSH Iz</p>\n</li>\n<li><p>Iz表示操作数的类型，大写字母 I 指寻址方法(Addressing Method)，小写字母z 指操作数类型(Operand Type)</p>\n</li>\n<li><p>查看A 2.1，I表示立即数，再查看 A2.2，找到操作数类型，在32位系统下，是double world，也就是4 bytes</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125114133738.png\" alt=\"image-20240125114133738\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125114244161.png\" alt=\"image-20240125114244161\"></p>\n</li>\n<li><p>所以操作码 68对应的指令就是push 4个字节的立即数，所以继续读取68之后的四个字节</p>\n</li>\n<li><p>对应的IA-32指令格式如下</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125114611907.png\" alt=\"image-20240125114611907\"></p>\n</li>\n</ul>\n<h3 id=\"ModR-M-1\"><a href=\"#ModR-M-1\" class=\"headerlink\" title=\"ModR&#x2F;M\"></a>ModR&#x2F;M</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">89C1 MOV ECX,EAX<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>首先解析89，在table A-2中查找到是 MOV Ev,Gv</p>\n</li>\n<li><p>接着查找操作数类型v表示4字节</p>\n</li>\n<li><p>查找寻址方法E G。首先 E G 都和ModR&#x2F;M有关。E表示寄存器或者内存地址形式的操作数。G表示寄存器形式的操作数。</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125115449317.png\" alt=\"image-20240125115449317\"></p>\n</li>\n<li><p>所以查看操作码后面的一个字节C1，即是ModR&#x2F;M选项。、</p>\n</li>\n<li><p>C1的解析形式如下</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125120835898.png\" alt=\"image-20240125120835898\"></p>\n</li>\n<li><p>接下来我们就查表</p>\n<ul>\n<li>E和G表示寻址方法，分别出现在下图的E区和G区。小写字母v表示操作数类型，上面查表得到是dword，是32位。<ul>\n<li>E中既有内存地址也有寄存器。ModR&#x2F;M值从00 到BF对应的都是E区中的内存地址，从C0到FF对应的都是寄存器</li>\n<li>而G区只有寄存器，ModR&#x2F;M的REG从000到111</li>\n</ul>\n</li>\n<li>在下表中找到C1，它对应的32位在E区是ECX，在G区对应的是EAX</li>\n<li>在下表中可以找到C1二进制形式中每一部分对应的值，它可以唯一确定C1。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125120824827.png\" alt=\"image-20240125120824827\"></p>\n</li>\n<li><p>所以最终指令解析为，MOV ECX,EAX</p>\n</li>\n<li><p>用IA-32指令格式表示如下</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125121338182.png\" alt=\"image-20240125121338182\"></p>\n</li>\n</ul>\n<h3 id=\"Group\"><a href=\"#Group\" class=\"headerlink\" title=\"Group\"></a>Group</h3><ul>\n<li>Group 指令把操作码和ModR&#x2F;M组合起来，让操作码最多可以表示8种形式的映射</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">83C3 12 ADD EBX,12<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>操作码83对应的是Grp1 Ev,Ib。由前面知道，Ev表示4个字节的寄存器，Ib代表1字节的立即数</li>\n<li>紧跟在83后面的C3是ModR&#x2F;M，查找group表 Table A-6</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125160043421.png\" alt=\"image-20240125160043421\"></p>\n<ul>\n<li>因为操作码是 83，Grp1，且ModR&#x2F;M的第3 4 5bit是000。所以就是ADD</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125160247558.png\" alt=\"image-20240125160247558\"></p>\n<ul>\n<li><p>现在就解析成了ADD Ev,Ib</p>\n</li>\n<li><p>接着查ModR&#x2F;M表，确定Ev，因为v是4bytes，所以确定是EBX</p>\n</li>\n<li><p>现在变成了 ADD EBX,Ib，Ib就读取后面1个字节的立即数</p>\n</li>\n<li><p>所以最终就变成了 ADD EBX,12</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125160711027.png\" alt=\"image-20240125160711027\"></p>\n</li>\n</ul>\n<h3 id=\"前缀-Prefix\"><a href=\"#前缀-Prefix\" class=\"headerlink\" title=\"前缀 Prefix\"></a>前缀 Prefix</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">66:81FE 3412 CMP SI,1234<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>对于前缀指令，竟然也查Table A-2，就是one byte 操作码的表</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125161103779.png\" alt=\"image-20240125161103779\"></p>\n</li>\n<li><p>66表示操作数大小的前缀。更确切的说是Operand-Size Override Prefix。Prefix: 66意思是把32位大小的操作数识别为16位，或者把16位大小的操作数识别为32位</p>\n</li>\n<li><p>81是操作码，表示 Grp1 Ev,lz，且是16byte的</p>\n</li>\n<li><p>综上，就变成了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">66:81FE 3412 Grp1 Ev,lz  operand Size &#x3D; 16 bit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>81后面紧跟的FE，拆开</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125161559206.png\" alt=\"image-20240125161559206\"></p>\n</li>\n<li><p>所以Grp1就表示成CMP，查表可知</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">66:81FE 3412 CMP Ev,lz operand Size &#x3D; 16 bit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>对于Ev，就还是查表，因为是16bit。所以对应的就是SI</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125161816557.png\" alt=\"image-20240125161816557\"></p>\n</li>\n<li><p>记者对于lz，就是读取16bit的立即数，也就是2个字节</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">6681FE  CMP SI,1234<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125162008510.png\" alt=\"image-20240125162008510\"></p>\n<h3 id=\"双字节操作码\"><a href=\"#双字节操作码\" class=\"headerlink\" title=\"双字节操作码\"></a>双字节操作码</h3><ul>\n<li>单字节操作码不够用时，扩展为双字节操作码。</li>\n<li>双字节操作码中第一个字节恒为0F，所以和单字节操作码的映射方式是一样的</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0F85 FA1F0000 JNZ XXXXXXXX<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>首先找到0F，表示是2-byte的Escape符号。继续在Table A-3中找85</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125162800575.png\" alt=\"image-20240125162800575\"></p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240125163010283.png\" alt=\"image-20240125163010283\"></p>\n</li>\n<li><p>可以看到它就是JNE&#x2F;JNZ</p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>Jcc为Conditional Jump(条件跳转)指令一般。这种条件跳转指令之前都有比较语句(CMP、TEST)，并根据比较的结果决定是否跳转。</p>\n<p>Jcc 指令有多种形式，示例中的0F85被解析为JNE(Jump Not Equal)或 JNZ(Jump Not Zero)指令。(两条指令含义相同)。</p>\n<p>Jcc指令(0F80~0F8F)的操作数在Table A-3 中显示为“Long-displacement”操作数。<strong>一般Long表示4个字节(32位)，Short表示1个字节(8位)。</strong>所以Jcc指令的操作数为4字节大小的Displacement(移位值)。</p>\n\n</div>\n<ul>\n<li><p>因为JNE指令的操作数是4 bytes大小的移位值，所以继续读取操作码后面的4 bytes，整条指令就是</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0F85 FA1F0000 JNE 00001FFA<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240126132836845.png\" alt=\"image-20240126132836845\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>这里的00001FFA是相对位移，要计算它的实际地址。</p>\n<p>假设当前的eip是401000，这条指令的长度是6bytes。所以跳转的实际地址是 401000 + 6 + 1FFA &#x3D; 403000</p>\n</p>\n</div>\n<h3 id=\"移位值-立即数\"><a href=\"#移位值-立即数\" class=\"headerlink\" title=\"移位值 &amp; 立即数\"></a>移位值 &amp; 立即数</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">C705 00CF4000 01000100 MOV DWORD PTR DS:[40CF00]，10001<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>首先查找C7，发现是Grp 11 Ev,Iz</p>\n<p><img src=\"/../re-engineer-core-principle-06/image-20240126133902198.png\" alt=\"image-20240126133902198\"></p>\n</li>\n</ul>\n<h2 id=\"这部分剩余的内容等需要了再看\"><a href=\"#这部分剩余的内容等需要了再看\" class=\"headerlink\" title=\"这部分剩余的内容等需要了再看\"></a>这部分剩余的内容等需要了再看</h2>","feature":true,"text":"引言 快看完了，加油冲冲冲！希望回家前看完 0x45 TLS回调函数 TLS(Thread Local Storage 线程局部存储)回调函数(Callback function)常用于反调试。 TLS回调函数的运行要先于EP代码的执行，因此它可以作为一种反调试技术使用 45.1...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x45-TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">0x45 TLS回调函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-1-HelloTls-exe\"><span class=\"toc-text\">45.1 HelloTls.exe</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-2-TLS\"><span class=\"toc-text\">45.2 TLS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-DATA-DIRECTORY-9\"><span class=\"toc-text\">IMAGE_DATA_DIRECTORY[9]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-TLS-DIRECTORY\"><span class=\"toc-text\">IMAGE_TLS_DIRECTORY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">回调函数地址数组</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-3-TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">45.3 TLS回调函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IMAGE-TLS-CALLBACK\"><span class=\"toc-text\">IMAGE_TLS_CALLBACK</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-4-TlsTest-exe\"><span class=\"toc-text\">45.4 TlsTest.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DLL-PROCESS-ATTACH\"><span class=\"toc-text\">DLL_PROCESS_ATTACH</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DLL-THREAD-ATTACH\"><span class=\"toc-text\">DLL_THREAD_ATTACH</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DLL-THREAD-DETACH\"><span class=\"toc-text\">DLL_THREAD_DETACH</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DLL-PROCESS-DETACH\"><span class=\"toc-text\">DLL_PROCESS_DETACH</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-5-%E8%B0%83%E8%AF%95TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">45.5 调试TLS回调函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#45-6-%E6%89%8B%E5%B7%A5%E6%B7%BB%E5%8A%A0TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">45.6 手工添加TLS回调函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E5%8E%9F%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">修改原程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%8A%A0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%8A%82%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">增加最后一个节区的大小</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%BE%91PE%E6%96%87%E4%BB%B6%E5%A4%B4\"><span class=\"toc-text\">编辑PE文件头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AEIMAGE-TLS-DIRECTORY%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">设置IMAGE_TLS_DIRECTORY结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">编写TLS回调函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x46-TEB\"><span class=\"toc-text\">0x46 TEB</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#46-1-TEB\"><span class=\"toc-text\">46.1 TEB</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TEB%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">TEB结构体的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TEB%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98\"><span class=\"toc-text\">TEB结构体成员</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">重要成员</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#46-2-TEB%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">46.2 TEB访问方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ntdll-NtCurrentTeb\"><span class=\"toc-text\">Ntdll.NtCurrentTeb()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#FS%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">FS段寄存器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x47-PEB\"><span class=\"toc-text\">0x47 PEB</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#47-1-PEB\"><span class=\"toc-text\">47.1 PEB</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PEB%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">PEB访问方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PEB%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">PEB结构体的定义</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#47-2-PEB%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">47.2 PEB的重要成员</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PEB-BeingDebugged\"><span class=\"toc-text\">PEB.BeingDebugged</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PEB-ImageBaseAddress\"><span class=\"toc-text\">PEB.ImageBaseAddress</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PEB-Ldr\"><span class=\"toc-text\">PEB.Ldr</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PEB-ProcessHeadp-PEB-NtGlobalFlag\"><span class=\"toc-text\">PEB.ProcessHeadp &amp; PEB.NtGlobalFlag</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x48-SEH-Structured-Exception-Handler\"><span class=\"toc-text\">0x48 SEH(Structured Exception Handler)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-1-SEH\"><span class=\"toc-text\">48.1 SEH</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-2-SEH%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">48.2 SEH练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">正常运行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">调试运行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-3-os%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">48.3 os的异常处理方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">正常运行时的异常处理方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">调试运行时的异常处理方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-4-%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">48.4 异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EXCEPITON-ACCESS-VIOLATION-C0000005\"><span class=\"toc-text\">EXCEPITON_ACCESS_VIOLATION(C0000005)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EXCEPTION-BREAKPOINT\"><span class=\"toc-text\">EXCEPTION_BREAKPOINT</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EXCEPTION-ILLEGAL-INSTRUCTION-C000001D\"><span class=\"toc-text\">EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EXCEPTION-INT-DIVIDE-BY-ZERO-C0000094\"><span class=\"toc-text\">EXCEPTION_INT_DIVIDE_BY_ZERO(C0000094)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EXCEPTION-SINGLE-STEP-80000004\"><span class=\"toc-text\">EXCEPTION_SINGLE_STEP(80000004)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-5-SEH%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">48.5 SEH详细说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SEH%E9%93%BE\"><span class=\"toc-text\">SEH链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">异常处理函数的定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TEB-NtTib-ExceptionList\"><span class=\"toc-text\">TEB.NtTib.ExceptionList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SEH%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">SEH安装方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-6-%E7%BB%83%E4%B9%A0-seh-exe\"><span class=\"toc-text\">48.6 练习 seh.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0SEH\"><span class=\"toc-text\">添加SEH</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">发生异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">查看异常处理器参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">调试异常处理器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4SEH\"><span class=\"toc-text\">删除SEH</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#48-7-%E8%AE%BE%E7%BD%AEOllydbg%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">48.7 设置Ollydbg选项</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%BD%E7%95%A5kernel32%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E5%86%85%E5%AD%98%E9%9D%9E%E6%B3%95%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">忽略kernel32中发生的内存非法访问异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%91%E8%A2%AB%E8%B0%83%E8%AF%95%E8%80%85%E6%B4%BE%E9%80%81%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">向被调试者派送异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">其他异常处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">简单练习</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x49-IA-32%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">0x49 IA-32指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-1-IA-32%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">49.1 IA-32指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-2-%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">49.2 常用术语</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E6%B1%87%E7%BC%96%E5%99%A8\"><span class=\"toc-text\">反汇编器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8\"><span class=\"toc-text\">反编译器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-3-IA-32%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">49.3 IA-32指令格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80-Instruction-Prefixes\"><span class=\"toc-text\">指令前缀 Instruction Prefixes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%A0%81-Operation-Code\"><span class=\"toc-text\">操作码 Operation Code</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ModR-M\"><span class=\"toc-text\">ModR&#x2F;M</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SIB-Scale-Index-Base\"><span class=\"toc-text\">SIB Scale-Index-Base</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E7%A7%BB-Displacement\"><span class=\"toc-text\">位移 Displacement</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AB%8B%E5%8D%B3%E6%95%B0\"><span class=\"toc-text\">立即数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-4-%E6%89%93%E5%8D%B0iA-32%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">49.4 打印iA-32指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A6%81%E6%89%93%E5%8D%B0%E7%9A%84%E6%88%AA%E5%9B%BE\"><span class=\"toc-text\">要打印的截图</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#49-5-%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">49.5 指令解析练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%A0%81%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">操作码映射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E6%95%B0\"><span class=\"toc-text\">操作数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ModR-M-1\"><span class=\"toc-text\">ModR&#x2F;M</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Group\"><span class=\"toc-text\">Group</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BC%80-Prefix\"><span class=\"toc-text\">前缀 Prefix</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%A0%81\"><span class=\"toc-text\">双字节操作码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E4%BD%8D%E5%80%BC-%E7%AB%8B%E5%8D%B3%E6%95%B0\"><span class=\"toc-text\">移位值 &amp; 立即数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%99%E9%83%A8%E5%88%86%E5%89%A9%E4%BD%99%E7%9A%84%E5%86%85%E5%AE%B9%E7%AD%89%E9%9C%80%E8%A6%81%E4%BA%86%E5%86%8D%E7%9C%8B\"><span class=\"toc-text\">这部分剩余的内容等需要了再看</span></a></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"re-engineer-core-principle-07","uid":"ad9b5bba7260fe69f150a16ce9de4386","slug":"re-engineer-core-principle-07","date":"2024-01-30T14:45:03.000Z","updated":"2024-02-28T14:46:10.615Z","comments":true,"path":"api/articles/re-engineer-core-principle-07.json","keywords":null,"cover":[],"text":"引言 终于到第七部分了，快看完了 0x50 反调试技术50.1 反调试技术 反调试技术有很强的依赖性。有些反调试技术仅在特定版本的os下工作 本章的大部分技术可以用在Windows XP SP3(32位)和Win7 32位下 50.3 反调试技术分类 根据破解方法分成静态和动态两...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"巅峰极客","uid":"cdb488d648a90943d7354784532a6374","slug":"巅峰极客","date":"2023-07-31T12:38:30.000Z","updated":"2023-08-01T09:17:46.710Z","comments":true,"path":"api/articles/巅峰极客.json","keywords":null,"cover":[],"text":"巅峰极客hellosql 这个题我知道是时间延迟注入，也知道用笛卡尔积，但是我当时的方法就是测不出来 过滤了* if 空格 时间延迟我当时用的是 SELECT A.table_name FROM information_schema.columns A, information_...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}