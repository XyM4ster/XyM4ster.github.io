{"title":"Scala_LazyList反序列化漏洞利用","uid":"de8b97b3b30ced078cc1db74c65885b4","slug":"Scala-LazyList反序列化漏洞利用","date":"2023-09-04T14:20:44.000Z","updated":"2023-09-05T07:28:19.649Z","comments":true,"path":"api/articles/Scala-LazyList反序列化漏洞利用.json","keywords":null,"cover":[],"content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p>SCTF的hello java看了大佬们的wp，完全看不懂。最近的WMCTF，发现很多关于java反序列化的知识,决心要好好学一下java反序列化&#x2F;再回头看这道题，搜索到了大佬的复现博客，赶紧膜拜了一下。</p>\n\n</details>\n<h1 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h1><p><a href=\"https://blog.csdn.net/qq_42585535/article/details/132319833\">基于LazyList的Scala反序列化漏洞透析(CVE-2022-36944)_小白Lanb0的博客-CSDN博客</a></p>\n<h1 id=\"漏洞复现环境\"><a href=\"#漏洞复现环境\" class=\"headerlink\" title=\"漏洞复现环境\"></a>漏洞复现环境</h1><p><a href=\"https://github.com/yarocher/lazylist-cve-poc\">GitHub - yarocher&#x2F;lazylist-cve-poc: POC for the CVE-2022-36944 vulnerability exploit</a></p>\n<h2 id=\"利用条件\"><a href=\"#利用条件\" class=\"headerlink\" title=\"利用条件\"></a>利用条件</h2><ul>\n<li>Scala 版本 &lt;2.13.9</li>\n</ul>\n<h1 id=\"Scala简介\"><a href=\"#Scala简介\" class=\"headerlink\" title=\"Scala简介\"></a>Scala简介</h1><ul>\n<li>这一部分主要是参考上面博客的内容，也有些是我自己的理解</li>\n</ul>\n<p>Scala运行在<strong>Java</strong>虚拟机上，并兼容现有的Java程序。Scala源代码被编译成<strong>Java字节码</strong>，所以它可以运行于<strong>JVM</strong>之上，并可以调用现有的Java类库</p>\n<ul>\n<li><p>Scala可以看成是java的扩展</p>\n</li>\n<li><p>具有更丰富功能的java</p>\n</li>\n</ul>\n<h2 id=\"匹配器match\"><a href=\"#匹配器match\" class=\"headerlink\" title=\"匹配器match\"></a>匹配器match</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token comment\">// 定义一个值</span>\n<span class=\"token keyword\">val</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n<span class=\"token comment\">// 使用match对值进行匹配</span>\nx <span class=\"token keyword\">match</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 每个case表示一种匹配情况</span>\n  <span class=\"token keyword\">case</span> 条件<span class=\"token number\">1</span> <span class=\"token keyword\">=></span> 结果<span class=\"token number\">1</span> <span class=\"token comment\">// 如果x满足条件1，就返回结果1</span>\n  <span class=\"token keyword\">case</span> 条件<span class=\"token number\">2</span> <span class=\"token keyword\">=></span> 结果<span class=\"token number\">2</span> <span class=\"token comment\">// 如果x满足条件2，就返回结果2</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">case</span> _ <span class=\"token keyword\">=></span> 默认结果 <span class=\"token comment\">// 如果x都不满足上面的条件，就返回默认结果，_表示任意值</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"其他用法\"><a href=\"#其他用法\" class=\"headerlink\" title=\"其他用法\"></a>其他用法</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token comment\">// 把match赋值给一个变量</span>\n<span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> x <span class=\"token keyword\">match</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">case</span> 条件<span class=\"token number\">1</span> <span class=\"token keyword\">=></span> 结果<span class=\"token number\">1</span> \n  <span class=\"token keyword\">case</span> 条件<span class=\"token number\">2</span> <span class=\"token keyword\">=></span> 结果<span class=\"token number\">2</span> \n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 把match作为函数的参数</span>\n<span class=\"token keyword\">def</span> foo <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  println <span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\nfoo <span class=\"token punctuation\">(</span>x <span class=\"token keyword\">match</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">case</span> 条件<span class=\"token number\">1</span> <span class=\"token keyword\">=></span> 结果<span class=\"token number\">1</span> \n  <span class=\"token keyword\">case</span> 条件<span class=\"token number\">2</span> <span class=\"token keyword\">=></span> 结果<span class=\"token number\">2</span> \n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 把match作为函数的返回值</span>\n<span class=\"token keyword\">def</span> bar <span class=\"token punctuation\">(</span>z<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Boolean</span> <span class=\"token operator\">=</span> z <span class=\"token keyword\">match</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">case</span> \\\"yes\\\" <span class=\"token keyword\">=></span> <span class=\"token boolean\">true</span> \n  <span class=\"token keyword\">case</span> \\\"no\\\" <span class=\"token keyword\">=></span> <span class=\"token boolean\">false</span> \n  <span class=\"token keyword\">case</span> _ <span class=\"token keyword\">=></span> <span class=\"token boolean\">false</span> \n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"apply方法\"><a href=\"#apply方法\" class=\"headerlink\" title=\"apply方法\"></a>apply方法</h2><p><strong>当我们用括号传递参数给一个类或者对象时，Scala会自动调用它的apply方法，并把参数传给它。</strong></p>\n<h3 id=\"apply方法定义在伴生对象中\"><a href=\"#apply方法定义在伴生对象中\" class=\"headerlink\" title=\"apply方法定义在伴生对象中\"></a>apply方法定义在伴生对象中</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token comment\">// 定义一个类Person，有一个name属性</span>\n<span class=\"token keyword\">class</span> Person<span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 定义一个伴生对象Person，有一个apply方法，接受一个name参数，返回一个Person实例</span>\n<span class=\"token keyword\">object</span> Person <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Person<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 创建一个Person实例，可以直接用Person(\"Alice\")，而不需要用new Person(\"Alice\")</span>\n<span class=\"token keyword\">val</span> alice <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">(</span><span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//相当于Person.apply(\"Alice\")</span>\n\n<span class=\"token comment\">// 打印alice的name属性，输出Alice</span>\nprintln<span class=\"token punctuation\">(</span>alice<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>这里的Person(“Alice”)是在用括号传递参数，就会调用Person的apply方法</li>\n</ul>\n<h3 id=\"apply方法定义在伴生类中\"><a href=\"#apply方法定义在伴生类中\" class=\"headerlink\" title=\"apply方法定义在伴生类中\"></a>apply方法定义在伴生类中</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> Main <span class=\"token punctuation\">&#123;</span>\n\n  <span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">class</span> Person<span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//在类中定义apply方法，输出name</span>\n      <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span><span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> println<span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token id function\">s</span><span class=\"token string\">\"I am </span><span class=\"token interpolation\"><span class=\"token punctuation\">$</span><span class=\"token expression\">name</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">var</span> p<span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Person<span class=\"token punctuation\">(</span><span class=\"token string\">\"lanb0\"</span><span class=\"token punctuation\">)</span>\n    \n    p<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//相当于p.apply()</span>\n    <span class=\"token comment\">//I am lanb0</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><code>Unit</code>是一个特殊的类型，表示不返回任何有用的值。类似于Java中的<code>void</code>类型，<code>Unit</code>在方法或函数不需要返回值时使用</li>\n</ul>\n<h2 id=\"特质trait\"><a href=\"#特质trait\" class=\"headerlink\" title=\"特质trait\"></a>特质trait</h2><p>Scala语言中，有一个Scala语言中，有一个重要的概念叫做特质(trait)，它<strong>类似于Java语言中的接口</strong>，但是比接口更加强大和灵活。</p>\n<p>特质(trait)是一种定义了一组<strong>抽象或具体</strong>的属性和方法的类型，它可以被类(class)或对象(object)扩展(extends)或混入(mix in)。</p>\n<p>特质可以实现多重继承，也就是说，<strong>一个类可以继承多个特质</strong>，从而获得所有特质中定义的属性和方法。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> PersonBody <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">val</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>它不能被实例化，像java中的接口</li>\n</ul>\n<h3 id=\"扩展单个特质\"><a href=\"#扩展单个特质\" class=\"headerlink\" title=\"扩展单个特质\"></a>扩展单个特质</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> Main <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">trait</span> PersonBody <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">class</span> Person<span class=\"token punctuation\">(</span>name <span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> PersonBody<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">var</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> <span class=\"token number\">170</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Person<span class=\"token punctuation\">(</span><span class=\"token string\">\"Cloud\"</span><span class=\"token punctuation\">)</span>\n    println<span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">//170</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>重写(实现)属性或方法时，需要使用override关键字来修饰</strong></p>\n<p><strong>trait的方法声明必须被实现</strong></p>\n<h3 id=\"扩展多个特质\"><a href=\"#扩展多个特质\" class=\"headerlink\" title=\"扩展多个特质\"></a>扩展多个特质</h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> Main <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">trait</span> PersonBody <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">trait</span> PersonHobby<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> hobbyGame<span class=\"token operator\">=</span><span class=\"token string\">\"Honor of King : World\"</span>\n    <span class=\"token keyword\">def</span> showHobby<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token builtin\">Unit</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">trait</span> PersonScore<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> math<span class=\"token operator\">=</span><span class=\"token string\">\"150\"</span>\n    <span class=\"token keyword\">def</span> showScore<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token builtin\">Unit</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">class</span> Person<span class=\"token punctuation\">(</span>name <span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> PersonBody <span class=\"token keyword\">with</span> PersonHobby <span class=\"token keyword\">with</span> PersonScore <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">var</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> <span class=\"token number\">170</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">def</span> showHobby<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n      println<span class=\"token punctuation\">(</span>hobbyGame<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">def</span> showScore<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n      println<span class=\"token punctuation\">(</span>math<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Person<span class=\"token punctuation\">(</span><span class=\"token string\">\"Cloud\"</span><span class=\"token punctuation\">)</span>\n    person<span class=\"token punctuation\">.</span>showHobby<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    person<span class=\"token punctuation\">.</span>showScore<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">/*\n输出\nHonor of King : World\n150\n*/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>跟着多个with，扩展多个特质</li>\n</ul>\n<h3 id=\"自身类型self-type\"><a href=\"#自身类型self-type\" class=\"headerlink\" title=\"自身类型self-type\"></a>自身类型self-type</h3><p>self-type表示一个类或特质依赖于另一个类型，即它必须和另一个类型混入（mixin）才能被实例化。</p>\n<ul>\n<li>假设有一个类Cat</li>\n</ul>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> Cat <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Tom\"</span>\n  <span class=\"token keyword\">val</span> color<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Gray\"</span>\n  <span class=\"token keyword\">def</span> meow<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> println<span class=\"token punctuation\">(</span><span class=\"token string\">\"Meow!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>现在想给猫添加一些新的功能，比如说话、唱歌、跳舞</li>\n</ul>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Talkative <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">def</span> talk<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">trait</span> Singer <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">def</span> sing<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">trait</span> Dancer <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">def</span> dance<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>但是并不是所有的猫都有，假设只有会说话的猫才能唱歌，也就是唱歌依赖于说话</li>\n</ul>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Talkative <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">def</span> talk<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">trait</span> Singer <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">self</span><span class=\"token operator\">:</span> Talkative <span class=\"token keyword\">=></span> <span class=\"token comment\">// 声明自身类型，表示Singer依赖于Talkative</span>\n  <span class=\"token keyword\">def</span> sing<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    talk<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 可以直接使用Talkative的成员</span>\n    println<span class=\"token punctuation\">(</span><span class=\"token string\">\"La la la...\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">trait</span> Dancer <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">self</span><span class=\"token operator\">:</span> Singer <span class=\"token keyword\">=></span> <span class=\"token comment\">// 声明自身类型，表示Dancer依赖于Singer</span>\n  <span class=\"token keyword\">def</span> dance<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    sing<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 可以直接使用Singer的成员</span>\n    println<span class=\"token punctuation\">(</span><span class=\"token string\">\"Shake shake shake...\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时我再新建对象，也就是给猫混入了这些 特质</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> tom <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Cat <span class=\"token keyword\">with</span> Talkative <span class=\"token keyword\">with</span> Singer <span class=\"token keyword\">with</span> Dancer <span class=\"token comment\">// 创建一个会说话、唱歌、跳舞的猫</span>\ntom<span class=\"token punctuation\">.</span>talk<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 输出：Meow!</span>\ntom<span class=\"token punctuation\">.</span>sing<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 输出：Meow! La la la...</span>\ntom<span class=\"token punctuation\">.</span>dance<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 输出：Meow! La la la... Shake shake shake...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>但是如果给猫没有talkative，而是直接Singer，就会报错</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> jerry <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Cat <span class=\"token keyword\">with</span> Singer <span class=\"token comment\">// 报错：illegal inheritance; self-type Cat with Singer does not conform to Singer's selftype Singer with Talkative</span>\n<span class=\"token keyword\">val</span> lily <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Cat <span class=\"token keyword\">with</span> Dancer <span class=\"token comment\">// 报错：illegal inheritance; self-type Cat with Dancer does not conform to Dancer's selftype Dancer with Singer</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"单例对象\"><a href=\"#单例对象\" class=\"headerlink\" title=\"单例对象\"></a>单例对象</h2><details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><p>这一部分是我在看payload生成的源码时，新学的知识</p>\n</p>\n</details>\n<p><strong>单例对象在整个应用程序中只有一个实例，不受类的实例化影响，需要将对象定义放在类的外部，或使用 <code>object</code> 关键字来定义一个独立的对象。</strong></p>\n<p>这里给出了一个单例对象的例子</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> TestScalaObject <span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">val</span> TEST_SYMBOL <span class=\"token operator\">=</span> <span class=\"token string\">\"*\"</span>\n <span class=\"token keyword\">def</span> testMethod<span class=\"token punctuation\">(</span>x <span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token builtin\">String</span> <span class=\"token operator\">=</span> x\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果我对他用scalac编译，就会产生下面的结果</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230904223747081.png\" alt=\"image-20230904223747081\"></p>\n<p><strong>问题：那这个如果反编译之后呢？</strong></p>\n<p><em>TestScalaObject.class</em>:</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">public <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> TestScalaObject <span class=\"token keyword\">extends</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object<span class=\"token punctuation\">&#123;</span>\n    public static <span class=\"token keyword\">final</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span><span class=\"token builtin\">String</span> testMethod<span class=\"token punctuation\">(</span>java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    public static <span class=\"token keyword\">final</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span><span class=\"token builtin\">String</span> TEST_SYMBOL<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><em>TestScalaObject$.class</em>:</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">public <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> TestScalaObject$ <span class=\"token keyword\">extends</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object implements scala<span class=\"token punctuation\">.</span>ScalaObject<span class=\"token punctuation\">&#123;</span>\n    public static <span class=\"token keyword\">final</span> TestScalaObject$ MODULE$<span class=\"token punctuation\">;</span>\n    public static <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    public java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span><span class=\"token builtin\">String</span> TEST_SYMBOL<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    public java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span><span class=\"token builtin\">String</span> testMethod<span class=\"token punctuation\">(</span>java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>下面来自GPT:</p>\n<ul>\n<li><p><code>MODULE$</code> 的存在是为了保持对象的单例性。由于 Scala 对象是单例的，编译器会在伴生类中创建一个静态的、命名为 <code>MODULE$</code> 的实例，以确保对象始终是单例的。</p>\n</li>\n<li><p>这样，就通过 <code>TestScalaObject$.MODULE$</code> 来访问 <code>TestScalaObject</code> 对象的方法和属性。</p>\n</li>\n<li><p>在例子中，<code>TestScalaObject$.MODULE$</code> 实际上是 <code>TestScalaObject</code> 对象的实例。通过它，可以访问 <code>TestScalaObject</code> 中定义的成员，如 <code>TEST_SYMBOL</code> 和 <code>testMethod</code>。</p>\n</li>\n</ul>\n<p>总结一下，<code>public static final TestScalaObject$ MODULE$;</code> 是一个静态的、命名为 <code>MODULE$</code> 的对象，<strong>它代表了 <code>TestScalaObject</code> 对象的单例实例</strong>。它的存在确保了对象的单例性，并允许你通过它访问对象中定义的成员。</p>\n<h2 id=\"Lazylist\"><a href=\"#Lazylist\" class=\"headerlink\" title=\"Lazylist\"></a>Lazylist</h2><p>lazylist是一种惰性求值的列表，<strong>列表中的元素只有在需要的时候才会被计算</strong>，而不是一开始就全部计算好。这样可以节省内存和时间，也可以表示无限的序列。</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230904225132420.png\" alt=\"image-20230904225132420\"></p>\n<ul>\n<li>第一部分用var定义了一个值 LazyState</li>\n<li>()表示是个无参构造器</li>\n<li>LazyList.State[A]是返回值</li>\n<li>这就是个匿名函数：val 一个值：() &#x3D;&gt; return</li>\n</ul>\n<h3 id=\"State-head及tail\"><a href=\"#State-head及tail\" class=\"headerlink\" title=\"State,head及tail\"></a>State,head及tail</h3><p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230831095859251.png\" alt=\"image-20230831095859251\"></p>\n<p><strong>State：</strong></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230904224354255.png\" alt=\"image-20230904224354255\"></p>\n<p><strong>state:</strong></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230904224334266.png\" alt=\"image-20230904224334266\"></p>\n<p><strong>bitmap$0</strong></p>\n<p>来自StackOverflow</p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p>That’s where the initialization states for <code>lazy val</code>s are stored. When you access a <code>lazy val</code> (or a nested <code>object</code>, which is equivalent), the compiler uses the bitmap field to determine whether it’s already been evaluated.</p>\n\n</details>\n<ul>\n<li>就是确定是否值被计算过了，因为head和tail的序列化和反序列化方法不一样</li>\n</ul>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>首先创建一个具有无限个数字1的Lazylist</li>\n</ul>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> ones <span class=\"token operator\">=</span> LazyList<span class=\"token punctuation\">.</span>continually<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>下面这个表示丢弃前0个元素，使用head方法获取剩余list的第一个元素</li>\n</ul>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\">println<span class=\"token punctuation\">(</span>ones<span class=\"token punctuation\">.</span>drop<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//1</span>\nprintln<span class=\"token punctuation\">(</span>ones<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//LazyList(1, &lt;not computed>)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>问题1：这里为什么会输出not computed？</strong></p>\n<ol>\n<li>head方法调用state.head</li>\n</ol>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230904230208768.png\" alt=\"image-20230904230208768\"></p>\n<ol start=\"2\">\n<li>懒加载的state开始初始化</li>\n</ol>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230904225539446.png\" alt=\"image-20230904225539446\"></p>\n<ul>\n<li>这里会调用lazyState方法，就是LazyList构造器中的LazyState()，返回的值是下面的State[A]</li>\n</ul>\n<ol start=\"3\">\n<li>State[A]调用它的head方法</li>\n</ol>\n<ul>\n<li>head方法：返回一个元素，这个元素是当前LazyList计算出的第一个元素。</li>\n<li>tail方法：返回一个新的LazyList，除了第一个元素外，其他元素的集合</li>\n</ul>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230904225408318.png\" alt=\"image-20230904225408318\"></p>\n<p><strong>通过上面的流程可以看出lazylist的本质是不停的用方法取值，而不是一开始所有的1存在内存中</strong></p>\n<p>所以LazyList是Not computed，不是计算好的集合</p>\n<h2 id=\"Lazylist的序列化和反序列化\"><a href=\"#Lazylist的序列化和反序列化\" class=\"headerlink\" title=\"Lazylist的序列化和反序列化\"></a>Lazylist的序列化和反序列化</h2><p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905094044268.png\" alt=\"image-20230905094044268\"></p>\n<p>它是LazyList的序列化代理，代替LazyList进行序列化和反序列化</p>\n<ul>\n<li>这些已经计算出来的元素会以一种紧凑的顺序格式进行序列化，然后跟着未计算出来的元素，它们使用标准的Java序列化方式来存储未计算出来的元素的结构</li>\n</ul>\n<p><strong>序列化</strong></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905094622854.png\" alt=\"image-20230905094622854\"></p>\n<ul>\n<li>首先调用默认的wirteObject方法，标准的序列化</li>\n<li>然后判断已经计算过的元素，将么个元素序列化</li>\n<li>遇到没计算过的元素，跳出循环</li>\n<li>序列化一个SerializeEnd，表示计算过的元素序列化完了</li>\n<li>将tail，也就是未计算的元素序列化</li>\n</ul>\n<p><strong>反序列化</strong></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905094937764.png\" alt=\"image-20230905094937764\"></p>\n<ul>\n<li>首先调用默认的readObject</li>\n<li>初始化一个缓冲区，存储已经计算出来的元素</li>\n<li>判断是否到了序列化的末尾<ul>\n<li>如果没有，就添加到Init缓冲区。<code>asInstanceOf</code>是Scala中的一个类型转换操作符，用于将一个对象强制转换为指定的类型。这里就是转换成A类型</li>\n<li>如果到了末尾，就跳出循环</li>\n</ul>\n</li>\n<li>将没有计算出来的元素，类型转换为lazylist</li>\n<li>使用++方法连接init和tail</li>\n</ul>\n<h2 id=\"匿名函数-vs-正常函数\"><a href=\"#匿名函数-vs-正常函数\" class=\"headerlink\" title=\"匿名函数 vs 正常函数\"></a>匿名函数 vs 正常函数</h2><h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a><strong>匿名函数</strong></h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token comment\">// 定义一个接受两个整数参数并返回它们的和的匿名函数</span>\n<span class=\"token keyword\">val</span> addition<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> x <span class=\"token operator\">+</span> y\n\n<span class=\"token comment\">// 使用匿名函数进行计算</span>\n<span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> addition<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 打印结果</span>\nprintln<span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 输出: 8</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>val addition: <strong>(Int, Int) &#x3D;&gt; Int</strong> &#x3D; (x, y) &#x3D;&gt; x + y   </p>\n<p>这里的addition是变量名，并不是函数名</p>\n<p>前面看成一部分，后面堪称一部分，也就是定义一个函数，参数类型为Int Int，返回值为Int</p>\n<h3 id=\"正常函数\"><a href=\"#正常函数\" class=\"headerlink\" title=\"正常函数\"></a><strong>正常函数</strong></h3><pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> add<span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  x <span class=\"token operator\">+</span> y\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"无参匿名函数\"><a href=\"#无参匿名函数\" class=\"headerlink\" title=\"无参匿名函数\"></a>无参匿名函数</h2><p>scala中的无参匿名函数都会被编译器转换为实现了Function0接口的实例对象</p>\n<p><strong>说人话：无参的函数会实现Function0接口，Function0接口中定义了apply()方法，所以在（)的时候，就会调用Function的apply方法</strong></p>\n<ol>\n<li>测试无参匿名函数</li>\n</ol>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> a<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">object</span> Main <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">class</span> test<span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> func<span class=\"token operator\">:</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">=></span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">def</span> show<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n          func<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>对这个代码点击左键，发现它认为func是Function0的apply方法</li>\n</ul>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230831154600032.png\" alt=\"image-20230831154600032\"></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230831154822266.png\" alt=\"image-20230831154822266\"></p>\n<ul>\n<li>也就是无参匿名函数确实实现了Function0接口</li>\n</ul>\n<ol start=\"2\">\n<li>用scalac进行编译<code>scalac a.scala</code>，生成文件如下</li>\n</ol>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230901132629733.png\" alt=\"image-20230901132629733\"></p>\n<ol start=\"3\">\n<li>用javap进行反编译，再次印证，func()方法是Function0类型的</li>\n</ol>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230901133435055.png\" alt=\"image-20230901133435055\"></p>\n<h1 id=\"漏洞分析\"><a href=\"#漏洞分析\" class=\"headerlink\" title=\"漏洞分析\"></a>漏洞分析</h1><details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><p>LazyList反序列化时会调用一个<strong>无参的匿名函数</strong>来更新LazyList的状态，这个函数可以被控制。因为Scala中的无参匿名函数都实现了Function0接口，也就是可以给LazyList传一个精心构造的函数，该函数只要实现了Function0接口。</p>\n</p>\n</details>\n<p>首先是ObjectInputStream.readObject方法接受到伪造的序列化字节流之后，尝试反序列化LazyList，进而把控制权转交给SerializationProxy类的readObject方法</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101322325.png\" alt=\"image-20230905101322325\"></p>\n<p>这里会执行 ++ 方法，接下来会执行prependedAll方法，且该方法是在trait Seq0ps中定义的，LazyList中重写了该方法</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101401436.png\" alt=\"image-20230905101401436\"></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101459283.png\" alt=\"image-20230905101459283\"></p>\n<p>跳转到LazyList的prependedAll方法</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101533466.png\" alt=\"image-20230905101533466\"></p>\n<p>跟进konwIsEmpty方法</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101659762.png\" alt=\"image-20230905101659762\"></p>\n<p>跟进IsEmpty方法：</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101732041.png\" alt=\"image-20230905101732041\"></p>\n<ul>\n<li>这里的eq是比较state和State.Empty是否指向同一个位置</li>\n</ul>\n<p>再跟进state字段，发现跳转到了LazyList定义state处：</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101853614.png\" alt=\"image-20230905101853614\"></p>\n<ul>\n<li>也就是这里会执行lazyState()，而它就是LazyList构造器中接受的方法，发现它实现了Funciton0接口</li>\n</ul>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905101930835.png\" alt=\"image-20230905101930835\"></p>\n<p><strong>综上所述，我需要找一个实现了Function0接口的函数，把它替换掉</strong></p>\n<h1 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h1><h2 id=\"匿名函数编译后的形式\"><a href=\"#匿名函数编译后的形式\" class=\"headerlink\" title=\"匿名函数编译后的形式\"></a>匿名函数编译后的形式</h2><p>查看poc中的DefaultProviders，看到这样的代码</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905103234953.png\" alt=\"image-20230905103234953\"></p>\n<p><strong>问题：这里是在用反射，为什么className是一个看不懂的东西，anonfun是啥玩意？</strong></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p>Scala编译器在编译Scala代码时，会将<strong>匿名函数转换成Java字节码</strong>，这样就可以在Java虚拟机上运行。</p>\n<p>为了与Java兼容，Scala编译器会为每个匿名函数生成一个类，并给这个类一个特殊的名字，通常是anonfun加上一些数字和符号。这个类名的作用是唯一地标识这个匿名函数，以便在运行时调用。</p>\n\n</details>\n<p>$URLInput:表示ProcessBuilderImpl的内部类</p>\n<p>$$anonfun:表示匿名函数的前缀，表示这是一个自动生成的类。</p>\n<p>$$lessinit$greater:是<code>&lt;init&gt;</code>的转义形式，<strong>表示这个匿名函数是在构造器中定义的</strong>。</p>\n<p>$1:是匿名函数的序号，表示这是第一个匿名函数。</p>\n<p><strong>问题：为什么要这样构造呢？</strong></p>\n<p>举个例子：</p>\n<pre class=\"line-numbers language-scala\" data-language=\"scala\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> a<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">def</span> msg<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">String</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"i am class a\"</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> b <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token keyword\">=></span><span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//这里注意冒号和等号之间的空格</span>\n<span class=\"token keyword\">class</span> c<span class=\"token punctuation\">(</span>url<span class=\"token operator\">:</span>a<span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> b<span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">.</span>msg<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">/**\n这行代码的意思是给c的构造器是a类型 接收参数为url,\n给b的构造器传一个函数url.msg()\n*/</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><code>=&gt;</code> 符号表示这是一个按需求值的参数，也称为 call-by-name 参数。这意味着在实际使用时，<code>stream</code> 参数会被按需求进行求值或调用。</li>\n<li>类<code>b</code>的构造函数接受一个按需传递的参数<code>name</code>，该参数的类型是<code>String</code>。当创建<code>b</code>类的实例时，可以在构造函数中传递一个<strong>表达式或函数</strong>，而不是一个具体的字符串值。只有当<code>name</code>参数在类的方法或属性中被使用时，它才会被求值。</li>\n</ul>\n<p>用scalac进行编译</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905123832110.png\" alt=\"image-20230905123832110\"></p>\n<p><strong>这个红框框的class表示的是url.msg()这个匿名函数</strong></p>\n<ul>\n<li>anonfun：匿名，lessinit$greater表示在构造器中定义的函数</li>\n</ul>\n<p><strong>注意：只有b中的参数是传名参数时，才会出现红框框的class</strong></p>\n<ul>\n<li>因为传名参数处接受的是一个函数，这个函数可以理解成匿名函数</li>\n</ul>\n<p>类比上面的关系，如果这样构造，就会调用父类的构造函数中的内容，也就是下面三个均可以利用</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905104638439.png\" alt=\"image-20230905104638439\"></p>\n<h2 id=\"poc源码分析\"><a href=\"#poc源码分析\" class=\"headerlink\" title=\"poc源码分析\"></a>poc源码分析</h2><details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><p>这里利用ProcessBuilderImpl的FileOutput</p>\n</p>\n</details>\n<p>首先创建一个1.txt，用绝对路径</p>\n<p>在Main.java中，添加下面的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\n<span class=\"token class-name\">String</span> fileToTruncate <span class=\"token operator\">=</span> <span class=\"token string\">\"1.txt的路径\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">PayloadGenerator</span> payloadGenerator <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LazyList</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DefaultProviders</span><span class=\"token punctuation\">.</span><span class=\"token constant\">FILE_OUTPUT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">boolean</span> append<span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//清空文件</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> payload <span class=\"token operator\">=</span> payloadGenerator<span class=\"token punctuation\">.</span><span class=\"token function\">generatePayload</span><span class=\"token punctuation\">(</span>fileToTruncate<span class=\"token punctuation\">,</span>append<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> base64<span class=\"token operator\">=</span> <span class=\"token class-name\">Base64</span><span class=\"token punctuation\">.</span><span class=\"token function\">getEncoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">encodeToString</span><span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>base64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"LazyList-不是scala源码中的，是Poc中自己写的\"><a href=\"#LazyList-不是scala源码中的，是Poc中自己写的\" class=\"headerlink\" title=\"LazyList(不是scala源码中的，是Poc中自己写的)\"></a><strong>LazyList</strong>(不是scala源码中的，是Poc中自己写的)</h3><p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905105218814.png\" alt=\"image-20230905105218814\"></p>\n<ul>\n<li>获取源码中的LazyList，向里面添加writeObjectSource方法</li>\n</ul>\n<p><strong>这里作者说添加了一个方法并设置bitmap为false的原因是：想让在真正的？？？</strong></p>\n<h3 id=\"generatePayload：\"><a href=\"#generatePayload：\" class=\"headerlink\" title=\"generatePayload：\"></a><strong>generatePayload</strong>：</h3><p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905110847110.png\" alt=\"image-20230905110847110\"></p>\n<p>这里首先会apply(args)，function0是一个函数，所以会执行这个函数</p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><strong>Funciton：apply()</strong></p>\n<ul>\n<li>如果有一个 <code>Function&lt;Integer, String&gt;</code> 类型的函数对象，表示接受一个整数参数并返回一个字符串结果，那么可以使用 <code>apply</code> 方法来执行函数的逻辑</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Function</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> function <span class=\"token operator\">=</span> num <span class=\"token operator\">-></span> <span class=\"token string\">\"Result: \"</span> <span class=\"token operator\">+</span> num<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> result <span class=\"token operator\">=</span> function<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 输出：Result: 10</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n</details>\n<h4 id=\"跳转到了fileOutput\"><a href=\"#跳转到了fileOutput\" class=\"headerlink\" title=\"跳转到了fileOutput\"></a>跳转到了fileOutput</h4><p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905111148587.png\" alt=\"image-20230905111148587\"></p>\n<p>上面的红框框表示一个接受 Object 数组作为输入，并返回一个 Function0<Object> 对象的函数</p>\n<p><strong>问题：这里为什么要传一个ProcessBuilder$.class呢？</strong></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905114649144.png\" alt=\"image-20230905114649144\"></p>\n<p>查看反编译的结果，发现有一个$outer</p>\n<ul>\n<li>是编译器自动生成的方法</li>\n<li><code>$outer</code> 方法是用于返回外部类（<code>ProcessBuilderImpl.OStreamBuilder</code>，Os）的实例</li>\n</ul>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905115135718.png\" alt=\"image-20230905115135718\"></p>\n<p>而<code>ProcessBuilder$</code>是ProcessBuilder的伴生对象，也就是Object processBuilder，它继承了<code>ProcessBuilderImple</code>，所以传一个<code>ProcessBuilder$.class</code></p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905120945888.png\" alt=\"image-20230905120945888\"></p>\n<p>end</p>\n<p>执行结束后，返回的就是new FileOutputStream这个函数，此时的Function0就有了这两个参数</p>\n<p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905121408634.png\" alt=\"image-20230905121408634\"></p>\n<h4 id=\"执行createList\"><a href=\"#执行createList\" class=\"headerlink\" title=\"执行createList\"></a>执行createList</h4><p><img src=\"/../Scala-LazyList%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20230905121446396.png\" alt=\"image-20230905121446396\"></p>\n<details class=\"custom-details\">\n<summary>Click to see more</summary>\n<p><p><strong>问题：为什么fileName是MODULE？</strong></p>\n<ul>\n<li>参照前面的单例对象，这里是用来访问Empty内部的方法和属性</li>\n</ul>\n<p>:::details Click to see more</p>\n<p>这里设置bitmap$0为true，前面在lazylist中添加了一个方法，那里设置bitmap为false，作者说是想在序列化开始前，才设置为false。但是其实我不太理解为什么。</p>\n</p>\n</details>\n<h4 id=\"执行序列化\"><a href=\"#执行序列化\" class=\"headerlink\" title=\"执行序列化\"></a>执行序列化</h4><ul>\n<li>newInstance LazyList的序列化代理serializationProxy，开始序列化</li>\n</ul>\n<h3 id=\"Victim\"><a href=\"#Victim\" class=\"headerlink\" title=\"Victim\"></a>Victim</h3><ul>\n<li>在victim中，反序列化刚才的结果，最后发现1.txt中的文件真的被清空了</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> <span class=\"token class-name\">String</span> data1 <span class=\"token operator\">=</span> <span class=\"token string\">\"前面Base64的结果\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">deserialize</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDecoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>data1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>至此，终于完成了Scala LazyList反序列化的漏洞分析，撒花❀。</p>\n<p>克服困难的过程很艰辛也很有趣。</p>\n<p>没有前面师傅的博客，我肯定到现在也不明白，也没有勇气从0开始复现。</p>\n<p>十分感谢参考博客中的小白师傅。</p>\n<p>最后，关于java的反序列化，还有很长的路要走，期待可以多多进步，希望明年这个时候，已经加入了W&amp;M，冲冲冲！</p>\n<h1 id=\"未尽事宜\"><a href=\"#未尽事宜\" class=\"headerlink\" title=\"未尽事宜\"></a>未尽事宜</h1><ul>\n<li>学一下到底怎么用反射去获取类，添加方法<ul>\n<li>poc中用了classPool 和反射的工具类 ReflectUtil</li>\n</ul>\n</li>\n<li>看一下Github上另一篇关于scala lazylist的分析，修漏洞的</li>\n<li>为什么LazyList中是ArraySeq.class？</li>\n</ul>\n","text":"引言 Click to see more SCTF的hello java看了大佬们的wp，完全看不懂。最近的WMCTF，发现很多关于java反序列化的知识,决心要好好学一下java反序列化&#x2F;再回头看这道题，搜索到了大佬的复现博客，赶紧膜拜了一下。 参考博客基于LazyL...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","count":1,"path":"api/tags/漏洞分析.json"},{"name":"Scala","slug":"Scala","count":1,"path":"api/tags/Scala.json"},{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2\"><span class=\"toc-text\">参考博客</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">漏洞复现环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">利用条件</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Scala%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">Scala简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%B9%E9%85%8D%E5%99%A8match\"><span class=\"toc-text\">匹配器match</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">基本用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">其他用法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#apply%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">apply方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#apply%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%9C%A8%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E4%B8%AD\"><span class=\"toc-text\">apply方法定义在伴生对象中</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#apply%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%9C%A8%E4%BC%B4%E7%94%9F%E7%B1%BB%E4%B8%AD\"><span class=\"toc-text\">apply方法定义在伴生类中</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E8%B4%A8trait\"><span class=\"toc-text\">特质trait</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E5%8D%95%E4%B8%AA%E7%89%B9%E8%B4%A8\"><span class=\"toc-text\">扩展单个特质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E5%A4%9A%E4%B8%AA%E7%89%B9%E8%B4%A8\"><span class=\"toc-text\">扩展多个特质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E8%BA%AB%E7%B1%BB%E5%9E%8Bself-type\"><span class=\"toc-text\">自身类型self-type</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">单例对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lazylist\"><span class=\"toc-text\">Lazylist</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#State-head%E5%8F%8Atail\"><span class=\"toc-text\">State,head及tail</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lazylist%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">Lazylist的序列化和反序列化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-vs-%E6%AD%A3%E5%B8%B8%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">匿名函数 vs 正常函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">匿名函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%B8%B8%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">正常函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A0%E5%8F%82%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">无参匿名函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90\"><span class=\"toc-text\">漏洞分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8\"><span class=\"toc-text\">漏洞利用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">匿名函数编译后的形式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#poc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">poc源码分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LazyList-%E4%B8%8D%E6%98%AFscala%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%EF%BC%8C%E6%98%AFPoc%E4%B8%AD%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84\"><span class=\"toc-text\">LazyList(不是scala源码中的，是Poc中自己写的)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#generatePayload%EF%BC%9A\"><span class=\"toc-text\">generatePayload：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%BA%86fileOutput\"><span class=\"toc-text\">跳转到了fileOutput</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8CcreateList\"><span class=\"toc-text\">执行createList</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">执行序列化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Victim\"><span class=\"toc-text\">Victim</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E5%B0%BD%E4%BA%8B%E5%AE%9C\"><span class=\"toc-text\">未尽事宜</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Program-Analysis-04","uid":"0c7c1359362e7af148487a65d7d4a6f0","slug":"Program-Analysis-04","date":"2023-09-09T15:34:02.000Z","updated":"2023-10-26T15:38:08.533Z","comments":true,"path":"api/articles/Program-Analysis-04.json","keywords":null,"cover":[],"text":"Static Analysis for securityInformation Flow Security目标 避免不想要的信息流 Access Control vs. Information Flow SecurityAccess Control 检查程序是否有权限 关心信息是...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Program-Analysis-03","uid":"6d51a8663bc5dbf1359ee897f7f5225c","slug":"Program-Analysis-03","date":"2023-09-01T14:31:42.000Z","updated":"2023-10-26T15:37:57.261Z","comments":true,"path":"api/articles/Program-Analysis-03.json","keywords":null,"cover":[],"text":"Interprocedural AnalysisMotivation（为什么需要过程间分析呢）问题1：之前学到都是过程内分析，但是肯定会有方法调用，那该怎么办呢？ 之前都是会做最保守的假设，也就是最安全的假设 对于常量分析而言，就假设不是常量 下面的 x y n对于过程内分析(i...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}