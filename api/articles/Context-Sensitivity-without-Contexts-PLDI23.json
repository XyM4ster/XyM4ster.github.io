{"title":"Context-Sensitivity-without-Contexts-PLDI23","uid":"39f6a6f9864fa629c2ab8230b6f47fbc","slug":"Context-Sensitivity-without-Contexts-PLDI23","date":"2023-10-08T05:40:18.000Z","updated":"2023-10-18T09:35:51.585Z","comments":true,"path":"api/articles/Context-Sensitivity-without-Contexts-PLDI23.json","keywords":null,"cover":[],"content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>学完了南大软件分析的课程，关注了谭老师的个人主页。</li>\n<li>想着看一篇论文，能对学的内容有更好的理解。</li>\n</ul>\n<h1 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h1><p><strong>Q1：首先说上下文敏感的做法</strong></p>\n<ul>\n<li>在不同上下文中分析，分离方法变量，和堆对象，也就是同时应用上下文敏感和堆上下文敏感</li>\n</ul>\n<p><strong>Q2：但是这种方法带来了问题：</strong></p>\n<ul>\n<li>因为需要clone不同的上下文，每个都要单独分析</li>\n</ul>\n<p><strong>Q3：现在有了selective context-sensitivity</strong></p>\n<ul>\n<li>只对选定的方法应用上下文敏感</li>\n<li>其余方法应用C.I.</li>\n</ul>\n<p>问题：啥是选定的方法呢？</p>\n<p><strong>Q4：但是这种方法效率有限</strong></p>\n<ul>\n<li>并没有从根本上改变上下文敏感性的主要方法</li>\n</ul>\n<p>because the selective approaches do not<br>fundamentally alter the primary methodology of context sensitivity</p>\n<p><strong>Q5：提出clone的本质</strong></p>\n<ul>\n<li>不同上下文下，clone的主要目的是把merge到一个callee method的flow 过滤掉</li>\n<li>我的理解也就是不让他merge</li>\n</ul>\n<p><strong>Q6：提出本文的方法</strong></p>\n<p>从PFG的视角</p>\n<ul>\n<li>such effect can be simulated by cutting off (Cut) the edges that introduce precision loss to certain pointers </li>\n<li>adding Shortcut edges directly from source pointers to the target ones circumventing the method on PFG</li>\n</ul>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><ul>\n<li>指针分析是一组静态分析技术，旨在计算程序指针在程序执行期间可能指向的一组抽象值</li>\n</ul>\n<p><strong>Q1：参考文献分别指出了</strong></p>\n<ul>\n<li><p>传统的C.I.指针分析，和PFG的一些基本概念，指针集沿着PFG的边传播</p>\n</li>\n<li><p>C.I.的低精度问题</p>\n</li>\n</ul>\n<p><strong>Q2：接着为了改善精度，就有了C.S.</strong></p>\n<ul>\n<li>包括call site sensitivity</li>\n<li>object sensitivity</li>\n<li>type sensitivity</li>\n</ul>\n<p>但是即使应用最广泛的2obj sensitivity，在复杂的程序面前，也没法在短时间内分析完</p>\n<p><strong>Q3：为了分析更复杂的程序，有了selective context-sensitivity</strong></p>\n<p>就是关于如何选择上下文的，能让指针分析更快的，这里面还有他们自己之前提出的方法。</p>\n<ul>\n<li>这些方法需要预先分析选定一组方法</li>\n<li>接着只对选定的方法进行上下文敏感的分析。其余应用C.I.</li>\n</ul>\n<p>但是还是在纠结于怎么选，C.S.的核心方法没有改变</p>\n<ul>\n<li><p>仍然需要复制方法</p>\n</li>\n<li><p>仍然需要在不同的上下文中分别分析每个方法的元素</p>\n</li>\n<li><p>一旦其中几个威胁到可伸缩性，分析就会面临非常缓慢甚至不可扩展的风险</p>\n</li>\n</ul>\n<p><strong>这里的扩展性指的是特殊的方法么，就是不适用的？</strong></p>\n<p>GPT</p>\n<ul>\n<li>可扩展性是指指针分析算法或技术能够有效地处理大型代码库和复杂程序的能力</li>\n<li>也就是随着代码量的增加，可以很好的应对，不是时间复杂度指数级的增长</li>\n</ul>\n<p><strong>Q4：C.I.的原因是</strong></p>\n<ul>\n<li>方法 m的数据流会merge，然后再流出去</li>\n</ul>\n<p><strong>Q5：本文方法的核心</strong></p>\n<ul>\n<li>不需预先分析</li>\n<li>只是在on-the-fly(动态执行)上下文不敏感的指针分析算法在PFG中</li>\n</ul>\n<p>它的核心是PFG(N,E)：</p>\n<ul>\n<li>N是PFG，node的集合和edges的集合</li>\n<li>E是边，包括<ul>\n<li>edges to cut off</li>\n<li>shortcut edges to add</li>\n</ul>\n</li>\n</ul>\n<p><strong>which edges to cut off?</strong></p>\n<ul>\n<li>切断这样的边：可能把方法内部merge的object flow，带到方法外部某处的边</li>\n<li>换句话说：精度损失的主要原因是流出去了，那我现在不让他流出去，在内部瞎转悠，又不会影响其他的方法</li>\n</ul>\n<p><strong>where to add shortcuts？</strong></p>\n<ul>\n<li>在object flow merge之前 locate 一下，作为source。上一步不是有cut edge么，cut edge的目标作为target，</li>\n</ul>\n<p><strong>Q4：但是具体该怎么做呢？</strong></p>\n<h1 id=\"Motivating-Example\"><a href=\"#Motivating-Example\" class=\"headerlink\" title=\"Motivating Example\"></a>Motivating Example</h1><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231008210024112.png\" alt=\"image-20231008210024112\"> </p>\n<p>Figure1（a）</p>\n<ul>\n<li><p>对于这个程序，a就是应用上下文不敏感进行分析，和学的一样，会Merge</p>\n</li>\n<li><p>如果用上下文敏感来进行分析的话，那就会把上下文clone两次，这样也会消耗很多资源</p>\n</li>\n</ul>\n<p>Figure1（b）</p>\n<ul>\n<li>带x的箭头就是，cut off，blue的箭头代表添加的shortcut</li>\n<li>因为不准的原因是，第4行代码的store语句，会让数据流从item流到o15.item 和o20.item，因此把他cut</li>\n<li>让item1直接指向o15.item</li>\n</ul>\n<p>因此就是用C.I.的指针分析算法加上cut off和shortcut，就能得到和上下文敏感同样的精度</p>\n<h1 id=\"The-cur-short-approach-Informally\"><a href=\"#The-cur-short-approach-Informally\" class=\"headerlink\" title=\"The cur-short approach ,Informally\"></a>The cur-short approach ,Informally</h1><p>这一部分定义了对于不同代码的不同principle</p>\n<p>file access pattern、container access pattern、local flow pattern</p>\n<h2 id=\"overview\"><a href=\"#overview\" class=\"headerlink\" title=\"overview\"></a>overview</h2><p>通俗的解释本文的过程是，对于merge的数据流，cut掉出口，在PFG上添加shortcut</p>\n<p><em><strong>Local Pointers：</strong></em>指针p是方法m的局部变量，称为local pointers，否则p就是non local，当p在m的外部定义，或者p是一个instance field</p>\n<p><strong><em>Nebulous path, Entrance and Exit</em>：</strong></p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231008212444818.png\" alt=\"image-20231008212444818\"></p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231008213429462.png\" alt=\"image-20231008213429462\"></p>\n<p>这个紫色的框从item–&gt;o15.item–&gt;r，就是一个Nebulous path。serItem方法是Entrance，getItem方法是exit</p>\n<ul>\n<li>有两个setItem方法的non-local 指针，他们merge到了该方法的指针item(文中用s表示start开始)，最后会有一个分支，getItem方法的local 指针r，r 导出去了两个getItem方法的non-local指针。</li>\n</ul>\n<p><em><strong>Target and Source pointers</strong></em>:</p>\n<p>Target：指的是所有p（Nebulous path)的end node的所有后继节点，他们接收merge的结果，也就是上图中的item1，item2</p>\n<p>Source：指的是所有P（Nebulous path)的start node的所有前驱节点，他们是merge贡献的来源，也就是上图中的result1，result2</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231008213812960.png\" alt=\"image-20231008213812960\"></p>\n<p>这个就很好理解了，然后作者说：</p>\n<ul>\n<li>他不会把已经添加到PFG中的边真正的cut掉，因为程序是动态的，你添加上了，就会有指针集的流到</li>\n<li>而是不添加应该cut的边</li>\n</ul>\n<p>为了有更好的精度，需要找到尽可能多的target,cut off这些会引起 指针分析精度丢失的边，并且对于每个Target，找到他对应的source，然后添加shortcut。</p>\n<p>但是对于真正的程序，很难找到一种通用的方法来处理所有的精度丢失问题。</p>\n<p>在分析时，必须确保分析的soundness。</p>\n<p><strong>问题：是不是需要学一下指针分析课程的最后一节？</strong></p>\n<p>对于一般的程序来说，主要的代码是file access pattern、container access pattern、local flow pattern，这三个会引起指针分析精度的丢失，因此重点讨论一下，在这三种情况下，entrance、exit、source、target分别对应的是啥。</p>\n<p><strong>问题：一直在说没有上下文，不需要clone，不需要选择上下文，这个还没理解好。</strong></p>\n<h2 id=\"Field-Access-Pattern\"><a href=\"#Field-Access-Pattern\" class=\"headerlink\" title=\"Field Access Pattern\"></a>Field Access Pattern</h2><p>Java中有两种field，分别是load 和store</p>\n<h3 id=\"handling-of-Store\"><a href=\"#handling-of-Store\" class=\"headerlink\" title=\"handling of Store\"></a>handling of Store</h3><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009103638264.png\" alt=\"image-20231009103638264\"></p>\n<p>对于x.f&#x3D;y，这种情况。</p>\n<ul>\n<li><p>方法m包含了start node，并且x和y来自于方法m的<strong>parameters</strong>(也就是Item item，因为这会在传参时候污染)或者variable</p>\n<ul>\n<li>这里的parameter，我理解就包括this，形参定义的参数</li>\n</ul>\n</li>\n<li><p>不同的call的参数会在方法m内部merge</p>\n</li>\n</ul>\n<p>这是导致指针集不准的原因</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009104238298.png\" alt=\"image-20231009104238298\"></p>\n<p>这里看Figure1，不准的原因是会merge，而且这个item(3)还会传给this.item。</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009110132281.png\" alt=\"image-20231009110132281\"></p>\n<p>所以，作者对于cut-shortcut的idea是</p>\n<p>对于cut</p>\n<ul>\n<li><p>首先找到 x.f &#x3D; y，这样的表达式，并且满足</p>\n<ul>\n<li>x和y都是方法m的参数(this或者形参)</li>\n<li>x和y没有重写，保证它确实是从call site处传过来的，也就是确实merge了</li>\n</ul>\n</li>\n<li><p>如果发现了这样的statement，这就形成了nebulous path（参照前面nebulous path的定义，确实一个node就能形成，因为它进来是汇聚，出去是分支），此时方法m，就是entrance 和exit。</p>\n</li>\n<li><p>此时的target就是x.f所访问的，也就是figule 1 (a)中的o15.item和o20.itemm</p>\n</li>\n<li><p>把这个store的边 cut掉</p>\n</li>\n</ul>\n<p>对于shortcut</p>\n<ul>\n<li>item1就是source，o15.item是它对应的target，加上一条shortcut，item2是source,o20.item是target</li>\n</ul>\n<h3 id=\"handling-of-load\"><a href=\"#handling-of-load\" class=\"headerlink\" title=\"handling of load\"></a>handling of load</h3><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009142853362.png\" alt=\"image-20231009142853362\"></p>\n<p>对于load语句</p>\n<p>x &#x3D; y.f</p>\n<ul>\n<li>y来自于方法m的parameter</li>\n<li>x是方法m的返回值，并且x的值由y,f获得，对象在方法m内部merge了</li>\n</ul>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009143250531.png\" alt=\"image-20231009143250531\"></p>\n<p>根据上面的规则</p>\n<ul>\n<li>方法getItem包括r</li>\n<li>this是方法getItem的参数</li>\n<li>r是返回值</li>\n</ul>\n<p>作者的idea是cut off 方法m的return edges</p>\n<ul>\n<li>首先找到一个statement：x&#x3D;y.f<ul>\n<li>y的值是方法m的参数，并且没有重定义</li>\n<li>x是m方法的返回值</li>\n</ul>\n</li>\n<li>cut off return edges，从方法m到接收变量的这个边被cut掉</li>\n</ul>\n<p>对于上图的结果就是，cut掉r到result1，和r到result2，加一个o15.item到result1，和o20.item到result2 </p>\n<h3 id=\"handling-of-Nested-Call-for-Field-Access（处理字段访问的嵌套调用）\"><a href=\"#handling-of-Nested-Call-for-Field-Access（处理字段访问的嵌套调用）\" class=\"headerlink\" title=\"handling of Nested Call for Field Access（处理字段访问的嵌套调用）\"></a>handling of Nested Call for Field Access（处理字段访问的嵌套调用）</h3><p>如果对于嵌套的方法调用，按照上面的分析，就可能会有问题。<img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009152358972.png\" alt=\"image-20231009152358972\"></p>\n<p>比如这个</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009153110340.png\" alt=\"image-20231009153110340\"></p>\n<p>这里显然是不能直接加t–&gt;o8.f和t–&gt;o10.f，这里我理解nebulous path的start node是t，所以source 就是t1 t2，target就是o8.f和o10.f，只是要一直向前找，找method的caller，caller的caller，直到找到真正的target</p>\n<p>详细的会在Section 4.2中说明</p>\n<h2 id=\"Container-Access-Pattern\"><a href=\"#Container-Access-Pattern\" class=\"headerlink\" title=\"Container Access Pattern\"></a>Container Access Pattern</h2><p>关于容器的处理，之前学的指针分析算法，并没有这部分的内容。</p>\n<h3 id=\"Handing-of-Containers\"><a href=\"#Handing-of-Containers\" class=\"headerlink\" title=\"Handing of Containers\"></a>Handing of Containers</h3><p>这里其实和上面是类似的，对于ArrayList来说，add方法，也是一个方法，那就也会merge。</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009154945613.png\" alt=\"image-20231009154945613\"></p>\n<ul>\n<li><p>这里认为add方法是entrance，get方法是exit。</p>\n</li>\n<li><p>那这里a b就是一个source，理解成 $Entrance_{cs}^{arg}$，当前调用点的参数</p>\n</li>\n<li><p>x和y就是target，理解成$Exit_{cs}^{lhs}$，当前调用点exit方法的接收变量(lhs)</p>\n</li>\n<li><p>所以就在对应的$Entrance_{cs}^{arg}$和$Exit_{cs}^{lhs}$上添加shortcut edges</p>\n</li>\n</ul>\n<p><strong>Q1：那如何判断entrance 和 exit是不是对应的呢？</strong></p>\n<p>如果是同一个container，比如 line3的add（）和line4的get()，那entrance 和 exit肯定是Match的</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009173121267.png\" alt=\"image-20231009173121267\"></p>\n<ul>\n<li>也就是看$Entrance_{cs}^{rv}$和$Exit_{cs}^{rv}$的指针集是否有重叠，指向同一个地方，是不是同一个调用点<ul>\n<li>例如line 3的entrance rv是l1，line4 get方法是exit，它的rv是l1，他俩的指针集 overlap</li>\n</ul>\n</li>\n</ul>\n<p><strong>但是这种方法不能处理其他的容器，例如iterators和Map的keySet()，这是为啥呢？？</strong>1</p>\n<p><strong>Q2：为了解决上面的，引入了Pointer-host map(ptH)</strong></p>\n<p>现在我还不知道对应的rules是啥样的，只能按照当前的理解</p>\n<ul>\n<li>$pt_H(l1)&#x3D;{o_1}$表示arrlist o1 被assign 给了 l1</li>\n</ul>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009173136339.png\" alt=\"image-20231009173136339\"></p>\n<p>因此如果$pt_H(Entrance_{cs}^{rv})$和$pt_H(Exit_{cs}^{rv})$ overlap，就认为他俩可能是同一个container，就在arg和lhs加一条edge,这里的rv是recive variable</p>\n<p>也就是在上面的例子中，</p>\n<p>line3中 的add的receiver variable是$pt_{H}$(l1)，line4的receiver variable也是ptH(l1)，因此就加一条shortcut edge，从a–&gt;x，类似的从b到y也加一个</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009165849852.png\" alt=\"image-20231009165849852\"></p>\n<p>对应上面的Iterator来说，因为ptH(it1）&#x3D; pth(l1)&#x3D; {o1}，所以在l1和It1上加一条边</p>\n<h3 id=\"Handling-of-Host-Dependent-Objects\"><a href=\"#Handling-of-Host-Dependent-Objects\" class=\"headerlink\" title=\"Handling of Host-Dependent Objects.\"></a>Handling of Host-Dependent Objects.</h3><ul>\n<li><p>规则和前面一样，还是cut掉从exit到 $Exit_{cs}^{lhs}$的边，并且添加一个shortcut edge 从entrance arg到exit lhs</p>\n</li>\n<li><p>不同的地方是要扩展entrance、exit和pth</p>\n</li>\n</ul>\n<p>扩展exit</p>\n<ul>\n<li>现在认为next()就是exit</li>\n</ul>\n<p>扩展pth：</p>\n<p><em>host-related pointer</em>：Hptr，理解成Line 11 的it1   作为key</p>\n<p><em>host object</em>：H 理解成object o1\t\t\t\t\t\t\t作为value</p>\n<p><strong>Q1：那如何通过Key获取value？</strong></p>\n<p><em>Transfer methods：</em></p>\n<ul>\n<li><p>iterator依赖于一个container，把container称为host，把iterator object称为host-dependent object</p>\n</li>\n<li><p>如果一个host-dependent object是通过调用host H的类的方法m创建的，那么m称为一个Transfer。</p>\n</li>\n</ul>\n<p>Line11的iterator()就是一个transfer method，it1就是Hptr指向的对象</p>\n<p>对于每个transfer的call site</p>\n<ul>\n<li>把receiver variable的host object传给LHS variable，也就是把o1传给ptH(it1)</li>\n</ul>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010175847696.png\" alt=\"image-20231010175847696\"></p>\n<h3 id=\"Local-Flow-Pattern\"><a href=\"#Local-Flow-Pattern\" class=\"headerlink\" title=\"Local Flow Pattern\"></a>Local Flow Pattern</h3><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010100537861.png\" alt=\"image-20231010100537861\"></p>\n<h1 id=\"Formlism-and-soundness\"><a href=\"#Formlism-and-soundness\" class=\"headerlink\" title=\"Formlism and soundness\"></a>Formlism and soundness</h1><h2 id=\"Pointer-Analysis-with-cut-shortcut\"><a href=\"#Pointer-Analysis-with-cut-shortcut\" class=\"headerlink\" title=\"Pointer Analysis with cut-shortcut\"></a>Pointer Analysis with cut-shortcut</h2><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010103716165.png\" alt=\"image-20231010103716165\"></p>\n<ul>\n<li>定义了指针分析的rules，大体上和之前学的都相同</li>\n<li>s–&gt;t表明s指向的t也指向，就是把s的指针集加到t中，所以也用了pt(s) 包含于 pt(t)这种表达</li>\n</ul>\n<p>对于Cut-Shortcut，定义下面三个集合：</p>\n<ul>\n<li><em>cutStores：</em>是store statement的集合，如果一个 store statement j 在cutStore中，j生成的store edge就会被cut off</li>\n<li><em>cutReturns</em>：是return variables的集合。如果一个return variable $m_{ret}$在cutReturns中，从$m_{ret}$到m的call site的LHS variable会被cut</li>\n<li>*$E_{SC}$*是shortcut edgs的集合。如果一个边 s –&gt;t加到$E_{SC}$中，就会被加到PFG中，那s指向的对象也会被t指向</li>\n</ul>\n<h2 id=\"Field-Access-Pattern-1\"><a href=\"#Field-Access-Pattern-1\" class=\"headerlink\" title=\"Field  Access Pattern\"></a>Field  Access Pattern</h2><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010105458297.png\" alt=\"image-20231010105458297\"></p>\n<h4 id=\"Handling-of-Store\"><a href=\"#Handling-of-Store\" class=\"headerlink\" title=\"Handling of Store\"></a>Handling of Store</h4><p><em><strong>ARG2VAR</strong></em></p>\n<ul>\n<li>方法m的形参是 $m_{pk}&#x3D;x$，方法中x没有被重定义</li>\n<li>把实参传递给x</li>\n</ul>\n<p><em><strong>CutStore</strong></em></p>\n<ul>\n<li><p>x和y都是从形参(形参也是从调用点的实参获得的)中获得的参数，且有i这样的statement</p>\n</li>\n<li><p>如果i在cutStores中，就把</p>\n</li>\n<li><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010104707141.png\" alt=\"image-20231010104707141\"></p>\n</li>\n<li><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010163141985.png\" alt=\"image-20231010163141985\"></p>\n<p>。<img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009152358972.png\" alt=\"image-20231009152358972\"></p>\n<p>this.f&#x3D;p 属于cutStore，  a1.f&#x3D;p — &gt;  a1.f &#x3D; t1</p>\n<p>o8属于pt(a1)   从t1到08.f加一条边</p>\n<p>看一下这个rules：</p>\n<ul>\n<li>当不再有 ARG2VAR，也就是不再有参数传递，说明已经到顶了</li>\n<li>就加边</li>\n</ul>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010163449801.png\" alt=\"image-20231010163449801\"></p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4></li>\n</ul>\n<h4 id=\"handling-of-Load\"><a href=\"#handling-of-Load\" class=\"headerlink\" title=\"handling of Load\"></a>handling of Load</h4><p>根据上面的规则</p>\n<ul>\n<li>方法getItem包括r</li>\n<li>this是方法getItem的参数</li>\n<li>r是返回值</li>\n</ul>\n<p>作者的idea是cut off 方法m的return edges</p>\n<ul>\n<li>首先找到一个statement：x&#x3D;y.f<ul>\n<li>y的值是方法m的参数，并且没有重定义</li>\n<li>x是m方法的返回值</li>\n</ul>\n</li>\n<li>cut off return edges，从方法m到接收变量的这个边被cut掉</li>\n</ul>\n<p>对于上图的结果就是，cut掉r到result1，和r到result2，加一个o15.item到result1，和o20.item到result2 </p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009143250531.png\" alt=\"image-20231009143250531\"></p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010163853969.png\" alt=\"image-20231010163853969\"></p>\n<p>就对着前面的定义理解就行了，挺好理解</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010165333152.png\" alt=\"image-20231010165333152\"></p>\n<ul>\n<li><p>有可能方法中有黄色部分的两条语句，那为了保证这种情况也能满足，就定义了RelayEdge。</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010170004682.png\" alt=\"image-20231010170004682\"></p>\n</li>\n</ul>\n<h2 id=\"Container-Access-Pattern-1\"><a href=\"#Container-Access-Pattern-1\" class=\"headerlink\" title=\"Container Access Pattern\"></a>Container Access Pattern</h2><p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231009154945613.png\" alt=\"image-20231009154945613\"></p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010171025340.png\" alt=\"image-20231010171025340\"></p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231010180212078.png\" alt=\"image-20231010180212078\"></p>\n<p><em>CutContainer</em>：cut掉所有return edege，来自exit 的method</p>\n<p><em>ShortcutContainer</em>：添加边</p>\n<p>host是container l1</p>\n<p>o1属于pth（l1） 把参数传给</p>\n<p>HostSource和HostTarget就是在做<strong>Handing of Containers</strong></p>\n<p>TransferHost：这个就是上面讲的transfermethod，比如对于</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">it <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>也就是把pth(l) 给it</p>\n<p>COLHOST：Collection包括 list set queue deque</p>\n<p>它在处理<code>ArrayList l1 = new ArrayList() </code>，把o1给pth(o1)。</p>\n<p><img src=\"/../Context-Sensitivity-without-Contexts-PLDI23/image-20231011103402766.png\" alt=\"image-20231011103402766\"></p>\n<p>这个我没太看懂</p>\n<h2 id=\"Local-Flow-Pattern-1\"><a href=\"#Local-Flow-Pattern-1\" class=\"headerlink\" title=\"Local Flow Pattern\"></a>Local Flow Pattern</h2><h1 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h1><p>用doop和Tai-e实现了上面这些rules。</p>\n<p>作者选取的精度指标是</p>\n<p>cast-resolution analysis：the number of casts that may fail—#fail-cast</p>\n<p> a method reachability analysis：the number of reachable methods—#reach-mtd\t</p>\n<p>a devirtualization analysis: the number of virtual call sites that cannot be disambiguated into monomorphic calls  无法将代码中的调用区分为单态调用。  也就是当存在多个重载的方法时，找不到具体的方法</p>\n<p>a call-graph building analysis ：the number of call graph edges</p>\n<p><strong>Soundness（Recall）</strong></p>\n<ul>\n<li>这里我理解指针分析的Recall就是正确识别所有可用的指针的能力</li>\n</ul>\n<p>作者又对不同的大型程序，分析了方法的效率。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>感觉大佬写的文章确实好，在学了课之后，有些地方很容易懂</li>\n<li>接下来看一下Tai-e的那篇文章，复现一下论文的代码</li>\n</ul>\n","text":"引言 学完了南大软件分析的课程，关注了谭老师的个人主页。 想着看一篇论文，能对学的内容有更好的理解。 AbstractQ1：首先说上下文敏感的做法 在不同上下文中分析，分离方法变量，和堆对象，也就是同时应用上下文敏感和堆上下文敏感 Q2：但是这种方法带来了问题： 因为需要clon...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Abstract\"><span class=\"toc-text\">Abstract</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Introduction\"><span class=\"toc-text\">Introduction</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Motivating-Example\"><span class=\"toc-text\">Motivating Example</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#The-cur-short-approach-Informally\"><span class=\"toc-text\">The cur-short approach ,Informally</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#overview\"><span class=\"toc-text\">overview</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Field-Access-Pattern\"><span class=\"toc-text\">Field Access Pattern</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#handling-of-Store\"><span class=\"toc-text\">handling of Store</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#handling-of-load\"><span class=\"toc-text\">handling of load</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#handling-of-Nested-Call-for-Field-Access%EF%BC%88%E5%A4%84%E7%90%86%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">handling of Nested Call for Field Access（处理字段访问的嵌套调用）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Container-Access-Pattern\"><span class=\"toc-text\">Container Access Pattern</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Handing-of-Containers\"><span class=\"toc-text\">Handing of Containers</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Handling-of-Host-Dependent-Objects\"><span class=\"toc-text\">Handling of Host-Dependent Objects.</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Local-Flow-Pattern\"><span class=\"toc-text\">Local Flow Pattern</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Formlism-and-soundness\"><span class=\"toc-text\">Formlism and soundness</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-with-cut-shortcut\"><span class=\"toc-text\">Pointer Analysis with cut-shortcut</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Field-Access-Pattern-1\"><span class=\"toc-text\">Field  Access Pattern</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Handling-of-Store\"><span class=\"toc-text\">Handling of Store</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#handling-of-Load\"><span class=\"toc-text\">handling of Load</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Container-Access-Pattern-1\"><span class=\"toc-text\">Container Access Pattern</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Local-Flow-Pattern-1\"><span class=\"toc-text\">Local Flow Pattern</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Evaluation\"><span class=\"toc-text\">Evaluation</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Tai-e-Static-Analysis-Framework-OOPSLA'23","uid":"e225c813c8f4b0b48846cd97578ebb48","slug":"Tai-e-Static-Analysis-Framework-OOPSLA-23","date":"2023-10-17T01:44:12.000Z","updated":"2023-10-18T09:35:53.722Z","comments":true,"path":"api/articles/Tai-e-Static-Analysis-Framework-OOPSLA-23.json","keywords":null,"cover":[],"text":"引言 这篇论文是我看谭老师课题组的第二篇文章，因为对于静态分析一直停留在理论，想着要看看代码，自己试试 ABSTRACT静态分析在Bug detection、安全分析、程序解释、优化等方面已经非常成熟。 静态分析在IR生成、confrol flow graph、control f...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"bottomupcs","uid":"280fda85aebd83efe2030df16a32f5ff","slug":"bottomupcs","date":"2023-09-20T08:43:17.000Z","updated":"2023-10-08T05:34:47.890Z","comments":true,"path":"api/articles/bottomupcs.json","keywords":null,"cover":null,"text":" 165d50f05814027fb7fe5e4ae8a088d8cabf1ea2d88ccf0f53dc7b0b289f333341828fd88b2557819d802f94103d3ae533a248f976fe4b8635c776fc2c174c3bf94982f99e8...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}