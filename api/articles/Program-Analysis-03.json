{"title":"Program-Analysis-03","uid":"6d51a8663bc5dbf1359ee897f7f5225c","slug":"Program-Analysis-03","date":"2023-09-01T14:31:42.000Z","updated":"2023-10-26T15:37:57.261Z","comments":true,"path":"api/articles/Program-Analysis-03.json","keywords":null,"cover":[],"content":"<h1 id=\"Interprocedural-Analysis\"><a href=\"#Interprocedural-Analysis\" class=\"headerlink\" title=\"Interprocedural Analysis\"></a>Interprocedural Analysis</h1><h2 id=\"Motivation（为什么需要过程间分析呢）\"><a href=\"#Motivation（为什么需要过程间分析呢）\" class=\"headerlink\" title=\"Motivation（为什么需要过程间分析呢）\"></a>Motivation（为什么需要过程间分析呢）</h2><p><strong>问题1：之前学到都是过程内分析，但是肯定会有方法调用，那该怎么办呢？</strong></p>\n<ul>\n<li>之前都是会做最保守的假设，也就是最安全的假设</li>\n<li>对于常量分析而言，就假设不是常量</li>\n</ul>\n<p>下面的 x y n对于过程内分析(inter procedural)而言，都是nac</p>\n<p><img src=\"/../Program-Analysis-03/image-20230817211434068.png\" alt=\"image-20230817211434068\"></p>\n<p>为了更好的精度，就需要过程间分析：也就是需要沿着过程间分析的control - flow edges传递数据流信息。</p>\n<p>对于下面的图，最关键的就是call graph</p>\n<p><img src=\"/../Program-Analysis-03/image-20230817211617439.png\" alt=\"image-20230817211617439\"></p>\n<h2 id=\"Call-Graph-Construction\"><a href=\"#Call-Graph-Construction\" class=\"headerlink\" title=\"Call Graph Construction\"></a>Call Graph Construction</h2><h3 id=\"Call-Graph\"><a href=\"#Call-Graph\" class=\"headerlink\" title=\"Call Graph\"></a>Call Graph</h3><ul>\n<li>call graph就是一系列call edges的集合，从调用点到他们的目标方法</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230817212045071.png\" alt=\"image-20230817212045071\"></p>\n<h3 id=\"Call-Graph-Construction-for-OOPLS（focus-on-java）\"><a href=\"#Call-Graph-Construction-for-OOPLS（focus-on-java）\" class=\"headerlink\" title=\"Call Graph Construction for OOPLS（focus on java）\"></a>Call Graph Construction for OOPLS（focus on java）</h3><p><img src=\"/../Program-Analysis-03/image-20230817212304829.png\" alt=\"image-20230817212304829\"></p>\n<h3 id=\"Method-Calls-Invocation-in-Java\"><a href=\"#Method-Calls-Invocation-in-Java\" class=\"headerlink\" title=\"Method Calls(Invocation) in Java\"></a>Method Calls(Invocation) in Java</h3><p><img src=\"/../Program-Analysis-03/image-20230817230247609.png\" alt=\"image-20230817230247609\"></p>\n<p>Special call处理三种方法： 私有方法、构造函数、父类方法</p>\n<ul>\n<li>static call和special call都是在编译时，就可以确定了，但是像其他的实例方法，需要在运行时候才能确定</li>\n<li>Instruction：指Java的<strong>IR中的指令</strong></li>\n<li>Receiver objects：方法调用对应的实例对象（static方法调用不需要对应实例）。</li>\n<li>Target methods：表达<strong>IR指令到被调用目标方法的映射关系</strong></li>\n<li>Num of target methods：call对应的可能被调用的目标方法的数量。Virtual call与动态绑定和多态实现有关，可以对应多个对象下的重写方法。所以<strong>Virtual call的可能对象可能超过1个</strong>。</li>\n<li>Determinacy：指什么时候能够确定这个call的对应方法。Virtual call与多态有关，只能在运行时决定调用哪一个具体方法的实现。其他两种call都和多态机制不相关，编译时刻就可以确定。</li>\n</ul>\n<p> 意思也就是：在编译时刻，不能确定传给哪个对象，不能确定是调用父类的方法还是子类的方法。</p>\n<h3 id=\"Method-Dispatch-of-Virtual-Calls\"><a href=\"#Method-Dispatch-of-Virtual-Calls\" class=\"headerlink\" title=\"Method Dispatch of Virtual Calls\"></a>Method Dispatch of Virtual Calls</h3><p>在run-time时，一个virtual call取决于以下两点：</p>\n<ul>\n<li>received object的类型(也就是o的类型，应该是Class)</li>\n<li>调用点的method signature</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230817231018639.png\" alt=\"image-20230817231018639\"></p>\n<p>一个signature是一个方法的identifier</p>\n<p><img src=\"/../Program-Analysis-03/image-20230817231119367.png\" alt=\"image-20230817231119367\"></p>\n<ul>\n<li>class type：这里是C</li>\n<li>method name：foo</li>\n<li>descriptor：返回类型+参数类型</li>\n</ul>\n<p>这里用C.foo(P,Q,R)简写</p>\n<p>接着定义了一个Dispatch(c,m)模拟运行时的方法调用过程</p>\n<p><img src=\"/../Program-Analysis-03/image-20230817231614531.png\" alt=\"image-20230817231614531\"></p>\n<p><strong>这里的目标是找到m方法并调用</strong></p>\n<ul>\n<li>如果c包含一个和m有同样名字和descriprot的<strong>非抽象</strong>方法 m’(因为只有非抽象的方法才能被调用)</li>\n<li>否则就去c的父类中找</li>\n</ul>\n<h3 id=\"An-Example\"><a href=\"#An-Example\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../Program-Analysis-03/image-20230817234913493.png\" alt=\" \"></p>\n<p><img src=\"/../Program-Analysis-03/image-20230817232030077.png\" alt=\"image-20230817232030077\"></p>\n<ul>\n<li>这里的B表示的是received object的类型</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230817234925578.png\" alt=\"image-20230817234925578\"></p>\n<h3 id=\"Class-Hierarchy-Analysis-CHA\"><a href=\"#Class-Hierarchy-Analysis-CHA\" class=\"headerlink\" title=\"Class Hierarchy Analysis(CHA)\"></a>Class Hierarchy Analysis(CHA)</h3><p>这个算法的目标是在编译时，根据receiver variable来判断它可能调用哪个类的方法</p>\n<ul>\n<li>它需要类的迭代信息</li>\n<li>需要receiver variable的 declared type</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230818204856753.png\" alt=\"image-20230818204856753\"></p>\n<h3 id=\"Call-Resolution-of-CHA\"><a href=\"#Call-Resolution-of-CHA\" class=\"headerlink\" title=\"Call Resolution of CHA\"></a>Call Resolution of CHA</h3><p>这里定义了一个函数Resolve(cs)，通过调用点来判断可能的目标方法</p>\n<p><img src=\"/../Program-Analysis-03/image-20230818205156276.png\" alt=\"image-20230818205156276\"></p>\n<p>这里分成三类，分别是静态方法，special call(构造器、super、私有方法)，和virtual call</p>\n<h4 id=\"static-call\"><a href=\"#static-call\" class=\"headerlink\" title=\"static call\"></a>static call</h4><p><img src=\"/../Program-Analysis-03/image-20230818205455206.png\" alt=\"image-20230818205455206\"></p>\n<ul>\n<li>就直接调用就行了</li>\n</ul>\n<h4 id=\"special-call\"><a href=\"#special-call\" class=\"headerlink\" title=\"special call\"></a>special call</h4><p>这里以super方法为例</p>\n<p><img src=\"/../Program-Analysis-03/image-20230818205527658.png\" alt=\"image-20230818205527658\"></p>\n<ul>\n<li>首先获得它的类，</li>\n<li>然后用Dispatch，根据前面学的，Dispatch就是先在当前类找同名方法，如果没有，就找它的父类</li>\n</ul>\n<h4 id=\"virtual-call\"><a href=\"#virtual-call\" class=\"headerlink\" title=\"virtual call\"></a>virtual call</h4><ul>\n<li>获得receive variable的类型</li>\n<li><strong>然后对它和它的所有子类应用dispatch</strong></li>\n</ul>\n<h4 id=\"An-example\"><a href=\"#An-example\" class=\"headerlink\" title=\"An example\"></a>An example</h4><p><img src=\"/../Program-Analysis-03/image-20230818205846768.png\" alt=\"image-20230818205839605\"></p>\n<p>c.foo()  肯定就是C.foo()</p>\n<p>a.foo()    返回结果是 {A.foo()，C.foo()，D.foo()}</p>\n<p>b.foo() 返回结果：{A.foo()，C.foo()，D.foo()}</p>\n<ul>\n<li><p>先对B应用Dispatch，他没有这个方法，就要去它的父类中找，所以是A.foo()</p>\n</li>\n<li><p>这里我用java测试一下，如果B类中没有这个方法，那是会去找他的父类，<strong>这条性质我忘记了</strong> ，就严格按照Dispatch的定义来就行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">B</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        b<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A的foo调用\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../Program-Analysis-03/image-20230818210830243.png\" alt=\"image-20230818210830243\"></p>\n</li>\n</ul>\n<h3 id=\"Features-of-CHA\"><a href=\"#Features-of-CHA\" class=\"headerlink\" title=\"Features of CHA\"></a>Features of CHA</h3><p>优点：</p>\n<ul>\n<li>快，只考虑receiver variable</li>\n<li>忽略数据流信息</li>\n</ul>\n<p>ide中用的就是CHA </p>\n<p><img src=\"/../Program-Analysis-03/image-20230818211402699.png\" alt=\"image-20230818211402699\"></p>\n<h3 id=\"Call-Graph-Construction-Algorithm\"><a href=\"#Call-Graph-Construction-Algorithm\" class=\"headerlink\" title=\"Call Graph Construction -&gt; Algorithm\"></a>Call Graph Construction -&gt; Algorithm</h3><p><img src=\"/../Program-Analysis-03/image-20230818212105348.png\" alt=\"image-20230818212105348\"></p>\n<h3 id=\"An-Example-1\"><a href=\"#An-Example-1\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../Program-Analysis-03/image-20230818221958372.png\" alt=\"image-20230818221958372\"></p>\n<h2 id=\"Interprocedural-Control-Flow-Graph\"><a href=\"#Interprocedural-Control-Flow-Graph\" class=\"headerlink\" title=\"Interprocedural Control-Flow Graph\"></a>Interprocedural Control-Flow Graph</h2><p>CFG表示一个方法的结构</p>\n<p>ICFG就是表示整个程序的结构</p>\n<p>ICFG包括所有方法的CFG，再加上两种额外的边</p>\n<ul>\n<li>Call edges</li>\n<li>Return edges：</li>\n<li>return sites：紧跟着call site的下一条语句是return site</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230818222414975.png\" alt=\"image-20230818222414975\"></p>\n<p><img src=\"/../Program-Analysis-03/image-20230818222947646.png\" alt=\"image-20230818222947646\"></p>\n<ul>\n<li>从call graph中获取这两种边</li>\n</ul>\n<h3 id=\"An-example-1\"><a href=\"#An-example-1\" class=\"headerlink\" title=\"An example\"></a>An example</h3><p><img src=\"/../Program-Analysis-03/image-20230818224613267.png\" alt=\"image-20230818224613267\"></p>\n<ul>\n<li>这里的小黄是 call-to-return edges，就是从Call site到return site</li>\n<li>它用来传递Local data-flow，比如 a&#x3D;6</li>\n</ul>\n<h2 id=\"Interprocedural-Data-Flow-Analysis\"><a href=\"#Interprocedural-Data-Flow-Analysis\" class=\"headerlink\" title=\"Interprocedural Data-Flow Analysis\"></a>Interprocedural Data-Flow Analysis</h2><p><img src=\"/../Program-Analysis-03/image-20230818223410639.png\" alt=\"image-20230818223410639\"></p>\n<ul>\n<li>现在多了两种边，需要多两种transfer</li>\n</ul>\n<h3 id=\"Interprocedural-Contant-Propagation\"><a href=\"#Interprocedural-Contant-Propagation\" class=\"headerlink\" title=\"Interprocedural Contant Propagation\"></a>Interprocedural Contant Propagation</h3><p><img src=\"/../Program-Analysis-03/image-20230818223556449.png\" alt=\"image-20230818223556449\"></p>\n<p><img src=\"/../Program-Analysis-03/image-20230818231300538.png\" alt=\"image-20230818231300538\"></p>\n<ul>\n<li>这里要保留edge transfer的返回结果，比如返回的是b，原来流到这的也是b，所以要kill 原来的b</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230818232053033.png\" alt=\"image-20230818232053033\"></p>\n<p>如果是过程内分析(IntraProcedural)，那就会保证一种safe的情况，正如本节课最开始的时候说的，就会对于有call method这种，假设不是常量。</p>\n<p><img src=\"/../Program-Analysis-03/image-20230818232931811.png\" alt=\"image-20230818232931811\"></p>\n<ul>\n<li>这里就会假设addOne的返回值不是常量，所以一直到最后b c都不是常量</li>\n<li>因此就会unprecise</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230818233056081.png\" alt=\"image-20230818233056081\"></p>\n<p><img src=\"/../Program-Analysis-03/image-20230818233129686.png\" alt=\"image-20230818233129686\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../Program-Analysis-03/image-20230906170823179.png\" alt=\"image-20230906170823179\"></p>\n<p>前面学的都是一个方法内部的分析，也就是过程内分析，只有CFG</p>\n<p>现在再加两种边，call edege和return edge，他们俩从CG(call graph)中获取，构成了这个的ICFG</p>\n<h1 id=\"Pointer-Analysis\"><a href=\"#Pointer-Analysis\" class=\"headerlink\" title=\"Pointer Analysis\"></a>Pointer Analysis</h1><h2 id=\"Problem-of-CHA\"><a href=\"#Problem-of-CHA\" class=\"headerlink\" title=\"Problem of CHA\"></a>Problem of CHA</h2><p><img src=\"/../Program-Analysis-03/image-20230819204842348.png\" alt=\"image-20230819204842348\"></p>\n<ul>\n<li>对于CHA来说，n.get只看Number的类型，所以会返回三个call targets，有2个是false postives，这样对于常量分析来说，返回了 0，1，2，所以是NAC</li>\n</ul>\n<p>因此就有了指针分析，可以更准确的找到调用的方法.</p>\n<ul>\n<li>会根据n指向的对象来构造调用图，所以只会调用One的get方法(1 call target)，基于这个做常量传播，就是准确的。</li>\n</ul>\n<h2 id=\"Pointer-Analysis-1\"><a href=\"#Pointer-Analysis-1\" class=\"headerlink\" title=\"Pointer Analysis\"></a>Pointer Analysis</h2><p>分析的是内存中指向哪个地址</p>\n<p>对于oo语言来说</p>\n<ul>\n<li>回答的是一个对象指向哪些对象</li>\n</ul>\n<p>是may analysis</p>\n<ul>\n<li>对于一个指针指向哪些对象，是一个over-approximation，我们问的问题<strong>是一个指针可能指向哪个对象</strong></li>\n</ul>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p><img src=\"/../Program-Analysis-03/image-20230819210045111.png\" alt=\"image-20230819210045111\"></p>\n<p><strong>问题1： 为什么y指向new B</strong></p>\n<ul>\n<li>因为返回的this.b之前被赋值了，变成了指向new B，所以y也指向new B</li>\n</ul>\n<h2 id=\"Pointer-Analysis-and-alias-Analysis（别名分析）\"><a href=\"#Pointer-Analysis-and-alias-Analysis（别名分析）\" class=\"headerlink\" title=\"Pointer Analysis and alias Analysis（别名分析）\"></a>Pointer Analysis and alias Analysis（别名分析）</h2><p><strong>指针分析</strong></p>\n<ul>\n<li>一个指针指向哪个对象</li>\n</ul>\n<p><strong>别名分析</strong></p>\n<ul>\n<li>两个指针指向同一个对象么</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230819214030664.png\" alt=\"image-20230819214030664\"></p>\n<p>别名分析的信息可以通过指针分析推导出来</p>\n<h2 id=\"Application-of-Pointer-Analysis\"><a href=\"#Application-of-Pointer-Analysis\" class=\"headerlink\" title=\"Application of Pointer Analysis\"></a>Application of Pointer Analysis</h2><ul>\n<li>Compiler optimization</li>\n<li>Bug detection</li>\n<li>Security Analysisi</li>\n<li>Call graph,aliases</li>\n</ul>\n<h2 id=\"Key-Factors-in-Pointer-Analysis\"><a href=\"#Key-Factors-in-Pointer-Analysis\" class=\"headerlink\" title=\"Key Factors in Pointer Analysis\"></a>Key Factors in Pointer Analysis</h2><p><img src=\"/../Program-Analysis-03/image-20230819214951488.png\" alt=\"image-20230819214951488\"></p>\n<h3 id=\"Heap-abstraction\"><a href=\"#Heap-abstraction\" class=\"headerlink\" title=\"Heap abstraction\"></a>Heap abstraction</h3><p><strong>问题：指针分析时，如何对堆的内存进行建模？</strong></p>\n<ul>\n<li>程序动态执行时，如果程序中有循环，就会产生无穷多个对象，这样指针分析就无法终止了？</li>\n</ul>\n<p><strong>那如何终止？</strong></p>\n<ul>\n<li>用堆抽象，把无穷的对象 抽象成 有限的抽象的对象</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230819215335308.png\" alt=\"image-20230819215335308\"></p>\n<h4 id=\"Allocation-Site-Abstraction\"><a href=\"#Allocation-Site-Abstraction\" class=\"headerlink\" title=\"Allocation-Site Abstraction\"></a>Allocation-Site Abstraction</h4><ul>\n<li>给具体的对象建模时，抽象成他们的创建点</li>\n<li>用这个抽象点去代表具体的对象</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230819215656384.png\" alt=\"image-20230819215656384\"></p>\n<ul>\n<li>把三次循环的结果，抽象成一个创建点o2</li>\n<li>静态分析就只处理o2，也就是程序中有几个new，静态分析就处理几个对象</li>\n</ul>\n<h3 id=\"Context-Sensitivity-上下文敏感\"><a href=\"#Context-Sensitivity-上下文敏感\" class=\"headerlink\" title=\"Context Sensitivity(上下文敏感 )\"></a>Context Sensitivity(上下文敏感 )</h3><p><strong>问题：如何堆调用上下文进行建模?</strong></p>\n<p><strong>Context-sensitive：</strong></p>\n<ul>\n<li>会区分不同方法的上下文</li>\n<li>如果一个方法有多个上下文，就都分析</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230819220014991.png\" alt=\"image-20230819220014991\"></p>\n<ul>\n<li>这种就分析2次</li>\n</ul>\n<p><strong>上下文敏感对提升指针分析非常有用。</strong></p>\n<p><strong>Context-insentitive</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230819220117482.png\" alt=\"image-20230819220117482\"></p>\n<ul>\n<li>只分析1次</li>\n<li>但是merge data flow，可能会丢失精度</li>\n</ul>\n<h3 id=\"Flow-sensitivity\"><a href=\"#Flow-sensitivity\" class=\"headerlink\" title=\"Flow sensitivity\"></a>Flow sensitivity</h3><p><strong>问题：如何对指针分析中的control flow建模？下面两种方法</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230819235926928.png\" alt=\"image-20230819235926928\"></p>\n<ul>\n<li>该图中，左边是flow-sensitive，右边是flow-insensitive</li>\n</ul>\n<p><strong>flow-sensitive</strong>：</p>\n<ul>\n<li>在每个程序的Location，都维持一个指向关系的map</li>\n<li>下面为什么s指向的值是x 而不是y，我还重新学了一下java的String知识。<ul>\n<li>总结来说开始时c.f指向的是常量池中的x，s也指向的是x</li>\n<li>但是c.f现在指向了y，就是常量池中新建了一个y，但是此时s还指向的是刚才的，所以是x</li>\n</ul>\n</li>\n</ul>\n<p><strong>flow-insensitive</strong></p>\n<ul>\n<li>忽略程序流的控制流信息，维持程序中的所有指向</li>\n<li>所以o1.f的所有可能值就是{x,y}</li>\n<li>s指向c.f，所有s的所有可能值也是{x,y}</li>\n</ul>\n<p><strong>总结</strong>;</p>\n<p>目前java中都使用flow-insensitive</p>\n<h3 id=\"Analysis-Scope\"><a href=\"#Analysis-Scope\" class=\"headerlink\" title=\"Analysis Scope\"></a>Analysis Scope</h3><p><strong>问题：指针分析时应该分析程序中的哪一部分呢？有下面两种方式</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230820001012063.png\" alt=\"image-20230820001012063\"></p>\n<ul>\n<li>对于whole-program，左边的蓝色图，分析x&#x3D;o1，，y&#x3D;o1,z&#x3D;o4</li>\n<li>对于Demand-driven，右边的黄图，只需要分析z&#x3D;04就够了</li>\n</ul>\n<p><strong>whole-program</strong></p>\n<ul>\n<li>计算程序中所有pointer的指向信息</li>\n</ul>\n<p><strong>Demand-driven(需求驱动)</strong></p>\n<ul>\n<li>根据specific sites of interest进行分析</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>选择全程序分析</li>\n</ul>\n<h3 id=\"Pointer-Analysis-in-this-course\"><a href=\"#Pointer-Analysis-in-this-course\" class=\"headerlink\" title=\"Pointer Analysis in this course\"></a>Pointer Analysis in this course</h3><p><img src=\"/../Program-Analysis-03/image-20230820001351612.png\" alt=\"image-20230820001351612\"></p>\n<p>目前没有研究说 Context-sensitive比Context-insensitive不好</p>\n<p>先学Flow-insensitive，再学Flow-sensitive</p>\n<p>Whole-program可以分析完所有的程序，适用于各种需求</p>\n<h2 id=\"Concerned-Statements\"><a href=\"#Concerned-Statements\" class=\"headerlink\" title=\"Concerned Statements\"></a>Concerned Statements</h2><p>指针分析只关注影响指针指向的语句</p>\n<h3 id=\"Pointers-in-Java\"><a href=\"#Pointers-in-Java\" class=\"headerlink\" title=\"Pointers in Java\"></a>Pointers in Java</h3><p>会local variable，就会Static field</p>\n<p>会Instance field 就会Array element</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820014739396.png\" alt=\"image-20230820014739396\"></p>\n<ul>\n<li><p>本地变量</p>\n</li>\n<li><p>Static field：C.f  \t</p>\n</li>\n<li><p>Instance field：x.f   x指向的对象有一个field f</p>\n</li>\n<li><p>Array element：忽略索引，用一个single field，也就是arr，来指向存储在array中的任何值</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230820014701202.png\" alt=\"image-20230820014701202\"></p>\n<h3 id=\"Pointer-Affecting-Statements\"><a href=\"#Pointer-Affecting-Statements\" class=\"headerlink\" title=\"Pointer-Affecting Statements\"></a>Pointer-Affecting Statements</h3><p>只需要关注下面这5种语句，对于很长的语句，简化成3AC</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820015155573.png\" alt=\"image-20230820015155573\"></p>\n<p>focus  virtual call</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820015214325.png\" alt=\"image-20230820015214325\"></p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>Pointer Analysis<ul>\n<li>CHA的问题：对于CHA，找到的call target是一个元组，即所有可能的方法，如果对于常量传播而言，得到的结果就是NAC，因此有了指针分析。只有一个call target</li>\n<li>Pointer Analysis：一个指针可能指向哪些对象。 但是这不也是不准确的么</li>\n<li>指针分析分析的是啥？<ul>\n<li>java中的指针主要有4类<ul>\n<li>本地变量</li>\n<li>static field :C.f</li>\n<li>Instance field: x.f</li>\n<li>Array element: array[i]</li>\n</ul>\n</li>\n<li>只分析直接影响指针的，pointer-affecting statements，有5种<ul>\n<li>New</li>\n<li>Assign<ul>\n<li>x&#x3D;y</li>\n</ul>\n</li>\n<li>Store<ul>\n<li>x.f&#x3D;y</li>\n</ul>\n</li>\n<li>Load<ul>\n<li>y&#x3D;x.f</li>\n</ul>\n</li>\n<li>Call<ul>\n<li>r&#x3D;x.k(a,…)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指针分析的关键因素<ul>\n<li>Heap abstraction<ul>\n<li>把new抽象成创建点</li>\n</ul>\n</li>\n<li>Context Sensitivity<ul>\n<li>对调用的上下文进行建模</li>\n</ul>\n</li>\n<li>Flow sensitivity<ul>\n<li>如何对控制流进行建模？也就是是否关注程序的具体顺序</li>\n</ul>\n</li>\n<li>Analysis Scope<ul>\n<li>1.分析整个程序</li>\n<li>2.只根据需求进行分析</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230907111536185.png\" alt=\"image-20230907111536185\"></p>\n<h1 id=\"Pointer-Analysis-Foundations-（I）\"><a href=\"#Pointer-Analysis-Foundations-（I）\" class=\"headerlink\" title=\"Pointer Analysis Foundations （I）\"></a>Pointer Analysis Foundations （I）</h1><h2 id=\"Point-Analysis-Rules\"><a href=\"#Point-Analysis-Rules\" class=\"headerlink\" title=\"Point Analysis: Rules\"></a>Point Analysis: Rules</h2><h3 id=\"Domains-and-Notations\"><a href=\"#Domains-and-Notations\" class=\"headerlink\" title=\"Domains and Notations\"></a>Domains and Notations</h3><p><img src=\"/../Program-Analysis-03/image-20230820020740779.png\" alt=\"image-20230820020740779\"></p>\n<p>Points-to relations：理解为一个map</p>\n<p>Key 就是指针  value是相应指针的指针集</p>\n<h4 id=\"Rules\"><a href=\"#Rules\" class=\"headerlink\" title=\"Rules\"></a>Rules</h4><p><img src=\"/../Program-Analysis-03/image-20230820021340002.png\" alt=\"image-20230820021340002\"></p>\n<p>横线上面的是条件，下面的是结论</p>\n<p><strong>New</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230820021330728.png\" alt=\"image-20230820021330728\"></p>\n<ul>\n<li>用oi表示创建出来的对象，所以让x指向oi，就是把pi加到x的指针集中</li>\n</ul>\n<p><strong>Assign</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230820021826727.png\" alt=\"image-20230820021826727\"></p>\n<ul>\n<li>y指向一个对象，要让x也指向这个</li>\n</ul>\n<p><strong>Store</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230820022029401.png\" alt=\"image-20230820022029401\"></p>\n<ul>\n<li>如果x指向oi，y指向oj，就让oi.f指向oj，也就是把oj加到oi.f的指针集中</li>\n</ul>\n<p><strong>Load</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230820022635029.png\" alt=\"image-20230820022635029\"></p>\n<p>x指向oi，oi的f执行oj，那就让y也指向oj</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820023242087.png\" alt=\"image-20230820023242087\"></p>\n<h2 id=\"How-to-Implement-Pointer-Analysis\"><a href=\"#How-to-Implement-Pointer-Analysis\" class=\"headerlink\" title=\"How to Implement Pointer Analysis\"></a>How to Implement Pointer Analysis</h2><p>指针分析的关键：当pt(x)变化时，把这种变化传播给x的相关指针</p>\n<p>解决方式：</p>\n<ul>\n<li>用graph去连接相关的指针</li>\n<li>当Pt(x)改变时，把指针变化的部分传播到 x的后继</li>\n</ul>\n<h3 id=\"Pointer-Flow-Graph-PFG\"><a href=\"#Pointer-Flow-Graph-PFG\" class=\"headerlink\" title=\"Pointer Flow Graph(PFG)\"></a>Pointer Flow Graph(PFG)</h3><p><img src=\"/../Program-Analysis-03/image-20230820225301480.png\" alt=\"image-20230820225301480\"></p>\n<ul>\n<li>一个节点n代表一个变量，或者是一个抽象对象的field</li>\n<li>一条边x–&gt;y，意味着x的指向可能(may analysis)流到y的指向</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230820225511750.png\" alt=\"image-20230820225511750\"></p>\n<p>这个图中PFG Edges中的&lt;-，表示流动，意思是y的指针流到x</p>\n<h3 id=\"PFG-Examples\"><a href=\"#PFG-Examples\" class=\"headerlink\" title=\"PFG Examples\"></a>PFG Examples</h3><p>根据左边的program，得到右边的图</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820230328608.png\" alt=\"image-20230820230328608\"></p>\n<p><strong>问题：下图中蓝色圈中为什么不能是c.f?</strong></p>\n<p>c.f只是一个指针表达式，真正的指针是抽象创建点，而且这里其实也表示d.f，所以它只能是个抽象的点</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820230556062.png\" alt=\"image-20230820230556062\"></p>\n<p>假设现在有一个新的表达式，创建点是j，那么最终会从b一直流到a和e</p>\n<h3 id=\"Implementing-Pointer-Analysis\"><a href=\"#Implementing-Pointer-Analysis\" class=\"headerlink\" title=\"Implementing Pointer Analysis\"></a>Implementing Pointer Analysis</h3><p><img src=\"/../Program-Analysis-03/image-20230820231347283.png\" alt=\"image-20230820231347283\"></p>\n<p>PFG和指针信息相互依存</p>\n<p>指针分析得到的信息越多，PFG中的边也会越多，也会让指针分析的信息更多</p>\n<ul>\n<li>这里我理解会根据左边红色的构建PFG，然后还是假设b点有个指针集pt(b)&#x3D;{oj}，它也需要根据新构建出来的边，继续流动</li>\n</ul>\n<h2 id=\"Pointer-Analysis：Algorithms\"><a href=\"#Pointer-Analysis：Algorithms\" class=\"headerlink\" title=\"Pointer Analysis：Algorithms\"></a>Pointer Analysis：Algorithms</h2><h3 id=\"Algorithms（该算法目前不设计call-method）\"><a href=\"#Algorithms（该算法目前不设计call-method）\" class=\"headerlink\" title=\"Algorithms（该算法目前不设计call method）\"></a>Algorithms（该算法目前不设计call method）</h3><p><img src=\"/../Program-Analysis-03/image-20230907121358578.png\" alt=\"image-20230907121358578\"></p>\n<h4 id=\"Worklist\"><a href=\"#Worklist\" class=\"headerlink\" title=\"Worklist\"></a>Worklist</h4><p>WL：work list存储要处理的信息，里面是一个个的pair</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820233036780.png\" alt=\"image-20230820233036780\"></p>\n<ul>\n<li>oi要被加入到x的指针集中</li>\n</ul>\n<h4 id=\"Handling-of-New-and-Assign\"><a href=\"#Handling-of-New-and-Assign\" class=\"headerlink\" title=\"Handling of New and Assign\"></a>Handling of New and Assign</h4><p>先处理 new和 assign</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820234444850.png\" alt=\"image-20230820234444850\"></p>\n<p><strong>第一步：加边</strong></p>\n<p>看红色部分</p>\n<p>首先对于 x &#x3D; new T()</p>\n<p>​\t- 那就是把oi，加入到x的指针集中</p>\n<p>对于 x &#x3D; y</p>\n<ul>\n<li>调用AddEdge函数，如果s -&gt; t不属于PFG，就在PFG上加一条边，注意这里的边是流向，而不是指向</li>\n<li>如果pt(s)不等于空，那也就是会流向t，也就是需要在t中，添加s的指针集，让t指向所有s能指向的地方</li>\n</ul>\n<p><strong>第二步：处理worklist</strong></p>\n<p>看上面算法的第二部分</p>\n<p>首先会做一个减法，也就是本来已经有的就不用动，只添加一些新的</p>\n<p><img src=\"/../Program-Analysis-03/image-20230821000638227.png\" alt=\"image-20230821000638227\"></p>\n<p>然后进行propogate</p>\n<p><img src=\"/../Program-Analysis-03/image-20230820235905992.png\" alt=\"image-20230820235905992\"></p>\n<p>圆圈1真正对指针集 进行了修改，把去重后的加入到n的指针集合中。</p>\n<p>此时对PFG进行遍历，找出n的所有后继节点s（也就是之后n会流向的地方），同样把&lt;s，pts&gt;加入到worklist中，后续进行处理，修改他们的指针集</p>\n<p>Differential Propagation</p>\n<p><img src=\"/../Program-Analysis-03/image-20230821002915288.png\" alt=\"image-20230821002915288\"></p>\n<ul>\n<li>减少集合的操作量，如果在c处就算出来了，就不用之后每一步都算了</li>\n</ul>\n<h4 id=\"Handling-of-Store-and-load\"><a href=\"#Handling-of-Store-and-load\" class=\"headerlink\" title=\"Handling of Store and load\"></a>Handling of Store and load</h4><p><img src=\"/../Program-Analysis-03/image-20230821013103213.png\" alt=\"image-20230821013103213\"></p>\n<p>if n represents a variable x 这句我没理解</p>\n<p>如果对于每个oi，有x.f &#x3D; y 或者 y &#x3D; x.f的语句，就加对应的边，和上面一样</p>\n<h3 id=\"Algorithms-Review\"><a href=\"#Algorithms-Review\" class=\"headerlink\" title=\"Algorithms Review\"></a>Algorithms Review</h3><p><img src=\"/../Program-Analysis-03/image-20230821014443700.png\" alt=\"image-20230821014443700\"></p>\n<ul>\n<li>算法的本质是在修改指针集，和addedge</li>\n<li>两个是相辅相成的，待处理的会放到WL中</li>\n</ul>\n<h3 id=\"An-Example-2\"><a href=\"#An-Example-2\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../Program-Analysis-03/image-20230821020036897.png\" alt=\"image-20230821020036897\"></p>\n<p>用流不敏感来处理</p>\n<ol>\n<li>从new开始处理</li>\n<li>处理 x &#x3D; y的情况</li>\n<li>处理WL</li>\n</ol>\n<p><img src=\"/../Program-Analysis-03/image-20230821020127052.png\" alt=\"image-20230821020127052\"></p>\n<h2 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../Program-Analysis-03/image-20230907123754434.png\" alt=\"image-20230907123754434\"></p>\n<ul>\n<li>Pointer Analysis foundations<ul>\n<li>如何实现指针分析呢？ 关键是当x的指针集改变时，要把它传给和x相关的指针<ul>\n<li>用一个graph去连接相关的指针，当pt(x)改变时，把改变传给x的后继</li>\n</ul>\n</li>\n<li>Point Flow Graph(PFG)<ul>\n<li>通过指针信息构建PFG，PFG中的边表示流向，a-&gt;b表示a的指针集流到b，也就是在b的指针集中添加a的指向</li>\n</ul>\n</li>\n<li>指针分析算法<ul>\n<li>对于x &#x3D; new T(),add{x,{oi}}</li>\n<li>对于x&#x3D;y，就AddEdge(y,x)</li>\n<li>处理WL中的指针，和对应的指针集<ul>\n<li>取出一个&lt;n,pts&gt;，用pts-ptn，只改变新添加的指针</li>\n<li>用Propagate方法<ul>\n<li>将上面的差集加入到ptn中</li>\n<li>PFG中每个n节点的后继s，都把{s,差集}加入到WL中</li>\n</ul>\n</li>\n<li>如果n代表一个变量x，也就是它有field<ul>\n<li>对于x.f&#x3D;y，就AddEdge(y,oi.f)</li>\n<li>对于y&#x3D;x.f，就AddEge(oi.f,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>AddEdge(s,t)方法<ul>\n<li>在PFG上添加s-&gt;t</li>\n<li>如果pt(s)不为空，就添加&lt;t,pt(s)&gt;到WL中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pointer-Analysis-with-Method-Calls\"><a href=\"#Pointer-Analysis-with-Method-Calls\" class=\"headerlink\" title=\"Pointer Analysis with Method Calls\"></a>Pointer Analysis with Method Calls</h2><p>CHA：解决call targets通过a的declared type</p>\n<p>Pointer Analysis：resolve call targets 基于pt(a)</p>\n<p>以前是根据CHA建call graph,那是会有假边</p>\n<p>现在根据指针分析来建call graph</p>\n<h3 id=\"Rule\"><a href=\"#Rule\" class=\"headerlink\" title=\"Rule\"></a>Rule</h3><p><strong>jvm在进行方法调用的时候，做的4件事</strong></p>\n<ol>\n<li><p>Dispatch</p>\n</li>\n<li><p>Received Object</p>\n</li>\n<li><p>参数</p>\n</li>\n<li><p>返回值</p>\n</li>\n</ol>\n<p><img src=\"/../Program-Analysis-03/image-20230821215430336.png\" alt=\"image-20230821215430336\"></p>\n<ol>\n<li><p>首先x指向oi 调用点接着对oi和k进行Dispatch，目标是找到要调用的方法</p>\n</li>\n<li><p>找到后，让oi 指向$pt(m_{this})$,也就是传receive object</p>\n</li>\n<li><p>传参数 也就是把形参aj传给 $m_{pj}$（当前变量中的pj参数）</p>\n</li>\n<li><p>传返回值，把$m_{ret}$传递给r</p>\n</li>\n</ol>\n<p><strong>问题：为什么不在x和this之间连一条边？(也就是黑色虚线为啥不是实线)</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230822010231414.png\" alt=\"image-20230822010231414\"></p>\n<ul>\n<li>假设x的指针集中  A B C三个调用点，且A B C三个类满足继承关系，那如果存在边，就会流过去，这也就让每个this的指针集中包括了{new A new B new C}，这显然是不合理的，每个类的this应该只有自己的类</li>\n</ul>\n<p>在每次算法执行时，oi是确定的某个对象(唯一的，只有一个)，然后针对这个对象做Dispatch，能够找到唯一的receive object</p>\n<h3 id=\"Interprocedural-Pointer-Analysis\"><a href=\"#Interprocedural-Pointer-Analysis\" class=\"headerlink\" title=\"Interprocedural Pointer Analysis\"></a>Interprocedural Pointer Analysis</h3><p>Call graph形成一个可达的世界：</p>\n<ul>\n<li><p>在效率上有提升：好处是不可达的方法说明程序中根本就不会用到，所以就不用分析</p>\n</li>\n<li><p>在精度上有提升：对于不可达的方法，他们有关的指针集都是假的，因为永远也不会用到  </p>\n</li>\n<li><p>Entry methods在最开始一定是可达的</p>\n</li>\n<li><p>其他</p>\n</li>\n</ul>\n<h3 id=\"Algorithms\"><a href=\"#Algorithms\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h3><p><img src=\"/../Program-Analysis-03/image-20230907121358578.png\" alt=\"image-20230907121358578\"> </p>\n<p><img src=\"/../Program-Analysis-03/image-20230822055356299.png\" alt=\"image-20230822055356299\"></p>\n<p>黄色的部分是新加的</p>\n<ul>\n<li><p>这里的$m^{entry}$方法，就理解成main方法，程序从main开始分析  </p>\n</li>\n<li><p>RM：reachable methods 可达的方法 </p>\n</li>\n<li><p>S: S是可达的语句的集合，也就是RM方法中的语句</p>\n</li>\n<li><p>$S_m$: 方法m中的语句</p>\n</li>\n<li><p>CG：call graph的边</p>\n</li>\n<li><p>AddReachable：把新的方法加入到可达的世界中</p>\n</li>\n</ul>\n<p><strong>AddReachable啥时候被调用？</strong></p>\n<ul>\n<li>entry方法是一开始的，肯定是可达，调用</li>\n<li>发现新的调用边的时候</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230822055100882.png\" alt=\"image-20230822055100882\"></p>\n<ul>\n<li>前面两行就是把新的方法加入到S集合中</li>\n</ul>\n<p><strong>为什么在算法的一开始，不处理load 和 store语句，只处理New 和 assign呢</strong></p>\n<p>因为像new和assign语句，你不需要知道他们的指针信息，就可以直接操作。</p>\n<p>但是对于 x.f &#x3D; y这样的语句，需要知道x的指针集信息，如果y指向oi，x指向oj，需要把y加入到oi.f中，但是此时一开始，x的指针集是空的</p>\n<p><strong>ProcessCall：就是在做上面那4件事</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230907211836085.png\" alt=\"image-20230907211836085\"></p>\n<p> 对于每个call site l :  x.k方法：</p>\n<ul>\n<li>用Dispatch找到对应的方法m</li>\n<li>把&lt;mthis,{oi}&gt;添加到WL </li>\n<li>如果 l -&gt;m不属于PFG，l是call site，m是目标方法 </li>\n<li>因为m是一个新的方法，所以要addreachable<ul>\n<li>遍历m的每个形式参数pi(parameter)，连接实参(argument)和形参，addEdge</li>\n<li>传返回值从mret到r，addEdge</li>\n</ul>\n</li>\n</ul>\n<p><strong>问题：为什么oi是个新的对象，还要判断l-&gt;m是否属于call graph呢</strong>  </p>\n<p>因为这里的oj是x的定义类型，之前可能有oj，ok进来，就把这个边连接上了。<strong>没太懂。</strong></p>\n<p>就是x的指针集中可能在oi之前 还有oj，就之前可能某一条语句让x和y指向了同一个地方，那Dispatch的结果如果是一样的，这条边就连接过了</p>\n<p><strong>这里的l之前也是有可能处理过的</strong></p>\n<p>因为每次x的指针集变化，就会在WL中添加东西，都会触发ProcessCall，就会执行l</p>\n<h3 id=\"An-Example-3\"><a href=\"#An-Example-3\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p> <img src=\"/../Program-Analysis-03/image-20230907215524233.png\" alt=\"image-20230907215524233\"></p>\n<p>首先执行AddReachable方法，就是把{a,o3} {b,o4}添加到WL中</p>\n<p>接着对{a,o3}执行Propagate，因为a的指针集是空的，所以没什么变化。</p>\n<p>接着对{b,o4}执行Propagate，因为b的指针集也是空的，所以也没什么变化</p>\n<ul>\n<li><p>但是因为b是变量，执行ProcessCall</p>\n<ul>\n<li>对{b,o4}进行Dispatch，由于b是从o4流过来的，所以Dispatch的结果是B.foo(A)</li>\n</ul>\n<p><strong>这里很好的体现了Pointer Analysis和CHA的区别，CHA是要对类和所有子类进行Dispatch，所以必然Dispatch的结果就不一样</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230907220322648.png\" alt=\"image-20230907220322648\"></p>\n<ul>\n<li><p>接着把{B.foo,{o4}}添加到WL ,添加一条边从5(行号)-&gt;B.foo(A) </p>\n</li>\n<li><p>对m，调用AddReachable方法</p>\n<ul>\n<li><p>添加{B.foo(A)}到RM</p>\n</li>\n<li><p>把所有的statement都加入到S中</p>\n</li>\n<li><p>添加{r,o11}到WL</p>\n</li>\n</ul>\n</li>\n<li><p>添加边从a到y，在WL中加{y,o3}</p>\n</li>\n<li><p>连接从r到c</p>\n</li>\n</ul>\n</li>\n<li><p>继续处理WL中的元素</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230907221447704.png\" alt=\"image-20230907221447704\"></p>\n<h2 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../Program-Analysis-03/image-20230907221511394.png\" alt=\"image-20230907221511394\"></p>\n<p><strong>Q1：指针分析对于method call的规则</strong></p>\n<ul>\n<li>做了4件事，Dispatch，传this，传参数，传返回值</li>\n</ul>\n<p><strong>Q2：过程间的指针分析算法</strong></p>\n<h1 id=\"Pointer-Analysis-Context-Sensitivity\"><a href=\"#Pointer-Analysis-Context-Sensitivity\" class=\"headerlink\" title=\"Pointer Analysis Context Sensitivity\"></a>Pointer Analysis Context Sensitivity</h1><h2 id=\"problem-of-Context-Insensitive-Pointer-Analysis\"><a href=\"#problem-of-Context-Insensitive-Pointer-Analysis\" class=\"headerlink\" title=\"problem of Context-Insensitive  Pointer Analysis\"></a>problem of Context-Insensitive  Pointer Analysis</h2><p>现在认为我们上一节学的指针分析就是<strong>上下文不敏感</strong>的指针分析</p>\n<ul>\n<li>对于动态分析来说，分析x.get的结果，返回的肯定是1，因为x指向的是new One</li>\n<li>对于常量传播而言，应用上节的指针分析算法，那么<ul>\n<li>在调用x &#x3D; id(n1)时，会把形参n1的指针集{o1}传给n</li>\n<li>在调用x &#x3D; id(n2)时，会把形参n2的指针集{o2}传给n</li>\n<li>结束时，会把n的指针集传给x和y，因为call graph就是这样构建的，只要n改了，就会加到WL中，那必然x 和y也会改</li>\n<li>所以x的指针集就是{o1,o2}，对于常量传播而言,i就是NAC，结果就是不准的</li>\n</ul>\n</li>\n</ul>\n<p><strong>问题是：id返回的值没有做区分，把o1,o2都返回了，就是上下文不敏感，其实本质上是在传参AddEdge时，并没有指定具体的方法形参</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230908152425903.png\" alt=\"image-20230908152425903\"></p>\n<p><strong>如果用上下文敏感进行分析 ，让n1指向的是id(n1)：n，这样结果就对了</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230908153448949.png\" alt=\"image-20230908153448949\"></p>\n<h2 id=\"Imprecision-of-Context-Insensitivity-C-I\"><a href=\"#Imprecision-of-Context-Insensitivity-C-I\" class=\"headerlink\" title=\"Imprecision of Context Insensitivity (C.I.)\"></a>Imprecision of Context Insensitivity (C.I.)</h2><p>Context Insensitivity不准的原因是：</p>\n<ul>\n<li><p>不同的方法调用的上下文不一样，如返回点，调用参数等</p>\n</li>\n<li><p>不同的方法的变量可能指向不同的对象</p>\n</li>\n<li><p>在CI的指针分析中，我们是直接传的，混在一起的，这里n被修改，导致x和y都被修改了</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230908154116108.png\" alt=\"image-20230908154116108\"></p>\n<h2 id=\"Context-Sensitivity-C-S\"><a href=\"#Context-Sensitivity-C-S\" class=\"headerlink\" title=\"Context Sensitivity (C.S.)\"></a>Context Sensitivity (C.S.)</h2><ul>\n<li>引入它就是分析不同的数据流</li>\n</ul>\n<p>最古老的最好的上下文敏感技术是call-site sensitivity</p>\n<ul>\n<li><p>代表了call site的调用链中每个方法的上下文</p>\n<ul>\n<li>方法的 call site</li>\n<li>caller 的call site</li>\n<li>call of caller call site</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230910142418510.png\" alt=\"image-20230910142418510\"></p>\n</li>\n<li><p>id就有2个上下文，2个call site</p>\n</li>\n</ul>\n<h3 id=\"Cloning-Based-Context-Sensitivity\"><a href=\"#Cloning-Based-Context-Sensitivity\" class=\"headerlink\" title=\"Cloning-Based Context Sensitivity\"></a>Cloning-Based Context Sensitivity</h3><ul>\n<li>在基于克隆的上下文敏感指针分析中，每个方法被被一个或多个上下文修饰</li>\n<li>实际上是在给变量加上下文</li>\n<li>相当于每个方法和它的变量都有了克隆</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230910143156063.png\" alt=\"image-20230910143156063\"></p>\n<ul>\n<li>这里的n就别clone 2次，这里就是用行号1 2对变量进行了标记，返回的时候，也会根据标记进行返回</li>\n</ul>\n<h3 id=\"Context-Sensitive-Heap\"><a href=\"#Context-Sensitive-Heap\" class=\"headerlink\" title=\"Context-Sensitive Heap\"></a>Context-Sensitive Heap</h3><ul>\n<li>OO程序(例如java)，它要频繁修改堆区，New的对象存储在堆里面</li>\n<li>所以要把上下文敏感应到到堆抽象中</li>\n<li>这里给每个oi，都添加了4个上下文</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230910143903012.png\" alt=\"image-20230910143903012\"></p>\n<p><strong>为什么对heap应用上下文敏感可以提升精度呢？</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230910144324225.png\" alt=\"image-20230910144324225\"></p>\n<ul>\n<li>在动态执行中，一个调用点在不同的 call  context下可能创建多个对象</li>\n<li>那不同的对象可能有不同的数据流，存不同的值到他们的field中</li>\n<li>如果没有heap context sensitive，那么可能会<strong>merge  data flows</strong>，这点很重要，参考前面的，如果有两个调用newX，那么就会都流到y，</li>\n</ul>\n<h4 id=\"An-Exmaple\"><a href=\"#An-Exmaple\" class=\"headerlink\" title=\"An Exmaple\"></a>An Exmaple</h4><h5 id=\"CS-but-no-CS-heap\"><a href=\"#CS-but-no-CS-heap\" class=\"headerlink\" title=\"CS but no CS heap\"></a><strong>CS but no CS heap</strong></h5><p>也就是上下文敏感，但是堆的上下文不敏感</p>\n<ul>\n<li><p>可以发现o8.f是o1, o2</p>\n</li>\n<li><p>本质原因是因为在算法中，并没有对方法中new的对象的创建点进行区分，认为都是一个创建点。</p>\n</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230910154745904.png\" alt=\"image-20230910154745904\"></p>\n<h5 id=\"C-I-C-S-heap\"><a href=\"#C-I-C-S-heap\" class=\"headerlink\" title=\"C.I. + C.S heap\"></a>C.I. + C.S heap</h5><p><img src=\"/../Program-Analysis-03/image-20230911222952191.png\" alt=\"image-20230911222952191\"></p>\n<p>右边是有堆的上下文敏感的，此时可以看到 3:x指向的对象是3:O8，堆上下文进行了区分。</p>\n<p>如果你是对堆上下文敏感，但是对象上下文不敏感，x处还是3:o8,4:o8，因为没有对x进行区分</p>\n<p>根据算法对上面的过程画PFG：</p>\n<p><img src=\"/../Program-Analysis-03/image-20230910154432184.png\" alt=\"image-20230910154432184\"></p>\n<h2 id=\"Context-Sensitive-Pointer-Analysis-Rules\"><a href=\"#Context-Sensitive-Pointer-Analysis-Rules\" class=\"headerlink\" title=\"Context Sensitive Pointer Analysis: Rules\"></a>Context Sensitive Pointer Analysis: Rules</h2><h3 id=\"Domains\"><a href=\"#Domains\" class=\"headerlink\" title=\"Domains\"></a>Domains</h3><p><img src=\"/../Program-Analysis-03/image-20230911224055664.png\" alt=\"image-20230911224055664\"></p>\n<p>field本身不需要上下文</p>\n<p>当引用具体的field时，引用的是具体的某个对象的field</p>\n<p>上下文敏感的指针：上下文敏感的变量 和上下文敏感的对象的field</p>\n<p>指针集：原来是对象的集合，现在是有上下文的对象</p>\n<h3 id=\"Rules（4种基本语句）\"><a href=\"#Rules（4种基本语句）\" class=\"headerlink\" title=\"Rules（4种基本语句）\"></a>Rules（4种基本语句）</h3><p><img src=\"/../Program-Analysis-03/image-20230912105625551.png\" alt=\"image-20230912105625551\"></p>\n<p>Assign：</p>\n<p>在上下文c下的x和y，如果y指向c’下的oi，那x也指向c’下的oi。</p>\n<p>load：</p>\n<p>还是x和y在同样的上下文下，进行相关的操作</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><p>之前学的是4件事</p>\n<ol>\n<li>Dispatch</li>\n<li>传this</li>\n<li>传参数</li>\n<li>传返回值</li>\n</ol>\n<p>但是现在不一样了：</p>\n<ol>\n<li>Dispatch：取目标函数</li>\n<li>选择上下文：根据调用点l，为目标方法m选择一个上下文</li>\n</ol>\n<p>这里就用了前面的clone技术，是call -site sensitivity，这里用行号表示上下文</p>\n<p><img src=\"/../Program-Analysis-03/image-20230912110532590.png\" alt=\"image-20230912110532590\"></p>\n<ol start=\"3\">\n<li>传receive object：把Dispatch的结果，传给$c^t$的this方法</li>\n<li>传参数：传给特定上下文的参数。$c下的a_j传给c^t下的m_{pj}$</li>\n<li>传返回值：把$c^t下的m_{ret}传给c下的r$</li>\n</ol>\n<p><strong>关于上下文的理解：</strong></p>\n<ul>\n<li>正常函数调用时，也会有特定的栈调用特定的函数，每调用一次有新的栈，这就是上下文敏感</li>\n<li>相当于进房间每次都从一个门进，也从同样的门出</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230912111457558.png\" alt=\"image-20230912111457558\"></p>\n<h2 id=\"Pointer-Flow-Graph-with-C-S\"><a href=\"#Pointer-Flow-Graph-with-C-S\" class=\"headerlink\" title=\"Pointer Flow Graph with C.S.\"></a>Pointer Flow Graph with C.S.</h2><p><img src=\"/../Program-Analysis-03/image-20230913145833196.png\" alt=\"image-20230913145833196\"></p>\n<p>Nodes：现在PFG中的节点都有上下文</p>\n<p>Edges：从一条边流到另一条边也是带有上下文的流动</p>\n<h2 id=\"C-S-Pointer-Analysis-Algorithm\"><a href=\"#C-S-Pointer-Analysis-Algorithm\" class=\"headerlink\" title=\"C.S. Pointer Analysis Algorithm\"></a>C.S. Pointer Analysis Algorithm</h2><p>该算法基本和C.I.的算法一样 </p>\n<p><img src=\"/../Program-Analysis-03/image-20230913151136893.png\" alt=\"image-20230913151136893\"></p>\n<p><strong>为什么callee(被调用者)有上下文？</strong></p>\n<ul>\n<li>因为要clone,保证多次调用不merge，不流到一处</li>\n</ul>\n<p><strong>为什么call site也有上下文？</strong></p>\n<ul>\n<li>一个call site在不同的上下文下，调用点方法可能不一样</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230913151556753.png\" alt=\"image-20230913151556753\"></p>\n<p><img src=\"/../Program-Analysis-03/image-20230913155333936.png\" alt=\"image-20230913155333936\">最开始给entry方法一个空的上下文</p>\n<p><strong>这里为什么c:m不属于RM？</strong></p>\n<p>为什么会有这种情况呢？</p>\n<p><strong>Select函数</strong></p>\n<p>根据四个参数选</p>\n<ul>\n<li>c 上下文</li>\n<li>l callsite</li>\n<li>c’ oi：receive object</li>\n<li>m：Dispatch找到的方法</li>\n</ul>\n<p>Select之后给this传receive object，就是让this指向现在的对象</p>\n<p><strong>整个流程是忽略控制流信息的</strong></p>\n<p>他只是拿的statements的集合，看整个流程，他也是先处理new ，处理 x &#x3D; y，再处理load store 方法调用，因此是flow insensitive</p>\n<h2 id=\"未尽事宜\"><a href=\"#未尽事宜\" class=\"headerlink\" title=\"未尽事宜\"></a>未尽事宜</h2><ul>\n<li>想一想pointer Analysis算法中一些细节是为什么？</li>\n<li>默写一下指针分析的算法，和C.S.的pointer Analysis</li>\n<li>看一下谭老师指针分析2020的论文</li>\n</ul>\n<p>Yue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. “A Principled Approach to  Selective Context Sensitivity for Pointer Analysis”. TOPLAS 2020</p>\n<h2 id=\"Context-Sensitivity-Variant\"><a href=\"#Context-Sensitivity-Variant\" class=\"headerlink\" title=\"Context Sensitivity Variant\"></a>Context Sensitivity Variant</h2><p>不是所有的技术都要考虑 Select的所有参数</p>\n<p><img src=\"/../Program-Analysis-03/image-20230913160930816.png\" alt=\"image-20230913160930816\"></p>\n<h3 id=\"Context-insensitivity\"><a href=\"#Context-insensitivity\" class=\"headerlink\" title=\"Context insensitivity\"></a>Context insensitivity</h3><p><img src=\"/../Program-Analysis-03/image-20230913161039320.png\" alt=\"image-20230913161039320\"></p>\n<p>C.I.是C.S.的一种特例，每次都返回一个空，也就是每次都一样，也就是上下文不敏感。</p>\n<h3 id=\"Call-site-Sensitivity\"><a href=\"#Call-site-Sensitivity\" class=\"headerlink\" title=\"Call-site Sensitivity\"></a>Call-site Sensitivity</h3><p><img src=\"/../Program-Analysis-03/image-20230913161415976.png\" alt=\"image-20230913161415976\"></p>\n<ul>\n<li><p>每个上下文包含call sites的list，也就是一个调用链</p>\n<ul>\n<li>在一个method call中，他把call site加到caller的上下文中，作为callee 的上下文</li>\n<li>也就是是调用栈的抽象，(A.B.C.f方法)</li>\n</ul>\n</li>\n<li><p>只需要Select的<strong>前两个参数</strong>，c表示当前的上下文，从l’ 到l’’，l表示现在的call site，把l加进去</p>\n</li>\n</ul>\n<h4 id=\"An-example-2\"><a href=\"#An-example-2\" class=\"headerlink\" title=\"An example\"></a>An example</h4><p><img src=\"/../Program-Analysis-03/image-20230913162203629.png\" alt=\"image-20230913162203629\"></p>\n<p><strong>问题：这里的void  bar()的上下文是什么？</strong></p>\n<ul>\n<li>在bar()方法中，又调用了自己。</li>\n<li>也就是程序从9跳转到13时，此时上下文是[3,9]</li>\n<li>但是执行到15时，又调用了13，再执行13方法，此时就是[3,9,15],……</li>\n<li>那就会有无穷无尽的上下文，指针分析不能终止</li>\n</ul>\n<h4 id=\"K-limiting-Context-Abstraction\"><a href=\"#K-limiting-Context-Abstraction\" class=\"headerlink\" title=\"K-limiting Context Abstraction\"></a>K-limiting Context Abstraction</h4><p>目的</p>\n<ul>\n<li>确保指针分析可以终止</li>\n<li>避免太多的上下文</li>\n</ul>\n<p>方法：设置一个上下文的边界 k</p>\n<ul>\n<li>每个上下文包括调用链中的最后k个call site</li>\n<li>对于method context k &#x3D; 2 ，对于 heap context k &#x3D;1</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230913164033014.png\" alt=\"image-20230913164033014\"></p>\n<p><strong>对于上面的程序，k&#x3D;1时，void bar()的上下文是什么</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230913163953139.png\" alt=\"image-20230913163953139\"></p>\n<ul>\n<li>也就是只有当前的call site，没有之前的call chain，所以执行到13时上下文就只有9，再往下执行，又会执行一次void bar()，<strong>所以上下文是[9,15]</strong></li>\n</ul>\n<p><strong>对于k&#x3D;2时</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230913164300411.png\" alt=\"image-20230913164300411\"></p>\n<p><strong>此时上下文是call chain中的最后一个l’’ +  当前的call site</strong></p>\n<h4 id=\"1-Call-Site-Example\"><a href=\"#1-Call-Site-Example\" class=\"headerlink\" title=\"1-Call-Site: Example\"></a>1-Call-Site: Example</h4><p><img src=\"/../Program-Analysis-03/image-20230913172338648.png\" alt=\"image-20230913172338648\"></p>\n<ul>\n<li>这里体现出了1-call-site 上下文敏感的作用，因为是1-call site，<strong>所以方法的上下文就是它的call site</strong>，没有之前的call chain</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230913172711649.png\" alt=\"image-20230913172711649\"></p>\n<ul>\n<li>O12 和  O13直接沿着PFG传下去</li>\n</ul>\n<h4 id=\"C-I-VS-C-S-1-Call-Site\"><a href=\"#C-I-VS-C-S-1-Call-Site\" class=\"headerlink\" title=\"C.I. VS C.S.(1-Call-Site)\"></a>C.I. VS C.S.(1-Call-Site)</h4><p><img src=\"/../Program-Analysis-03/image-20230913172845067.png\" alt=\"image-20230913172845067\"></p>\n<h3 id=\"Object-Sensitivity\"><a href=\"#Object-Sensitivity\" class=\"headerlink\" title=\"Object Sensitivity\"></a>Object Sensitivity</h3><ul>\n<li><p>每个上下文包含一系列抽象的对象的list</p>\n<ul>\n<li><p>在一个method call中，使用receiver object和它的heap context作为callee context</p>\n</li>\n<li><p>reveiver obejct +  heap context可以唯一确定一个对象</p>\n<p><img src=\"/../Program-Analysis-03/image-20230913173347032.png\" alt=\"image-20230913173347032\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"An-Example-4\"><a href=\"#An-Example-4\" class=\"headerlink\" title=\"An Example\"></a>An Example</h4><p><img src=\"/../Program-Analysis-03/image-20230913175033431.png\" alt=\"image-20230913175033431\"></p>\n<p><strong>为什么分析a1.set时，void doSet(B p)的上下文是o1呢？</strong></p>\n<ul>\n<li>因为object sensitivity主要由heap context 和receiver object构成，整个代码中可以看到是没有heap context 的，<strong>因为并没有在方法中new 一个对象</strong> </li>\n<li>所以只考虑receiver object,就是o1</li>\n</ul>\n<h4 id=\"1-Call-Site-vs-Object-Sensitivity\"><a href=\"#1-Call-Site-vs-Object-Sensitivity\" class=\"headerlink\" title=\"1-Call-Site vs Object Sensitivity\"></a>1-Call-Site vs Object Sensitivity</h4><p><img src=\"/../Program-Analysis-03/image-20230913175914461.png\" alt=\"image-20230913175914461\"></p>\n<ul>\n<li>对于这个程序来说，显然1- call site是不准的，因为1-call site认为当前的call site就是他的上下文，所以在调用doSet时，都会认为上下文是12</li>\n<li>而object sensitivity是准的，它始终会让this指向receiver object，在判断上下文的时候，也会用的是当前的receiver object，那在一个方法里，receive object都是一个this,所以是准的</li>\n</ul>\n<p><strong>也就是1-call site只有一层，只记得上一层，二层方法调用就不好使了</strong></p>\n<p><strong>Object Sensitivity始终对象只有this</strong></p>\n<p><img src=\"/../Program-Analysis-03/image-20230913180919817.png\" alt=\"image-20230913180919817\"></p>\n<ul>\n<li>但是这种情况下，1-Object就不准了，因为this用了两次，这两个this指向的是同一个receiver object，那就会给同样的上下文</li>\n</ul>\n<h3 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>其实上面两种方法都很怕自己最关键的地方调用2次，就会merge</strong></p>\n<ul>\n<li>1-call-site是，1已经用尽的情况下，调用了2次同样的方法，2次就会认为是同样的上下文。</li>\n<li>1-object是在同一个方法中，用了2次this,2个this都指向的是receiver object</li>\n</ul>\n<h3 id=\"Type-Sensitivity\"><a href=\"#Type-Sensitivity\" class=\"headerlink\" title=\"Type Sensitivity\"></a>Type Sensitivity</h3><p>大佬觉得上面两个还是不够快，于是研究了这种方法</p>\n<ul>\n<li><p>每个上下文包括一系列type的list:</p>\n<ul>\n<li>在一个method call中，使用包含receiver object的调用点的type，和它的heap context作为callee context</li>\n<li>是在object sensitivity之上一个粗粒度的抽象</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230913183532419.png\" alt=\"image-20230913183532419\"></p>\n</li>\n</ul>\n<p>在这个例子中吗，InType(o3)表示的就是o3所在的类，就是包含了receiver object的调用点的类</p>\n<h3 id=\"Type-vs-Object-Sensitivity\"><a href=\"#Type-vs-Object-Sensitivity\" class=\"headerlink\" title=\"Type vs Object Sensitivity\"></a>Type vs Object Sensitivity</h3><ul>\n<li>因为它是基于object sensitivity，它的精度肯定小于等于object sensitivity</li>\n</ul>\n<p><img src=\"/../Program-Analysis-03/image-20230913184126640.png\" alt=\"image-20230913184126640\"></p>\n<p>对于object sensitivity，foo()的上下文是o3 o5 o7。</p>\n<p>如果对于Type Sensitivity,foo()的上下文只有X,他们的创建点都在X中。</p>\n<p><img src=\"/../Program-Analysis-03/image-20230913184536688.png\" alt=\"image-20230913184536688\"></p>\n","text":"Interprocedural AnalysisMotivation（为什么需要过程间分析呢）问题1：之前学到都是过程内分析，但是肯定会有方法调用，那该怎么办呢？ 之前都是会做最保守的假设，也就是最安全的假设 对于常量分析而言，就假设不是常量 下面的 x y n对于过程内分析(i...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":7,"path":"api/tags/Program-Analysis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Interprocedural-Analysis\"><span class=\"toc-text\">Interprocedural Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Motivation%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90%E5%91%A2%EF%BC%89\"><span class=\"toc-text\">Motivation（为什么需要过程间分析呢）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Call-Graph-Construction\"><span class=\"toc-text\">Call Graph Construction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph\"><span class=\"toc-text\">Call Graph</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph-Construction-for-OOPLS%EF%BC%88focus-on-java%EF%BC%89\"><span class=\"toc-text\">Call Graph Construction for OOPLS（focus on java）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Method-Calls-Invocation-in-Java\"><span class=\"toc-text\">Method Calls(Invocation) in Java</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Method-Dispatch-of-Virtual-Calls\"><span class=\"toc-text\">Method Dispatch of Virtual Calls</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example\"><span class=\"toc-text\">An Example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Class-Hierarchy-Analysis-CHA\"><span class=\"toc-text\">Class Hierarchy Analysis(CHA)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Resolution-of-CHA\"><span class=\"toc-text\">Call Resolution of CHA</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#static-call\"><span class=\"toc-text\">static call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#special-call\"><span class=\"toc-text\">special call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#virtual-call\"><span class=\"toc-text\">virtual call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-example\"><span class=\"toc-text\">An example</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Features-of-CHA\"><span class=\"toc-text\">Features of CHA</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph-Construction-Algorithm\"><span class=\"toc-text\">Call Graph Construction -&gt; Algorithm</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-1\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interprocedural-Control-Flow-Graph\"><span class=\"toc-text\">Interprocedural Control-Flow Graph</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-example-1\"><span class=\"toc-text\">An example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interprocedural-Data-Flow-Analysis\"><span class=\"toc-text\">Interprocedural Data-Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interprocedural-Contant-Propagation\"><span class=\"toc-text\">Interprocedural Contant Propagation</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis\"><span class=\"toc-text\">Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Problem-of-CHA\"><span class=\"toc-text\">Problem of CHA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-1\"><span class=\"toc-text\">Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Example\"><span class=\"toc-text\">Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-and-alias-Analysis%EF%BC%88%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90%EF%BC%89\"><span class=\"toc-text\">Pointer Analysis and alias Analysis（别名分析）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Application-of-Pointer-Analysis\"><span class=\"toc-text\">Application of Pointer Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Key-Factors-in-Pointer-Analysis\"><span class=\"toc-text\">Key Factors in Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Heap-abstraction\"><span class=\"toc-text\">Heap abstraction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Allocation-Site-Abstraction\"><span class=\"toc-text\">Allocation-Site Abstraction</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-Sensitivity-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F\"><span class=\"toc-text\">Context Sensitivity(上下文敏感 )</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Flow-sensitivity\"><span class=\"toc-text\">Flow sensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Analysis-Scope\"><span class=\"toc-text\">Analysis Scope</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Analysis-in-this-course\"><span class=\"toc-text\">Pointer Analysis in this course</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Concerned-Statements\"><span class=\"toc-text\">Concerned Statements</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointers-in-Java\"><span class=\"toc-text\">Pointers in Java</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Affecting-Statements\"><span class=\"toc-text\">Pointer-Affecting Statements</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Foundations-%EF%BC%88I%EF%BC%89\"><span class=\"toc-text\">Pointer Analysis Foundations （I）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Point-Analysis-Rules\"><span class=\"toc-text\">Point Analysis: Rules</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Domains-and-Notations\"><span class=\"toc-text\">Domains and Notations</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Rules\"><span class=\"toc-text\">Rules</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-to-Implement-Pointer-Analysis\"><span class=\"toc-text\">How to Implement Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Flow-Graph-PFG\"><span class=\"toc-text\">Pointer Flow Graph(PFG)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PFG-Examples\"><span class=\"toc-text\">PFG Examples</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Implementing-Pointer-Analysis\"><span class=\"toc-text\">Implementing Pointer Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis%EF%BC%9AAlgorithms\"><span class=\"toc-text\">Pointer Analysis：Algorithms</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms%EF%BC%88%E8%AF%A5%E7%AE%97%E6%B3%95%E7%9B%AE%E5%89%8D%E4%B8%8D%E8%AE%BE%E8%AE%A1call-method%EF%BC%89\"><span class=\"toc-text\">Algorithms（该算法目前不设计call method）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Worklist\"><span class=\"toc-text\">Worklist</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Handling-of-New-and-Assign\"><span class=\"toc-text\">Handling of New and Assign</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Handling-of-Store-and-load\"><span class=\"toc-text\">Handling of Store and load</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms-Review\"><span class=\"toc-text\">Algorithms Review</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-2\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-with-Method-Calls\"><span class=\"toc-text\">Pointer Analysis with Method Calls</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rule\"><span class=\"toc-text\">Rule</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interprocedural-Pointer-Analysis\"><span class=\"toc-text\">Interprocedural Pointer Analysis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms\"><span class=\"toc-text\">Algorithms</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-3\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-3\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Context-Sensitivity\"><span class=\"toc-text\">Pointer Analysis Context Sensitivity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#problem-of-Context-Insensitive-Pointer-Analysis\"><span class=\"toc-text\">problem of Context-Insensitive  Pointer Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Imprecision-of-Context-Insensitivity-C-I\"><span class=\"toc-text\">Imprecision of Context Insensitivity (C.I.)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Context-Sensitivity-C-S\"><span class=\"toc-text\">Context Sensitivity (C.S.)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cloning-Based-Context-Sensitivity\"><span class=\"toc-text\">Cloning-Based Context Sensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-Sensitive-Heap\"><span class=\"toc-text\">Context-Sensitive Heap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-Exmaple\"><span class=\"toc-text\">An Exmaple</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#CS-but-no-CS-heap\"><span class=\"toc-text\">CS but no CS heap</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#C-I-C-S-heap\"><span class=\"toc-text\">C.I. + C.S heap</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Context-Sensitive-Pointer-Analysis-Rules\"><span class=\"toc-text\">Context Sensitive Pointer Analysis: Rules</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Domains\"><span class=\"toc-text\">Domains</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%884%E7%A7%8D%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%EF%BC%89\"><span class=\"toc-text\">Rules（4种基本语句）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Flow-Graph-with-C-S\"><span class=\"toc-text\">Pointer Flow Graph with C.S.</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-S-Pointer-Analysis-Algorithm\"><span class=\"toc-text\">C.S. Pointer Analysis Algorithm</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E5%B0%BD%E4%BA%8B%E5%AE%9C\"><span class=\"toc-text\">未尽事宜</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Context-Sensitivity-Variant\"><span class=\"toc-text\">Context Sensitivity Variant</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-insensitivity\"><span class=\"toc-text\">Context insensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-site-Sensitivity\"><span class=\"toc-text\">Call-site Sensitivity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-example-2\"><span class=\"toc-text\">An example</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#K-limiting-Context-Abstraction\"><span class=\"toc-text\">K-limiting Context Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Call-Site-Example\"><span class=\"toc-text\">1-Call-Site: Example</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#C-I-VS-C-S-1-Call-Site\"><span class=\"toc-text\">C.I. VS C.S.(1-Call-Site)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-Sensitivity\"><span class=\"toc-text\">Object Sensitivity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-Example-4\"><span class=\"toc-text\">An Example</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Call-Site-vs-Object-Sensitivity\"><span class=\"toc-text\">1-Call-Site vs Object Sensitivity</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-4\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Type-Sensitivity\"><span class=\"toc-text\">Type Sensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Type-vs-Object-Sensitivity\"><span class=\"toc-text\">Type vs Object Sensitivity</span></a></li></ol></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Scala_LazyList反序列化漏洞利用","uid":"de8b97b3b30ced078cc1db74c65885b4","slug":"Scala-LazyList反序列化漏洞利用","date":"2023-09-04T14:20:44.000Z","updated":"2023-09-05T07:28:19.649Z","comments":true,"path":"api/articles/Scala-LazyList反序列化漏洞利用.json","keywords":null,"cover":[],"text":"引言 Click to see more SCTF的hello java看了大佬们的wp，完全看不懂。最近的WMCTF，发现很多关于java反序列化的知识,决心要好好学一下java反序列化&#x2F;再回头看这道题，搜索到了大佬的复现博客，赶紧膜拜了一下。 参考博客基于LazyL...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"漏洞分析","slug":"漏洞分析","count":1,"path":"api/tags/漏洞分析.json"},{"name":"Scala","slug":"Scala","count":1,"path":"api/tags/Scala.json"},{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"wmctf","uid":"9b333f38efd344acbd675306690f4b47","slug":"wmctf","date":"2023-08-29T05:32:25.000Z","updated":"2023-10-18T09:28:22.561Z","comments":true,"path":"api/articles/wmctf.json","keywords":null,"cover":null,"text":" BOOT-INF目录：这个目录通常是在使用Spring Boot框架时出现的。它是用于打包可执行的JAR文件的特殊目录。在这个目录下，通常包含了应用程序的所有依赖项（JAR文件）和应用程序的类文件。这些类文件可以包括Spring Boot的启动类、配置类以及其他应用程序的自定义...","link":"","photos":[],"count_time":{"symbolsCount":462,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}