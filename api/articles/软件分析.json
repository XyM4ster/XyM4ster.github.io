{"title":"软件分析","uid":"16dae33580f19f4496bcfc3620372612","slug":"软件分析","date":"2023-10-08T02:25:41.000Z","updated":"2023-10-16T08:58:46.051Z","comments":true,"path":"api/articles/软件分析.json","keywords":null,"cover":[],"content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>学这个的起因是想入门一下模糊测试方向，跟着知乎的学习路线，学了这个课程</li>\n<li>谭老师和李老师讲的非常非常好</li>\n<li>兜兜转转学这个已经2个月了，感觉很多地方还是不是理解的很明白</li>\n</ul>\n<h1 id=\"Programming-Languages-PL\"><a href=\"#Programming-Languages-PL\" class=\"headerlink\" title=\"Programming Languages(PL)\"></a>Programming Languages(PL)</h1><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806164104535.png\" alt=\"image-20230806164104535\"></p>\n<ul>\n<li><p>在运行程序前，分析程序可能有的问题</p>\n</li>\n<li><p>静态分析是在编译时，在程序运行之前，判断一个程序是否满足一些性质</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806170110550.png\" alt=\"image-20230806170110550\"></p>\n<ul>\n<li><p>对于这些<code>interesting proverties</code>，比如是否有空指针，是不能直接被给出准确的答案的</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806170455433.png\" alt=\"image-20230806170455433\"></p>\n</li>\n<li><p>sound包括truth</p>\n</li>\n<li><p>complete爆出来的一定是truth</p>\n</li>\n</ul>\n<p>从上面可以发现没有perfect，所以要么妥协<code>soundness</code>，要么妥协<code>completeness</code></p>\n<p>妥协<code>soundness</code>就会产生漏报</p>\n<p>妥协<code>completeness</code>就会产生误报</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806170825386.png\" alt=\"image-20230806170825386\"></p>\n<ul>\n<li><p>所以 几乎所有的静态分析都是<code>sound</code>，意思就是能多报几个，即使里面有误报，也不漏报   </p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806171554556.png\" alt=\"image-20230806171554556\"></p>\n</li>\n<li><p>只有分析了 蓝色和 绿色两条路径，才能分析出 它是 not safe，所以要soundness</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806172413490.png\" alt=\"image-20230806172413490\"></p>\n</li>\n<li><p>第一种方法虽然准确度高，但是浪费内存</p>\n<p>确保soundness(准确度)，保证精度和速度的平衡</p>\n<p>第一步：先抽象</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806212413467.png\" alt=\"image-20230806212413467\"></p>\n<ul>\n<li>没有确定的值，用新的符号表示</li>\n</ul>\n<p>第二步：转换规则</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806212727117.png\" alt=\"image-20230806212727117\"></p>\n<p>第三步：根据上一步确定的规则计算</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806213040551.png\" alt=\"image-20230806213040551\"></p>\n<ul>\n<li>可以看出静态分析是有用的，但是由于是sound，over-approximated，  对于3来说就是误报，因为他是9</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806213435210.png\" alt=\"image-20230806213435210\"></p>\n<ul>\n<li><p>flow merge很重要，因为很难考虑所有情况</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806214553222.png\" alt=\"image-20230806214553222\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：静态分析和动态测试有什么不同？</strong></p>\n<ul>\n<li>静态分析是在程序编译时进行分析</li>\n</ul>\n<p>**Q2：soundness和completeness **</p>\n<ul>\n<li>静态分析不能直接给出准确的答案，要么是soundness，也就是过近似，包括很多结果，但是会误报</li>\n<li>要么是completeness，很精确，但是会漏报</li>\n<li>静态分析都是soundness</li>\n</ul>\n<p><strong>Q3：为什么静态分析需要soundness？</strong></p>\n<ul>\n<li>很显然他需要报出所有可能的结果</li>\n</ul>\n<p><strong>Q4：如何理解抽象和over-approximation？</strong></p>\n<p>如果想在程序运行前判断这个程序，那就需要对程序中的一些运算进行抽象，形成一定的规则来进行判断</p>\n<ul>\n<li>抽象之后的结果是尽可能满足所有情况的，对于特殊情况，就会有错误，所以是over-approximation</li>\n</ul>\n<h1 id=\"intermediate-representation\"><a href=\"#intermediate-representation\" class=\"headerlink\" title=\"intermediate representation\"></a>intermediate representation</h1><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807155037706.png\" alt=\"image-20230807155037706\"></p>\n<h2 id=\"Compiler\"><a href=\"#Compiler\" class=\"headerlink\" title=\"Compiler\"></a>Compiler</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807160151499.png\" alt=\"image-20230807160151499\"></p>\n<ul>\n<li><p>词法分析器（Scanner），结合正则表达式，通过词法分析（Lexical Analysis）将 source code 翻译为 token。</p>\n</li>\n<li><p>语法分析器（Parser），结合上下文无关文法（Context-Free Grammar），通过语法分析（Syntax Analysis），将 token 解析为抽象语法树（Abstract Syntax Tree, AST）</p>\n</li>\n<li><p>语义分析器（Type Checker），结合属性文法（Attribute Grammar），通过语义分析（Semantic Analysis），将 AST 解析为 decorated AST</p>\n</li>\n<li><p>Translator，将 decorated AST 翻译为生成三地址码这样的中间表示形式（Intermediate Representation, IR），并<strong>基于 IR 做静态分析</strong>（例如代码优化这样的工作）。</p>\n</li>\n</ul>\n<p>经过前面所有的处理生成 IR ，静态分析器 对 IR进行分析 </p>\n<h3 id=\"AST-vs-IR\"><a href=\"#AST-vs-IR\" class=\"headerlink\" title=\"AST vs IR\"></a>AST vs IR</h3><p><strong>为什么Compiler中用IR而不是AST呢</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807161223246.png\" alt=\"image-20230807161223246\"></p>\n<ul>\n<li>AST是high-level，接近语法结构的</li>\n<li>AST是依赖语言的</li>\n<li>AST适合快速的类型检查</li>\n<li>AST缺少控制流信息，IR中的go to可以轻易的看出控制流信息</li>\n</ul>\n<h2 id=\"IR-3AC\"><a href=\"#IR-3AC\" class=\"headerlink\" title=\"IR:3AC\"></a>IR:3AC</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807161524280.png\" alt=\"image-20230807161524280\"></p>\n<p><strong>为什么叫3地址码？</strong></p>\n<ul>\n<li>名称： a,b</li>\n<li>常量：3</li>\n<li>编译器生成的临时变量：t1,t2</li>\n</ul>\n<p>常见的 3AC 包括：</p>\n<ul>\n<li>x &#x3D; y bop z：双目运算并赋值，bop &#x3D; binary operator</li>\n<li>x &#x3D; uop z：单目运算并赋值，uop &#x3D; unary operator</li>\n<li>x &#x3D; y：直接赋值</li>\n<li>goto L：无条件跳转，L &#x3D; label</li>\n<li>if x goto L：条件跳转</li>\n<li>if x rop y goto L：包含了关系运算的条件跳转，rop &#x3D; relational operator</li>\n</ul>\n<h3 id=\"3AC-in-real-static-Analyzer-Soot\"><a href=\"#3AC-in-real-static-Analyzer-Soot\" class=\"headerlink\" title=\"3AC in real static Analyzer Soot\"></a>3AC in real static Analyzer Soot</h3><p>Soot是个静态分析的框架，其中的IR是Jimple</p>\n<p><strong>在Soot中，Java源代码首先被编译成Java字节码，然后将字节码转换为Jimple表示形式</strong></p>\n<p>Jimple：(Java Intermediate Language）是一种用于表示Java字节码的中间语言</p>\n<h2 id=\"jvm中的方法调用-（PL）\"><a href=\"#jvm中的方法调用-（PL）\" class=\"headerlink\" title=\"jvm中的方法调用:（PL）\"></a>jvm中的方法调用:（PL）</h2><ul>\n<li><p>invokespecial：call constructor, call superclass method(调用父类方法)，call private methods </p>\n</li>\n<li><p>invokevirtual：call  instance methods（virtual dispatch 动态分配）</p>\n</li>\n<li><p>invokeinterface：call static methods</p>\n</li>\n<li><p>method Signature：包含 class name（方法声明所在的类 ）  return type  method name(parameter1 type,parameter2 type)</p>\n</li>\n</ul>\n<p>下面是一些Jimple和对应的Java程序</p>\n<ol>\n<li><strong>方法调用</strong></li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809101253593.png\" alt=\"image-20230809101253593\"></p>\n<ul>\n<li>specialinvoke是在调用StringBuilder的构造器，void 表示没有返回值</li>\n</ul>\n<p><code>specialinvoke $r3.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();</code>  </p>\n<ul>\n<li>$r3表示临时变量，&lt;&gt;中的东西是method Signature, java.lang.StringBuilder就是所在的类, **&lt; init &gt;**是默认的构造函数</li>\n</ul>\n<p><code>$r3 = virtualinvoke $r3.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java, lang.String)&gt;(r1);</code></p>\n<ul>\n<li>是在$r3的基础上调用的方法， <code>$r3</code>是StringBuilder类，返回值是StringBuilder，调用append方法，java, lang.String是参数 类型</li>\n</ul>\n<ol start=\"2\">\n<li><strong>main方法调用</strong></li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809102623594.png\" alt=\"image-20230809102623594\"></p>\n<p>如果没给显示的构造函数，就会默认的生成一个构造函数</p>\n<ol start=\"3\">\n<li><strong>静态方法调用</strong></li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809105135545.png\" alt=\"image-20230809105135545\"></p>\n<p>clinit：一个类的静态初始化的函数，用于在类记载过程中执行类的初始化</p>\n<p>:::tips</p>\n<p>Java虚拟机加载一个类时，它会首先检查是否存在类的静态初始化代码块（<code>static &#123;&#125;</code>），如果存在，则将这些代码块的内容放入<code>&lt;clinit&gt;</code>方法中。<code>&lt;clinit&gt;</code>方法会在类首次使用之前被调用，确保类的静态初始化在使用之前完成</p>\n<p>:::</p>\n<h2 id=\"Static-Single-Assignment-SSA）静态单赋值\"><a href=\"#Static-Single-Assignment-SSA）静态单赋值\" class=\"headerlink\" title=\"Static Single Assignment(SSA）静态单赋值\"></a>Static Single Assignment(SSA）静态单赋值</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809105950556.png\" alt=\"image-20230809105950556\"></p>\n<ul>\n<li>也就是每次都用一个最新的变量</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809110000741.png\" alt=\"image-20230809110000741\"></p>\n<ul>\n<li>在merge的时候，会用$phi$，根据控制流的信息决定选择哪个变量</li>\n</ul>\n<h1 id=\"Control-Flow-Analysis\"><a href=\"#Control-Flow-Analysis\" class=\"headerlink\" title=\"Control Flow Analysis\"></a>Control Flow Analysis</h1><p>控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。</p>\n<ul>\n<li>需要构建Control Flow Graph(CFG)</li>\n<li>CFG的node可以是一个单独的3AC，但是更常见的是一个Basic Blocks</li>\n</ul>\n<h2 id=\"Basic-Blocks\"><a href=\"#Basic-Blocks\" class=\"headerlink\" title=\"Basic Blocks\"></a>Basic Blocks</h2><p>需要满足以下性质：</p>\n<ul>\n<li>只能从块的第一条指令进入</li>\n<li>只能从块的最后一条指令离开</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<ul>\n<li>这个算法逻辑感很强，值得反复考虑</li>\n</ul>\n\n</div>\n<h3 id=\"构建node\"><a href=\"#构建node\" class=\"headerlink\" title=\"构建node\"></a>构建node</h3><ul>\n<li>入口只有一个，就是开始的指令</li>\n<li>出口只有一个，就是结束的指令</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809111246762.png\" alt=\"image-20230809111246762\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809112035790.png\" alt=\"image-20230809112035790\"></p>\n<p>方法：</p>\n<ol>\n<li>决定P的leaders：</li>\n</ol>\n<ul>\n<li><p>程序的第一条指令是leader</p>\n</li>\n<li><p>goto指向的指令是leader</p>\n</li>\n<li><p>跳转指令的后一条指令是leader</p>\n</li>\n</ul>\n<p>例子：</p>\n<ul>\n<li><p>从这个可以看出 因为(3)是(12)的target，所以(3)就不能放到第一个bbs中，否则程序有两个入口</p>\n</li>\n<li><p>(4)接下来有可能跳转到(7)，所以(5)就不能加进来，否则程序有两个出口</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>构建P的基本快</li>\n</ol>\n<ul>\n<li>就是从一个leader开始，到下一个leader的前一条指令</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811225051270.png\" alt=\"image-20230811225051270\"></p>\n<h3 id=\"构建边\"><a href=\"#构建边\" class=\"headerlink\" title=\"构建边\"></a>构建边</h3><p>块A到块B有一条边当且仅当：</p>\n<ul>\n<li><p>A B之间有跳转，自然要添边</p>\n</li>\n<li><p>AB紧挨着，A块的最后一条指令紧挨着B的第一条指令</p>\n<ul>\n<li>这种AB之间需要一条边</li>\n<li>但是不能是无条件的跳转</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811225843258.png\" alt=\"image-20230811225843258\"></p>\n</li>\n</ul>\n<p>从上可知</p>\n<ul>\n<li>由j–&gt;i的变化，变成从A—&gt;B的变换，现在变成了粗粒度的，也就是说A B之间指令的变换，也不影响跳转了。(原来假设i  变成i + 1，那 j–&gt; i，也要变成 j –&gt;i + 1)</li>\n</ul>\n<h3 id=\"构建CFG\"><a href=\"#构建CFG\" class=\"headerlink\" title=\"构建CFG\"></a>构建CFG</h3><ul>\n<li>除了构建好的基本块，我们还会额外添加两个结点，「入口（Entry）」和「出口（Exit）」</li>\n<li>这两个结点不对应任何 IR</li>\n<li>如果一个基本块的最后一条指令会让程序离开这段 IR，那么这个基本块就会有一条边指向出口。</li>\n<li>但是可能有个很多return，也就可能有很多出边</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809115245878.png\" alt=\"image-20230809115245878\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809115553127.png\" alt=\"image-20230809115553127\"></p>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：compilers 和 static analyzers静态分析器的关系</strong></p>\n<ul>\n<li>编译器的作用是将source code转换成machine code</li>\n<li>该过程中间经过词法分析、语法分析，语义分析，形成IR，静态分析器对IR进行分析。</li>\n</ul>\n<p><strong>Q2：3AC</strong></p>\n<ul>\n<li>3地址码就是中间表示intermediate representation，就是在字节码 和 机器码中间的一种表示</li>\n<li>在soot中，源代码—-&gt;字节码—&gt;jimple（也就是java的IR，Java Intermediate Language）—&gt; 机器码</li>\n</ul>\n<p><strong>Q3：在IR的top中如何构建basic blocks？</strong></p>\n<ul>\n<li>首先一个basic block包含了该部分中最大的3AC，满足只有一个入口，和一个出口</li>\n<li>接着，按照规则构建node，构建边，最后加上Entry和exit，就形成了完整的CFG。</li>\n</ul>\n<h1 id=\"Data-Flow-Analysis\"><a href=\"#Data-Flow-Analysis\" class=\"headerlink\" title=\"Data Flow Analysis\"></a>Data Flow Analysis</h1><h2 id=\"Data-Flow-Analysis-1\"><a href=\"#Data-Flow-Analysis-1\" class=\"headerlink\" title=\"Data Flow Analysis\"></a>Data Flow Analysis</h2><p>数据流分析的核心：How data Flows on CFG？</p>\n<ul>\n<li><p>对数据的抽象( +  - T  unknown等)</p>\n</li>\n<li><p>Flows：根据分析的类型，做出合适的估算，应该是sound的</p>\n</li>\n<li><p>Node：数据如何transfer(转换函数)，比如 + - </p>\n</li>\n<li><p>Edges：控制流如何处理</p>\n</li>\n<li><p>CFG：一个程序</p>\n</li>\n</ul>\n<p>不同的数据流分析，有着不同的data abstraction, flow safe-approximation策略，transfer functions&amp;control-flow handlings。</p>\n<h2 id=\"Preliminaries-of-Data-Flow-Analysis\"><a href=\"#Preliminaries-of-Data-Flow-Analysis\" class=\"headerlink\" title=\"Preliminaries of Data Flow Analysis\"></a>Preliminaries of Data Flow Analysis</h2><h3 id=\"Input-and-Output-States\"><a href=\"#Input-and-Output-States\" class=\"headerlink\" title=\"Input and Output States\"></a>Input and Output States</h3><ul>\n<li>每一条IR的执行，都让状态从<strong>输入状态</strong>变成新的<strong>输出状态</strong></li>\n<li>输入&#x2F;输出状态与语句前&#x2F;后的 <strong>program point</strong> 相关联。</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811231809896.png\" alt=\"image-20230811231809896\"></p>\n<ul>\n<li>在数据流分析中，我们会把每个程序点关联一个数据值，代表从那一点中可观察到的抽象程序状态</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811232044640.png\" alt=\"image-20230811232044640\"></p>\n<ul>\n<li>从pp中观察到抽象的状态，并组成一个集合</li>\n</ul>\n<h3 id=\"关于转移方程约束的概念\"><a href=\"#关于转移方程约束的概念\" class=\"headerlink\" title=\"关于转移方程约束的概念\"></a>关于转移方程约束的概念</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811232328151.png\" alt=\"image-20230811232328151\"></p>\n<h3 id=\"关于控制流约束的概念\"><a href=\"#关于控制流约束的概念\" class=\"headerlink\" title=\"关于控制流约束的概念\"></a>关于控制流约束的概念</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811232718115.png\" alt=\"image-20230811232718115\"></p>\n<ul>\n<li>B的所有前驱的out的meet构成B的输入</li>\n</ul>\n<h2 id=\"Data-Flow-Analysis-Applications\"><a href=\"#Data-Flow-Analysis-Applications\" class=\"headerlink\" title=\"Data Flow Analysis Applications\"></a>Data Flow Analysis Applications</h2><h3 id=\"不会涉及到的概念\"><a href=\"#不会涉及到的概念\" class=\"headerlink\" title=\"不会涉及到的概念\"></a>不会涉及到的概念</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811033038211.png\" alt=\"image-20230811033038211\"></p>\n<ul>\n<li>首先不存在方法调用，讲的是函数内部的</li>\n<li>之后讲跨函数的</li>\n<li>变量不涉及引用，也就是没有两个变量指向一个空间，在指针分析中讲</li>\n</ul>\n<h3 id=\"Reaching-Definitions-Analysis\"><a href=\"#Reaching-Definitions-Analysis\" class=\"headerlink\" title=\"Reaching Definitions Analysis\"></a>Reaching Definitions Analysis</h3><p>may analysis: 理解成集合的union</p>\n<p>就是所有情况都得考虑，may be true的都被报出来</p>\n<p>也就是有一个是true就行，所以应该考虑所有的path，所以应该union</p>\n<p>must anaysis：理解成集合的交集^</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230810233602698.png\" alt=\"image-20230810233602698\"></p>\n<h4 id=\"Input-and-Output-States-1\"><a href=\"#Input-and-Output-States-1\" class=\"headerlink\" title=\"Input and Output States\"></a>Input and Output States</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230810233921862.png\" alt=\"image-20230810233921862\"></p>\n<p>绿色的是红色的抽象</p>\n<p>domain：值域</p>\n<p>对于程序中所有的in 和 out，找到一个solution,通过解析 safe-approximation中的约束规则，得出的solution 。这些约束规则基于transfer function(转换规则)，基于控制流信息</p>\n<p>通过解这些约束规则，得到solution</p>\n<ul>\n<li>用符号表示transer function</li>\n</ul>\n<h4 id=\"Transer-function\"><a href=\"#Transer-function\" class=\"headerlink\" title=\"Transer function\"></a>Transer function</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811032034914.png\" alt=\"image-20230811032034914\"></p>\n<p>对bbs中的每个执行f，那么最后得到的结果就是bss的transer function</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811032642576.png\" alt=\"image-20230811032642576\"></p>\n<p>反向的时候先执行 fsn的 transer function，再执行fsn-1，</p>\n<ul>\n<li>上面黄色的代表：B的所有前驱的out的meet构成B的in</li>\n<li>下面粉色的out：B的后继的in的meet</li>\n</ul>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>假定 x 有定值 d (<strong>definition</strong>)，如果存在一个路径，从紧随 d 的点到达某点 p，并且此路径上面没有 x 的其他定值点，则称 x 的定值 d 到达 (<strong>reaching</strong>) p。</li>\n<li>如果这条路径上有x的其他定值，我们就说x的这个定值被kill了</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811033559511.png\" alt=\"image-20230811033559511\"></p>\n<ul>\n<li><p>到达定值可以用来分析未定义的变量。例如，我们在程序入口为各变量引入一个 dummy 定值。当程序出口的某变量定值依然为 dummy，则我们可以认为该变量未被定义。</p>\n</li>\n<li><p>对于一条赋值语句 D: v &#x3D; x op y，该语句生成了 v 的一个定值 D，并杀死程序中其它对变量 v 定义的定值。</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024517653.png\" alt=\"image-20230812024517653\"></p>\n<p><strong>说人话：</strong></p>\n<p><strong>是在分析在程序中的某点，BBS中定义的一条语句是不是有意义的</strong></p>\n<p>对于第一次遍历(红字)</p>\n<ul>\n<li><p>比如对于B1的出口，定义的D1和D2都是有意义的</p>\n</li>\n<li><p>比如对于B2的出口，D1就没有意义，因为D4重新定义了y，所以要被Kill，D2、D3是有意义的。</p>\n<p>算法：</p>\n<ul>\n<li>该算法是检查程序的其他处有没有定义这个变量，如果定义了就kill掉</li>\n<li>因为路径中没经过的BBS，肯定没有定义过，所以是0，kill不kill无所谓</li>\n</ul>\n<p>理解：</p>\n<ul>\n<li>按照理解来说，可以检查这条路径上之前有没有定义过，但是这样可能比较麻烦</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"理解Reaching-Definitions-到达定值\"><a href=\"#理解Reaching-Definitions-到达定值\" class=\"headerlink\" title=\"理解Reaching Definitions(到达定值)\"></a>理解Reaching Definitions(到达定值)</h4><h4 id=\"Abstraction-用Di进行抽象\"><a href=\"#Abstraction-用Di进行抽象\" class=\"headerlink\" title=\"Abstraction(用Di进行抽象)\"></a>Abstraction(用Di进行抽象)</h4><ul>\n<li>程序中所有变量的定值</li>\n<li>能被一个 bit vectors表示</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811234620667.png\" alt=\"image-20230811234620667\"></p>\n<p>Transer function</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811234832713.png\" alt=\"image-20230811234832713\"></p>\n<ul>\n<li>从入口kill掉其他的定值，并加入新生成的定值</li>\n<li>v &#x3D; x op y，gen v, kill 其它所有的 v</li>\n</ul>\n<h4 id=\"Control-Flow\"><a href=\"#Control-Flow\" class=\"headerlink\" title=\"Control Flow\"></a>Control Flow</h4><p>按照本节最开始讲的一个完整的Data Flow Analysis的结构，需要对transer function的结果进行约束。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811235332766.png\" alt=\"image-20230811235332766\"></p>\n<h4 id=\"Algorithm-of-Reaching-Definition-Analysis\"><a href=\"#Algorithm-of-Reaching-Definition-Analysis\" class=\"headerlink\" title=\"Algorithm of Reaching Definition Analysis\"></a>Algorithm of Reaching Definition Analysis</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811042913200.png\" alt=\"image-20230811042913200\"></p>\n<ul>\n<li><p>首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。</p>\n</li>\n<li><p>当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，需要修改各 BB 的 IN 和 OUT。</p>\n</li>\n<li><p>最终结果就是绿色的，例如b5是0011 1011，也就表示D3 D4 D5 D6 D7会流到B5结束的位置</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024517653.png\" alt=\"image-20230812024517653\"></p>\n</li>\n<li><p>在每个数据流分析中，我们把pp和一个数据流的值相关联，代表可以从这点观察到的所有可能的抽象状态。</p>\n</li>\n<li><p>通过不停的用transer function和control flow，不停的解和算，直到找到一个solution。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024739528.png\" alt=\"image-20230812024739528\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024725322.png\" alt=\"image-20230812024725322\"></p>\n</li>\n</ul>\n<p><strong>为什么程序会停止？</strong></p>\n<ul>\n<li><p>程序会继续运行，是因为有的bbs变化了，说明有循环，也就是下面这种情况，一i那位如果程序都是顺序执行，就不会有bbs变化，所以一定会停止</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812030831779.png\" alt=\"image-20230812030831779\"></p>\n</li>\n<li><p>某一点有可能从0 —&gt; 0，有可能从0 —&gt;1，也有可能从1 —-&gt;1，但是不可能从1—&gt;0，所以程序一定会停止</p>\n</li>\n</ul>\n<p><strong>为什么不会从1—&gt;0？</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812031148958.png\" alt=\"image-20230812031148958\"></p>\n<ul>\n<li>假设最终从红色快Di&#x3D;1，流入S，红色框中这一位能是1，说明从S中出来时，这一位就是1，否则不能流到红色框处</li>\n<li>那上次出来是1，说明没有被Kill掉，这次肯定也不会被kill，也可以说，水都流到这了，一定可以流出去</li>\n</ul>\n<h3 id=\"Live-Variables-Analysis（活跃变量分析）\"><a href=\"#Live-Variables-Analysis（活跃变量分析）\" class=\"headerlink\" title=\"Live Variables Analysis（活跃变量分析）\"></a>Live Variables Analysis（活跃变量分析）</h3><ul>\n<li>沿着p有一条路径，活跃变量分析分析p处的v是不是alive</li>\n<li>换句话说：后面use的v是不是我在p处定义的v，如果是，说明p在v处是alive的，也就是是有效的</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<p><strong>活跃变量分析是在分析在该点处定义的变量有没有被使用，是不是废物变量</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812070750920.png\" alt=\"image-20230812070750920\"></p>\n<h4 id=\"Abstraction\"><a href=\"#Abstraction\" class=\"headerlink\" title=\"Abstraction\"></a>Abstraction</h4><ul>\n<li><p>用第i个bit表示vi</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812071415418.png\" alt=\"image-20230812071415418\"></p>\n</li>\n</ul>\n<p><strong>程序应该是forward的还是backward？</strong></p>\n<p>这里想探究的问题是变量是否是live？</p>\n<p>因为想知道在某一点是不是alive的，所以你得走到最后，才能知道，因为你不知道中间是否有重定义</p>\n<ul>\n<li>所以要从后往前来比较方便</li>\n</ul>\n<h4 id=\"Control-flow\"><a href=\"#Control-flow\" class=\"headerlink\" title=\"Control flow\"></a>Control flow</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812225343496.png\" alt=\"image-20230812225343496\"></p>\n<h4 id=\"Transer-function-1\"><a href=\"#Transer-function-1\" class=\"headerlink\" title=\"Transer function\"></a>Transer function</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812224629538.png\" alt=\"image-20230812224629538\"></p>\n<p>首先程序是Backward，已知out求in</p>\n<p><strong>问题1 ：这里的out为什么是union</strong></p>\n<ul>\n<li>因为无论s1 use v 还是s2 use v，Out[B]都等于1</li>\n<li>也就是下面有一条路径是活跃的用了v，在B的in处，都是alive的</li>\n</ul>\n<p><strong>问题2：如何求出IN[B]</strong></p>\n<p>我的考虑：</p>\n<ul>\n<li>如果B中对v进行了重新定义，IN[B]就为0</li>\n<li>所以out[b]-kill[b]</li>\n<li>我没有考虑完全所有的情况</li>\n</ul>\n<p>算法：</p>\n<ul>\n<li>首先枚举所有可能的情况</li>\n<li>如果v在B中被重定义了，就应该out[b]-def_b，但是如果在重定义之前，使用了v，in[B]仍然为1，所以将两种情况合并，得到结果</li>\n<li>这里也可以直观的感受为什么程序是backward</li>\n</ul>\n<h4 id=\"Alogrithm-of-live-variables-Analysis\"><a href=\"#Alogrithm-of-live-variables-Analysis\" class=\"headerlink\" title=\"Alogrithm of live variables Analysis\"></a>Alogrithm of live variables Analysis</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812225519212.png\" alt=\"image-20230812225519212\"></p>\n<p><strong>问题1：为什么初始化为空？</strong></p>\n<ul>\n<li>may analysis初始化一般为空，must analysis初始化为all</li>\n</ul>\n<p>最终结果：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812232036968.png\" alt=\"image-20230812232036968\"></p>\n<h3 id=\"Available-Expressions-Analysis\"><a href=\"#Available-Expressions-Analysis\" class=\"headerlink\" title=\"Available Expressions Analysis\"></a>Available Expressions Analysis</h3><p>它是must analysis</p>\n<h4 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223059162.png\" alt=\"image-20230813223059162\"></p>\n<p>x op y 在 p 点可用的条件：</p>\n<ul>\n<li>从流图入口结点到达 p 的每条路径都对 x op y 求了值，</li>\n<li>且在最后一次求值之后再没有对 x 或 y 赋值</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<ul>\n<li><p>是在分析表达式(x &#x3D; y+3   表达式是y + 3)有没有意义，是不是白算,看是否所有路径都求了，也就是如果都求了，结果是1，那就可以被替换</p>\n</li>\n<li><p>也就是如果最后一次算y +3，后面还有对y的重新赋值，那你算的y + 3没有意义</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813231942248.png\" alt=\"image-20230813231942248\"></p>\n</li>\n</ul>\n<p>对于程序的最终结果，蓝色部分来说</p>\n<ul>\n<li>表达式p-1就没有意义，因为p在B2处被重定义了</li>\n<li>表达式z&#x2F;5有意义</li>\n<li>表达式2*y没有意义，在B5中y被重定义了</li>\n<li>表达式e7 *x有意义</li>\n<li>表达式y + 3没有意义</li>\n</ul>\n<p>他的最终目的是优化表达式：有意义的可以用同一个变量替换，省的重复计算</p>\n<h4 id=\"Abstraction-1\"><a href=\"#Abstraction-1\" class=\"headerlink\" title=\"Abstraction\"></a>Abstraction</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813222348767.png\" alt=\"image-20230813222348767\"></p>\n<ul>\n<li>0代表在这一点不是Available</li>\n</ul>\n<h4 id=\"Transer-function-Control-flow\"><a href=\"#Transer-function-Control-flow\" class=\"headerlink\" title=\"Transer function &amp; Control flow\"></a>Transer function &amp; Control flow</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223502406.png\" alt=\"image-20230813223502406\"></p>\n<ul>\n<li>生成新的表达式：x op y</li>\n<li>kill掉引用了变量a的表达式{a + b}</li>\n<li>最后得到{x op y}</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223436635.png\" alt=\"image-20230813223436635\"></p>\n<p>在黄色这点，该表达式是avaliable的</p>\n<ul>\n<li>可以根据定义判断<ul>\n<li>每一条路径都计算了 e16 * x</li>\n<li>在表达式的最后(last evaluation)y也就是b语句，没有对x重定义</li>\n</ul>\n</li>\n<li>用上面的transerfunction判断<ul>\n<li>到x &#x3D; …处时，e16 * x被kill</li>\n<li>到b处，又生成了e16 * x</li>\n<li>两条路径都有e16 * x，所以是avaliable</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223930416.png\" alt=\"image-20230813223930416\"></p>\n<ul>\n<li>因此，上面的可以被优化成全部用t替换</li>\n<li>到整个程序的最后一条语句时，不用再对t进行计算，因为Last evaluation已经计算过了</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224059470.png\" alt=\"image-20230813224059470\"></p>\n<p><strong>问题1：为什么是交？</strong></p>\n<ul>\n<li>因为需要所有的path都计算last evaluation，需要取一个最终的结果</li>\n</ul>\n<p>假设有一条path如果是1的话，另一条path是0，那这个表达式是否是avaliable呢？</p>\n<ul>\n<li>因为要safe，所以它有可能是不可达的，所以那就要认为是不可达的</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813231002042.png\" alt=\"image-20230813231002042\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224456551.png\" alt=\"image-20230813224456551\"></p>\n<ul>\n<li>看这个小绿箭头和绿方框， z &#x2F; 5这个表达式有可能是不avalable的，所以要取交，认为他是0</li>\n</ul>\n<p><strong>问题2：如何理解under approximation？</strong></p>\n<ul>\n<li><p>也就是它可能会有漏报</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224537845.png\" alt=\"image-20230813224537845\"></p>\n</li>\n<li><p>对于这种情况，按照上面的transer function，到c表达式的In的地方，显然{e16 * x}不是avaliable</p>\n</li>\n<li><p>所以在c处要重新计算</p>\n</li>\n</ul>\n<p>但是有可能上面的x和重定义的x都等于3</p>\n<ul>\n<li>这种情况下，也就是可以把c处进行优化，就是不用再重新计算了</li>\n</ul>\n<p><strong>但是按照transer function，我并没有产生误报，只是没有优化，并不影响程序的执行</strong></p>\n<h4 id=\"Alogrithm-of-Available-Expressions-Analysis\"><a href=\"#Alogrithm-of-Available-Expressions-Analysis\" class=\"headerlink\" title=\"Alogrithm of Available Expressions Analysis\"></a>Alogrithm of Available Expressions Analysis</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224942134.png\" alt=\"image-20230813224942134\"></p>\n<p><strong>问题1：为什么OUT[B]的初始化是all(都是1)</strong></p>\n<p>按照现在的理解</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813225518326.png\" alt=\"image-20230813225518326\"></p>\n<ul>\n<li>根据这个图，如果初始化是0的话，也就是此时红色框处的输入就变成了00000，那我上一步做的就没有意义了，p-1此时一定是avaliable的</li>\n<li>因为是交，所以为了保留原来的结果，一定得是11111</li>\n</ul>\n<p>musy analysis 初始化一般都是all</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813231942248.png\" alt=\"image-20230813231942248\"></p>\n<h2 id=\"Analysis-Comparison\"><a href=\"#Analysis-Comparison\" class=\"headerlink\" title=\"Analysis Comparison\"></a>Analysis Comparison</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>Reaching Definitons</th>\n<th>Live Variables</th>\n<th>Avaliable Expressions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Domain</td>\n<td>definitions的集合</td>\n<td>variables的集合</td>\n<td>expressions的集合</td>\n</tr>\n<tr>\n<td>Direction</td>\n<td>forward（会不会path）</td>\n<td>backward(后面有没有use)</td>\n<td>forward（所有的Path有没有evaluation）</td>\n</tr>\n<tr>\n<td>May&#x2F;Must</td>\n<td>May analysis</td>\n<td>May analysis</td>\n<td>Must Analysis</td>\n</tr>\n<tr>\n<td>Boundary（边界）</td>\n<td>out[entry]&#x3D;null</td>\n<td>in[exit]&#x3D;null</td>\n<td>out[entry]&#x3D;null</td>\n</tr>\n<tr>\n<td>Initialization</td>\n<td>out&#x3D;null</td>\n<td>in&#x3D;null</td>\n<td>out&#x3D;all</td>\n</tr>\n<tr>\n<td>Transer function</td>\n<td>out &#x3D; gen U (in - kill)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Meet</td>\n<td>并</td>\n<td>并</td>\n<td>交</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>根据含义去确定Boundary(边界)</p>\n<ul>\n<li>inialization：对于到达性分析，entry都没有定义Di，所以out[entry]一定是null</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<p>Reaching Definitions：</p>\n<ul>\n<li>分析在BBS中写的语句，例如 x &#x3D; y + 3，对于程序中的某点，有没有意义</li>\n<li>初始化时所有的Out都是0，是May analysis，因为有一条路径定义了一个Di，那么对于下一个bbs的输入，他是有意义的</li>\n</ul>\n<p>Live Variables Analysis：</p>\n<ul>\n<li>分析在某点如果定义了这个变量，对程序中的某点，有没有意义。</li>\n<li>初始化所有的in是0，是may analysis</li>\n</ul>\n<p>Available Expressions：</p>\n<ul>\n<li>分析定义的表达式：x &#x3D; y +3中的y + 3，对于程序中的某点，有没有意义</li>\n</ul>\n<p><strong>另一方面的理解</strong></p>\n<ul>\n<li>对于may analysis，是并，也就是有一条路径满足就行，那对于加法操作，初始化一定是0</li>\n<li>对于must analysis，是交，必须所有路径都满足，那对于乘法操作，初始化一定是1</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231007111124310.png\" alt=\"image-20231007111124310\"></p>\n<h2 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：理解三个数据流分析</strong></p>\n<ul>\n<li>首先数据流分析只分析一个函数内部的，不涉及到方法调用，也不涉及到两个变量指向同一个空间</li>\n<li>关于到达定制分析，活跃变量分析，可用表达式分析，看上面那个图的总结</li>\n</ul>\n<p><strong>Q3：理解迭代算法，以及为什么他能终止</strong></p>\n<ul>\n<li>迭代算法由transer function和约束条件组成，程序的结果会从0–&gt;1   1–&gt;1  0—&gt;0，不会从1–&gt;0，所以当所有的块不再改变时，程序就终止了</li>\n</ul>\n<h1 id=\"Data-Flow-Analysis-Foundations\"><a href=\"#Data-Flow-Analysis-Foundations\" class=\"headerlink\" title=\"Data Flow Analysis Foundations\"></a>Data Flow Analysis Foundations</h1><h2 id=\"iterative-algorithms（迭代算法）\"><a href=\"#iterative-algorithms（迭代算法）\" class=\"headerlink\" title=\"iterative algorithms（迭代算法）\"></a>iterative algorithms（迭代算法）</h2><ul>\n<li>对于数据流分析，迭代算法生成了一个solution，也就是01组成的串</li>\n</ul>\n<h3 id=\"view-itrative-algorithm-in-another-way\"><a href=\"#view-itrative-algorithm-in-another-way\" class=\"headerlink\" title=\"view itrative algorithm in another way\"></a>view itrative algorithm in another way</h3><ul>\n<li><p>对于一个有k个nodes的CFG，迭代算法在每次迭代时，更新每个节点的Out</p>\n</li>\n<li><p>假设数据流分析的值域是V，那么可以定义一个K个元素的元组(k-tuple)</p>\n<p>$$(Out[n_1],Out[n_2],…Out[n_k]$$\t</p>\n<p>也就是一个集合$$(V_1*V_2…V_n)$$,定义这个集合为$$V^k$$在每次迭代后，保存新的值</p>\n</li>\n<li><p>每次迭代都是通过应用transer function 和control flow, 把一个map $$V^k$$变成一个新的map$$V^k$$，整个过程可以抽象为：</p>\n<p>$$F : V^k -&gt;V^k$$</p>\n</li>\n<li><p>该算法输出一系列的k-tuples，直到每个node的output不再变化</p>\n</li>\n</ul>\n<h3 id=\"图示形式：\"><a href=\"#图示形式：\" class=\"headerlink\" title=\"图示形式：\"></a><strong>图示形式：</strong></h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814224716717.png\" alt=\"image-20230814224716717\"></p>\n<ul>\n<li>对于这个算法，绿色部分就对应上面的F 函数</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814224856721.png\" alt=\"image-20230814224856721\"></p>\n<ul>\n<li>也就是初始化时init 都为空，接着进行迭代</li>\n<li>令第一次的结果为$X_0$，$$X_1 &#x3D; F(X_0)$$</li>\n<li>最终不变时，达到的结果是$$X_i &#x3D; F(X_i)$$</li>\n<li>此时程序输入的是$X_i$，输出的也是$X_i$，也就是这个iterative algorithm达到了一个不动点(fixed point)</li>\n</ul>\n<h3 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h3><p>这个iterative alogrithm 是对于data flow analysis生成一个solution</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814225526811.png\" alt=\"image-20230814225526811\"></p>\n<ul>\n<li>这个程序一定会达到不动点么？</li>\n<li>如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢</li>\n<li>我们的算法要经过多少步达到不动点</li>\n</ul>\n<h2 id=\"partial-order（偏序）\"><a href=\"#partial-order（偏序）\" class=\"headerlink\" title=\"partial order（偏序）\"></a>partial order（偏序）</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814230238252.png\" alt=\"image-20230814230238252\"></p>\n<ul>\n<li>定义了一个偏序集(poset)，用pair表示，，P是一个集合，后面的符号(统称为&lt;&#x3D;)是偏序关系，如果集合中的元素满足上面的三条性质(自反性、反对称性、传递性)，就构成P上的偏序集合</li>\n</ul>\n<p><strong>例1：S是一个整数集，符号是小于等于</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814230845398.png\" alt=\"image-20230814230845398\"></p>\n<ul>\n<li>满足三条性质，构成偏序集</li>\n</ul>\n<p><strong>例2：S是一个整数集，符号是小于</strong></p>\n<ul>\n<li>显然不构成 1 &lt; 1 2 &lt; 2是错的</li>\n</ul>\n<p><strong>例3：S是一系列(下图)英文单词的集合，符号表示substring，s1&lt;&#x3D;s2，表示s1是s2的子串</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814231120660.png\" alt=\"image-20230814231120660\"></p>\n<p><strong>例4：S是{a,b,c}的幂集，符号表示子集</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815000131924.png\" alt=\"image-20230815000131924\"></p>\n<p><strong>理解偏序(partial)的含义</strong></p>\n<ul>\n<li>意味着不是集合中的每对元素都要满足给定的关系(符号 &lt;&#x3D;)</li>\n<li>比如上面的 pin 和 sin就不满足</li>\n</ul>\n<h3 id=\"Upper-and-Lower-Bounds-上下界\"><a href=\"#Upper-and-Lower-Bounds-上下界\" class=\"headerlink\" title=\"Upper and Lower Bounds(上下界)\"></a>Upper and Lower Bounds(上下界)</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814232015644.png\" alt=\"image-20230814232015644\"></p>\n<p>这玩意不就是高中数学</p>\n<ul>\n<li><p>u是S的upper bound，也就是S中的所有元素都$\\subseteq$u</p>\n</li>\n<li><p>l是S的lower bound，也就是l$\\subseteq$S中的所有元素</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814232727105.png\" alt=\"image-20230814232727105\"></p>\n<ul>\n<li>对于这个集合来说，显然upper是{a,b,c}，lower是{}</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814234635753.png\" alt=\"image-20230814234635753\">                                            </p>\n<ul>\n<li>最小上界(lub  or  join)：l_lS</li>\n<li>最大下界：(glb or meet)</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814234811170.png\" alt=\"image-20230814234811170\"></p>\n<p>如果只包含两个元素</p>\n<ul>\n<li>lub：a l_l  b  也就是 a join b，就是a并b</li>\n<li>glb： 也就是a meet b，就是 a 交 b</li>\n</ul>\n<h3 id=\"Some-Properties\"><a href=\"#Some-Properties\" class=\"headerlink\" title=\"Some  Properties\"></a>Some  Properties</h3><ul>\n<li>不是每个偏序集都有glb 或者 lub</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814235206315.png\" alt=\"image-20230814235206315\"></p>\n<ul>\n<li>如果一个Poset有lub 和 glb，那一定都是唯一的</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814235220480.png\" alt=\"image-20230814235220480\"></p>\n<h2 id=\"Lattice\"><a href=\"#Lattice\" class=\"headerlink\" title=\"Lattice\"></a>Lattice</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814235430059.png\" alt=\"image-20230814235430059\"></p>\n<ul>\n<li>偏序集中的每两个元素，都有它的最大下界和最小上界，这个偏序集被称为一个lattice</li>\n</ul>\n<p>上面的例3，显然不构成lattice，pin和sin在集合中找不到最小上界</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815000813488.png\" alt=\"image-20230815000813488\"></p>\n<h3 id=\"Complete-Lattice\"><a href=\"#Complete-Lattice\" class=\"headerlink\" title=\"Complete Lattice\"></a>Complete Lattice</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815000917322.png\" alt=\"image-20230815000917322\"></p>\n<ul>\n<li>给定一个lattice P和它的任意一个子集S，如果joinS和meet S(S中可能不只两个元素a b)存在，那么P是一个complete lattice</li>\n</ul>\n<p><strong>说人话：一个lattice的所有子集都lub和glb</strong></p>\n<ul>\n<li>lattice是任意两个元素都有glb和lub，complete lattice是任意一个子集</li>\n</ul>\n<p>\t</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815002153942.png\" alt=\"image-20230815002153942\"></p>\n<ul>\n<li>正整数集是无穷的，没有边界，所以不是complete lattice</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815001747514.png\" alt=\"image-20230815001747514\"></p>\n<ul>\n<li>对于这个幂集，它是complete lattice，假设子集是{a,b}，虽然glb和lub不在subset中，但是在lattice中</li>\n</ul>\n<p><strong>Bounds可以不在subset中，但是要在lattice</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815002015994.png\" alt=\"image-20230815002015994\"></p>\n<ul>\n<li>每一个complete lattice，都有一个top和bottom</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815002412780.png\" alt=\"image-20230815002412780\"></p>\n<ul>\n<li>每个有穷的lattice都是complete lattice</li>\n</ul>\n<h3 id=\"Product-Lattice\"><a href=\"#Product-Lattice\" class=\"headerlink\" title=\"Product Lattice\"></a>Product Lattice</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815004328353.png\" alt=\"image-20230815004328353\"></p>\n<ul>\n<li>给定一系列lattice，如果对于每一个偏序集，都有最小上界和最大下届，这些所有的偏序集就构成一个product lattice$$L^n &#x3D; (P,\\subseteq)$$</li>\n</ul>\n<p>这个product lattice被定义为：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815004340746.png\" alt=\"image-20230815004340746\"></p>\n<ul>\n<li>一个product lattice是一个lattice</li>\n<li>如果构成product lattice的每一个lattice都是complete lattice，那么这个product lattice也是complete lattice</li>\n</ul>\n<h2 id=\"Data-Flow-Analysis-Framework-via-Lattice\"><a href=\"#Data-Flow-Analysis-Framework-via-Lattice\" class=\"headerlink\" title=\"Data Flow Analysis Framework via Lattice\"></a>Data Flow Analysis Framework via Lattice</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815005117066.png\" alt=\"image-20230815005117066\"></p>\n<ul>\n<li>D：forward还是backward</li>\n<li>L：包括domain和operator</li>\n<li>F：一系列的从V 到V的transfer functions</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815005323828.png\" alt=\"image-20230815005323828\"></p>\n<ul>\n<li>可以看到，右边的图(may analysis)是从bottom往上走的</li>\n</ul>\n<p><strong>data flow analysis可以看成对lattice的值迭代的使用transfer functions和meet&#x2F;join operations</strong></p>\n<h2 id=\"Monotonicity（单调性）\"><a href=\"#Monotonicity（单调性）\" class=\"headerlink\" title=\"Monotonicity（单调性）\"></a>Monotonicity（单调性）</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815010435910.png\" alt=\"image-20230815010435910\"></p>\n<ul>\n<li>L是一个lattice，if 任意的x y属于L, $$x \\subseteq y$$，f(x)$\\subseteq$f(y)</li>\n</ul>\n<h3 id=\"Fixed-Point-Theorem-不动点定理\"><a href=\"#Fixed-Point-Theorem-不动点定理\" class=\"headerlink\" title=\"Fixed-Point Theorem(不动点定理)\"></a>Fixed-Point Theorem(不动点定理)</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815010934815.png\" alt=\"image-20230815010934815\"></p>\n<p>L是单调的，且L是有穷的，那么最小不动点和最大不动点能通过迭代求出来</p>\n<ol>\n<li><p>求最小不动点：第一次用bottom作为输入，得到f(bottom)，再把f(bottom)作为下一次的输入，直到求出一个不动点，这个不动点就是最小不动点</p>\n</li>\n<li><p>求最大不动点：第一次用top作为输入，得到f(top)，再把f(top)作为下一次的输入，直到求出一个不动点，这个不动点就是最大不动点</p>\n</li>\n</ol>\n<h4 id=\"证明不动点\"><a href=\"#证明不动点\" class=\"headerlink\" title=\"证明不动点\"></a>证明不动点</h4><h5 id=\"Existence-of-Fixed-Point\"><a href=\"#Existence-of-Fixed-Point\" class=\"headerlink\" title=\"Existence of Fixed Point\"></a>Existence of Fixed Point</h5><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815024144513.png\" alt=\"image-20230815024144513\"></p>\n<ul>\n<li>首先定义一个bottom，f(bottom）就是对bottom进行transer funtion变换，可以理解为右下的图，从{}走到了{a}</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815005323828.png\" alt=\"image-20230815005323828\"></p>\n<ul>\n<li>因为f是单调的，所以 f(bottom)$\\sqsubseteq$f(f((bottom))，一直到$f^i(bottom)$</li>\n<li>那由于L是有穷的(程序最终的111…111)，假设最终值是$f^H(bottom)$，此时再对他进行transer function，就不会变了(因为1不会变成0？)</li>\n<li>从下面gitbook的证明看出来，和我想的一样，但是这个ppt上的证明我属实没看懂</li>\n</ul>\n<p><strong>gitbook的证明：</strong></p>\n<p>根据$\\bot$和f的定义，我们可以得到：$\\bot \\sqsubseteq f(\\bot)$。</p>\n<p>由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\\bot \\sqsubseteq f(\\bot) \\sqsubseteq f^2(\\bot)\\sqsubseteq …\\sqsubseteq f^k(\\bot)\\sqsubseteq f^{k+1}(\\bot) $，且$f^k(\\bot) &#x3D; f^{k+1}(\\bot)$。</p>\n<h5 id=\"Least-Fixed-Point\"><a href=\"#Least-Fixed-Point\" class=\"headerlink\" title=\"Least Fixed Point\"></a>Least Fixed Point</h5><p><strong>gitbook的证明：(通俗易懂，ppt上写的我没看懂)</strong></p>\n<p>假设我们有另一个任意不动点 x，由于 f 是单调的，因此$f(\\bot) \\sqsubseteq f(x), f^2(\\bot) \\sqsubseteq f^2(x),…,f^{Fix} &#x3D; f^k(\\bot)\\sqsubseteq f^k(x) &#x3D; x$</p>\n<p>可知的确$f^{Fix}$是最小不动点。</p>\n<p><strong>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。</strong></p>\n<h1 id=\"Data-Flow-Analysis-Foundations-II\"><a href=\"#Data-Flow-Analysis-Foundations-II\" class=\"headerlink\" title=\"Data Flow Analysis Foundations II\"></a>Data Flow Analysis Foundations II</h1><h2 id=\"Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\"><a href=\"#Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\" class=\"headerlink\" title=\"Relate Iterative Algorithm to Fix-ed Point Theorem\"></a>Relate Iterative Algorithm to Fix-ed Point Theorem</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816061430910.png\" alt=\"image-20230816061430910\"></p>\n<p><strong>问题1：这两个怎么联系起来呢</strong>？</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816061010705.png\" alt=\"image-20230816061010705\"></p>\n<p><strong>第一步：确定product lattice，且是finite</strong></p>\n<ul>\n<li><p>这里的每一个节点都对应一个Lattice。假设他是reaching definitions，假设有3个变量D1 D2 D3</p>\n</li>\n<li><p>他的domain一定是(0,0,0)  … …. (D1,D2,D3)</p>\n</li>\n<li><p>所以它是lattice</p>\n</li>\n<li><p>每一个lattice都是finite，所以整体也是finite</p>\n</li>\n</ul>\n<p><strong>第二步：确定 f: L -&gt; L 是单调的</strong></p>\n<p>对于iterative algotithm来说，f相当于control flow和transer function</p>\n<ul>\n<li>因为 transer function**(OUT &#x3D; gen U (IN - kill))**的结果一定是从0 到1，不会从1到0 ，所以是单调的</li>\n</ul>\n<p>现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L</p>\n<ul>\n<li>即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $</li>\n</ul>\n<p>单调的定义是：x&lt; y, f(x) &lt; f(y)，这里的meet就相当于f</p>\n<ul>\n<li>根据定义， $y\\sqsubseteq y\\sqcup  z$，因为y meet z是least upper bound </li>\n<li>所以 $x\\sqsubseteq y\\sqcup  z$，这里证明$y\\sqcup  z$是x的上界</li>\n<li>又因为 $x\\sqsubseteq x\\sqcup  z$，且 $x \\sqcup z$是x的least upper bound</li>\n<li>所以 $x \\sqcup z\\sqsubseteq y\\sqcup  z$</li>\n</ul>\n<p>到这里可以把不动点定理应用到iterative algorithm中</p>\n<p><strong>这个证明我现在不是很懂，那是不是说明 x meet y也小于等于 y meet z呢</strong></p>\n<h2 id=\"Review-the-questions\"><a href=\"#Review-the-questions\" class=\"headerlink\" title=\"Review the questions\"></a>Review the questions</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814225526811.png\" alt=\"image-20230814225526811\"></p>\n<ul>\n<li><p>这个程序一定会达到不动点么？<strong>会，根据不动点定理</strong></p>\n</li>\n<li><p>如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢？<strong>greatest or least fixed point</strong></p>\n</li>\n<li><p>我们的算法要经过多少步达到不动点? </p>\n<p><strong>最坏情况是：h*k</strong></p>\n</li>\n</ul>\n<h2 id=\"When-will-the-algorithm-reach-the-fixed-point？\"><a href=\"#When-will-the-algorithm-reach-the-fixed-point？\" class=\"headerlink\" title=\"When will the algorithm reach the fixed point？\"></a>When will the algorithm reach the fixed point？</h2><ul>\n<li>lattice的高度：lattice中从bottom到top最长的path</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816063329661.png\" alt=\"image-20230816063329661\"></p>\n<ul>\n<li>假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 $i &#x3D; h \\times k$</li>\n<li>这也回答了上面最后一个问题</li>\n</ul>\n<h2 id=\"May-and-Must-Analysis-a-Lattice-View\"><a href=\"#May-and-Must-Analysis-a-Lattice-View\" class=\"headerlink\" title=\"May and Must Analysis , a Lattice View\"></a>May and Must Analysis , a Lattice View</h2><ul>\n<li>都是从unsafe 向safe 走，</li>\n</ul>\n<h3 id=\"May-Analysis-View\"><a href=\"#May-Analysis-View\" class=\"headerlink\" title=\"May  Analysis View\"></a>May  Analysis View</h3><p>将lattice抽象成一个视图</p>\n<p>例如，对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。</p>\n<p>目标：我们的目标是在程序运行后，找到一个可以替换的变量(优化)，<strong>也就是看最终哪个是0</strong>，如果是0的就可以被替换。</p>\n<p>那么在初始化的时候，用反证法要要求所有的都是0，然后找出不是0的。</p>\n<p>目标是找到可以替换的变量。</p>\n<ul>\n<li>下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换，所有都能替换。**—-&gt;对应sound**</li>\n<li>上界代表 safe but useless 的情绪，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义，也就是所有的都不能替换。</li>\n</ul>\n<p>而因为我们采用了 join 函数，那么我们必然会从 lattice 的最小下界往上走。而越往上走，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816071341859.png\" alt=\"image-20230816071341859\"></p>\n<h3 id=\"Must-Analysis-View\"><a href=\"#Must-Analysis-View\" class=\"headerlink\" title=\"Must Analysis View\"></a>Must Analysis View</h3><p>目标：找到最终表达式结果是1的，是1的就不用重复计算了，可以替换</p>\n<p><strong>那初始化的时候，用反证法，就假设都是1，</strong>意思就是所有的表达式都没有其中的值被重新定义，也就是所有的表达式都可以用原来的值替换，这肯定是Unsafe的。</p>\n<p>反之，所有的表达式都不avaliable,需要重新计算所有的值，肯定是safe，都别优化了</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816073057174.png\" alt=\"image-20230816073057174\"></p>\n<ul>\n<li>下界代表 safe but useless 的情形，因为需要重新计算每个表达式，即确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果</li>\n</ul>\n<p><strong>another view of leaest fixed point</strong></p>\n<p>以may analysis举例</p>\n<ul>\n<li>transer function中 kill 和gen是固定的</li>\n<li>control flow merge 是  union，对于lattice来说union是最小上界</li>\n<li>所以每次都走的是最小的一步，那最后得到的肯定是最小不动点</li>\n</ul>\n<h2 id=\"How-Precise-is-our-Solution\"><a href=\"#How-Precise-is-our-Solution\" class=\"headerlink\" title=\"How Precise is our Solution\"></a>How Precise is our Solution</h2><h3 id=\"Meet-Over-All-Paths-Solution-MOP\"><a href=\"#Meet-Over-All-Paths-Solution-MOP\" class=\"headerlink\" title=\"Meet-Over-All-Paths Solution(MOP)\"></a>Meet-Over-All-Paths Solution(MOP)</h3><ul>\n<li>这里的meet包括(meet&#x2F;join)</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816222855029.png\" alt=\"image-20230816222855029\"></p>\n<ul>\n<li>对所有的out应用transer function，再用meet操作符</li>\n<li>MOP在每条路径的结尾计算所有的data-flow的值，应用应用Meet去找到 lub &#x2F; glb</li>\n</ul>\n<p>但是基于上面的表达式可能有些问题</p>\n<p><strong>问题1：有些路径是不可执行的（not executable）</strong></p>\n<ul>\n<li>上面是考虑了所有的路径，但是有写路径可能永远不会被执行</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">x<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">></span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>问题2：not unbounded(没有边界)</strong></p>\n<ul>\n<li>如果有一条path中有循环，循环中定义s1,s2两个变量,也就是这条path上会包含非常多个s1,s2</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\ns1<span class=\"token punctuation\">;</span>\ns2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>问题3：Not enumerable</strong></p>\n<ul>\n<li>可能程序很大，不可枚举</li>\n</ul>\n<h3 id=\"Ours-iterative-Algorithm-vs-MOP\"><a href=\"#Ours-iterative-Algorithm-vs-MOP\" class=\"headerlink\" title=\"Ours(iterative Algorithm) vs MOP\"></a>Ours(iterative Algorithm) vs MOP</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816223938137.png\" alt=\"image-20230816223938137\"></p>\n<ul>\n<li><p>我们的算法是在每一个merge的时候，join</p>\n</li>\n<li><p>MOP是在最后merge</p>\n</li>\n</ul>\n<p>把黄色的部分用x代替，红色的部分用y代替</p>\n<p>证明一下他俩的关系：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816230725374.png\" alt=\"image-20230816230725374\"></p>\n<ul>\n<li>这个很好理解，F($x\\sqcup y$)是F(x)和F(y)的upper bound,F(x)和F(y)的最小上界是$F(x)\\sqcup F(y)$</li>\n<li>所以$MOP \\sqsubseteq Ours$</li>\n</ul>\n<p>当F具有可分配性时</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816231036088.png\" alt=\"image-20230816231036088\"></p>\n<p>bit-vector或者Gen&#x2F;kill的transer function(用join &#x2F; meet)都是distributive</p>\n<ul>\n<li>所以我们之前的都和MOP一样准确</li>\n</ul>\n<h2 id=\"关于must-analysis-还是-may-analysis的分析\"><a href=\"#关于must-analysis-还是-may-analysis的分析\" class=\"headerlink\" title=\"关于must analysis 还是 may analysis的分析\"></a>关于must analysis 还是 may analysis的分析</h2><h3 id=\"Reaching-definitons\"><a href=\"#Reaching-definitons\" class=\"headerlink\" title=\"Reaching definitons\"></a><strong>Reaching definitons</strong></h3><ul>\n<li>它的目标是：判断在此处定义的D1 … Di是否有意义，如果每意义，就被优化，1代表有意义，0代表无意义。</li>\n<li>也就是如果有一条路径是1，代表可能有意义，就不能被优化</li>\n<li>所以要 把结果并起来，所以是may analysis</li>\n</ul>\n<h3 id=\"live-avaliables\"><a href=\"#live-avaliables\" class=\"headerlink\" title=\"live avaliables\"></a>live avaliables</h3><ul>\n<li>它的目标是判断变量后面是否被用了，如果是无意义的变量，就把它的空间释放掉，用来存储新的寄存器值</li>\n<li>1代表有意义，0代表无意义</li>\n<li>也就是如果有1条路有意义，就不应该被优化</li>\n<li>所以同上</li>\n</ul>\n<h3 id=\"avaliable-expressions\"><a href=\"#avaliable-expressions\" class=\"headerlink\" title=\"avaliable expressions\"></a>avaliable expressions</h3><ul>\n<li>它的定义说要考虑所有的路径，是否在每一条路径都执行了x op y，如果都执行了，就可以把这个结果用一个新的变量替换</li>\n<li>那如果有一条路劲没计算，显然就不能别替换，输出是0</li>\n<li>所以要把所有的结果取 交集</li>\n</ul>\n<h2 id=\"Constant-Propagation\"><a href=\"#Constant-Propagation\" class=\"headerlink\" title=\"Constant Propagation\"></a>Constant Propagation</h2><p>程序的p点有一个变量x,判断在P点是否可以guaranteed x是一个常量</p>\n<ul>\n<li>要考虑所有的路径上是否定义的值都一样，如果有两条路径是x&#x3D;2，有一条是x&#x3D;3，那显然不行</li>\n<li>所以是must analysis</li>\n</ul>\n<p>从top往bottom走，最下面肯定是最安全的，因为你要考虑的问题(优化的目标)是 是否是constant，最下面是所有的都不是constant，所以肯定是safe</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817210307704.png\" alt=\"image-20230817210307704\"></p>\n<p>考虑所有的meet</p>\n<p>nac：Not a constant</p>\n<p>V：value</p>\n<ul>\n<li><p>nac 和 v肯定是nac</p>\n</li>\n<li><p>undef 和 v是 v</p>\n<p>但是这里有一种情况是，假设程序走了Undefined的路径，表示没有这个常量，但是输出结果是有一个常量，那在程序获取undefined三，少了一个值。</p>\n<p>解释：在constant propagation（常量传播）中，只考虑常量传播，不focus于未定义这种情况</p>\n</li>\n</ul>\n<h3 id=\"Transfer-function\"><a href=\"#Transfer-function\" class=\"headerlink\" title=\"Transfer function\"></a>Transfer function</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816235426102.png\" alt=\"image-20230816235426102\"></p>\n<p> _表示通配符，无论是啥值，都干掉\t</p>\n<ul>\n<li>x如果是常量，生成的就是x和对应的值</li>\n<li>如果x&#x3D;y，y是一个变量，那就去取y的值，如果是常量就是，不是就不是</li>\n<li>x&#x3D; y op z，就进行计算<ul>\n<li>两个都是常量</li>\n<li>有一个不是常量</li>\n<li>其中有一个是undefi，或者两个都是undef</li>\n</ul>\n</li>\n</ul>\n<p>这里提了一句，如果把undef给了一个值，那transfer function就不单调了。</p>\n<p><strong>我的理解：</strong></p>\n<p>回看定义</p>\n<p><strong>现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L</strong></p>\n<p><strong>即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $</strong></p>\n<ul>\n<li>假设z是undef，那 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $ 这个表达式不一定成立</li>\n</ul>\n<h3 id=\"为什么是Nondistributivity\"><a href=\"#为什么是Nondistributivity\" class=\"headerlink\" title=\"为什么是Nondistributivity\"></a>为什么是Nondistributivity</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817001140056.png\" alt=\"image-20230817001140056\"></p>\n<ul>\n<li>iterative algorithm的结果是nac</li>\n<li>mop的结果是10</li>\n<li>他俩不相等，所以他就不是distributivity</li>\n<li>实际结果是10，mop准</li>\n</ul>\n<h2 id=\"Worklist-Algorithm\"><a href=\"#Worklist-Algorithm\" class=\"headerlink\" title=\"Worklist Algorithm\"></a>Worklist Algorithm</h2><p>an optimization of iterative algorithm，是iterative algorithm的优化</p>\n<ul>\n<li>实际上用的是Worklist Algorithm</li>\n</ul>\n<p><strong>回顾iterative algorithm</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817001720388.png\" alt=\"image-20230817001720388\"></p>\n<ul>\n<li>有一个变化了，所有的都要重新算，很冗余</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231007124507027.png\" alt=\"image-20231007124507027\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817011427252.png\" alt=\"image-20230817011427252\"></p>\n<h2 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>Q1：理解迭代算法的功能</strong></p>\n<ul>\n<li>包括初始化，bounary，must analysis和may analysis的初始化不一样</li>\n<li>in、out</li>\n</ul>\n<p><strong>Q2：lattice和complete lattice</strong></p>\n<ul>\n<li>lattice表示偏序集中的每两个元素都有最小上界和最大下界</li>\n<li>complete lattice表示偏序集的每个子集都有最小上界和最大下界</li>\n</ul>\n<p><strong>Q3：理解不动点定理</strong></p>\n<ul>\n<li>如果一个lattice是单调的，且有穷的，那可以通过迭代算法得到最小不动点</li>\n</ul>\n<p><strong>Q4：在lattice中总结may analysis和must analysis</strong></p>\n<ul>\n<li>关于Must analysis和may analysis，很重要的一点是要理解程序的目标是什么</li>\n<li>如果他的目标是找1，结果是1的被替换，那就是must analysis</li>\n<li>如果目标是找0，0的被替换，那就是May analysis</li>\n</ul>\n<p><strong>Q5：MOP和迭代算法的关系</strong></p>\n<ul>\n<li>MOP算法走所有的路径，在程序的最后merge</li>\n<li>而迭代算法在有merge的情况下就会merge</li>\n</ul>\n<p><strong>Q6：关于常量传播</strong></p>\n<ul>\n<li>他是Must analysis</li>\n</ul>\n<p><strong>Q7：Worklist 算法</strong></p>\n<ul>\n<li>对迭代算法进行优化，只计算变化的块，后面的指针分析都是worklist算法</li>\n</ul>\n<h1 id=\"Interprocedural-Analysis\"><a href=\"#Interprocedural-Analysis\" class=\"headerlink\" title=\"Interprocedural Analysis\"></a>Interprocedural Analysis</h1><h2 id=\"Motivation（为什么需要过程间分析呢）\"><a href=\"#Motivation（为什么需要过程间分析呢）\" class=\"headerlink\" title=\"Motivation（为什么需要过程间分析呢）\"></a>Motivation（为什么需要过程间分析呢）</h2><p><strong>问题1：之前学到都是过程内分析，但是肯定会有方法调用，那该怎么办呢？</strong></p>\n<ul>\n<li>之前都是会做最保守的假设，也就是最安全的假设</li>\n<li>对于常量分析而言，就假设不是常量</li>\n</ul>\n<p>下面的 x y n对于过程内分析(inter procedural)而言，都是nac</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817211434068.png\" alt=\"image-20230817211434068\"></p>\n<p>为了更好的精度，就需要过程间分析：也就是需要沿着过程间分析的control - flow edges传递数据流信息。</p>\n<p>对于下面的图，最关键的就是call graph</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817211617439.png\" alt=\"image-20230817211617439\"></p>\n<h2 id=\"Call-Graph-Construction\"><a href=\"#Call-Graph-Construction\" class=\"headerlink\" title=\"Call Graph Construction\"></a>Call Graph Construction</h2><h3 id=\"Call-Graph\"><a href=\"#Call-Graph\" class=\"headerlink\" title=\"Call Graph\"></a>Call Graph</h3><ul>\n<li>call graph就是一系列call edges的集合，从调用点到他们的目标方法</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817212045071.png\" alt=\"image-20230817212045071\"></p>\n<h3 id=\"Call-Graph-Construction-for-OOPLS（focus-on-java）\"><a href=\"#Call-Graph-Construction-for-OOPLS（focus-on-java）\" class=\"headerlink\" title=\"Call Graph Construction for OOPLS（focus on java）\"></a>Call Graph Construction for OOPLS（focus on java）</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817212304829.png\" alt=\"image-20230817212304829\"></p>\n<h3 id=\"Method-Calls-Invocation-in-Java\"><a href=\"#Method-Calls-Invocation-in-Java\" class=\"headerlink\" title=\"Method Calls(Invocation) in Java\"></a>Method Calls(Invocation) in Java</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817230247609.png\" alt=\"image-20230817230247609\"></p>\n<p>Special call处理三种方法： 私有方法、构造函数、父类方法</p>\n<ul>\n<li>static call和special call都是在编译时，就可以确定了，但是像其他的实例方法，需要在运行时候才能确定</li>\n<li>Instruction：指Java的<strong>IR中的指令</strong></li>\n<li>Receiver objects：方法调用对应的实例对象（static方法调用不需要对应实例）。</li>\n<li>Target methods：表达<strong>IR指令到被调用目标方法的映射关系</strong></li>\n<li>Num of target methods：call对应的可能被调用的目标方法的数量。Virtual call与动态绑定和多态实现有关，可以对应多个对象下的重写方法。所以<strong>Virtual call的可能对象可能超过1个</strong>。</li>\n<li>Determinacy：指什么时候能够确定这个call的对应方法。Virtual call与多态有关，只能在运行时决定调用哪一个具体方法的实现。其他两种call都和多态机制不相关，编译时刻就可以确定。</li>\n</ul>\n<p> 意思也就是：在编译时刻，不能确定传给哪个对象，不能确定是调用父类的方法还是子类的方法。</p>\n<h3 id=\"Method-Dispatch-of-Virtual-Calls\"><a href=\"#Method-Dispatch-of-Virtual-Calls\" class=\"headerlink\" title=\"Method Dispatch of Virtual Calls\"></a>Method Dispatch of Virtual Calls</h3><p>在run-time时，一个virtual call取决于以下两点：</p>\n<ul>\n<li>received object的类型(也就是o的类型，应该是Class)</li>\n<li>调用点的method signature</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817231018639.png\" alt=\"image-20230817231018639\"></p>\n<p>一个signature是一个方法的identifier</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817231119367.png\" alt=\"image-20230817231119367\"></p>\n<ul>\n<li>class type：这里是C</li>\n<li>method name：foo</li>\n<li>descriptor：返回类型+参数类型</li>\n</ul>\n<p>这里用C.foo(P,Q,R)简写</p>\n<p>接着定义了一个Dispatch(c,m)模拟运行时的方法调用过程</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817231614531.png\" alt=\"image-20230817231614531\"></p>\n<p><strong>这里的目标是找到m方法并调用</strong></p>\n<ul>\n<li>如果c包含一个和m有同样名字和descriprot的<strong>非抽象</strong>方法 m’(因为只有非抽象的方法才能被调用)</li>\n<li>否则就去c的父类中找</li>\n</ul>\n<h3 id=\"An-Example\"><a href=\"#An-Example\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817234913493.png\" alt=\" \"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817232030077.png\" alt=\"image-20230817232030077\"></p>\n<ul>\n<li>这里的B表示的是received object的类型</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817234925578.png\" alt=\"image-20230817234925578\"></p>\n<h3 id=\"Class-Hierarchy-Analysis-CHA\"><a href=\"#Class-Hierarchy-Analysis-CHA\" class=\"headerlink\" title=\"Class Hierarchy Analysis(CHA)\"></a>Class Hierarchy Analysis(CHA)</h3><p>这个算法的目标是在编译时，根据receiver variable来判断它可能调用哪个类的方法</p>\n<ul>\n<li>它需要类的迭代信息</li>\n<li>需要receiver variable的 declared type</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818204856753.png\" alt=\"image-20230818204856753\"></p>\n<h3 id=\"Call-Resolution-of-CHA\"><a href=\"#Call-Resolution-of-CHA\" class=\"headerlink\" title=\"Call Resolution of CHA\"></a>Call Resolution of CHA</h3><p>这里定义了一个函数Resolve(cs)，通过调用点来判断可能的目标方法</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205156276.png\" alt=\"image-20230818205156276\"></p>\n<p>这里分成三类，分别是静态方法，special call(构造器、super、私有方法)，和virtual call</p>\n<h4 id=\"static-call\"><a href=\"#static-call\" class=\"headerlink\" title=\"static call\"></a>static call</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205455206.png\" alt=\"image-20230818205455206\"></p>\n<ul>\n<li>就直接调用就行了</li>\n</ul>\n<h4 id=\"special-call\"><a href=\"#special-call\" class=\"headerlink\" title=\"special call\"></a>special call</h4><p>这里以super方法为例</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205527658.png\" alt=\"image-20230818205527658\"></p>\n<ul>\n<li>首先获得它的类，</li>\n<li>然后用Dispatch，根据前面学的，Dispatch就是先在当前类找同名方法，如果没有，就找它的父类</li>\n</ul>\n<h4 id=\"virtual-call\"><a href=\"#virtual-call\" class=\"headerlink\" title=\"virtual call\"></a>virtual call</h4><ul>\n<li>获得receive variable的类型</li>\n<li><strong>然后对它和它的所有子类应用dispatch</strong></li>\n</ul>\n<h4 id=\"An-example\"><a href=\"#An-example\" class=\"headerlink\" title=\"An example\"></a>An example</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205846768.png\" alt=\"image-20230818205839605\"></p>\n<p>c.foo()  肯定就是C.foo()</p>\n<p>a.foo()    返回结果是 {A.foo()，C.foo()，D.foo()}</p>\n<p>b.foo() 返回结果：{A.foo()，C.foo()，D.foo()}</p>\n<ul>\n<li><p>先对B应用Dispatch，他没有这个方法，就要去它的父类中找，所以是A.foo()</p>\n</li>\n<li><p>这里我用java测试一下，如果B类中没有这个方法，那是会去找他的父类，<strong>这条性质我忘记了</strong> ，就严格按照Dispatch的定义来就行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">B</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        b<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A的foo调用\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818210830243.png\" alt=\"image-20230818210830243\"></p>\n</li>\n</ul>\n<h3 id=\"Features-of-CHA\"><a href=\"#Features-of-CHA\" class=\"headerlink\" title=\"Features of CHA\"></a>Features of CHA</h3><p>优点：</p>\n<ul>\n<li>快，只考虑receiver variable</li>\n<li>忽略数据流信息</li>\n</ul>\n<p>ide中用的就是CHA </p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818211402699.png\" alt=\"image-20230818211402699\"></p>\n<h3 id=\"Call-Graph-Construction-Algorithm\"><a href=\"#Call-Graph-Construction-Algorithm\" class=\"headerlink\" title=\"Call Graph Construction -&gt; Algorithm\"></a>Call Graph Construction -&gt; Algorithm</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818212105348.png\" alt=\"image-20230818212105348\"></p>\n<h3 id=\"An-Example-1\"><a href=\"#An-Example-1\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818221958372.png\" alt=\"image-20230818221958372\"></p>\n<h2 id=\"Interprocedural-Control-Flow-Graph\"><a href=\"#Interprocedural-Control-Flow-Graph\" class=\"headerlink\" title=\"Interprocedural Control-Flow Graph\"></a>Interprocedural Control-Flow Graph</h2><p>CFG表示一个方法的结构</p>\n<p>ICFG就是表示整个程序的结构</p>\n<p>ICFG包括所有方法的CFG，再加上两种额外的边</p>\n<ul>\n<li>Call edges</li>\n<li>Return edges：</li>\n<li>return sites：紧跟着call site的下一条语句是return site</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818222414975.png\" alt=\"image-20230818222414975\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818222947646.png\" alt=\"image-20230818222947646\"></p>\n<ul>\n<li>从call graph中获取这两种边</li>\n</ul>\n<h3 id=\"An-example-1\"><a href=\"#An-example-1\" class=\"headerlink\" title=\"An example\"></a>An example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818224613267.png\" alt=\"image-20230818224613267\"></p>\n<ul>\n<li>这里的小黄是 call-to-return edges，就是从Call site到return site</li>\n<li>它用来传递Local data-flow，比如 a&#x3D;6</li>\n</ul>\n<h2 id=\"Interprocedural-Data-Flow-Analysis\"><a href=\"#Interprocedural-Data-Flow-Analysis\" class=\"headerlink\" title=\"Interprocedural Data-Flow Analysis\"></a>Interprocedural Data-Flow Analysis</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818223410639.png\" alt=\"image-20230818223410639\"></p>\n<ul>\n<li>现在多了两种边，需要多两种transfer</li>\n</ul>\n<h3 id=\"Interprocedural-Contant-Propagation\"><a href=\"#Interprocedural-Contant-Propagation\" class=\"headerlink\" title=\"Interprocedural Contant Propagation\"></a>Interprocedural Contant Propagation</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818223556449.png\" alt=\"image-20230818223556449\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818231300538.png\" alt=\"image-20230818231300538\"></p>\n<ul>\n<li>这里要保留edge transfer的返回结果，比如返回的是b，原来流到这的也是b，所以要kill 原来的b</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818232053033.png\" alt=\"image-20230818232053033\"></p>\n<p>如果是过程内分析(IntraProcedural)，那就会保证一种safe的情况，正如本节课最开始的时候说的，就会对于有call method这种，假设不是常量。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818232931811.png\" alt=\"image-20230818232931811\"></p>\n<ul>\n<li>这里就会假设addOne的返回值不是常量，所以一直到最后b c都不是常量</li>\n<li>因此就会unprecise</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818233056081.png\" alt=\"image-20230818233056081\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818233129686.png\" alt=\"image-20230818233129686\"></p>\n<h2 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230906170823179.png\" alt=\"image-20230906170823179\"></p>\n<p>前面学的都是一个方法内部的分析，也就是过程内分析，只有CFG</p>\n<p>现在再加两种边，call edege和return edge，他们俩从CG(call graph)中获取，构成了这个的ICFG</p>\n<h1 id=\"Pointer-Analysis\"><a href=\"#Pointer-Analysis\" class=\"headerlink\" title=\"Pointer Analysis\"></a>Pointer Analysis</h1><h2 id=\"Problem-of-CHA\"><a href=\"#Problem-of-CHA\" class=\"headerlink\" title=\"Problem of CHA\"></a>Problem of CHA</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819204842348.png\" alt=\"image-20230819204842348\"></p>\n<ul>\n<li>对于CHA来说，n.get只看Number的类型，所以会返回三个call targets，有2个是false postives，这样对于常量分析来说，返回了 0，1，2，所以是NAC</li>\n</ul>\n<p>因此就有了指针分析，可以更准确的找到调用的方法.</p>\n<ul>\n<li>会根据n指向的对象来构造调用图，所以只会调用One的get方法(1 call target)，基于这个做常量传播，就是准确的。</li>\n</ul>\n<h2 id=\"Pointer-Analysis-1\"><a href=\"#Pointer-Analysis-1\" class=\"headerlink\" title=\"Pointer Analysis\"></a>Pointer Analysis</h2><p>分析的是内存中指向哪个地址</p>\n<p>对于oo语言来说</p>\n<ul>\n<li>回答的是一个对象指向哪些对象</li>\n</ul>\n<p>是may analysis</p>\n<ul>\n<li>对于一个指针指向哪些对象，是一个over-approximation，我们问的问题<strong>是一个指针可能指向哪个对象</strong></li>\n</ul>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819210045111.png\" alt=\"image-20230819210045111\"></p>\n<p><strong>问题1： 为什么y指向new B</strong></p>\n<ul>\n<li>因为返回的this.b之前被赋值了，变成了指向new B，所以y也指向new B</li>\n</ul>\n<h2 id=\"Pointer-Analysis-and-alias-Analysis（别名分析）\"><a href=\"#Pointer-Analysis-and-alias-Analysis（别名分析）\" class=\"headerlink\" title=\"Pointer Analysis and alias Analysis（别名分析）\"></a>Pointer Analysis and alias Analysis（别名分析）</h2><p><strong>指针分析</strong></p>\n<ul>\n<li>一个指针指向哪个对象</li>\n</ul>\n<p><strong>别名分析</strong></p>\n<ul>\n<li>两个指针指向同一个对象么</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819214030664.png\" alt=\"image-20230819214030664\"></p>\n<p>别名分析的信息可以通过指针分析推导出来</p>\n<h2 id=\"Application-of-Pointer-Analysis\"><a href=\"#Application-of-Pointer-Analysis\" class=\"headerlink\" title=\"Application of Pointer Analysis\"></a>Application of Pointer Analysis</h2><ul>\n<li>Compiler optimization</li>\n<li>Bug detection</li>\n<li>Security Analysisi</li>\n<li>Call graph,aliases</li>\n</ul>\n<h2 id=\"Key-Factors-in-Pointer-Analysis\"><a href=\"#Key-Factors-in-Pointer-Analysis\" class=\"headerlink\" title=\"Key Factors in Pointer Analysis\"></a>Key Factors in Pointer Analysis</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819214951488.png\" alt=\"image-20230819214951488\"></p>\n<h3 id=\"Heap-abstraction\"><a href=\"#Heap-abstraction\" class=\"headerlink\" title=\"Heap abstraction\"></a>Heap abstraction</h3><p><strong>问题：指针分析时，如何对堆的内存进行建模？</strong></p>\n<ul>\n<li>程序动态执行时，如果程序中有循环，就会产生无穷多个对象，这样指针分析就无法终止了？</li>\n</ul>\n<p><strong>那如何终止？</strong></p>\n<ul>\n<li>用堆抽象，把无穷的对象 抽象成 有限的抽象的对象</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819215335308.png\" alt=\"image-20230819215335308\"></p>\n<h4 id=\"Allocation-Site-Abstraction\"><a href=\"#Allocation-Site-Abstraction\" class=\"headerlink\" title=\"Allocation-Site Abstraction\"></a>Allocation-Site Abstraction</h4><ul>\n<li>给具体的对象建模时，抽象成他们的创建点</li>\n<li>用这个抽象点去代表具体的对象</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819215656384.png\" alt=\"image-20230819215656384\"></p>\n<ul>\n<li>把三次循环的结果，抽象成一个创建点o2</li>\n<li>静态分析就只处理o2，也就是程序中有几个new，静态分析就处理几个对象</li>\n</ul>\n<h3 id=\"Context-Sensitivity-上下文敏感\"><a href=\"#Context-Sensitivity-上下文敏感\" class=\"headerlink\" title=\"Context Sensitivity(上下文敏感 )\"></a>Context Sensitivity(上下文敏感 )</h3><p><strong>问题：如何堆调用上下文进行建模?</strong></p>\n<p><strong>Context-sensitive：</strong></p>\n<ul>\n<li>会区分不同方法的上下文</li>\n<li>如果一个方法有多个上下文，就都分析</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819220014991.png\" alt=\"image-20230819220014991\"></p>\n<ul>\n<li>这种就分析2次</li>\n</ul>\n<p><strong>上下文敏感对提升指针分析非常有用。</strong></p>\n<p><strong>Context-insentitive</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819220117482.png\" alt=\"image-20230819220117482\"></p>\n<ul>\n<li>只分析1次</li>\n<li>但是merge data flow，可能会丢失精度</li>\n</ul>\n<h3 id=\"Flow-sensitivity\"><a href=\"#Flow-sensitivity\" class=\"headerlink\" title=\"Flow sensitivity\"></a>Flow sensitivity</h3><p><strong>问题：如何对指针分析中的control flow建模？下面两种方法</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819235926928.png\" alt=\"image-20230819235926928\"></p>\n<ul>\n<li>该图中，左边是flow-sensitive，右边是flow-insensitive</li>\n</ul>\n<p><strong>flow-sensitive</strong>：</p>\n<ul>\n<li>在每个程序的Location，都维持一个指向关系的map</li>\n<li>下面为什么s指向的值是x 而不是y，我还重新学了一下java的String知识。<ul>\n<li>总结来说开始时c.f指向的是常量池中的x，s也指向的是x</li>\n<li>但是c.f现在指向了y，就是常量池中新建了一个y，但是此时s还指向的是刚才的，所以是x</li>\n</ul>\n</li>\n</ul>\n<p><strong>flow-insensitive</strong></p>\n<ul>\n<li>忽略程序流的控制流信息，维持程序中的所有指向</li>\n<li>所以o1.f的所有可能值就是{x,y}</li>\n<li>s指向c.f，所有s的所有可能值也是{x,y}</li>\n</ul>\n<p><strong>总结</strong>;</p>\n<p>目前java中都使用flow-insensitive</p>\n<h3 id=\"Analysis-Scope\"><a href=\"#Analysis-Scope\" class=\"headerlink\" title=\"Analysis Scope\"></a>Analysis Scope</h3><p><strong>问题：指针分析时应该分析程序中的哪一部分呢？有下面两种方式</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820001012063.png\" alt=\"image-20230820001012063\"></p>\n<ul>\n<li>对于whole-program，左边的蓝色图，分析x&#x3D;o1，，y&#x3D;o1,z&#x3D;o4</li>\n<li>对于Demand-driven，右边的黄图，只需要分析z&#x3D;04就够了</li>\n</ul>\n<p><strong>whole-program</strong></p>\n<ul>\n<li>计算程序中所有pointer的指向信息</li>\n</ul>\n<p><strong>Demand-driven(需求驱动)</strong></p>\n<ul>\n<li>根据specific sites of interest进行分析</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>选择全程序分析</li>\n</ul>\n<h3 id=\"Pointer-Analysis-in-this-course\"><a href=\"#Pointer-Analysis-in-this-course\" class=\"headerlink\" title=\"Pointer Analysis in this course\"></a>Pointer Analysis in this course</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820001351612.png\" alt=\"image-20230820001351612\"></p>\n<p>目前没有研究说 Context-sensitive比Context-insensitive不好</p>\n<p>先学Flow-insensitive，再学Flow-sensitive</p>\n<p>Whole-program可以分析完所有的程序，适用于各种需求</p>\n<h2 id=\"Concerned-Statements\"><a href=\"#Concerned-Statements\" class=\"headerlink\" title=\"Concerned Statements\"></a>Concerned Statements</h2><p>指针分析只关注影响指针指向的语句</p>\n<h3 id=\"Pointers-in-Java\"><a href=\"#Pointers-in-Java\" class=\"headerlink\" title=\"Pointers in Java\"></a>Pointers in Java</h3><p>会local variable，就会Static field</p>\n<p>会Instance field 就会Array element</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820014739396.png\" alt=\"image-20230820014739396\"></p>\n<ul>\n<li><p>本地变量</p>\n</li>\n<li><p>Static field：C.f  \t</p>\n</li>\n<li><p>Instance field：x.f   x指向的对象有一个field f</p>\n</li>\n<li><p>Array element：忽略索引，用一个single field，也就是arr，来指向存储在array中的任何值</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820014701202.png\" alt=\"image-20230820014701202\"></p>\n<h3 id=\"Pointer-Affecting-Statements\"><a href=\"#Pointer-Affecting-Statements\" class=\"headerlink\" title=\"Pointer-Affecting Statements\"></a>Pointer-Affecting Statements</h3><p>只需要关注下面这5种语句，对于很长的语句，简化成3AC</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820015155573.png\" alt=\"image-20230820015155573\"></p>\n<p>focus  virtual call</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820015214325.png\" alt=\"image-20230820015214325\"></p>\n<h2 id=\"总结-5\"><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>Pointer Analysis<ul>\n<li>CHA的问题：对于CHA，找到的call target是一个元组，即所有可能的方法，如果对于常量传播而言，得到的结果就是NAC，因此有了指针分析。只有一个call target</li>\n<li>Pointer Analysis：一个指针可能指向哪些对象。 但是这不也是不准确的么</li>\n<li>指针分析分析的是啥？<ul>\n<li>java中的指针主要有4类<ul>\n<li>本地变量</li>\n<li>static field :C.f</li>\n<li>Instance field: x.f</li>\n<li>Array element: array[i]</li>\n</ul>\n</li>\n<li>只分析直接影响指针的，pointer-affecting statements，有5种<ul>\n<li>New</li>\n<li>Assign<ul>\n<li>x&#x3D;y</li>\n</ul>\n</li>\n<li>Store<ul>\n<li>x.f&#x3D;y</li>\n</ul>\n</li>\n<li>Load<ul>\n<li>y&#x3D;x.f</li>\n</ul>\n</li>\n<li>Call<ul>\n<li>r&#x3D;x.k(a,…)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指针分析的关键因素<ul>\n<li>Heap abstraction<ul>\n<li>把new抽象成创建点</li>\n</ul>\n</li>\n<li>Context Sensitivity<ul>\n<li>对调用的上下文进行建模</li>\n</ul>\n</li>\n<li>Flow sensitivity<ul>\n<li>如何对控制流进行建模？也就是是否关注程序的具体顺序</li>\n</ul>\n</li>\n<li>Analysis Scope<ul>\n<li>1.分析整个程序</li>\n<li>2.只根据需求进行分析</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907111536185.png\" alt=\"image-20230907111536185\"></p>\n<h1 id=\"Pointer-Analysis-Foundations-（I）\"><a href=\"#Pointer-Analysis-Foundations-（I）\" class=\"headerlink\" title=\"Pointer Analysis Foundations （I）\"></a>Pointer Analysis Foundations （I）</h1><h2 id=\"Point-Analysis-Rules\"><a href=\"#Point-Analysis-Rules\" class=\"headerlink\" title=\"Point Analysis: Rules\"></a>Point Analysis: Rules</h2><h3 id=\"Domains-and-Notations\"><a href=\"#Domains-and-Notations\" class=\"headerlink\" title=\"Domains and Notations\"></a>Domains and Notations</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820020740779.png\" alt=\"image-20230820020740779\"></p>\n<p>Points-to relations：理解为一个map</p>\n<p>Key 就是指针  value是相应指针的指针集</p>\n<h5 id=\"Rules\"><a href=\"#Rules\" class=\"headerlink\" title=\"Rules\"></a>Rules</h5><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820021340002.png\" alt=\"image-20230820021340002\"></p>\n<p>横线上面的是条件，下面的是结论</p>\n<p><strong>New</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820021330728.png\" alt=\"image-20230820021330728\"></p>\n<ul>\n<li>用oi表示创建出来的对象，所以让x指向oi，就是把pi加到x的指针集中</li>\n</ul>\n<p><strong>Assign</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820021826727.png\" alt=\"image-20230820021826727\"></p>\n<ul>\n<li>y指向一个对象，要让x也指向这个</li>\n</ul>\n<p><strong>Store</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820022029401.png\" alt=\"image-20230820022029401\"></p>\n<ul>\n<li>如果x指向oi，y指向oj，就让oi.f指向oj，也就是把oj加到oi.f的指针集中</li>\n</ul>\n<p><strong>Load</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820022635029.png\" alt=\"image-20230820022635029\"></p>\n<p>x指向oi，oi的f执行oj，那就让y也指向oj</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820023242087.png\" alt=\"image-20230820023242087\"></p>\n<h2 id=\"How-to-Implement-Pointer-Analysis\"><a href=\"#How-to-Implement-Pointer-Analysis\" class=\"headerlink\" title=\"How to Implement Pointer Analysis\"></a>How to Implement Pointer Analysis</h2><p>指针分析的关键：当pt(x)变化时，把这种变化传播给x的相关指针</p>\n<p>解决方式：</p>\n<ul>\n<li>用graph去连接相关的指针</li>\n<li>当Pt(x)改变时，把指针变化的部分传播到 x的后继</li>\n</ul>\n<h3 id=\"Pointer-Flow-Graph-PFG\"><a href=\"#Pointer-Flow-Graph-PFG\" class=\"headerlink\" title=\"Pointer Flow Graph(PFG)\"></a>Pointer Flow Graph(PFG)</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820225301480.png\" alt=\"image-20230820225301480\"></p>\n<ul>\n<li>一个节点n代表一个变量，或者是一个抽象对象的field</li>\n<li>一条边x–&gt;y，意味着x的指向可能(may analysis)流到y的指向</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820225511750.png\" alt=\"image-20230820225511750\"></p>\n<p>这个图中PFG Edges中的&lt;-，表示流动，意思是y的指针流到x</p>\n<h3 id=\"PFG-Examples\"><a href=\"#PFG-Examples\" class=\"headerlink\" title=\"PFG Examples\"></a>PFG Examples</h3><p>根据左边的program，得到右边的图</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820230328608.png\" alt=\"image-20230820230328608\"></p>\n<p><strong>问题：下图中蓝色圈中为什么不能是c.f?</strong></p>\n<p>c.f只是一个指针表达式，真正的指针是抽象创建点，而且这里其实也表示d.f，所以它只能是个抽象的点</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820230556062.png\" alt=\"image-20230820230556062\"></p>\n<p>假设现在有一个新的表达式，创建点是j，那么最终会从b一直流到a和e</p>\n<h3 id=\"Implementing-Pointer-Analysis\"><a href=\"#Implementing-Pointer-Analysis\" class=\"headerlink\" title=\"Implementing Pointer Analysis\"></a>Implementing Pointer Analysis</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820231347283.png\" alt=\"image-20230820231347283\"></p>\n<p>PFG和指针信息相互依存</p>\n<p>指针分析得到的信息越多，PFG中的边也会越多，也会让指针分析的信息更多</p>\n<ul>\n<li>这里我理解会根据左边红色的构建PFG，然后还是假设b点有个指针集pt(b)&#x3D;{oj}，它也需要根据新构建出来的边，继续流动</li>\n</ul>\n<h2 id=\"Pointer-Analysis：Algorithms\"><a href=\"#Pointer-Analysis：Algorithms\" class=\"headerlink\" title=\"Pointer Analysis：Algorithms\"></a>Pointer Analysis：Algorithms</h2><h3 id=\"Algorithms（该算法目前不设计call-method）\"><a href=\"#Algorithms（该算法目前不设计call-method）\" class=\"headerlink\" title=\"Algorithms（该算法目前不设计call method）\"></a>Algorithms（该算法目前不设计call method）</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907121358578.png\" alt=\"image-20230907121358578\"></p>\n<h4 id=\"Worklist\"><a href=\"#Worklist\" class=\"headerlink\" title=\"Worklist\"></a>Worklist</h4><p>WL：work list存储要处理的信息，里面是一个个的pair</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820233036780.png\" alt=\"image-20230820233036780\"></p>\n<ul>\n<li>oi要被加入到x的指针集中</li>\n</ul>\n<h4 id=\"Handling-of-New-and-Assign\"><a href=\"#Handling-of-New-and-Assign\" class=\"headerlink\" title=\"Handling of New and Assign\"></a>Handling of New and Assign</h4><p>先处理 new和 assign</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820234444850.png\" alt=\"image-20230820234444850\"></p>\n<p><strong>第一步：加边</strong></p>\n<p>看红色部分</p>\n<p>首先对于 x &#x3D; new T()</p>\n<p>​\t- 那就是把oi，加入到x的指针集中</p>\n<p>对于 x &#x3D; y</p>\n<ul>\n<li>调用AddEdge函数，如果s -&gt; t不属于PFG，就在PFG上加一条边，注意这里的边是流向，而不是指向</li>\n<li>如果pt(s)不等于空，那也就是会流向t，也就是需要在t中，添加s的指针集，让t指向所有s能指向的地方</li>\n</ul>\n<p><strong>第二步：处理worklist</strong></p>\n<p>看上面算法的第二部分</p>\n<p>首先会做一个减法，也就是本来已经有的就不用动，只添加一些新的</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821000638227.png\" alt=\"image-20230821000638227\"></p>\n<p>然后进行propogate</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820235905992.png\" alt=\"image-20230820235905992\"></p>\n<p>圆圈1真正对指针集 进行了修改，把去重后的加入到n的指针集合中。</p>\n<p>此时对PFG进行遍历，找出n的所有后继节点s（也就是之后n会流向的地方），同样把&lt;s，pts&gt;加入到worklist中，后续进行处理，修改他们的指针集</p>\n<p>Differential Propagation</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821002915288.png\" alt=\"image-20230821002915288\"></p>\n<ul>\n<li>减少集合的操作量，如果在c处就算出来了，就不用之后每一步都算了</li>\n</ul>\n<h4 id=\"Handling-of-Store-and-load\"><a href=\"#Handling-of-Store-and-load\" class=\"headerlink\" title=\"Handling of Store and load\"></a>Handling of Store and load</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821013103213.png\" alt=\"image-20230821013103213\"></p>\n<p>if n represents a variable x 这句我没理解</p>\n<p>如果对于每个oi，有x.f &#x3D; y 或者 y &#x3D; x.f的语句，就加对应的边，和上面一样</p>\n<h3 id=\"Algorithms-Review\"><a href=\"#Algorithms-Review\" class=\"headerlink\" title=\"Algorithms Review\"></a>Algorithms Review</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821014443700.png\" alt=\"image-20230821014443700\"></p>\n<ul>\n<li>算法的本质是在修改指针集，和addedge</li>\n<li>两个是相辅相成的，待处理的会放到WL中</li>\n</ul>\n<h3 id=\"An-Example-2\"><a href=\"#An-Example-2\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821020036897.png\" alt=\"image-20230821020036897\"></p>\n<p>用流不敏感来处理</p>\n<ol>\n<li>从new开始处理</li>\n<li>处理 x &#x3D; y的情况</li>\n<li>处理WL</li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821020127052.png\" alt=\"image-20230821020127052\"></p>\n<h2 id=\"总结-6\"><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907123754434.png\" alt=\"image-20230907123754434\"></p>\n<ul>\n<li>Pointer Analysis foundations<ul>\n<li>如何实现指针分析呢？ 关键是当x的指针集改变时，要把它传给和x相关的指针<ul>\n<li>用一个graph去连接相关的指针，当pt(x)改变时，把改变传给x的后继</li>\n</ul>\n</li>\n<li>Point Flow Graph(PFG)<ul>\n<li>通过指针信息构建PFG，PFG中的边表示流向，a-&gt;b表示a的指针集流到b，也就是在b的指针集中添加a的指向</li>\n</ul>\n</li>\n<li>指针分析算法<ul>\n<li>对于x &#x3D; new T(),add{x,{oi}}</li>\n<li>对于x&#x3D;y，就AddEdge(y,x)</li>\n<li>处理WL中的指针，和对应的指针集<ul>\n<li>取出一个&lt;n,pts&gt;，用pts-ptn，只改变新添加的指针</li>\n<li>用Propagate方法<ul>\n<li>将上面的差集加入到ptn中</li>\n<li>PFG中每个n节点的后继s，都把{s,差集}加入到WL中</li>\n</ul>\n</li>\n<li>如果n代表一个变量x，也就是它有field<ul>\n<li>对于x.f&#x3D;y，就AddEdge(y,oi.f)</li>\n<li>对于y&#x3D;x.f，就AddEge(oi.f,y)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>AddEdge(s,t)方法<ul>\n<li>在PFG上添加s-&gt;t</li>\n<li>如果pt(s)不为空，就添加&lt;t,pt(s)&gt;到WL中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pointer-Analysis-with-Method-Calls\"><a href=\"#Pointer-Analysis-with-Method-Calls\" class=\"headerlink\" title=\"Pointer Analysis with Method Calls\"></a>Pointer Analysis with Method Calls</h2><p>CHA：解决call targets通过a的declared type</p>\n<p>Pointer Analysis：resolve call targets 基于pt(a)</p>\n<p>以前是根据CHA建call graph,那是会有假边</p>\n<p>现在根据指针分析来建call graph</p>\n<h3 id=\"Rule\"><a href=\"#Rule\" class=\"headerlink\" title=\"Rule\"></a>Rule</h3><p><strong>jvm在进行方法调用的时候，做的4件事</strong></p>\n<ol>\n<li><p>Dispatch</p>\n</li>\n<li><p>Received Object</p>\n</li>\n<li><p>参数</p>\n</li>\n<li><p>返回值</p>\n</li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821215430336.png\" alt=\"image-20230821215430336\"></p>\n<ol>\n<li><p>首先x指向oi 调用点接着对oi和k进行Dispatch，目标是找到要调用的方法</p>\n</li>\n<li><p>找到后，让oi 指向$pt(m_{this})$,也就是传receive object</p>\n</li>\n<li><p>传参数 也就是把形参aj传给 $m_{pj}$（当前变量中的pj参数）</p>\n</li>\n<li><p>传返回值，把$m_{ret}$传递给r</p>\n</li>\n</ol>\n<p><strong>问题：为什么不在x和this之间连一条边？(也就是黑色虚线为啥不是实线)</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230822010231414.png\" alt=\"image-20230822010231414\"></p>\n<ul>\n<li>假设x的指针集中  A B C三个调用点，且A B C三个类满足继承关系，那如果存在边，就会流过去，这也就让每个this的指针集中包括了{new A new B new C}，这显然是不合理的，每个类的this应该只有自己的类</li>\n</ul>\n<p>在每次算法执行时，oi是确定的某个对象(唯一的，只有一个)，然后针对这个对象做Dispatch，能够找到唯一的receive object</p>\n<h3 id=\"Interprocedural-Pointer-Analysis\"><a href=\"#Interprocedural-Pointer-Analysis\" class=\"headerlink\" title=\"Interprocedural Pointer Analysis\"></a>Interprocedural Pointer Analysis</h3><p>Call graph形成一个可达的世界：</p>\n<ul>\n<li><p>在效率上有提升：好处是不可达的方法说明程序中根本就不会用到，所以就不用分析</p>\n</li>\n<li><p>在精度上有提升：对于不可达的方法，他们有关的指针集都是假的，因为永远也不会用到  </p>\n</li>\n<li><p>Entry methods在最开始一定是可达的</p>\n</li>\n<li><p>其他</p>\n</li>\n</ul>\n<h3 id=\"Algorithms\"><a href=\"#Algorithms\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907121358578.png\" alt=\"image-20230907121358578\"> </p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230822055356299.png\" alt=\"image-20230822055356299\"></p>\n<p>黄色的部分是新加的</p>\n<ul>\n<li><p>这里的$m^{entry}$方法，就理解成main方法，程序从main开始分析  </p>\n</li>\n<li><p>RM：reachable methods 可达的方法 </p>\n</li>\n<li><p>S: S是可达的语句的集合，也就是RM方法中的语句</p>\n</li>\n<li><p>$S_m$: 方法m中的语句</p>\n</li>\n<li><p>CG：call graph的边</p>\n</li>\n<li><p>AddReachable：把新的方法加入到可达的世界中</p>\n</li>\n</ul>\n<p><strong>AddReachable啥时候被调用？</strong></p>\n<ul>\n<li>entry方法是一开始的，肯定是可达，调用</li>\n<li>发现新的调用边的时候</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230822055100882.png\" alt=\"image-20230822055100882\"></p>\n<ul>\n<li>前面两行就是把新的方法加入到S集合中</li>\n</ul>\n<p><strong>为什么在算法的一开始，不处理load 和 store语句，只处理New 和 assign呢</strong></p>\n<p>因为像new和assign语句，你不需要知道他们的指针信息，就可以直接操作。</p>\n<p>但是对于 x.f &#x3D; y这样的语句，需要知道x的指针集信息，如果y指向oi，x指向oj，需要把y加入到oi.f中，但是此时一开始，x的指针集是空的</p>\n<p><strong>ProcessCall：就是在做上面那4件事</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907211836085.png\" alt=\"image-20230907211836085\"></p>\n<p> 对于每个call site l :  x.k方法：</p>\n<ul>\n<li>用Dispatch找到对应的方法m</li>\n<li>把&lt;mthis,{oi}&gt;添加到WL </li>\n<li>如果 l -&gt;m不属于PFG，l是call site，m是目标方法 </li>\n<li>因为m是一个新的方法，所以要addreachable<ul>\n<li>遍历m的每个形式参数pi(parameter)，连接实参(argument)和形参，addEdge</li>\n<li>传返回值从mret到r，addEdge</li>\n</ul>\n</li>\n</ul>\n<p><strong>问题：为什么oi是个新的对象，还要判断l-&gt;m是否属于call graph呢</strong>  </p>\n<p>因为这里的oj是x的定义类型，之前可能有oj，ok进来，就把这个边连接上了。<strong>没太懂。</strong></p>\n<p>就是x的指针集中可能在oi之前 还有oj，就之前可能某一条语句让x和y指向了同一个地方，那Dispatch的结果如果是一样的，这条边就连接过了</p>\n<p><strong>这里的l之前也是有可能处理过的</strong></p>\n<p>因为每次x的指针集变化，就会在WL中添加东西，都会触发ProcessCall，就会执行l</p>\n<h3 id=\"An-Example-3\"><a href=\"#An-Example-3\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p> <img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907215524233.png\" alt=\"image-20230907215524233\"></p>\n<p>首先执行AddReachable方法，就是把{a,o3} {b,o4}添加到WL中</p>\n<p>接着对{a,o3}执行Propagate，因为a的指针集是空的，所以没什么变化。</p>\n<p>接着对{b,o4}执行Propagate，因为b的指针集也是空的，所以也没什么变化</p>\n<ul>\n<li><p>但是因为b是变量，执行ProcessCall</p>\n<ul>\n<li>对{b,o4}进行Dispatch，由于b是从o4流过来的，所以Dispatch的结果是B.foo(A)</li>\n</ul>\n<p><strong>这里很好的体现了Pointer Analysis和CHA的区别，CHA是要对类和所有子类进行Dispatch，所以必然Dispatch的结果就不一样</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907220322648.png\" alt=\"image-20230907220322648\"></p>\n<ul>\n<li><p>接着把{B.foo,{o4}}添加到WL ,添加一条边从5(行号)-&gt;B.foo(A) </p>\n</li>\n<li><p>对m，调用AddReachable方法</p>\n<ul>\n<li><p>添加{B.foo(A)}到RM</p>\n</li>\n<li><p>把所有的statement都加入到S中</p>\n</li>\n<li><p>添加{r,o11}到WL</p>\n</li>\n</ul>\n</li>\n<li><p>添加边从a到y，在WL中加{y,o3}</p>\n</li>\n<li><p>连接从r到c</p>\n</li>\n</ul>\n</li>\n<li><p>继续处理WL中的元素</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907221447704.png\" alt=\"image-20230907221447704\"></p>\n<h2 id=\"总结-7\"><a href=\"#总结-7\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230907221511394.png\" alt=\"image-20230907221511394\"></p>\n<p><strong>Q1：指针分析对于method call的规则</strong></p>\n<ul>\n<li>做了4件事，Dispatch，传this，传参数，传返回值</li>\n</ul>\n<p><strong>Q2：过程间的指针分析算法</strong></p>\n<h1 id=\"Pointer-Analysis-Context-Sensitivity\"><a href=\"#Pointer-Analysis-Context-Sensitivity\" class=\"headerlink\" title=\"Pointer Analysis Context Sensitivity\"></a>Pointer Analysis Context Sensitivity</h1><h2 id=\"problem-of-Context-Insensitive-Pointer-Analysis\"><a href=\"#problem-of-Context-Insensitive-Pointer-Analysis\" class=\"headerlink\" title=\"problem of Context-Insensitive  Pointer Analysis\"></a>problem of Context-Insensitive  Pointer Analysis</h2><p>现在认为我们上一节学的指针分析就是<strong>上下文不敏感</strong>的指针分析</p>\n<ul>\n<li>对于动态分析来说，分析x.get的结果，返回的肯定是1，因为x指向的是new One</li>\n<li>对于常量传播而言，应用上节的指针分析算法，那么<ul>\n<li>在调用x &#x3D; id(n1)时，会把形参n1的指针集{o1}传给n</li>\n<li>在调用x &#x3D; id(n2)时，会把形参n2的指针集{o2}传给n</li>\n<li>结束时，会把n的指针集传给x和y，因为call graph就是这样构建的，只要n改了，就会加到WL中，那必然x 和y也会改</li>\n<li>所以x的指针集就是{o1,o2}，对于常量传播而言,i就是NAC，结果就是不准的</li>\n</ul>\n</li>\n</ul>\n<p><strong>问题是：id返回的值没有做区分，把o1,o2都返回了，就是上下文不敏感，其实本质上是在传参AddEdge时，并没有指定具体的方法形参</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230908152425903.png\" alt=\"image-20230908152425903\"></p>\n<p><strong>如果用上下文敏感进行分析 ，让n1指向的是id(n1)：n，这样结果就对了</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230908153448949.png\" alt=\"image-20230908153448949\"></p>\n<h2 id=\"Imprecision-of-Context-Insensitivity-C-I\"><a href=\"#Imprecision-of-Context-Insensitivity-C-I\" class=\"headerlink\" title=\"Imprecision of Context Insensitivity (C.I.)\"></a>Imprecision of Context Insensitivity (C.I.)</h2><p>Context Insensitivity不准的原因是：</p>\n<ul>\n<li><p>不同的方法调用的上下文不一样，如返回点，调用参数等</p>\n</li>\n<li><p>不同的方法的变量可能指向不同的对象</p>\n</li>\n<li><p>在CI的指针分析中，我们是直接传的，混在一起的，这里n被修改，导致x和y都被修改了</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230908154116108.png\" alt=\"image-20230908154116108\"></p>\n<h2 id=\"Context-Sensitivity-C-S\"><a href=\"#Context-Sensitivity-C-S\" class=\"headerlink\" title=\"Context Sensitivity (C.S.)\"></a>Context Sensitivity (C.S.)</h2><ul>\n<li>引入它就是分析不同的数据流</li>\n</ul>\n<p>最古老的最好的上下文敏感技术是call-site sensitivity</p>\n<ul>\n<li><p>代表了call site的调用链中每个方法的上下文</p>\n<ul>\n<li>方法的 call site</li>\n<li>caller 的call site</li>\n<li>call of caller call site</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230910142418510.png\" alt=\"image-20230910142418510\"></p>\n</li>\n<li><p>id就有2个上下文，2个call site</p>\n</li>\n</ul>\n<h3 id=\"Cloning-Based-Context-Sensitivity\"><a href=\"#Cloning-Based-Context-Sensitivity\" class=\"headerlink\" title=\"Cloning-Based Context Sensitivity\"></a>Cloning-Based Context Sensitivity</h3><ul>\n<li>在基于克隆的上下文敏感指针分析中，每个方法被被一个或多个上下文修饰</li>\n<li>实际上是在给变量加上下文</li>\n<li>相当于每个方法和它的变量都有了克隆</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230910143156063.png\" alt=\"image-20230910143156063\"></p>\n<ul>\n<li>这里的n就别clone 2次，这里就是用行号1 2对变量进行了标记，返回的时候，也会根据标记进行返回</li>\n</ul>\n<h3 id=\"Context-Sensitive-Heap\"><a href=\"#Context-Sensitive-Heap\" class=\"headerlink\" title=\"Context-Sensitive Heap\"></a>Context-Sensitive Heap</h3><ul>\n<li>OO程序(例如java)，它要频繁修改堆区，New的对象存储在堆里面</li>\n<li>所以要把上下文敏感应到到堆抽象中</li>\n<li>这里给每个oi，都添加了4个上下文</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230910143903012.png\" alt=\"image-20230910143903012\"></p>\n<p><strong>为什么对heap应用上下文敏感可以提升精度呢？</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230910144324225.png\" alt=\"image-20230910144324225\"></p>\n<ul>\n<li>在动态执行中，一个调用点在不同的 call  context下可能创建多个对象</li>\n<li>那不同的对象可能有不同的数据流，存不同的值到他们的field中</li>\n<li>如果没有heap context sensitive，那么可能会<strong>merge  data flows</strong>，这点很重要，参考前面的，如果有两个调用newX，那么就会都流到y，</li>\n</ul>\n<h4 id=\"An-Exmaple\"><a href=\"#An-Exmaple\" class=\"headerlink\" title=\"An Exmaple\"></a>An Exmaple</h4><h5 id=\"CS-but-no-CS-heap\"><a href=\"#CS-but-no-CS-heap\" class=\"headerlink\" title=\"CS but no CS heap\"></a><strong>CS but no CS heap</strong></h5><p>也就是上下文敏感，但是堆的上下文不敏感</p>\n<ul>\n<li><p>可以发现o8.f是o1, o2</p>\n</li>\n<li><p>本质原因是因为在算法中，并没有对方法中new的对象的创建点进行区分，认为都是一个创建点。</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230910154745904.png\" alt=\"image-20230910154745904\"></p>\n<h5 id=\"C-I-C-S-heap\"><a href=\"#C-I-C-S-heap\" class=\"headerlink\" title=\"C.I. + C.S heap\"></a>C.I. + C.S heap</h5><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230911222952191.png\" alt=\"image-20230911222952191\"></p>\n<p>右边是有堆的上下文敏感的，此时可以看到 3:x指向的对象是3:O8，堆上下文进行了区分。</p>\n<p>如果你是对堆上下文敏感，但是对象上下文不敏感，x处还是3:o8,4:o8，因为没有对x进行区分</p>\n<p>根据算法对上面的过程画PFG：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230910154432184.png\" alt=\"image-20230910154432184\"></p>\n<h2 id=\"Context-Sensitive-Pointer-Analysis-Rules\"><a href=\"#Context-Sensitive-Pointer-Analysis-Rules\" class=\"headerlink\" title=\"Context Sensitive Pointer Analysis: Rules\"></a>Context Sensitive Pointer Analysis: Rules</h2><h3 id=\"Domains\"><a href=\"#Domains\" class=\"headerlink\" title=\"Domains\"></a>Domains</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230911224055664.png\" alt=\"image-20230911224055664\"></p>\n<p>field本身不需要上下文</p>\n<p>当引用具体的field时，引用的是具体的某个对象的field</p>\n<p>上下文敏感的指针：上下文敏感的变量 和上下文敏感的对象的field</p>\n<p>指针集：原来是对象的集合，现在是有上下文的对象</p>\n<h3 id=\"Rules（4种基本语句）\"><a href=\"#Rules（4种基本语句）\" class=\"headerlink\" title=\"Rules（4种基本语句）\"></a>Rules（4种基本语句）</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230912105625551.png\" alt=\"image-20230912105625551\"></p>\n<p>Assign：</p>\n<p>在上下文c下的x和y，如果y指向c’下的oi，那x也指向c’下的oi。</p>\n<p>load：</p>\n<p>还是x和y在同样的上下文下，进行相关的操作</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><p>之前学的是4件事</p>\n<ol>\n<li>Dispatch</li>\n<li>传this</li>\n<li>传参数</li>\n<li>传返回值</li>\n</ol>\n<p>但是现在不一样了：</p>\n<ol>\n<li>Dispatch：取目标函数</li>\n<li>选择上下文：根据调用点l，为目标方法m选择一个上下文</li>\n</ol>\n<p>这里就用了前面的clone技术，是call -site sensitivity，这里用行号表示上下文</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230912110532590.png\" alt=\"image-20230912110532590\"></p>\n<ol start=\"3\">\n<li>传receive object：把Dispatch的结果，传给$c^t$的this方法</li>\n<li>传参数：传给特定上下文的参数。$c下的a_j传给c^t下的m_{pj}$</li>\n<li>传返回值：把$c^t下的m_{ret}传给c下的r$</li>\n</ol>\n<p><strong>关于上下文的理解：</strong></p>\n<ul>\n<li>正常函数调用时，也会有特定的栈调用特定的函数，每调用一次有新的栈，这就是上下文敏感</li>\n<li>相当于进房间每次都从一个门进，也从同样的门出</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230912111457558.png\" alt=\"image-20230912111457558\"></p>\n<h2 id=\"Pointer-Flow-Graph-with-C-S\"><a href=\"#Pointer-Flow-Graph-with-C-S\" class=\"headerlink\" title=\"Pointer Flow Graph with C.S.\"></a>Pointer Flow Graph with C.S.</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913145833196.png\" alt=\"image-20230913145833196\"></p>\n<p>Nodes：现在PFG中的节点都有上下文</p>\n<p>Edges：从一条边流到另一条边也是带有上下文的流动</p>\n<h2 id=\"C-S-Pointer-Analysis-Algorithm\"><a href=\"#C-S-Pointer-Analysis-Algorithm\" class=\"headerlink\" title=\"C.S. Pointer Analysis Algorithm\"></a>C.S. Pointer Analysis Algorithm</h2><p>该算法基本和C.I.的算法一样 </p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913151136893.png\" alt=\"image-20230913151136893\"></p>\n<p><strong>为什么callee(被调用者)有上下文？</strong></p>\n<ul>\n<li>因为要clone,保证多次调用不merge，不流到一处</li>\n</ul>\n<p><strong>为什么call site也有上下文？</strong></p>\n<ul>\n<li>一个call site在不同的上下文下，调用点方法可能不一样</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913151556753.png\" alt=\"image-20230913151556753\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913155333936.png\" alt=\"image-20230913155333936\">最开始给entry方法一个空的上下文</p>\n<p><strong>这里为什么c:m不属于RM？</strong></p>\n<p>为什么会有这种情况呢？</p>\n<p><strong>Select函数</strong></p>\n<p>根据四个参数选</p>\n<ul>\n<li>c 上下文</li>\n<li>l callsite</li>\n<li>c’ oi：receive object</li>\n<li>m：Dispatch找到的方法</li>\n</ul>\n<p>Select之后给this传receive object，就是让this指向现在的对象</p>\n<p><strong>整个流程是忽略控制流信息的</strong></p>\n<p>他只是拿的statements的集合，看整个流程，他也是先处理new ，处理 x &#x3D; y，再处理load store 方法调用，因此是flow insensitive</p>\n<h2 id=\"未尽事宜\"><a href=\"#未尽事宜\" class=\"headerlink\" title=\"未尽事宜\"></a>未尽事宜</h2><ul>\n<li>想一想pointer Analysis算法中一些细节是为什么？</li>\n<li>默写一下指针分析的算法，和C.S.的pointer Analysis</li>\n<li>看一下谭老师指针分析2020的论文</li>\n</ul>\n<p>Yue Li, Tian Tan, Anders Møller, and Yannis Smaragdakis. “A Principled Approach to  Selective Context Sensitivity for Pointer Analysis”. TOPLAS 2020</p>\n<h2 id=\"Context-Sensitivity-Variant\"><a href=\"#Context-Sensitivity-Variant\" class=\"headerlink\" title=\"Context Sensitivity Variant\"></a>Context Sensitivity Variant</h2><p>不是所有的技术都要考虑 Select的所有参数</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913160930816.png\" alt=\"image-20230913160930816\"></p>\n<h3 id=\"Context-insensitivity\"><a href=\"#Context-insensitivity\" class=\"headerlink\" title=\"Context insensitivity\"></a>Context insensitivity</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913161039320.png\" alt=\"image-20230913161039320\"></p>\n<p>C.I.是C.S.的一种特例，每次都返回一个空，也就是每次都一样，也就是上下文不敏感。</p>\n<h3 id=\"Call-site-Sensitivity\"><a href=\"#Call-site-Sensitivity\" class=\"headerlink\" title=\"Call-site Sensitivity\"></a>Call-site Sensitivity</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913161415976.png\" alt=\"image-20230913161415976\"></p>\n<ul>\n<li><p>每个上下文包含call sites的list，也就是一个调用链</p>\n<ul>\n<li>在一个method call中，他把call site加到caller的上下文中，作为callee 的上下文</li>\n<li>也就是是调用栈的抽象，(A.B.C.f方法)</li>\n</ul>\n</li>\n<li><p>只需要Select的<strong>前两个参数</strong>，c表示当前的上下文，从l’ 到l’’，l表示现在的call site，把l加进去</p>\n</li>\n</ul>\n<h4 id=\"An-example-2\"><a href=\"#An-example-2\" class=\"headerlink\" title=\"An example\"></a>An example</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913162203629.png\" alt=\"image-20230913162203629\"></p>\n<p><strong>问题：这里的void  bar()的上下文是什么？</strong></p>\n<ul>\n<li>在bar()方法中，又调用了自己。</li>\n<li>也就是程序从9跳转到13时，此时上下文是[3,9]</li>\n<li>但是执行到15时，又调用了13，再执行13方法，此时就是[3,9,15],……</li>\n<li>那就会有无穷无尽的上下文，指针分析不能终止</li>\n</ul>\n<h4 id=\"K-limiting-Context-Abstraction\"><a href=\"#K-limiting-Context-Abstraction\" class=\"headerlink\" title=\"K-limiting Context Abstraction\"></a>K-limiting Context Abstraction</h4><p>目的</p>\n<ul>\n<li>确保指针分析可以终止</li>\n<li>避免太多的上下文</li>\n</ul>\n<p>方法：设置一个上下文的边界 k</p>\n<ul>\n<li>每个上下文包括调用链中的最后k个call site</li>\n<li>对于method context k &#x3D; 2 ，对于 heap context k &#x3D;1</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913164033014.png\" alt=\"image-20230913164033014\"></p>\n<p><strong>对于上面的程序，k&#x3D;1时，void bar()的上下文是什么</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913163953139.png\" alt=\"image-20230913163953139\"></p>\n<ul>\n<li>也就是只有当前的call site，没有之前的call chain，所以执行到13时上下文就只有9，再往下执行，又会执行一次void bar()，<strong>所以上下文是[9,15]</strong></li>\n</ul>\n<p><strong>对于k&#x3D;2时</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913164300411.png\" alt=\"image-20230913164300411\"></p>\n<p><strong>此时上下文是call chain中的最后一个l’’ +  当前的call site</strong></p>\n<h4 id=\"1-Call-Site-Example\"><a href=\"#1-Call-Site-Example\" class=\"headerlink\" title=\"1-Call-Site: Example\"></a>1-Call-Site: Example</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913172338648.png\" alt=\"image-20230913172338648\"></p>\n<ul>\n<li>这里体现出了1-call-site 上下文敏感的作用，因为是1-call site，<strong>所以方法的上下文就是它的call site</strong>，没有之前的call chain</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913172711649.png\" alt=\"image-20230913172711649\"></p>\n<ul>\n<li>O12 和  O13直接沿着PFG传下去</li>\n</ul>\n<h4 id=\"C-I-VS-C-S-1-Call-Site\"><a href=\"#C-I-VS-C-S-1-Call-Site\" class=\"headerlink\" title=\"C.I. VS C.S.(1-Call-Site)\"></a>C.I. VS C.S.(1-Call-Site)</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913172845067.png\" alt=\"image-20230913172845067\"></p>\n<h3 id=\"Object-Sensitivity\"><a href=\"#Object-Sensitivity\" class=\"headerlink\" title=\"Object Sensitivity\"></a>Object Sensitivity</h3><ul>\n<li><p>每个上下文包含一系列抽象的对象的list</p>\n<ul>\n<li><p>在一个method call中，使用receiver object和它的heap context作为callee context</p>\n</li>\n<li><p>reveiver obejct +  heap context可以唯一确定一个对象</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913173347032.png\" alt=\"image-20230913173347032\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"An-Example-4\"><a href=\"#An-Example-4\" class=\"headerlink\" title=\"An Example\"></a>An Example</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913175033431.png\" alt=\"image-20230913175033431\"></p>\n<p><strong>为什么分析a1.set时，void doSet(B p)的上下文是o1呢？</strong></p>\n<ul>\n<li>因为object sensitivity主要由heap context 和receiver object构成，整个代码中可以看到是没有heap context 的，<strong>因为并没有在方法中new 一个对象</strong> </li>\n<li>所以只考虑receiver object,就是o1</li>\n</ul>\n<h4 id=\"1-Call-Site-vs-Object-Sensitivity\"><a href=\"#1-Call-Site-vs-Object-Sensitivity\" class=\"headerlink\" title=\"1-Call-Site vs Object Sensitivity\"></a>1-Call-Site vs Object Sensitivity</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913175914461.png\" alt=\"image-20230913175914461\"></p>\n<ul>\n<li>对于这个程序来说，显然1- call site是不准的，因为1-call site认为当前的call site就是他的上下文，所以在调用doSet时，都会认为上下文是12</li>\n<li>而object sensitivity是准的，它始终会让this指向receiver object，在判断上下文的时候，也会用的是当前的receiver object，那在一个方法里，receive object都是一个this,所以是准的</li>\n</ul>\n<p><strong>也就是1-call site只有一层，只记得上一层，二层方法调用就不好使了</strong></p>\n<p><strong>Object Sensitivity始终对象只有this</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913180919817.png\" alt=\"image-20230913180919817\"></p>\n<ul>\n<li>但是这种情况下，1-Object就不准了，因为this用了两次，这两个this指向的是同一个receiver object，那就会给同样的上下文</li>\n</ul>\n<h3 id=\"总结-8\"><a href=\"#总结-8\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>其实上面两种方法都很怕自己最关键的地方调用2次，就会merge</strong></p>\n<ul>\n<li>1-call-site是，1已经用尽的情况下，调用了2次同样的方法，2次就会认为是同样的上下文。</li>\n<li>1-object是在同一个方法中，用了2次this,2个this都指向的是receiver object</li>\n</ul>\n<h3 id=\"Type-Sensitivity\"><a href=\"#Type-Sensitivity\" class=\"headerlink\" title=\"Type Sensitivity\"></a>Type Sensitivity</h3><p>大佬觉得上面两个还是不够快，于是研究了这种方法</p>\n<ul>\n<li><p>每个上下文包括一系列type的list:</p>\n<ul>\n<li>在一个method call中，使用包含receiver object的调用点的type，和它的heap context作为callee context</li>\n<li>是在object sensitivity之上一个粗粒度的抽象</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913183532419.png\" alt=\"image-20230913183532419\"></p>\n</li>\n</ul>\n<p>在这个例子中吗，InType(o3)表示的就是o3所在的类，就是包含了receiver object的调用点的类</p>\n<h3 id=\"Type-vs-Object-Sensitivity\"><a href=\"#Type-vs-Object-Sensitivity\" class=\"headerlink\" title=\"Type vs Object Sensitivity\"></a>Type vs Object Sensitivity</h3><ul>\n<li>因为它是基于object sensitivity，它的精度肯定小于等于object sensitivity</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913184126640.png\" alt=\"image-20230913184126640\"></p>\n<p>对于object sensitivity，foo()的上下文是o3 o5 o7。</p>\n<p>如果对于Type Sensitivity,foo()的上下文只有X,他们的创建点都在X中。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230913184536688.png\" alt=\"image-20230913184536688\"></p>\n<h1 id=\"Static-Analysis-for-security\"><a href=\"#Static-Analysis-for-security\" class=\"headerlink\" title=\"Static Analysis for security\"></a>Static Analysis for security</h1><h2 id=\"Information-Flow-Security\"><a href=\"#Information-Flow-Security\" class=\"headerlink\" title=\"Information Flow Security\"></a>Information Flow Security</h2><p>目标</p>\n<ul>\n<li>避免不想要的信息流</li>\n</ul>\n<h3 id=\"Access-Control-vs-Information-Flow-Security\"><a href=\"#Access-Control-vs-Information-Flow-Security\" class=\"headerlink\" title=\"Access Control vs. Information Flow Security\"></a>Access Control vs. Information Flow Security</h3><p>Access Control</p>\n<ul>\n<li>检查程序是否有权限</li>\n<li>关心信息是如何访问的</li>\n</ul>\n<p>Information flow security</p>\n<ul>\n<li>可以追踪信息的流动</li>\n<li>关心信息是如何传播的</li>\n</ul>\n<h3 id=\"Information-Flow\"><a href=\"#Information-Flow\" class=\"headerlink\" title=\"Information Flow\"></a>Information Flow</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919141259543.png\" alt=\"image-20230919141259543\"></p>\n<ul>\n<li>和前面学的一样，箭头表示信息的流动</li>\n</ul>\n<h3 id=\"Information-Flow-security\"><a href=\"#Information-Flow-security\" class=\"headerlink\" title=\"Information Flow security\"></a>Information Flow security</h3><ul>\n<li>定义程序中的变量不同的安全等级</li>\n</ul>\n<h4 id=\"Security-Levels\"><a href=\"#Security-Levels\" class=\"headerlink\" title=\"Security Levels\"></a>Security Levels</h4><ul>\n<li>H : 就是hight security，保密信息</li>\n<li>L : 就是low security，公开的可观察到的信息</li>\n</ul>\n<p>安全等级用lattice进行抽象：L&lt;&#x3D; H</p>\n<h3 id=\"Information-Flow-Policy\"><a href=\"#Information-Flow-Policy\" class=\"headerlink\" title=\"Information Flow Policy\"></a>Information Flow Policy</h3><p>下面是**J. A. Goguen and J. Meseguer, “Security policies and security models”. S&amp;P 1982.*论文中提出的policy</p>\n<p>限制信息在不同的security level之间如何流动</p>\n<p>Noninterference policy：非干涉</p>\n<ul>\n<li>high variables 不能影响 low variables的信息</li>\n<li>也就是说不能通过观测low variables的信息来推测出high variables中的信息</li>\n</ul>\n<p><strong>Noninterference policy example</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919143041180.png\" alt=\"image-20230919143041180\"></p>\n<ul>\n<li>上面红色的是不允许的，因为high variables流到了low variables</li>\n</ul>\n<h2 id=\"Confidentiality-and-Integrity（保密性和完整性）\"><a href=\"#Confidentiality-and-Integrity（保密性和完整性）\" class=\"headerlink\" title=\"Confidentiality and Integrity（保密性和完整性）\"></a>Confidentiality and Integrity（保密性和完整性）</h2><p>保密性：防止信息流出去</p>\n<p>完整性：防止其他信息流进来，造成污染，污染了信息就不完整了</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919143432988.png\" alt=\"image-20230919143432988\"></p>\n<h3 id=\"Integrity\"><a href=\"#Integrity\" class=\"headerlink\" title=\"Integrity\"></a>Integrity</h3><p>涉及到了很多外部数据的注入，违反数据的完整性，CTF中常用的方法</p>\n<ul>\n<li>Command injection</li>\n<li>SQL inhecttion</li>\n<li>Xss</li>\n</ul>\n<h3 id=\"Confidentiality-and-Integrity\"><a href=\"#Confidentiality-and-Integrity\" class=\"headerlink\" title=\"Confidentiality and Integrity\"></a>Confidentiality and Integrity</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919143934943.png\" alt=\"image-20230919143934943\"></p>\n<h3 id=\"Integrity-更广泛的定义\"><a href=\"#Integrity-更广泛的定义\" class=\"headerlink\" title=\"Integrity 更广泛的定义\"></a>Integrity 更广泛的定义</h3><ul>\n<li>准确性：保护数据不被污染</li>\n<li>完全性：对于数据库系统，防止数据丢失</li>\n<li>一致性：对于文件传输系统，发送方和接收方需要是一样的</li>\n</ul>\n<h2 id=\"Explict-Flows-and-Covert-Channels（显示流和隐藏信道）\"><a href=\"#Explict-Flows-and-Covert-Channels（显示流和隐藏信道）\" class=\"headerlink\" title=\"Explict Flows and Covert Channels（显示流和隐藏信道）\"></a>Explict Flows and Covert Channels（显示流和隐藏信道）</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919145801828.png\" alt=\"image-20230919145801828\"></p>\n<p>前面这种直接赋值的方式就是显示流</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919150255672.png\" alt=\"image-20230919150255672\"></p>\n<p>对于这个程序，我们可以通过public来判断secret是否大于0，这就有了信息的流动，这种就是<strong>implicit flow</strong>隐式流。</p>\n<h3 id=\"Does-Secret-Information-Leak？\"><a href=\"#Does-Secret-Information-Leak？\" class=\"headerlink\" title=\"Does Secret Information Leak？\"></a>Does Secret Information Leak？</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919150858548.png\" alt=\"image-20230919150858548\"></p>\n<p>第二个可以通过执行时间判断，secret &lt; 0，会稳定的增加程序的执行时间</p>\n<p>最后一个如果secret 小于0，一定会爆出数组越界，所以也是会泄露信息。</p>\n<h3 id=\"Convert-Hidden-Channels\"><a href=\"#Convert-Hidden-Channels\" class=\"headerlink\" title=\"Convert&#x2F;Hidden Channels\"></a>Convert&#x2F;Hidden Channels</h3><ul>\n<li>隐藏信道意思就是他的最初的目的不是为了传递信息，这种叫隐藏信道</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919151104872.png\" alt=\"image-20230919151104872\"></p>\n<h3 id=\"Explicit-Flows-and-Convert-Channels\"><a href=\"#Explicit-Flows-and-Convert-Channels\" class=\"headerlink\" title=\"Explicit Flows and Convert Channels\"></a>Explicit Flows and Convert Channels</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919151452535.png\" alt=\"image-20230919151452535\"></p>\n<ul>\n<li>对于显示流，一下子泄露的是32bits的信息，但是对于隐式流，只是泄露1bit的信息</li>\n<li>所以现在集中于如何避免这些不想要的信息流，就是不让他胡乱传播。</li>\n</ul>\n<h2 id=\"Taint-Analysis-污点分析\"><a href=\"#Taint-Analysis-污点分析\" class=\"headerlink\" title=\"Taint Analysis(污点分析)\"></a>Taint Analysis(污点分析)</h2><p>把程序中的数据标记成两种：</p>\n<ul>\n<li>对于感兴趣的数据，给他打上标签，叫做污点数据</li>\n<li>其他的数据，叫非污点的数据</li>\n</ul>\n<p><strong>污点数据的源是source</strong>，实际上，通常污点数据来自于一些方法的返回值</p>\n<p>污点分析就是追踪数据如何流动的，把它<strong>流到的位置叫sink</strong>，实际上sink通常是一些敏感的方法</p>\n<h3 id=\"Taint-Analysis-：Two-Applications\"><a href=\"#Taint-Analysis-：Two-Applications\" class=\"headerlink\" title=\"Taint Analysis ：Two Applications\"></a>Taint Analysis ：Two Applications</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919152424513.png\" alt=\"image-20230919152424513\"></p>\n<p>保护保密性：</p>\n<ul>\n<li>Source：secret data的source</li>\n<li>Sink：泄露的地方</li>\n<li>针对Information leaks问题</li>\n</ul>\n<p>保护完整性：</p>\n<ul>\n<li>Source：不可信的数据source</li>\n<li>Sink：critical computation(关键计算)</li>\n<li>针对Injection erros</li>\n</ul>\n<h3 id=\"Taint-Analysis-and-Pointer-Analysis-Together\"><a href=\"#Taint-Analysis-and-Pointer-Analysis-Together\" class=\"headerlink\" title=\"Taint Analysis and Pointer Analysis, Together*\"></a>Taint Analysis and Pointer Analysis, Together*</h3><ul>\n<li>污点分析关注的问题是污点数据能否流到sink处？</li>\n<li>换种方式就是，sink的指针是否指向tainted data？</li>\n</ul>\n<p>！！！这不就来了么，这不就和前面学的指针分析非常非常像！</p>\n<details class=\"custom-details\">\n<summary>隐藏内容</summary>\n<p><p>污点分析关注污点数据在程序中如何流动</p>\n<p>指针分析关注抽象的对象在程序中如何流动</p>\n</p>\n</details>\n<p><strong>那怎么做呢，如何结合呢？</strong></p>\n<ul>\n<li>把污点数据当成是特殊的object</li>\n<li>把source当成是allocation sites</li>\n<li>利用指针分析去传播污点数据</li>\n</ul>\n<h3 id=\"Domains-and-Notations-1\"><a href=\"#Domains-and-Notations-1\" class=\"headerlink\" title=\"Domains and Notations\"></a>Domains and Notations</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919155213302.png\" alt=\"image-20230919155213302\"></p>\n<p>这里以C.I.为例，结合指针分析和污点分析</p>\n<ul>\n<li>在域中新加入了Tainted data，污点数据</li>\n<li>ti表示call site i 的tainted data</li>\n</ul>\n<h3 id=\"Taint-Analysis：Inputs-Outputs\"><a href=\"#Taint-Analysis：Inputs-Outputs\" class=\"headerlink\" title=\"Taint Analysis：Inputs &amp; Outputs\"></a>Taint Analysis：Inputs &amp; Outputs</h3><p>Inputs：</p>\n<ul>\n<li>Sources：a set of source methods（调用返回污点数据的方法）</li>\n<li>Sinks：a set of sink methods（污点数据流到的违反了security polices的方法）</li>\n</ul>\n<p>Outputs：</p>\n<ul>\n<li>TaintFlows：一系列污点数据的集合和sink 方法</li>\n</ul>\n<p> 例如&lt;ti,m&gt;属于TaintFlows，表明来自调用点i(source method)的污点数据可能流到sink method m</p>\n<h3 id=\"Rules：Call\"><a href=\"#Rules：Call\" class=\"headerlink\" title=\"Rules：Call\"></a>Rules：Call</h3><p>处理source</p>\n<ul>\n<li>这里的l理解成调用点，m理解成调用的目标方法，如果目标方法是Source，就把tl加到r的指针集中</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919155237335.png\" alt=\"image-20230919155237335\"></p>\n<h3 id=\"Rules：Same-As-Pointer-Analysis\"><a href=\"#Rules：Same-As-Pointer-Analysis\" class=\"headerlink\" title=\"Rules：Same As Pointer Analysis\"></a>Rules：Same As Pointer Analysis</h3><p>处理传播</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919155357590.png\" alt=\"image-20230919155357590\"></p>\n<h3 id=\"Rules：Call-1\"><a href=\"#Rules：Call-1\" class=\"headerlink\" title=\"Rules：Call\"></a>Rules：Call</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919155610097.png\" alt=\"image-20230919155610097\"></p>\n<p>处理Sink</p>\n<ul>\n<li>从CAll graph中取出目标方法</li>\n<li>如果目标方法属于Sink，如果参数中有污点数据，就把他加到TaintFlows</li>\n</ul>\n<h3 id=\"An-Example-5\"><a href=\"#An-Example-5\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919163312880.png\" alt=\"image-20230919163312880\"></p>\n<ul>\n<li><p>因为认为getPassword是一个Sink，所以根据Rule，会把t3加入到pw的指针集中</p>\n</li>\n<li><p>对于第七行log，因为log是一个sink方法，所以会检查他的参数s,s指向t3，而t3是一个污点的数据，在pw的指针集中。</p>\n</li>\n<li><p>所以把&lt;t3,log(String)&gt;加入到TainfFlows中，表示t3这个污点数据会流到log(String)方法中，会泄露出去。也可以通过PFG发现整个泄露的流程</p>\n<p><strong>但是指针分析也有处理不了的方法，比如这个”+”，append方法，就没法处理</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919163549201.png\" alt=\"image-20230919163549201\"></p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230919163622524.png\" alt=\"image-20230919163622524\"></p>\n<h1 id=\"Datalog-Based-Program-Analysis\"><a href=\"#Datalog-Based-Program-Analysis\" class=\"headerlink\" title=\"Datalog-Based Program Analysis\"></a>Datalog-Based Program Analysis</h1><h2 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h2><h3 id=\"Imperative-vs-Declarative-命名式-vs-声明式\"><a href=\"#Imperative-vs-Declarative-命名式-vs-声明式\" class=\"headerlink\" title=\"Imperative vs Declarative(命名式 vs 声明式)\"></a>Imperative vs Declarative(命名式 vs 声明式)</h3><ul>\n<li><p>Imperative：怎么做，java c++都是声明式语言</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921100616138.png\" alt=\"image-20230921100616138\"></p>\n</li>\n<li><p>Declarative：做什么，SQL</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921100626387.png\" alt=\"image-20230921100626387\"></p>\n</li>\n</ul>\n<h4 id=\"Pointer-Analysis-Imperative-Implementation\"><a href=\"#Pointer-Analysis-Imperative-Implementation\" class=\"headerlink\" title=\"Pointer Analysis Imperative Implementation\"></a>Pointer Analysis Imperative Implementation</h4><p> 如果要用命名式的语言实现指针分析，也就是具体的写一个代码，需要非常多细节的东西。</p>\n<h4 id=\"Pointer-Analysis-Declarative-Implementation\"><a href=\"#Pointer-Analysis-Declarative-Implementation\" class=\"headerlink\" title=\"Pointer Analysis Declarative Implementation\"></a>Pointer Analysis Declarative Implementation</h4><ul>\n<li>如果用datalog，就会很简单</li>\n</ul>\n<h2 id=\"Datalog\"><a href=\"#Datalog\" class=\"headerlink\" title=\"Datalog\"></a>Datalog</h2><ul>\n<li>是一种声明式的逻辑程序语言</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921112032438.png\" alt=\"image-20230921112032438\"></p>\n<ul>\n<li>没有赋值</li>\n<li>没有控制流</li>\n<li>没有函数</li>\n<li>不是图灵完备的</li>\n</ul>\n<h3 id=\"Predicates-Data-谓词\"><a href=\"#Predicates-Data-谓词\" class=\"headerlink\" title=\"Predicates(Data) 谓词\"></a>Predicates(Data) 谓词</h3><ul>\n<li>Datalog中，<strong>Predicates</strong> 位词（也可以叫relation）是一些列陈述的集合</li>\n<li>谓词是a table of data</li>\n<li>一个 <strong>fact</strong> 就是一个table中的一个tuple(元组)，通俗说就是属于这个表中的一条数据</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921112615343.png\" alt=\"image-20230921112615343\"></p>\n<ul>\n<li>显然根据这个例子，Xiaoming,18是一个fact，Abao,23不是一个fact</li>\n</ul>\n<h4 id=\"Atoms（元值，最小不可切分的一部分）\"><a href=\"#Atoms（元值，最小不可切分的一部分）\" class=\"headerlink\" title=\"Atoms（元值，最小不可切分的一部分）\"></a>Atoms（元值，最小不可切分的一部分）</h4><ul>\n<li>Atoms是Datalog中基本的元素，Atoms是Datalog的predicate</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921112906966.png\" alt=\"image-20230921112906966\"></p>\n<ul>\n<li>Terms<ul>\n<li>可以说变量：代表任意一个值 ，Age(person,age)</li>\n<li>也可以是常量 ，Age(“Xiaoming”,18)</li>\n</ul>\n</li>\n</ul>\n<p>P(X1,X2,…,Xn)是relational atom(关系型元词)</p>\n<p>Age(“Xiaoming”,18)就是relational atom(关系型元词)</p>\n<p>除了关系型元词，还有算数型元词</p>\n<ul>\n<li>age &gt;&#x3D; 18</li>\n</ul>\n<h3 id=\"Datalog-Rules-Logic\"><a href=\"#Datalog-Rules-Logic\" class=\"headerlink\" title=\"Datalog Rules(Logic)\"></a>Datalog Rules(Logic)</h3><ul>\n<li><p>Rule是表示逻辑推理的方法</p>\n</li>\n<li><p>Rule也用来具体说明fact是如何推断出来的</p>\n</li>\n<li><p>rule的形式是：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921114331264.png\" alt=\"image-20230921114331264\"></p>\n</li>\n<li><p>这里意味着从Body推出head，如果body是真的，那么head是真的</p>\n</li>\n<li><p>这里的逗号看成逻辑与</p>\n</li>\n</ul>\n<h3 id=\"Interpretation-of-Datalog-Rules\"><a href=\"#Interpretation-of-Datalog-Rules\" class=\"headerlink\" title=\"Interpretation of Datalog Rules\"></a>Interpretation of Datalog Rules</h3><ul>\n<li>考虑子目标中所有可能的组合</li>\n<li>如果一个组合让所有的subgoals都是true，那这个head astom也是真的</li>\n<li>这个head的predicate包含了所有的true astorm</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921120449099.png\" alt=\"image-20230921120449099\"></p>\n<p>对于一个Datalog program，就是Facts + Rules</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921120748690.png\" alt=\"image-20230921120748690\"></p>\n<p><strong>问题：那最开始的fact咋来的呢？</strong></p>\n<h3 id=\"EDB-and-IDB-Predicates\"><a href=\"#EDB-and-IDB-Predicates\" class=\"headerlink\" title=\"EDB and IDB Predicates\"></a>EDB and IDB Predicates</h3><p>datalog中提供了2种谓词</p>\n<ul>\n<li>EDB（Extensional database 外部数据库）<ul>\n<li>谓词是最开始被定义的</li>\n<li>relations是可以枚举的</li>\n<li>看成是input relations，因为是<strong>输入的</strong>，所以不需要经过推理</li>\n</ul>\n</li>\n<li>IDB（intensional database ）<ul>\n<li>谓词是通过rules建立的</li>\n<li>relations是由规则判断的</li>\n<li>能被看成是<strong>输出的</strong>relations，通过rules推导出来的</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921121713684.png\" alt=\"image-20230921121713684\"></p>\n<h3 id=\"Logical-Or\"><a href=\"#Logical-Or\" class=\"headerlink\" title=\"Logical Or\"></a>Logical Or</h3><p>Datalog中有两种表达Logical or的方式</p>\n<ul>\n<li>在头部写多个Rules</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921122002702.png\" alt=\"image-20230921122002702\"></p>\n<ul>\n<li><p>使用逻辑 or 操作符 分号 ; </p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921122028830.png\" alt=\"image-20230921122028830\"></p>\n</li>\n</ul>\n<p>逻辑or的优先级比逻辑与and低</p>\n<h3 id=\"Negation-逻辑非\"><a href=\"#Negation-逻辑非\" class=\"headerlink\" title=\"Negation(逻辑非)\"></a>Negation(逻辑非)</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921122323659.png\" alt=\"image-20230921122323659\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921122330377.png\" alt=\"image-20230921122330377\"></p>\n<ul>\n<li>对于计算补考的学生，就用<code>Student(student),!PassedStd(student)</code></li>\n</ul>\n<h3 id=\"Recursion\"><a href=\"#Recursion\" class=\"headerlink\" title=\"Recursion\"></a>Recursion</h3><ul>\n<li>Datalog支持递归的规则<ul>\n<li>这也就意味着IDB predicate能从它自身推断出来</li>\n</ul>\n</li>\n<li>例如，我们可以通过递归的规则计算图的可达性</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921122908651.png\" alt=\"image-20230921122908651\"></p>\n<ul>\n<li>已知Edge(a,b)是从a到b之间有一条边，Reach(a,b)是从a可以到b</li>\n<li>那么可以推导出Reach(from,to)，从from到node可达，且从node到to之间有一条边，那么从from到to就可达</li>\n</ul>\n<p><strong>有了递归的好处在于</strong></p>\n<ul>\n<li><p>如果没有，就像sql一样，只能表达基本的查询</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token keyword\">from</span>  <span class=\"token keyword\">where</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"Rule-Safety\"><a href=\"#Rule-Safety\" class=\"headerlink\" title=\"Rule Safety\"></a>Rule Safety</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921124150328.png\" alt=\"image-20230921124150328\"></p>\n<p>对于这两个rules，B(y)可以理解成在B中</p>\n<ul>\n<li>首先左边满足B,且x &gt;y，但是并没有限制x，所以会穷举所有的x，所以是无穷的</li>\n<li>对于右边的，同样是无穷的</li>\n</ul>\n<p>这种情况下，会让A也是无穷的，Datalog一直在计算</p>\n<p><strong>Datalog规定的规则：</strong></p>\n<ul>\n<li>A rule是safe当每个变量至少出现在一个<strong>non-nagated relations atom</strong>中。就是不出现在非中<ul>\n<li>因为非是一个无穷的集合，所以要不出现在非中</li>\n</ul>\n</li>\n<li>上面两个rules是safe</li>\n<li>datalog只允许写下安全的rules</li>\n</ul>\n<h3 id=\"Recursion-and-Negation\"><a href=\"#Recursion-and-Negation\" class=\"headerlink\" title=\"Recursion and Negation\"></a>Recursion and Negation</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921180244052.png\" alt=\"image-20230921180244052\"></p>\n<p>在这个例子中，如果B(1)是true，</p>\n<ul>\n<li><p>假设A(1)是false，这又推导出A(1)是true。</p>\n</li>\n<li><p>假设A(1)是false, A(1)又是true</p>\n</li>\n</ul>\n<p>所以这互相矛盾。</p>\n<p><strong>因此，Datalog中，递归和一个atom的非必须是分开的。</strong></p>\n<h3 id=\"Execution-of-Datalog-Programs\"><a href=\"#Execution-of-Datalog-Programs\" class=\"headerlink\" title=\"Execution of Datalog Programs\"></a>Execution of Datalog Programs</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921180047314.png\" alt=\"image-20230921180047314\"></p>\n<ul>\n<li>通过输入EDB和Rules，在datalog engine中，直到没有新的IDB生成</li>\n<li>单调性：只会有越来越多的facts，facts不会被删除</li>\n<li>一定会终止：<ul>\n<li>因为是单调的</li>\n<li>根据rule safety，是不允许它一直递归下去的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pointer-Analysis-via-Datalog\"><a href=\"#Pointer-Analysis-via-Datalog\" class=\"headerlink\" title=\"Pointer Analysis via Datalog\"></a>Pointer Analysis via Datalog</h2><p>EDB：指针分析中的EDB就是指针相关的信息</p>\n<p>IDB：指针分析的结果</p>\n<p>Rules:指针分析的rules</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921205344214.png\" alt=\"image-20230921205344214\"></p>\n<h3 id=\"An-Example-6\"><a href=\"#An-Example-6\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><h4 id=\"形成EDB\"><a href=\"#形成EDB\" class=\"headerlink\" title=\"形成EDB\"></a>形成EDB</h4><ul>\n<li>把程序变成谓词</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921205716360.png\" alt=\"image-20230921205716360\"></p>\n<h4 id=\"Datalog-Rules-for-Pointer-Analysis\"><a href=\"#Datalog-Rules-for-Pointer-Analysis\" class=\"headerlink\" title=\"Datalog Rules for Pointer Analysis\"></a>Datalog Rules for Pointer Analysis</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921210232986.png\" alt=\"image-20230921210232986\"></p>\n<ul>\n<li>红色表示已知的，蓝色表示推导出的结果</li>\n<li>这就可以看出用datalog实现pointer analysis十分的简洁</li>\n</ul>\n<h4 id=\"具体实现-算法\"><a href=\"#具体实现-算法\" class=\"headerlink\" title=\"具体实现(算法)\"></a>具体实现(算法)</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921211331632.png\" alt=\"image-20230921211331632\"></p>\n<ul>\n<li>首先判断符合new的语句，枚举表中的所有情况，在varPointsTo中添加，b o1 ,c o3</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921210953424.png\" alt=\"image-20230921210953424\"></p>\n<ul>\n<li>应用assign的规则</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921211009881.png\" alt=\"image-20230921211009881\"></p>\n<ul>\n<li>应用store：</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921211313188.png\" alt=\"image-20230921211313188\"></p>\n<ul>\n<li>应用load</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230921211400383.png\" alt=\"image-20230921211400383\"></p>\n<p>根据已有fact，应用rules，得到更多的fact,实际执行时候是不断迭代的，有新的rules能调用，就调用，并不是上面写的算法的过程。</p>\n<h3 id=\"Handle-method-calls\"><a href=\"#Handle-method-calls\" class=\"headerlink\" title=\"Handle method calls\"></a>Handle method calls</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922210954500.png\" alt=\"image-20230922210954500\"></p>\n<p>ThisVar：存在是this指针，m就是方法，this就是变量</p>\n<p>由于方法调用是做4件事，这里也是在做4件事，这里用了3个rule</p>\n<p><strong>第一个Rule:Dispatch，传this</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922211113498.png\" alt=\"image-20230922211113498\"></p>\n<p>EDB:</p>\n<ul>\n<li>首先是一个virtucal call，l：表示调用点，也是Label，x是变量，k是方法</li>\n<li>VarPointsTo表示x指向oi</li>\n<li>利用Dispatch表，找到了目标方法m</li>\n<li>根据ThisVar表，得到了this</li>\n</ul>\n<p>IDB：</p>\n<p>根据上面的输入，得到了</p>\n<ul>\n<li>传this，也就是this也指向o</li>\n<li>把m方法加到Reachable中</li>\n</ul>\n<p><strong>第二个Rule：传参数</strong></p>\n<p>Argument：l是调用点,i表示第几个，下标，,a实参</p>\n<p>Parameter：m是放，i表示第几个，下标，p形参</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922210542971.png\" alt=\"image-20230922210542971\"></p>\n<p><strong>第三个Rule：传返回值</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922210734375.png\" alt=\"image-20230922210734375\"></p>\n<ul>\n<li>根据CallGraph获取方法m</li>\n<li>获取m方法的返回值</li>\n<li>获取返回值的指针</li>\n<li>获取接收的方法，把o传给接收的方法</li>\n</ul>\n<p>对于全程序的指针分析</p>\n<ul>\n<li><p>入口方法一定是可达的，所以要加一个EntryMethod</p>\n</li>\n<li><p>对于new，要加一个Reachable，只有方法可达，才处理</p>\n</li>\n</ul>\n<p><strong>那为什么只有new加了Reachable呢？</strong></p>\n<ul>\n<li>因为其他方法都有VarPointsTo，如果方法不可达，那VarPointsTo肯定为假，所以也就不会触发相关的load store语句</li>\n</ul>\n<h2 id=\"Taint-Analysis-via-Datalog\"><a href=\"#Taint-Analysis-via-Datalog\" class=\"headerlink\" title=\"Taint Analysis via Datalog\"></a>Taint Analysis via Datalog</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922212727819.png\" alt=\"image-20230922212727819\"></p>\n<p>在指针分析的基础上</p>\n<ul>\n<li>需要Source</li>\n<li>需要Sink</li>\n<li>Taint：关联每个call site到污点数据的call site</li>\n</ul>\n<p>IDB predicate</p>\n<ul>\n<li>TaintFlow(t:T, m : M )表示t这个污点数据会流到sink method m处</li>\n</ul>\n<h3 id=\"Handle-Sources-and-Sinks\"><a href=\"#Handle-Sources-and-Sinks\" class=\"headerlink\" title=\"Handle Sources and Sinks\"></a>Handle Sources and Sinks</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922213020094.png\" alt=\"image-20230922213020094\"></p>\n<p>Handle sources：</p>\n<ul>\n<li>CallGraph：l , m</li>\n<li>现在告诉我m是个Source方法</li>\n<li>接收变量是r</li>\n<li>Taint告诉我现在在l 处产生了一个污点数据t</li>\n<li>因此把r 指向t</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922213027486.png\" alt=\"image-20230922213027486\"></p>\n<ul>\n<li>取出调用边</li>\n<li>现在m方法的第i个参数是个Sink</li>\n<li>取出第i个的实参</li>\n<li>取出它的指针集</li>\n<li>从Taint中取出它的label  j </li>\n<li>推导出从j处来的可能流到l调用点处的第i个参数中。</li>\n</ul>\n<p><strong>本质上就把EDB理解成表，所以EDB的rules就是在查表，IDB就是通过查表得出来的结论。</strong></p>\n<h2 id=\"总结-9\"><a href=\"#总结-9\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>优势：</p>\n<ul>\n<li>代码可读性很强</li>\n<li>隐藏了很多细节，所以很容易实现</li>\n<li>从优化的引擎中可以获益</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>限制了表达逻辑，有些情况不能表达</li>\n<li>不能完全控制，因为中间是个引擎，是个黑盒子</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230922214453887.png\" alt=\"image-20230922214453887\"></p>\n<h1 id=\"CFL-Reachability-and-IFDS\"><a href=\"#CFL-Reachability-and-IFDS\" class=\"headerlink\" title=\"CFL-Reachability and IFDS\"></a>CFL-Reachability and IFDS</h1><p><strong>Infeasible Paths：</strong></p>\n<ul>\n<li>PFG中不会被执行的边</li>\n</ul>\n<p>给定一个path，在静态时无法判断一条path是不是假边</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230923170828100.png\" alt=\"image-20230923170828100\"></p>\n<p>根据语义，age是年龄，那就一定大于0，所以右边这条红色的一定不会被执行。这样的path是infeasible path。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230923170842992.png\" alt=\"image-20230923170842992\"></p>\n<ul>\n<li><p>考虑上下文不敏感的情况，那x 和y的结果会有-1。</p>\n</li>\n<li><p>指针分析中最右边走r的路径仍然不可避免。</p>\n</li>\n<li><p>但是因为上下文不敏感导致错误的返回是可以避免的</p>\n</li>\n</ul>\n<h2 id=\"Realizable-Paths\"><a href=\"#Realizable-Paths\" class=\"headerlink\" title=\"Realizable Paths\"></a>Realizable Paths</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230923173422879.png\" alt=\"image-20230923173422879\"></p>\n<p>Realizable Paths：return应该和相应的call匹配</p>\n<ul>\n<li>Realizable path可能不会被执行，但是unealizable path应该一定不能被执行(也就是从1的call进来，不能从2的return出去)</li>\n</ul>\n<p>因此现在的目标就变成了<strong>找到Realizable path</strong></p>\n<p>那如何找呢？</p>\n<p>CFL-Reachability</p>\n<h2 id=\"CFL-Reachability-context-free-language\"><a href=\"#CFL-Reachability-context-free-language\" class=\"headerlink\" title=\"CFL-Reachability(context free language)\"></a>CFL-Reachability(context free language)</h2><h3 id=\"Context-free-grammar-CFG\"><a href=\"#Context-free-grammar-CFG\" class=\"headerlink\" title=\"Context-free grammar(CFG)\"></a>Context-free grammar(CFG)</h3><p>CFG是形式语言的描述方法，CFG 中的产生式规则由两部分组成：一个非终结符和一个由终结符和非终结符组成的符号串</p>\n<p>​\t\t$S-&gt;\\alpha$</p>\n<p>S表示非终结符，$\\alpha$表示终结符或者非终结符，或者空。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230923172708894.png\" alt=\"image-20230923172708894\"></p>\n<h3 id=\"CFL-Reachability\"><a href=\"#CFL-Reachability\" class=\"headerlink\" title=\"CFL-Reachability\"></a>CFL-Reachability</h3><p>用括号匹配的方式完成上面提出的问题，实现每一个call都对应它的return。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230923173819872.png\" alt=\"image-20230923173819872\"></p>\n<p>通过CFL进行括号匹配</p>\n<ul>\n<li>每个右括号都要有一个左括号，但是不是每一个左括号都有一个右括号<ul>\n<li>因为前面表示return要有对应的call，先有了左括号，才会有右括号的事。但是不是有左括号，就一定有右括号，因为可能程序还没有执行到return。</li>\n</ul>\n</li>\n<li>每个call site i，call edge是 (i，return edge 是)i，给每个edge都加了一个Label，也就是括号</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011152614451.png\" alt=\"image-20231011152614451\"></p>\n<p>A path是一个realizable path，如果path的word在Language L中。</p>\n<p>推导这个匹配的过程</p>\n<p>对于realizable</p>\n<ul>\n<li>对于1，realizable -&gt; matched realizable，mathed就是已经匹配的，对应1中的绿色部分</li>\n<li>第一个式子，就是个递归，realizable -&gt; $(_i realizable$,也就可以匹配多个单括号的情况，也就是2</li>\n</ul>\n<p>对于matched：</p>\n<ul>\n<li>matched 可以是一个e，也就是对应3  的情况</li>\n<li>也可以是一个$\\varepsilon$，就是很多很多e</li>\n<li>最后这个matched matched对应4的情况</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011154049504.png\" alt=\"image-20231011154049504\"></p>\n<ul>\n<li>应用上面的规则，左边就是realizable path，右边就不是realizable path</li>\n</ul>\n<h2 id=\"IFDS\"><a href=\"#IFDS\" class=\"headerlink\" title=\"IFDS\"></a>IFDS</h2><p>A Program Analysis Framework via Graph Reachablity</p>\n<ul>\n<li>通过图可达性进行程序分析</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011154726914.png\" alt=\"image-20231011154726914\"></p>\n<p>IFDS是<strong>interprocedural,Finite,Distributive, Subset Problem</strong></p>\n<ul>\n<li><p>interprocedural：全程序分析</p>\n</li>\n<li><p>Finite： domain是finite</p>\n</li>\n<li><p>distributive：分发的</p>\n</li>\n</ul>\n<p>IFDS提供了MRP solution。</p>\n<h3 id=\"Meet-Over-All-Realizable-Paths（MRP）\"><a href=\"#Meet-Over-All-Realizable-Paths（MRP）\" class=\"headerlink\" title=\"Meet-Over-All-Realizable-Paths（MRP）\"></a>Meet-Over-All-Realizable-Paths（MRP）</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011155237626.png\" alt=\"image-20231011155237626\"></p>\n<ul>\n<li>MOP是所有边都应用transfer function</li>\n<li>MRP是只对realizable path应用transfer funciton</li>\n</ul>\n<h3 id=\"Overview-of-IFDS\"><a href=\"#Overview-of-IFDS\" class=\"headerlink\" title=\"Overview of IFDS\"></a>Overview of IFDS</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011161625201.png\" alt=\"image-20231011161625201\"></p>\n<p>是一个程序分析框架</p>\n<p>给定一个程序P，和一个分析问题Q</p>\n<ul>\n<li>构建一个supergraph，理解成前面讲的ICFG，并且定义了flow function，也就是图1中蓝色的部分</li>\n<li>构建一个**exploded supergraph **G#，把flow function转换成了representation relations</li>\n<li>最后在G#上遍历，解决Q</li>\n</ul>\n<p>最后，n是一个program point，d属于MRP，如果有一个realizable path在G#中，从S的main方法到n</p>\n<h4 id=\"Supergraph\"><a href=\"#Supergraph\" class=\"headerlink\" title=\"Supergraph\"></a>Supergraph</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011162148173.png\" alt=\"image-20231011162148173\"></p>\n<p>G*代表supergrah</p>\n<ul>\n<li>G*是一个collection，包括所有的G1,G2</li>\n<li>每个Gp都有一个start node 和一个exit node</li>\n<li>把call方法变成了一个call node 和一个return site node</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011162430640.png\" alt=\"image-20231011162430640\"></p>\n<p>这里有3种边</p>\n<ul>\n<li>intraprocedural call-return edge：紫色部分</li>\n<li>call-to-start edge：绿色边</li>\n<li>exit-to-return edge：蓝色边</li>\n</ul>\n<h4 id=\"Design-Flow-Functions\"><a href=\"#Design-Flow-Functions\" class=\"headerlink\" title=\"Design Flow Functions\"></a>Design Flow Functions</h4><p><strong>$\\lambda$-expressions</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011163115884.png\" alt=\"image-20231011163115884\"></p>\n<ul>\n<li>是一个匿名函数</li>\n<li>$\\lambda e_{pardam}.e_{body}$,第一个是参数，第二个是Body</li>\n<li>($\\lambda x.x+1$)3，表示执行这个函数，输出就是4</li>\n</ul>\n<p><strong>design flow functions</strong></p>\n<p>目标是：判断是否被初始化</p>\n<p>认为未初始化是sound的。都假定未初始化都是1。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011164842258.png\" alt=\"image-20231011164842258\"></p>\n<ol>\n<li>程序中定义了x,g两个变量</li>\n<li>因为x已经被初始化了，把它从S中除去</li>\n<li>进入方法，所有的x由a替换</li>\n<li>g被初始化</li>\n<li>a-g的结果取决于，a和g两个，如果a和g中有一个没被初始化，a就没被初始化，加到S中，否则被出池化</li>\n<li>程序最后出来减去a</li>\n</ol>\n<p><strong>红框的内容，对应之前学的为什么要有call–&gt;return的边。</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011165547502.png\" alt=\"image-20231011165547502\"></p>\n<ul>\n<li><p>因为要传Local variable，在这里也就是传g</p>\n</li>\n<li><p>如果这里直接是$\\lambda S.S$，它也一定是sound的，你就认为它没初始化</p>\n</li>\n<li><p>为什么要减去g呢？</p>\n<ul>\n<li>首先程序是may analysis，也就是有一条边初始化了，就认为是初始化了，所以merge处是**+**</li>\n<li>那这里减去g就表示现在$\\lambda S.S$里面没有g，那最后有没有g完全由方法p决定，因为结果是+。方法里说定义了就是定义了，没定义就是没定义。</li>\n<li>如果不减，就默认，S中有g，一定会传下去，那就是不准的，因为并不知道会不会传下去。</li>\n</ul>\n<p><strong>关键点在于这个Merge的结果是什么。</strong></p>\n</li>\n</ul>\n<h4 id=\"Build-Exploded-Supergraph\"><a href=\"#Build-Exploded-Supergraph\" class=\"headerlink\" title=\"Build Exploded Supergraph\"></a>Build Exploded Supergraph</h4><h1 id=\"关于must-analysis-和-may-analysis的理解终极版\"><a href=\"#关于must-analysis-和-may-analysis的理解终极版\" class=\"headerlink\" title=\"关于must analysis 和 may analysis的理解终极版\"></a>关于must analysis 和 may analysis的理解终极版</h1><table>\n<thead>\n<tr>\n<th></th>\n<th>Reaching Definitons</th>\n<th>Live avaliable analysis</th>\n<th>avaliable expressions analysis</th>\n<th>变量是否初始化分析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>must&#x2F;may analysis</td>\n<td>may analysis</td>\n<td>may analysis</td>\n<td>must analysis</td>\n<td>may analysis</td>\n</tr>\n<tr>\n<td>unsafe的情况</td>\n<td>所有变量都不能到达</td>\n<td>所有变量都不活跃</td>\n<td>所有表达式都可用</td>\n<td>所有变量都未初始化</td>\n</tr>\n<tr>\n<td>safe but useful</td>\n<td>所有变量均可到达</td>\n<td>所有变量都活跃</td>\n<td>所有表达式都不可用</td>\n<td>所有变量都初始化</td>\n</tr>\n<tr>\n<td>目标</td>\n<td>找到未到达的变量，进行替换</td>\n<td>找到不活跃的变量进行替换</td>\n<td>对可用的表达式进行替换</td>\n<td>对未初始化的变量进行替换</td>\n</tr>\n<tr>\n<td>初始化(对应unsafe)</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>关于sound：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011212101731.png\" alt=\"image-20231011212101731\"></p>\n<p>大于目标的就是sound，那目标是找到不活跃的变量，所以sound就是所有的都不活跃。</p>\n<p>程序从unsafe也就是sound向safe分析。</p>\n<p><strong>Q1：第一步是判断是must analysis，还是May analysis</strong></p>\n<p>根据定义判断，<strong>有意义和无意义的结果要满足sound，&#x3D;&#x3D;是希望找到尽可能多的safe的结果&#x3D;&#x3D;，根据上面的may analysis view，分析从unsafe –&gt;safe，其实这里可以看出unsafe 就是sound</strong></p>\n<ul>\n<li>Reaching Definitions：定义是判断$D_i$是否有意义。也就是一条路径如果有意义，没有重新definitions，那就是有意义，所以是may analysis，对于Reaching Definitions，</li>\n<li>Live variables：一条路径用了这个变量，那就是有意义    <ul>\n<li>目标是找到不活跃的变量。</li>\n<li>假设所有变量都不活跃。</li>\n</ul>\n</li>\n<li>avaliable expressions：判断表达式是否可以被替换，也就是如果所有路径都算了，那就可以被替换。所以是must analysis</li>\n<li>constant propogate：所有路径都是一样的，才是常量，所以是must analysis</li>\n</ul>\n<p><strong>Q2：根据must(may) analysis，定义merge处是乘法(加法)</strong></p>\n<ul>\n<li>Reaching Definitions：加法</li>\n<li>Live variables：加法</li>\n<li>avaliable expressions：乘法</li>\n<li>constan propogate：乘法</li>\n</ul>\n<p><strong>Q3：关于初始化什么定义成1，什么定义成0</strong></p>\n<p>其实加法，显然应该全部初始化为0，目标是获得1.</p>\n<p>乘法全部初始化为1,目标是获得0。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20231011211537719.png\" alt=\"image-20231011211537719\"></p>\n<p><strong>为什么红框处是$\\lambda S.S-{g}$，而不是$\\lambda S.S$？</strong></p>\n<p>首先这个流程的最后结果会得到一个集合$\\lambda S.S$，而该集合是未定义变量的集合。这里和之前的May analysis的分析不太一样，我们之前得到的safe结果是活跃的变量的集合(定义的集合)。</p>\n<ol>\n<li>按照老师的理解：</li>\n</ol>\n<p>由于是may analysis，</p>\n<ul>\n<li>如果call返回的结果是未定义，那么$\\lambda S.S$中就会有g，会流出来，由于call-to-return边没有让g流出来，最后会流到下面。</li>\n<li>如果call返回的结果是定义了，也就是g不会流出来，而call-to-return边没有让g流出来，最后就不会流到下面。</li>\n<li>综上，结果正确。</li>\n</ul>\n<p>而如果该边是$\\lambda S.S$,最后结果无论怎样都认为g是未定义的，显然结果是不准的。</p>\n<ol start=\"2\">\n<li>按照正规我前面总结的表格分析：</li>\n</ol>\n<p>由于是may analysis，目标是让定义的变量尽可能的多，所以该边是$\\lambda S.S-{g}$</p>\n<ol start=\"3\">\n<li>按照我的理解：</li>\n</ol>\n<p>按照正规来说，这里应该定义未初始化的变量为0，初始化的变量为1。</p>\n<p>那么最后获得的集合，其实是一个定义变量的集合。</p>\n<p>也就和上图表示的不一样，上图获得的是一个定义变量的集合。</p>\n<ol start=\"4\">\n<li>按照上图定义1和0：</li>\n</ol>\n<p>如果按照上图来定义，那应该定义未初始化的变量为1，初始化的变量为0，此时最终获得的是未初始化的变量集合。</p>\n","text":"引言 学这个的起因是想入门一下模糊测试方向，跟着知乎的学习路线，学了这个课程 谭老师和李老师讲的非常非常好 兜兜转转学这个已经2个月了，感觉很多地方还是不是理解的很明白 Programming Languages(PL) 在运行程序前，分析程序可能有的问题 静态分析是在编译时，在...","link":"","photos":[],"count_time":{"symbolsCount":"45k","symbolsTime":"41 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":3,"path":"api/tags/Program-Analysis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Programming-Languages-PL\"><span class=\"toc-text\">Programming Languages(PL)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#intermediate-representation\"><span class=\"toc-text\">intermediate representation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Compiler\"><span class=\"toc-text\">Compiler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AST-vs-IR\"><span class=\"toc-text\">AST vs IR</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IR-3AC\"><span class=\"toc-text\">IR:3AC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3AC-in-real-static-Analyzer-Soot\"><span class=\"toc-text\">3AC in real static Analyzer Soot</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jvm%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%EF%BC%88PL%EF%BC%89\"><span class=\"toc-text\">jvm中的方法调用:（PL）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Static-Single-Assignment-SSA%EF%BC%89%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">Static Single Assignment(SSA）静态单赋值</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Control-Flow-Analysis\"><span class=\"toc-text\">Control Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Basic-Blocks\"><span class=\"toc-text\">Basic Blocks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BAnode\"><span class=\"toc-text\">构建node</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E8%BE%B9\"><span class=\"toc-text\">构建边</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BACFG\"><span class=\"toc-text\">构建CFG</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis\"><span class=\"toc-text\">Data Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-1\"><span class=\"toc-text\">Data Flow Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Preliminaries-of-Data-Flow-Analysis\"><span class=\"toc-text\">Preliminaries of Data Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Input-and-Output-States\"><span class=\"toc-text\">Input and Output States</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">关于转移方程约束的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">关于控制流约束的概念</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Applications\"><span class=\"toc-text\">Data Flow Analysis Applications</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">不会涉及到的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reaching-Definitions-Analysis\"><span class=\"toc-text\">Reaching Definitions Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Input-and-Output-States-1\"><span class=\"toc-text\">Input and Output States</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function\"><span class=\"toc-text\">Transer function</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3Reaching-Definitions-%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC\"><span class=\"toc-text\">理解Reaching Definitions(到达定值)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction-%E7%94%A8Di%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">Abstraction(用Di进行抽象)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Control-Flow\"><span class=\"toc-text\">Control Flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Algorithm-of-Reaching-Definition-Analysis\"><span class=\"toc-text\">Algorithm of Reaching Definition Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Live-Variables-Analysis%EF%BC%88%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%89\"><span class=\"toc-text\">Live Variables Analysis（活跃变量分析）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction\"><span class=\"toc-text\">Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Control-flow\"><span class=\"toc-text\">Control flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function-1\"><span class=\"toc-text\">Transer function</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Alogrithm-of-live-variables-Analysis\"><span class=\"toc-text\">Alogrithm of live variables Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Available-Expressions-Analysis\"><span class=\"toc-text\">Available Expressions Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction-1\"><span class=\"toc-text\">Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function-Control-flow\"><span class=\"toc-text\">Transer function &amp; Control flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Alogrithm-of-Available-Expressions-Analysis\"><span class=\"toc-text\">Alogrithm of Available Expressions Analysis</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Analysis-Comparison\"><span class=\"toc-text\">Analysis Comparison</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Foundations\"><span class=\"toc-text\">Data Flow Analysis Foundations</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iterative-algorithms%EF%BC%88%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">iterative algorithms（迭代算法）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#view-itrative-algorithm-in-another-way\"><span class=\"toc-text\">view itrative algorithm in another way</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%A4%BA%E5%BD%A2%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">图示形式：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%9D%A5%E4%BA%86\"><span class=\"toc-text\">问题来了</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#partial-order%EF%BC%88%E5%81%8F%E5%BA%8F%EF%BC%89\"><span class=\"toc-text\">partial order（偏序）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Upper-and-Lower-Bounds-%E4%B8%8A%E4%B8%8B%E7%95%8C\"><span class=\"toc-text\">Upper and Lower Bounds(上下界)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Some-Properties\"><span class=\"toc-text\">Some  Properties</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lattice\"><span class=\"toc-text\">Lattice</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Complete-Lattice\"><span class=\"toc-text\">Complete Lattice</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Product-Lattice\"><span class=\"toc-text\">Product Lattice</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Framework-via-Lattice\"><span class=\"toc-text\">Data Flow Analysis Framework via Lattice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Monotonicity%EF%BC%88%E5%8D%95%E8%B0%83%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">Monotonicity（单调性）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fixed-Point-Theorem-%E4%B8%8D%E5%8A%A8%E7%82%B9%E5%AE%9A%E7%90%86\"><span class=\"toc-text\">Fixed-Point Theorem(不动点定理)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%81%E6%98%8E%E4%B8%8D%E5%8A%A8%E7%82%B9\"><span class=\"toc-text\">证明不动点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Existence-of-Fixed-Point\"><span class=\"toc-text\">Existence of Fixed Point</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Least-Fixed-Point\"><span class=\"toc-text\">Least Fixed Point</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Foundations-II\"><span class=\"toc-text\">Data Flow Analysis Foundations II</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\"><span class=\"toc-text\">Relate Iterative Algorithm to Fix-ed Point Theorem</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Review-the-questions\"><span class=\"toc-text\">Review the questions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#When-will-the-algorithm-reach-the-fixed-point%EF%BC%9F\"><span class=\"toc-text\">When will the algorithm reach the fixed point？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#May-and-Must-Analysis-a-Lattice-View\"><span class=\"toc-text\">May and Must Analysis , a Lattice View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#May-Analysis-View\"><span class=\"toc-text\">May  Analysis View</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Must-Analysis-View\"><span class=\"toc-text\">Must Analysis View</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-Precise-is-our-Solution\"><span class=\"toc-text\">How Precise is our Solution</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Meet-Over-All-Paths-Solution-MOP\"><span class=\"toc-text\">Meet-Over-All-Paths Solution(MOP)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ours-iterative-Algorithm-vs-MOP\"><span class=\"toc-text\">Ours(iterative Algorithm) vs MOP</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Emust-analysis-%E8%BF%98%E6%98%AF-may-analysis%E7%9A%84%E5%88%86%E6%9E%90\"><span class=\"toc-text\">关于must analysis 还是 may analysis的分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reaching-definitons\"><span class=\"toc-text\">Reaching definitons</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#live-avaliables\"><span class=\"toc-text\">live avaliables</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#avaliable-expressions\"><span class=\"toc-text\">avaliable expressions</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Constant-Propagation\"><span class=\"toc-text\">Constant Propagation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Transfer-function\"><span class=\"toc-text\">Transfer function</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFNondistributivity\"><span class=\"toc-text\">为什么是Nondistributivity</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Worklist-Algorithm\"><span class=\"toc-text\">Worklist Algorithm</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-3\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Interprocedural-Analysis\"><span class=\"toc-text\">Interprocedural Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Motivation%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90%E5%91%A2%EF%BC%89\"><span class=\"toc-text\">Motivation（为什么需要过程间分析呢）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Call-Graph-Construction\"><span class=\"toc-text\">Call Graph Construction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph\"><span class=\"toc-text\">Call Graph</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph-Construction-for-OOPLS%EF%BC%88focus-on-java%EF%BC%89\"><span class=\"toc-text\">Call Graph Construction for OOPLS（focus on java）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Method-Calls-Invocation-in-Java\"><span class=\"toc-text\">Method Calls(Invocation) in Java</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Method-Dispatch-of-Virtual-Calls\"><span class=\"toc-text\">Method Dispatch of Virtual Calls</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example\"><span class=\"toc-text\">An Example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Class-Hierarchy-Analysis-CHA\"><span class=\"toc-text\">Class Hierarchy Analysis(CHA)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Resolution-of-CHA\"><span class=\"toc-text\">Call Resolution of CHA</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#static-call\"><span class=\"toc-text\">static call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#special-call\"><span class=\"toc-text\">special call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#virtual-call\"><span class=\"toc-text\">virtual call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-example\"><span class=\"toc-text\">An example</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Features-of-CHA\"><span class=\"toc-text\">Features of CHA</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph-Construction-Algorithm\"><span class=\"toc-text\">Call Graph Construction -&gt; Algorithm</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-1\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interprocedural-Control-Flow-Graph\"><span class=\"toc-text\">Interprocedural Control-Flow Graph</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-example-1\"><span class=\"toc-text\">An example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interprocedural-Data-Flow-Analysis\"><span class=\"toc-text\">Interprocedural Data-Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interprocedural-Contant-Propagation\"><span class=\"toc-text\">Interprocedural Contant Propagation</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-4\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis\"><span class=\"toc-text\">Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Problem-of-CHA\"><span class=\"toc-text\">Problem of CHA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-1\"><span class=\"toc-text\">Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Example\"><span class=\"toc-text\">Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-and-alias-Analysis%EF%BC%88%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90%EF%BC%89\"><span class=\"toc-text\">Pointer Analysis and alias Analysis（别名分析）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Application-of-Pointer-Analysis\"><span class=\"toc-text\">Application of Pointer Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Key-Factors-in-Pointer-Analysis\"><span class=\"toc-text\">Key Factors in Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Heap-abstraction\"><span class=\"toc-text\">Heap abstraction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Allocation-Site-Abstraction\"><span class=\"toc-text\">Allocation-Site Abstraction</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-Sensitivity-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F\"><span class=\"toc-text\">Context Sensitivity(上下文敏感 )</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Flow-sensitivity\"><span class=\"toc-text\">Flow sensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Analysis-Scope\"><span class=\"toc-text\">Analysis Scope</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Analysis-in-this-course\"><span class=\"toc-text\">Pointer Analysis in this course</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Concerned-Statements\"><span class=\"toc-text\">Concerned Statements</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointers-in-Java\"><span class=\"toc-text\">Pointers in Java</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Affecting-Statements\"><span class=\"toc-text\">Pointer-Affecting Statements</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-5\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Foundations-%EF%BC%88I%EF%BC%89\"><span class=\"toc-text\">Pointer Analysis Foundations （I）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Point-Analysis-Rules\"><span class=\"toc-text\">Point Analysis: Rules</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Domains-and-Notations\"><span class=\"toc-text\">Domains and Notations</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Rules\"><span class=\"toc-text\">Rules</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-to-Implement-Pointer-Analysis\"><span class=\"toc-text\">How to Implement Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Flow-Graph-PFG\"><span class=\"toc-text\">Pointer Flow Graph(PFG)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PFG-Examples\"><span class=\"toc-text\">PFG Examples</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Implementing-Pointer-Analysis\"><span class=\"toc-text\">Implementing Pointer Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis%EF%BC%9AAlgorithms\"><span class=\"toc-text\">Pointer Analysis：Algorithms</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms%EF%BC%88%E8%AF%A5%E7%AE%97%E6%B3%95%E7%9B%AE%E5%89%8D%E4%B8%8D%E8%AE%BE%E8%AE%A1call-method%EF%BC%89\"><span class=\"toc-text\">Algorithms（该算法目前不设计call method）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Worklist\"><span class=\"toc-text\">Worklist</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Handling-of-New-and-Assign\"><span class=\"toc-text\">Handling of New and Assign</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Handling-of-Store-and-load\"><span class=\"toc-text\">Handling of Store and load</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms-Review\"><span class=\"toc-text\">Algorithms Review</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-2\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-6\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-with-Method-Calls\"><span class=\"toc-text\">Pointer Analysis with Method Calls</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rule\"><span class=\"toc-text\">Rule</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interprocedural-Pointer-Analysis\"><span class=\"toc-text\">Interprocedural Pointer Analysis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms\"><span class=\"toc-text\">Algorithms</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-3\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-7\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Context-Sensitivity\"><span class=\"toc-text\">Pointer Analysis Context Sensitivity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#problem-of-Context-Insensitive-Pointer-Analysis\"><span class=\"toc-text\">problem of Context-Insensitive  Pointer Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Imprecision-of-Context-Insensitivity-C-I\"><span class=\"toc-text\">Imprecision of Context Insensitivity (C.I.)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Context-Sensitivity-C-S\"><span class=\"toc-text\">Context Sensitivity (C.S.)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cloning-Based-Context-Sensitivity\"><span class=\"toc-text\">Cloning-Based Context Sensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-Sensitive-Heap\"><span class=\"toc-text\">Context-Sensitive Heap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-Exmaple\"><span class=\"toc-text\">An Exmaple</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#CS-but-no-CS-heap\"><span class=\"toc-text\">CS but no CS heap</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#C-I-C-S-heap\"><span class=\"toc-text\">C.I. + C.S heap</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Context-Sensitive-Pointer-Analysis-Rules\"><span class=\"toc-text\">Context Sensitive Pointer Analysis: Rules</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Domains\"><span class=\"toc-text\">Domains</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%884%E7%A7%8D%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%EF%BC%89\"><span class=\"toc-text\">Rules（4种基本语句）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Flow-Graph-with-C-S\"><span class=\"toc-text\">Pointer Flow Graph with C.S.</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-S-Pointer-Analysis-Algorithm\"><span class=\"toc-text\">C.S. Pointer Analysis Algorithm</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E5%B0%BD%E4%BA%8B%E5%AE%9C\"><span class=\"toc-text\">未尽事宜</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Context-Sensitivity-Variant\"><span class=\"toc-text\">Context Sensitivity Variant</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-insensitivity\"><span class=\"toc-text\">Context insensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-site-Sensitivity\"><span class=\"toc-text\">Call-site Sensitivity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-example-2\"><span class=\"toc-text\">An example</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#K-limiting-Context-Abstraction\"><span class=\"toc-text\">K-limiting Context Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Call-Site-Example\"><span class=\"toc-text\">1-Call-Site: Example</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#C-I-VS-C-S-1-Call-Site\"><span class=\"toc-text\">C.I. VS C.S.(1-Call-Site)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object-Sensitivity\"><span class=\"toc-text\">Object Sensitivity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-Example-4\"><span class=\"toc-text\">An Example</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Call-Site-vs-Object-Sensitivity\"><span class=\"toc-text\">1-Call-Site vs Object Sensitivity</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-8\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Type-Sensitivity\"><span class=\"toc-text\">Type Sensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Type-vs-Object-Sensitivity\"><span class=\"toc-text\">Type vs Object Sensitivity</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Static-Analysis-for-security\"><span class=\"toc-text\">Static Analysis for security</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Information-Flow-Security\"><span class=\"toc-text\">Information Flow Security</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Access-Control-vs-Information-Flow-Security\"><span class=\"toc-text\">Access Control vs. Information Flow Security</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Information-Flow\"><span class=\"toc-text\">Information Flow</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Information-Flow-security\"><span class=\"toc-text\">Information Flow security</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Security-Levels\"><span class=\"toc-text\">Security Levels</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Information-Flow-Policy\"><span class=\"toc-text\">Information Flow Policy</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Confidentiality-and-Integrity%EF%BC%88%E4%BF%9D%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">Confidentiality and Integrity（保密性和完整性）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Integrity\"><span class=\"toc-text\">Integrity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Confidentiality-and-Integrity\"><span class=\"toc-text\">Confidentiality and Integrity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Integrity-%E6%9B%B4%E5%B9%BF%E6%B3%9B%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">Integrity 更广泛的定义</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Explict-Flows-and-Covert-Channels%EF%BC%88%E6%98%BE%E7%A4%BA%E6%B5%81%E5%92%8C%E9%9A%90%E8%97%8F%E4%BF%A1%E9%81%93%EF%BC%89\"><span class=\"toc-text\">Explict Flows and Covert Channels（显示流和隐藏信道）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Does-Secret-Information-Leak%EF%BC%9F\"><span class=\"toc-text\">Does Secret Information Leak？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Convert-Hidden-Channels\"><span class=\"toc-text\">Convert&#x2F;Hidden Channels</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Explicit-Flows-and-Convert-Channels\"><span class=\"toc-text\">Explicit Flows and Convert Channels</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Taint-Analysis-%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90\"><span class=\"toc-text\">Taint Analysis(污点分析)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Taint-Analysis-%EF%BC%9ATwo-Applications\"><span class=\"toc-text\">Taint Analysis ：Two Applications</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Taint-Analysis-and-Pointer-Analysis-Together\"><span class=\"toc-text\">Taint Analysis and Pointer Analysis, Together*</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Domains-and-Notations-1\"><span class=\"toc-text\">Domains and Notations</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Taint-Analysis%EF%BC%9AInputs-Outputs\"><span class=\"toc-text\">Taint Analysis：Inputs &amp; Outputs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%9ACall\"><span class=\"toc-text\">Rules：Call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%9ASame-As-Pointer-Analysis\"><span class=\"toc-text\">Rules：Same As Pointer Analysis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rules%EF%BC%9ACall-1\"><span class=\"toc-text\">Rules：Call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-5\"><span class=\"toc-text\">An Example</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Datalog-Based-Program-Analysis\"><span class=\"toc-text\">Datalog-Based Program Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Motivation\"><span class=\"toc-text\">Motivation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Imperative-vs-Declarative-%E5%91%BD%E5%90%8D%E5%BC%8F-vs-%E5%A3%B0%E6%98%8E%E5%BC%8F\"><span class=\"toc-text\">Imperative vs Declarative(命名式 vs 声明式)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Imperative-Implementation\"><span class=\"toc-text\">Pointer Analysis Imperative Implementation</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Declarative-Implementation\"><span class=\"toc-text\">Pointer Analysis Declarative Implementation</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Datalog\"><span class=\"toc-text\">Datalog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Predicates-Data-%E8%B0%93%E8%AF%8D\"><span class=\"toc-text\">Predicates(Data) 谓词</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Atoms%EF%BC%88%E5%85%83%E5%80%BC%EF%BC%8C%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8F%AF%E5%88%87%E5%88%86%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89\"><span class=\"toc-text\">Atoms（元值，最小不可切分的一部分）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Datalog-Rules-Logic\"><span class=\"toc-text\">Datalog Rules(Logic)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interpretation-of-Datalog-Rules\"><span class=\"toc-text\">Interpretation of Datalog Rules</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#EDB-and-IDB-Predicates\"><span class=\"toc-text\">EDB and IDB Predicates</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Logical-Or\"><span class=\"toc-text\">Logical Or</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Negation-%E9%80%BB%E8%BE%91%E9%9D%9E\"><span class=\"toc-text\">Negation(逻辑非)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Recursion\"><span class=\"toc-text\">Recursion</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rule-Safety\"><span class=\"toc-text\">Rule Safety</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Recursion-and-Negation\"><span class=\"toc-text\">Recursion and Negation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Execution-of-Datalog-Programs\"><span class=\"toc-text\">Execution of Datalog Programs</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-via-Datalog\"><span class=\"toc-text\">Pointer Analysis via Datalog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-6\"><span class=\"toc-text\">An Example</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BD%A2%E6%88%90EDB\"><span class=\"toc-text\">形成EDB</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Datalog-Rules-for-Pointer-Analysis\"><span class=\"toc-text\">Datalog Rules for Pointer Analysis</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">具体实现(算法)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Handle-method-calls\"><span class=\"toc-text\">Handle method calls</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Taint-Analysis-via-Datalog\"><span class=\"toc-text\">Taint Analysis via Datalog</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Handle-Sources-and-Sinks\"><span class=\"toc-text\">Handle Sources and Sinks</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-9\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CFL-Reachability-and-IFDS\"><span class=\"toc-text\">CFL-Reachability and IFDS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Realizable-Paths\"><span class=\"toc-text\">Realizable Paths</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CFL-Reachability-context-free-language\"><span class=\"toc-text\">CFL-Reachability(context free language)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-free-grammar-CFG\"><span class=\"toc-text\">Context-free grammar(CFG)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CFL-Reachability\"><span class=\"toc-text\">CFL-Reachability</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IFDS\"><span class=\"toc-text\">IFDS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Meet-Over-All-Realizable-Paths%EF%BC%88MRP%EF%BC%89\"><span class=\"toc-text\">Meet-Over-All-Realizable-Paths（MRP）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Overview-of-IFDS\"><span class=\"toc-text\">Overview of IFDS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Supergraph\"><span class=\"toc-text\">Supergraph</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Design-Flow-Functions\"><span class=\"toc-text\">Design Flow Functions</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Build-Exploded-Supergraph\"><span class=\"toc-text\">Build Exploded Supergraph</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Emust-analysis-%E5%92%8C-may-analysis%E7%9A%84%E7%90%86%E8%A7%A3%E7%BB%88%E6%9E%81%E7%89%88\"><span class=\"toc-text\">关于must analysis 和 may analysis的理解终极版</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Context-Sensitivity-without-Contexts-PLDI23","uid":"39f6a6f9864fa629c2ab8230b6f47fbc","slug":"Context-Sensitivity-without-Contexts-PLDI23","date":"2023-10-08T05:40:18.000Z","updated":"2023-10-18T09:35:51.585Z","comments":true,"path":"api/articles/Context-Sensitivity-without-Contexts-PLDI23.json","keywords":null,"cover":[],"text":"引言 学完了南大软件分析的课程，关注了谭老师的个人主页。 想着看一篇论文，能对学的内容有更好的理解。 AbstractQ1：首先说上下文敏感的做法 在不同上下文中分析，分离方法变量，和堆对象，也就是同时应用上下文敏感和堆上下文敏感 Q2：但是这种方法带来了问题： 因为需要clon...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":3,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":2,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"bottomupcs","uid":"280fda85aebd83efe2030df16a32f5ff","slug":"bottomupcs","date":"2023-09-20T08:43:17.000Z","updated":"2023-10-08T05:34:47.890Z","comments":true,"path":"api/articles/bottomupcs.json","keywords":null,"cover":null,"text":" 165d50f05814027fb7fe5e4ae8a088d8cabf1ea2d88ccf0f53dc7b0b289f333341828fd88b2557819d802f94103d3ae533a248f976fe4b8635c776fc2c174c3bf94982f99e8...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}