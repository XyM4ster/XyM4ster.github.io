{"title":"软件分析","uid":"16dae33580f19f4496bcfc3620372612","slug":"软件分析","date":"2023-08-06T08:41:41.000Z","updated":"2023-08-21T22:44:52.757Z","comments":true,"path":"api/articles/软件分析.json","keywords":null,"cover":[],"content":"<h1 id=\"Programming-Languages-PL\"><a href=\"#Programming-Languages-PL\" class=\"headerlink\" title=\"Programming Languages(PL)\"></a>Programming Languages(PL)</h1><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806164104535.png\" alt=\"image-20230806164104535\"></p>\n<ul>\n<li><p>在运行程序前，分析程序可能有的问题</p>\n</li>\n<li><p>静态分析是在编译时，在程序运行之前，判断一个程序是否满足一些性质</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806170110550.png\" alt=\"image-20230806170110550\"></p>\n<ul>\n<li><p>对于这些<code>interesting proverties</code>，比如是否有空指针，是不能直接被给出准确的答案的</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806170455433.png\" alt=\"image-20230806170455433\"></p>\n</li>\n<li><p>sound包括truth</p>\n</li>\n<li><p>complete爆出来的一定是truth</p>\n</li>\n</ul>\n<p>从上面可以发现没有perfect，所以要么妥协<code>soundness</code>，要么妥协<code>completeness</code></p>\n<p>妥协<code>soundness</code>就会产生漏报</p>\n<p>妥协<code>completeness</code>就会产生误报</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806170825386.png\" alt=\"image-20230806170825386\"></p>\n<ul>\n<li><p>所以 几乎所有的静态分析都是<code>sound</code>，意思就是能多报几个，即使里面有误报，也不漏报   </p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806171554556.png\" alt=\"image-20230806171554556\"></p>\n</li>\n<li><p>只有分析了 蓝色和 绿色两条路径，才能分析出 它是 not safe，所以要soundness</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806172413490.png\" alt=\"image-20230806172413490\"></p>\n</li>\n<li><p>第一种方法虽然准确度高，但是浪费内存</p>\n<p>确保soundness(准确度)，保证精度和速度的平衡</p>\n<p>第一步：先抽象</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806212413467.png\" alt=\"image-20230806212413467\"></p>\n<ul>\n<li>没有确定的值，用新的符号表示</li>\n</ul>\n<p>第二步：转换规则</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806212727117.png\" alt=\"image-20230806212727117\"></p>\n<p>第三步：根据上一步确定的规则计算</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806213040551.png\" alt=\"image-20230806213040551\"></p>\n<ul>\n<li>可以看出静态分析是有用的，但是由于是sound，over-approximated，  对于3来说就是误报，因为他是9</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806213435210.png\" alt=\"image-20230806213435210\"></p>\n<ul>\n<li><p>flow merge很重要，因为很难考虑所有情况</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230806214553222.png\" alt=\"image-20230806214553222\"></p>\n</li>\n</ul>\n<h1 id=\"intermediate-representation\"><a href=\"#intermediate-representation\" class=\"headerlink\" title=\"intermediate representation\"></a>intermediate representation</h1><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807155037706.png\" alt=\"image-20230807155037706\"></p>\n<h2 id=\"Compiler\"><a href=\"#Compiler\" class=\"headerlink\" title=\"Compiler\"></a>Compiler</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807160151499.png\" alt=\"image-20230807160151499\"></p>\n<ul>\n<li><p>词法分析器（Scanner），结合正则表达式，通过词法分析（Lexical Analysis）将 source code 翻译为 token。</p>\n</li>\n<li><p>语法分析器（Parser），结合上下文无关文法（Context-Free Grammar），通过语法分析（Syntax Analysis），将 token 解析为抽象语法树（Abstract Syntax Tree, AST）</p>\n</li>\n<li><p>语义分析器（Type Checker），结合属性文法（Attribute Grammar），通过语义分析（Semantic Analysis），将 AST 解析为 decorated AST</p>\n</li>\n<li><p>Translator，将 decorated AST 翻译为生成三地址码这样的中间表示形式（Intermediate Representation, IR），并<strong>基于 IR 做静态分析</strong>（例如代码优化这样的工作）。</p>\n</li>\n</ul>\n<p>经过前面所有的处理生成 IR ，静态分析器 对 IR进行分析 </p>\n<h3 id=\"AST-vs-IR\"><a href=\"#AST-vs-IR\" class=\"headerlink\" title=\"AST vs IR\"></a>AST vs IR</h3><p><strong>为什么Compiler中用IR而不是AST呢</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807161223246.png\" alt=\"image-20230807161223246\"></p>\n<ul>\n<li>AST是high-level，接近语法结构的</li>\n<li>AST是依赖语言的</li>\n<li>AST适合快速的类型检查</li>\n<li>AST缺少控制流信息，IR中的go to可以轻易的看出控制流信息</li>\n</ul>\n<h2 id=\"IR-3AC\"><a href=\"#IR-3AC\" class=\"headerlink\" title=\"IR:3AC\"></a>IR:3AC</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230807161524280.png\" alt=\"image-20230807161524280\"></p>\n<p><strong>为什么叫3地址码？</strong></p>\n<ul>\n<li>名称： a,b</li>\n<li>常量：3</li>\n<li>编译器生成的临时变量：t1,t2</li>\n</ul>\n<p>常见的 3AC 包括：</p>\n<ul>\n<li>x &#x3D; y bop z：双目运算并赋值，bop &#x3D; binary operator</li>\n<li>x &#x3D; uop z：单目运算并赋值，uop &#x3D; unary operator</li>\n<li>x &#x3D; y：直接赋值</li>\n<li>goto L：无条件跳转，L &#x3D; label</li>\n<li>if x goto L：条件跳转</li>\n<li>if x rop y goto L：包含了关系运算的条件跳转，rop &#x3D; relational operator</li>\n</ul>\n<h3 id=\"3AC-in-real-static-Analyzer-Soot\"><a href=\"#3AC-in-real-static-Analyzer-Soot\" class=\"headerlink\" title=\"3AC in real static Analyzer Soot\"></a>3AC in real static Analyzer Soot</h3><p>Soot是个静态分析的框架，其中的IR是Jimple</p>\n<p><strong>在Soot中，Java源代码首先被编译成Java字节码，然后将字节码转换为Jimple表示形式</strong></p>\n<p>Jimple：(Java Intermediate Language）是一种用于表示Java字节码的中间语言</p>\n<h2 id=\"jvm中的方法调用-（PL）\"><a href=\"#jvm中的方法调用-（PL）\" class=\"headerlink\" title=\"jvm中的方法调用:（PL）\"></a>jvm中的方法调用:（PL）</h2><ul>\n<li><p>invokespecial：call constructor, call superclass method(调用父类方法)，call private methods </p>\n</li>\n<li><p>invokevirtual：call  instance methods（virtual dispatch 动态分配）</p>\n</li>\n<li><p>invokeinterface：call static methods</p>\n</li>\n<li><p>method Signature：包含 class name（方法声明所在的类 ）  return type  method name(parameter1 type,parameter2 type)</p>\n</li>\n</ul>\n<p>下面是一些Jimple和对应的Java程序</p>\n<ol>\n<li><strong>方法调用</strong></li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809101253593.png\" alt=\"image-20230809101253593\"></p>\n<ul>\n<li>specialinvoke是在调用StringBuilder的构造器，void 表示没有返回值</li>\n</ul>\n<p><code>specialinvoke $r3.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();</code>  </p>\n<ul>\n<li>$r3表示临时变量，&lt;&gt;中的东西是method Signature, java.lang.StringBuilder就是所在的类, **&lt; init &gt;**是默认的构造函数</li>\n</ul>\n<p><code>$r3 = virtualinvoke $r3.&lt;java.lang.StringBuilder: java.lang.StringBuilder append(java, lang.String)&gt;(r1);</code></p>\n<ul>\n<li>是在$r3的基础上调用的方法， <code>$r3</code>是StringBuilder类，返回值是StringBuilder，调用append方法，java, lang.String是参数 类型</li>\n</ul>\n<ol start=\"2\">\n<li><strong>main方法调用</strong></li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809102623594.png\" alt=\"image-20230809102623594\"></p>\n<p>如果没给显示的构造函数，就会默认的生成一个构造函数</p>\n<ol start=\"3\">\n<li><strong>静态方法调用</strong></li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809105135545.png\" alt=\"image-20230809105135545\"></p>\n<p>clinit：一个类的静态初始化的函数，用于在类记载过程中执行类的初始化</p>\n<p>:::tips</p>\n<p>Java虚拟机加载一个类时，它会首先检查是否存在类的静态初始化代码块（<code>static &#123;&#125;</code>），如果存在，则将这些代码块的内容放入<code>&lt;clinit&gt;</code>方法中。<code>&lt;clinit&gt;</code>方法会在类首次使用之前被调用，确保类的静态初始化在使用之前完成</p>\n<p>:::</p>\n<h2 id=\"Static-Single-Assignment-SSA）静态单赋值\"><a href=\"#Static-Single-Assignment-SSA）静态单赋值\" class=\"headerlink\" title=\"Static Single Assignment(SSA）静态单赋值\"></a>Static Single Assignment(SSA）静态单赋值</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809105950556.png\" alt=\"image-20230809105950556\"></p>\n<ul>\n<li>也就是每次都用一个最新的变量</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809110000741.png\" alt=\"image-20230809110000741\"></p>\n<ul>\n<li>在merge的时候，会用$phi$，根据控制流的信息决定选择哪个变量</li>\n</ul>\n<h1 id=\"Control-Flow-Analysis\"><a href=\"#Control-Flow-Analysis\" class=\"headerlink\" title=\"Control Flow Analysis\"></a>Control Flow Analysis</h1><p>控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。</p>\n<ul>\n<li>需要构建Control Flow Graph(CFG)</li>\n<li>CFG的node可以是一个单独的3AC，但是更常见的是一个Basic Blocks</li>\n</ul>\n<h2 id=\"Basic-Blocks\"><a href=\"#Basic-Blocks\" class=\"headerlink\" title=\"Basic Blocks\"></a>Basic Blocks</h2><p>需要满足以下性质：</p>\n<ul>\n<li>只能从块的第一条指令进入</li>\n<li>只能从块的最后一条指令离开</li>\n</ul>\n<p>:::tips</p>\n<ul>\n<li>这个算法逻辑感很强，值得反复考虑</li>\n</ul>\n<p>:::</p>\n<h4 id=\"构建node\"><a href=\"#构建node\" class=\"headerlink\" title=\"构建node\"></a>构建node</h4><ul>\n<li>入口只有一个，就是开始的指令</li>\n<li>出口只有一个，就是结束的指令</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809111246762.png\" alt=\"image-20230809111246762\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809112035790.png\" alt=\"image-20230809112035790\"></p>\n<p>方法：</p>\n<ol>\n<li>决定P的leaders：</li>\n</ol>\n<ul>\n<li><p>程序的第一条指令是leader</p>\n</li>\n<li><p>goto指向的指令是leader</p>\n</li>\n<li><p>跳转指令的后一条指令是leader</p>\n</li>\n</ul>\n<p>例子：</p>\n<ul>\n<li><p>从这个可以看出 因为(3)是(12)的target，所以(3)就不能放到第一个bbs中，否则程序有两个入口</p>\n</li>\n<li><p>(4)接下来有可能跳转到(7)，所以(5)就不能加进来，否则程序有两个出口</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>构建P的基本快</li>\n</ol>\n<ul>\n<li>就是从一个leader开始，到下一个leader的前一条指令</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811225051270.png\" alt=\"image-20230811225051270\"></p>\n<h4 id=\"构建边\"><a href=\"#构建边\" class=\"headerlink\" title=\"构建边\"></a>构建边</h4><p>块A到块B有一条边当且仅当：</p>\n<ul>\n<li><p>A B之间有跳转，自然要添边</p>\n</li>\n<li><p>AB紧挨着，A块的最后一条指令紧挨着B的第一条指令</p>\n<ul>\n<li>这种AB之间需要一条边</li>\n<li>但是不能是无条件的跳转</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811225843258.png\" alt=\"image-20230811225843258\"></p>\n</li>\n</ul>\n<p>从上可知</p>\n<ul>\n<li>由j–&gt;i的变化，变成从A—&gt;B的变换，现在变成了粗粒度的，也就是说A B之间指令的变换，也不影响跳转了。(原来假设i  变成i + 1，那 j–&gt; i，也要变成 j –&gt;i + 1)</li>\n</ul>\n<h3 id=\"构建CFG\"><a href=\"#构建CFG\" class=\"headerlink\" title=\"构建CFG\"></a>构建CFG</h3><ul>\n<li>除了构建好的基本块，我们还会额外添加两个结点，「入口（Entry）」和「出口（Exit）」</li>\n<li>这两个结点不对应任何 IR</li>\n<li>如果一个基本块的最后一条指令会让程序离开这段 IR，那么这个基本块就会有一条边指向出口。</li>\n<li>但是可能有个很多return，也就可能有很多出边</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809115245878.png\" alt=\"image-20230809115245878\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230809115553127.png\" alt=\"image-20230809115553127\"></p>\n<h1 id=\"Data-Flow-Analisis\"><a href=\"#Data-Flow-Analisis\" class=\"headerlink\" title=\"Data Flow Analisis\"></a>Data Flow Analisis</h1><h2 id=\"Overview-of-Data-Flow-Analysis\"><a href=\"#Overview-of-Data-Flow-Analysis\" class=\"headerlink\" title=\"Overview of Data Flow Analysis\"></a>Overview of Data Flow Analysis</h2><p>数据流分析的核心：How data Flows on CFG？</p>\n<ul>\n<li><p>对数据的抽象( +  - T  unknown等)</p>\n</li>\n<li><p>Flows：根据分析的类型，做出合适的估算，应该是sound的</p>\n</li>\n<li><p>Node：数据如何transfer(转换函数)，比如 + - </p>\n</li>\n<li><p>Edges：控制流如何处理</p>\n</li>\n<li><p>CFG：一个程序</p>\n</li>\n</ul>\n<p>不同的数据流分析，有着不同的data abstraction, flow safe-approximation策略，transfer functions&amp;control-flow handlings。</p>\n<h2 id=\"Preliminaries-of-Data-Flow-Analysis\"><a href=\"#Preliminaries-of-Data-Flow-Analysis\" class=\"headerlink\" title=\"Preliminaries of Data Flow Analysis\"></a>Preliminaries of Data Flow Analysis</h2><h3 id=\"Input-and-Output-States\"><a href=\"#Input-and-Output-States\" class=\"headerlink\" title=\"Input and Output States\"></a>Input and Output States</h3><ul>\n<li>每一条IR的执行，都让状态从<strong>输入状态</strong>变成新的<strong>输出状态</strong></li>\n<li>输入&#x2F;输出状态与语句前&#x2F;后的 <strong>program point</strong> 相关联。</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811231809896.png\" alt=\"image-20230811231809896\"></p>\n<ul>\n<li>在数据流分析中，我们会把每个程序点关联一个数据值，代表从那一点中可观察到的抽象程序状态</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811232044640.png\" alt=\"image-20230811232044640\"></p>\n<ul>\n<li>从pp中观察到抽象的状态，并组成一个集合</li>\n</ul>\n<h3 id=\"关于转移方程约束的概念\"><a href=\"#关于转移方程约束的概念\" class=\"headerlink\" title=\"关于转移方程约束的概念\"></a>关于转移方程约束的概念</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811232328151.png\" alt=\"image-20230811232328151\"></p>\n<h3 id=\"关于控制流约束的概念\"><a href=\"#关于控制流约束的概念\" class=\"headerlink\" title=\"关于控制流约束的概念\"></a>关于控制流约束的概念</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811232718115.png\" alt=\"image-20230811232718115\"></p>\n<ul>\n<li>B的所有前驱的out的meey构成B的输入</li>\n</ul>\n<h2 id=\"Data-Flow-Analysis-Applications\"><a href=\"#Data-Flow-Analysis-Applications\" class=\"headerlink\" title=\"Data Flow Analysis Applications\"></a>Data Flow Analysis Applications</h2><h3 id=\"不会涉及到的概念\"><a href=\"#不会涉及到的概念\" class=\"headerlink\" title=\"不会涉及到的概念\"></a>不会涉及到的概念</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811033038211.png\" alt=\"image-20230811033038211\"></p>\n<ul>\n<li>首先不存在方法调用，讲的是函数内部的</li>\n<li>之后讲跨函数的</li>\n<li>变量不涉及引用，也就是没有两个变量指向一个空间，在指针分析中讲</li>\n</ul>\n<h3 id=\"Reaching-Definitions-Analysis\"><a href=\"#Reaching-Definitions-Analysis\" class=\"headerlink\" title=\"Reaching Definitions Analysis\"></a>Reaching Definitions Analysis</h3><p>may analysis: 理解成集合的union</p>\n<p>就是所有情况都得考虑，may be true的都被报出来</p>\n<p>也就是有一个是true就行，所以应该考虑所有的path，所以应该union</p>\n<p>must anaysis：理解成集合的交集^</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230810233602698.png\" alt=\"image-20230810233602698\"></p>\n<h4 id=\"Input-and-Output-States-1\"><a href=\"#Input-and-Output-States-1\" class=\"headerlink\" title=\"Input and Output States\"></a>Input and Output States</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230810233921862.png\" alt=\"image-20230810233921862\"></p>\n<p>绿色的是红色的抽象</p>\n<p>domain：值域</p>\n<p>对于程序中所有的in 和 out，找到一个solution,通过解析 safe-approximation中的约束规则，得出的solution 。这些约束规则基于transfer function(转换规则)，基于控制流信息</p>\n<p>通过解这些约束规则，得到solution</p>\n<ul>\n<li>用符号表示transer function</li>\n</ul>\n<h4 id=\"Transer-function\"><a href=\"#Transer-function\" class=\"headerlink\" title=\"Transer function\"></a>Transer function</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811032034914.png\" alt=\"image-20230811032034914\"></p>\n<p>对bbs中的每个执行f，那么最后得到的结果就是bss的transer function</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811032642576.png\" alt=\"image-20230811032642576\"></p>\n<p>反向的时候先执行 fsn的 transer function，再执行fsn-1，</p>\n<ul>\n<li>上面黄色的代表：B的所有前驱的out的meet构成B的in</li>\n<li>下面粉色的out：B的后继的in的meet</li>\n</ul>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li>假定 x 有定值 d (<strong>definition</strong>)，如果存在一个路径，从紧随 d 的点到达某点 p，并且此路径上面没有 x 的其他定值点，则称 x 的定值 d 到达 (<strong>reaching</strong>) p。</li>\n<li>如果这条路径上有x的其他定值，我们就说x的这个定值被kill了</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811033559511.png\" alt=\"image-20230811033559511\"></p>\n<ul>\n<li><p>到达定值可以用来分析未定义的变量。例如，我们在程序入口为各变量引入一个 dummy 定值。当程序出口的某变量定值依然为 dummy，则我们可以认为该变量未被定义。</p>\n</li>\n<li><p>对于一条赋值语句 D: v &#x3D; x op y，该语句生成了 v 的一个定值 D，并杀死程序中其它对变量 v 定义的定值。</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024517653.png\" alt=\"image-20230812024517653\"></p>\n<p><strong>说人话：</strong></p>\n<p><strong>是在分析在程序中的某点，BBS中定义的一条语句是不是有意义的</strong></p>\n<p>对于第一次遍历(红字)</p>\n<ul>\n<li><p>比如对于B1的出口，定义的D1和D2都是有意义的</p>\n</li>\n<li><p>比如对于B2的出口，D1就没有意义，因为D4重新定义了y，所以要被Kill，D2、D3是有意义的。</p>\n<p>算法：</p>\n<ul>\n<li>该算法是检查程序的其他处有没有定义这个变量，如果定义了就kill掉</li>\n<li>因为路径中没经过的BBS，肯定没有定义过，所以是0，kill不kill无所谓</li>\n</ul>\n<p>理解：</p>\n<ul>\n<li>按照理解来说，可以检查这条路径上之前有没有定义过，但是这样可能比较麻烦</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"理解Reaching-Definitions-到达定值\"><a href=\"#理解Reaching-Definitions-到达定值\" class=\"headerlink\" title=\"理解Reaching Definitions(到达定值)\"></a>理解Reaching Definitions(到达定值)</h4><h4 id=\"Abstraction-用Di进行抽象\"><a href=\"#Abstraction-用Di进行抽象\" class=\"headerlink\" title=\"Abstraction(用Di进行抽象)\"></a>Abstraction(用Di进行抽象)</h4><ul>\n<li>程序中所有变量的定值</li>\n<li>能被一个 bit vectors表示</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811234620667.png\" alt=\"image-20230811234620667\"></p>\n<p>Transer function</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811234832713.png\" alt=\"image-20230811234832713\"></p>\n<ul>\n<li>从入口kill掉其他的定值，并加入新生成的定值</li>\n<li>v &#x3D; x op y，gen v, kill 其它所有的 v</li>\n</ul>\n<h4 id=\"Control-Flow\"><a href=\"#Control-Flow\" class=\"headerlink\" title=\"Control Flow\"></a>Control Flow</h4><p>按照本节最开始讲的一个完整的Data Flow Analysis的结构，需要对transer function的结果进行约束。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811235332766.png\" alt=\"image-20230811235332766\"></p>\n<h4 id=\"Algorithm-of-Reaching-Definition-Analysis\"><a href=\"#Algorithm-of-Reaching-Definition-Analysis\" class=\"headerlink\" title=\"Algorithm of Reaching Definition Analysis\"></a>Algorithm of Reaching Definition Analysis</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230811042913200.png\" alt=\"image-20230811042913200\"></p>\n<ul>\n<li><p>首先让所有BB和入口的OUT为空。因为你不知道 BB 中有哪些定值被生成。</p>\n</li>\n<li><p>当任意 OUT 发生变化，则分析出的定值可能需要继续往下流动，需要修改各 BB 的 IN 和 OUT。</p>\n</li>\n<li><p>最终结果就是绿色的，例如b5是0011 1011，也就表示D3 D4 D5 D6 D7会流到B5结束的位置</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024517653.png\" alt=\"image-20230812024517653\"></p>\n</li>\n<li><p>在每个数据流分析中，我们把pp和一个数据流的值相关联，代表可以从这点观察到的所有可能的抽象状态。</p>\n</li>\n<li><p>通过不停的用transer function和control flow，不停的解和算，直到找到一个solution。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024739528.png\" alt=\"image-20230812024739528\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812024725322.png\" alt=\"image-20230812024725322\"></p>\n</li>\n</ul>\n<p><strong>为什么程序会停止？</strong></p>\n<ul>\n<li><p>程序会继续运行，是因为有的bbs变化了，说明有循环，也就是下面这种情况，一i那位如果程序都是顺序执行，就不会有bbs变化，所以一定会停止</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812030831779.png\" alt=\"image-20230812030831779\"></p>\n</li>\n<li><p>某一点有可能从0 —&gt; 0，有可能从0 —&gt;1，也有可能从1 —-&gt;1，但是不可能从1—&gt;0，所以程序一定会停止</p>\n</li>\n</ul>\n<p><strong>为什么不会从1—&gt;0？</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812031148958.png\" alt=\"image-20230812031148958\"></p>\n<ul>\n<li>假设最终从红色快Di&#x3D;1，流入S，红色框中这一位能是1，说明从S中出来时，这一位就是1，否则不能流到红色框处</li>\n<li>那上次出来是1，说明没有被Kill掉，这次肯定也不会被kill，也可以说，水都流到这了，一定可以流出去</li>\n</ul>\n<h3 id=\"Live-Variables-Analysis（活跃变量分析）\"><a href=\"#Live-Variables-Analysis（活跃变量分析）\" class=\"headerlink\" title=\"Live Variables Analysis（活跃变量分析）\"></a>Live Variables Analysis（活跃变量分析）</h3><ul>\n<li>沿着p有一条路径，活跃变量分析分析p处的v是不是alive</li>\n<li>换句话说：后面use的v是不是我在p处定义的v，如果是，说明p在v处是alive的，也就是是有效的</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<p><strong>活跃变量分析是在分析在该点处定义的变量有没有用，是不是废物变量</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812070750920.png\" alt=\"image-20230812070750920\"></p>\n<h4 id=\"Abstraction\"><a href=\"#Abstraction\" class=\"headerlink\" title=\"Abstraction\"></a>Abstraction</h4><ul>\n<li><p>用第i个bit表示vi</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812071415418.png\" alt=\"image-20230812071415418\"></p>\n</li>\n</ul>\n<p><strong>程序应该是forward的还是backward？</strong></p>\n<p>这里想探究的问题是变量是否是live？</p>\n<p>因为想知道在某一点是不是alive的，所以你得走到最后，才能知道，因为你不知道中间是否有重定义</p>\n<ul>\n<li>所以要从后往前来比较方便</li>\n</ul>\n<h4 id=\"Control-flow\"><a href=\"#Control-flow\" class=\"headerlink\" title=\"Control flow\"></a>Control flow</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812225343496.png\" alt=\"image-20230812225343496\"></p>\n<h4 id=\"Transer-function-1\"><a href=\"#Transer-function-1\" class=\"headerlink\" title=\"Transer function\"></a>Transer function</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812224629538.png\" alt=\"image-20230812224629538\"></p>\n<p>首先程序是Backward，已知out求in</p>\n<p><strong>问题1 ：这里的out为什么是union</strong></p>\n<ul>\n<li>因为无论s1 use v 还是s2 use v，Out[B]都等于1</li>\n<li>也就是下面有一条路径是活跃的用了v，在B的in处，都是alive的</li>\n</ul>\n<p><strong>问题2：如何求出IN[B]</strong></p>\n<p>我的考虑：</p>\n<ul>\n<li>如果B中对v进行了重新定义，IN[B]就为0</li>\n<li>所以out[b]-kill[b]</li>\n<li>我没有考虑完全所有的情况</li>\n</ul>\n<p>算法：</p>\n<ul>\n<li>首先枚举所有可能的情况</li>\n<li>如果v在B中被重定义了，就应该out[b]-def_b，但是如果在重定义之前，使用了v，in[B]仍然为1，所以将两种情况合并，得到结果</li>\n<li>这里也可以直观的感受为什么程序是backward</li>\n</ul>\n<h4 id=\"Alogrithm-of-live-variables-Analysis\"><a href=\"#Alogrithm-of-live-variables-Analysis\" class=\"headerlink\" title=\"Alogrithm of live variables Analysis\"></a>Alogrithm of live variables Analysis</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812225519212.png\" alt=\"image-20230812225519212\"></p>\n<p><strong>问题1：为什么初始化为空？</strong></p>\n<ul>\n<li>may analysis初始化一般为空，must analysis初始化为all</li>\n</ul>\n<p>最终结果：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230812232036968.png\" alt=\"image-20230812232036968\"></p>\n<h3 id=\"Available-Expressions-Analysis\"><a href=\"#Available-Expressions-Analysis\" class=\"headerlink\" title=\"Available Expressions Analysis\"></a>Available Expressions Analysis</h3><p>它是must analysis</p>\n<h4 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223059162.png\" alt=\"image-20230813223059162\"></p>\n<p>x op y 在 p 点可用的条件：</p>\n<ul>\n<li>从流图入口结点到达 p 的每条路径都对 x op y 求了值，</li>\n<li>且在最后一次求值之后再没有对 x 或 y 赋值</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<ul>\n<li><p>是在分析表达式(x &#x3D; y+3   表达式是y + 3)有没有意义，是不是白算,看是否所有路径都求了，也就是如果都求了，结果是1，那就可以被替换</p>\n</li>\n<li><p>也就是如果最后一次算y +3，后面还有对y的重新赋值，那你算的y + 3没有意义</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813231942248.png\" alt=\"image-20230813231942248\"></p>\n</li>\n</ul>\n<p>对于程序的最终结果，蓝色部分来说</p>\n<ul>\n<li>表达式p-1就没有意义，因为p在B2处被重定义了</li>\n<li>表达式z&#x2F;5有意义</li>\n<li>表达式2*y没有意义，在B5中y被重定义了</li>\n<li>表达式e7 *x有意义</li>\n<li>表达式y + 3没有意义</li>\n</ul>\n<p>他的最终目的是优化表达式：有意义的可以用同一个变量替换，省的重复计算</p>\n<h4 id=\"Abstraction-1\"><a href=\"#Abstraction-1\" class=\"headerlink\" title=\"Abstraction\"></a>Abstraction</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813222348767.png\" alt=\"image-20230813222348767\"></p>\n<ul>\n<li>0代表在这一点不是Available</li>\n</ul>\n<h4 id=\"Transer-function-Control-flow\"><a href=\"#Transer-function-Control-flow\" class=\"headerlink\" title=\"Transer function &amp; Control flow\"></a>Transer function &amp; Control flow</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223502406.png\" alt=\"image-20230813223502406\"></p>\n<ul>\n<li>生成新的表达式：x op y</li>\n<li>kill掉引用了变量a的表达式{a + b}</li>\n<li>最后得到{x op y}</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223436635.png\" alt=\"image-20230813223436635\"></p>\n<p>在黄色这点，该表达式是avaliable的</p>\n<ul>\n<li>可以根据定义判断<ul>\n<li>每一条路径都计算了 e16 * x</li>\n<li>在表达式的最后(last evaluation)y也就是b语句，没有对x重定义</li>\n</ul>\n</li>\n<li>用上面的transerfunction判断<ul>\n<li>到x &#x3D; …处时，e16 * x被kill</li>\n<li>到b处，又生成了e16 * x</li>\n<li>两条路径都有e16 * x，所以是avaliable</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813223930416.png\" alt=\"image-20230813223930416\"></p>\n<ul>\n<li>因此，上面的可以被优化成全部用t替换</li>\n<li>到整个程序的最后一条语句时，不用再对t进行计算，因为Last evaluation已经计算过了</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224059470.png\" alt=\"image-20230813224059470\"></p>\n<p><strong>问题1：为什么是交？</strong></p>\n<ul>\n<li>因为需要所有的path都计算last evaluation，需要取一个最终的结果</li>\n</ul>\n<p>假设有一条path如果是1的话，另一条path是0，那这个表达式是否是avaliable呢？</p>\n<ul>\n<li>因为要safe，所以它有可能是不可达的，所以那就要认为是不可达的</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813231002042.png\" alt=\"image-20230813231002042\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224456551.png\" alt=\"image-20230813224456551\"></p>\n<ul>\n<li>看这个小绿箭头和绿方框， z &#x2F; 5这个表达式有可能是不avalable的，所以要取交，认为他是0</li>\n</ul>\n<p><strong>问题2：如何理解under approximation？</strong></p>\n<ul>\n<li><p>也就是它可能会有漏报</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224537845.png\" alt=\"image-20230813224537845\"></p>\n</li>\n<li><p>对于这种情况，按照上面的transer function，到c表达式的In的地方，显然{e16 * x}不是avaliable</p>\n</li>\n<li><p>所以在c处要重新计算</p>\n</li>\n</ul>\n<p>但是有可能上面的x和重定义的x都等于3</p>\n<ul>\n<li>这种情况下，也就是可以把c处进行优化，就是不用再重新计算了</li>\n</ul>\n<p><strong>但是按照transer function，我并没有产生误报，只是没有优化，并不影响程序的执行</strong></p>\n<h4 id=\"Alogrithm-of-Available-Expressions-Analysis\"><a href=\"#Alogrithm-of-Available-Expressions-Analysis\" class=\"headerlink\" title=\"Alogrithm of Available Expressions Analysis\"></a>Alogrithm of Available Expressions Analysis</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813224942134.png\" alt=\"image-20230813224942134\"></p>\n<p><strong>问题1：为什么OUT[B]的初始化是all(都是1)</strong></p>\n<p>按照现在的理解</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813225518326.png\" alt=\"image-20230813225518326\"></p>\n<ul>\n<li>根据这个图，如果初始化是0的话，也就是此时红色框处的输入就变成了00000，那我上一步做的就没有意义了，p-1此时一定是avaliable的</li>\n<li>因为是交，所以为了保留原来的结果，一定得是11111</li>\n</ul>\n<p>musy analysis 初始化一般都是all</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230813231942248.png\" alt=\"image-20230813231942248\"></p>\n<h2 id=\"Analysis-Comparison\"><a href=\"#Analysis-Comparison\" class=\"headerlink\" title=\"Analysis Comparison\"></a>Analysis Comparison</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>Reaching Definitons</th>\n<th>Live Variables</th>\n<th>Avaliable Expressions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Domain</td>\n<td>definitions的集合</td>\n<td>variables的集合</td>\n<td>expressions的集合</td>\n</tr>\n<tr>\n<td>Direction</td>\n<td>forward（会不会path）</td>\n<td>backward(后面有没有use)</td>\n<td>forward（所有的Path有没有evaluation）</td>\n</tr>\n<tr>\n<td>May&#x2F;Must</td>\n<td>May analysis</td>\n<td>May analysis</td>\n<td>Must Analysis</td>\n</tr>\n<tr>\n<td>Boundary（边界）</td>\n<td>out[entry]&#x3D;null</td>\n<td>in[exit]&#x3D;null</td>\n<td>out[entry]&#x3D;null</td>\n</tr>\n<tr>\n<td>Initialization</td>\n<td>out&#x3D;null</td>\n<td>in&#x3D;null</td>\n<td>out&#x3D;all</td>\n</tr>\n<tr>\n<td>Transer function</td>\n<td>out &#x3D; gen U (in - kill)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Meet</td>\n<td>并</td>\n<td>并</td>\n<td>交</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>根据含义去确定Boundary(边界)</p>\n<ul>\n<li>inialization：对于到达性分析，entry都没有定义Di，所以out[entry]一定是null</li>\n</ul>\n<p><strong>说人话：</strong></p>\n<p>Reaching Definitions：</p>\n<ul>\n<li>分析在BBS中写的语句，例如 x &#x3D; y + 3，对于程序中的某点，有没有意义</li>\n</ul>\n<p>Live Variables Analysis：</p>\n<ul>\n<li>分析在某点如果定义了这个变量，对程序中的某点，有没有意义。</li>\n</ul>\n<p>Available Expressions：</p>\n<ul>\n<li>分析定义的表达式：x &#x3D; y +3中的y + 3，对于程序中的某点，有没有意义</li>\n</ul>\n<h1 id=\"Data-Flow-Analysis-Foundations\"><a href=\"#Data-Flow-Analysis-Foundations\" class=\"headerlink\" title=\"Data Flow Analysis Foundations\"></a>Data Flow Analysis Foundations</h1><h2 id=\"iterative-algorithms（迭代算法）\"><a href=\"#iterative-algorithms（迭代算法）\" class=\"headerlink\" title=\"iterative algorithms（迭代算法）\"></a>iterative algorithms（迭代算法）</h2><ul>\n<li>对于数据流分析，迭代算法生成了一个solution，也就是01组成的串</li>\n</ul>\n<h3 id=\"view-itrative-algorithm-in-another-way\"><a href=\"#view-itrative-algorithm-in-another-way\" class=\"headerlink\" title=\"view itrative algorithm in another way\"></a>view itrative algorithm in another way</h3><ul>\n<li><p>对于一个有k个nodes的CFG，迭代算法在每次迭代时，更新每个节点的Out</p>\n</li>\n<li><p>假设数据流分析的值域是V，那么可以定义一个K个元素的元组(k-tuple)</p>\n<p>$$(Out[n_1],Out[n_2],…Out[n_k]$$\t</p>\n<p>也就是一个集合$$(V_1*V_2…V_n)$$,定义这个集合为$$V^k$$在每次迭代后，保存新的值</p>\n</li>\n<li><p>每次迭代都是通过应用transer function 和control flow, 把一个map $$V^k$$变成一个新的map$$V^k$$，整个过程可以抽象为：</p>\n<p>$$F : V^k -&gt;V^k$$</p>\n</li>\n<li><p>该算法输出一系列的k-tuples，直到每个node的output不再变化</p>\n</li>\n</ul>\n<h3 id=\"图示形式：\"><a href=\"#图示形式：\" class=\"headerlink\" title=\"图示形式：\"></a><strong>图示形式：</strong></h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814224716717.png\" alt=\"image-20230814224716717\"></p>\n<ul>\n<li>对于这个算法，绿色部分就对应上面的F 函数</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814224856721.png\" alt=\"image-20230814224856721\"></p>\n<ul>\n<li>也就是初始化时init 都为空，接着进行迭代</li>\n<li>令第一次的结果为$X_0$，$$X_1 &#x3D; F(X_0)$$</li>\n<li>最终不变时，达到的结果是$$X_i &#x3D; F(X_i)$$</li>\n<li>此时程序输入的是$X_i$，输出的也是$X_i$，也就是这个iterative algorithm达到了一个不动点(fixed point)</li>\n</ul>\n<h3 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h3><p>这个iterative alogrithm 是对于data flow analysis生成一个solution</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814225526811.png\" alt=\"image-20230814225526811\"></p>\n<ul>\n<li>这个程序一定会达到不动点么？</li>\n<li>如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢</li>\n<li>我们的算法要经过多少步达到不动点</li>\n</ul>\n<h2 id=\"partial-order（偏序）\"><a href=\"#partial-order（偏序）\" class=\"headerlink\" title=\"partial order（偏序）\"></a>partial order（偏序）</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814230238252.png\" alt=\"image-20230814230238252\"></p>\n<ul>\n<li>定义了一个偏序集(poset)，用pair表示，，P是一个集合，后面的符号(统称为&lt;&#x3D;)是偏序关系，如果集合中的元素满足上面的三条性质(自反性、反对称性、传递性)，就构成P上的偏序集合</li>\n</ul>\n<p><strong>例1：S是一个整数集，符号是小于等于</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814230845398.png\" alt=\"image-20230814230845398\"></p>\n<ul>\n<li>满足三条性质，构成偏序集</li>\n</ul>\n<p><strong>例2：S是一个整数集，符号是小于</strong></p>\n<ul>\n<li>显然不构成 1 &lt; 1 2 &lt; 2是错的</li>\n</ul>\n<p><strong>例3：S是一系列(下图)英文单词的集合，符号表示substring，s1&lt;&#x3D;s2，表示s1是s2的子串</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814231120660.png\" alt=\"image-20230814231120660\"></p>\n<p><strong>例4：S是{a,b,c}的幂集，符号表示子集</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815000131924.png\" alt=\"image-20230815000131924\"></p>\n<p><strong>理解偏序(partial)的含义</strong></p>\n<ul>\n<li>意味着不是集合中的每对元素都要满足给定的关系(符号 &lt;&#x3D;)</li>\n<li>比如上面的 pin 和 sin就不满足</li>\n</ul>\n<h3 id=\"Upper-and-Lower-Bounds-上下界\"><a href=\"#Upper-and-Lower-Bounds-上下界\" class=\"headerlink\" title=\"Upper and Lower Bounds(上下界)\"></a>Upper and Lower Bounds(上下界)</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814232015644.png\" alt=\"image-20230814232015644\"></p>\n<p>这玩意不就是高中数学</p>\n<ul>\n<li><p>u是S的upper bound，也就是S中的所有元素都$\\subseteq$u</p>\n</li>\n<li><p>l是S的lower bound，也就是l$\\subseteq$S中的所有元素</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814232727105.png\" alt=\"image-20230814232727105\"></p>\n<ul>\n<li>对于这个集合来说，显然upper是{a,b,c}，lower是{}</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814234635753.png\" alt=\"image-20230814234635753\">                                            </p>\n<ul>\n<li>最小上界(lub  or  join)：l_lS</li>\n<li>最大下界：(glb or meet)</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814234811170.png\" alt=\"image-20230814234811170\"></p>\n<p>如果只包含两个元素</p>\n<ul>\n<li>lub：a l_l  b  也就是 a join b，就是a并b</li>\n<li>glb： 也就是a meet b，就是 a 交 b</li>\n</ul>\n<h3 id=\"Some-Properties\"><a href=\"#Some-Properties\" class=\"headerlink\" title=\"Some  Properties\"></a>Some  Properties</h3><ul>\n<li>不是每个偏序集都有glb 或者 lub</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814235206315.png\" alt=\"image-20230814235206315\"></p>\n<ul>\n<li>如果一个Poset有lub 和 glb，那一定都是唯一的</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814235220480.png\" alt=\"image-20230814235220480\"></p>\n<h2 id=\"Lattice\"><a href=\"#Lattice\" class=\"headerlink\" title=\"Lattice\"></a>Lattice</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814235430059.png\" alt=\"image-20230814235430059\"></p>\n<ul>\n<li>偏序集中的每两个元素，都有它的最大下界和最小上界，这个偏序集被称为一个lattice</li>\n</ul>\n<p>上面的例3，显然不构成lattice，pin和sin在集合中找不到glb</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815000813488.png\" alt=\"image-20230815000813488\"></p>\n<h3 id=\"Complete-Lattice\"><a href=\"#Complete-Lattice\" class=\"headerlink\" title=\"Complete Lattice\"></a>Complete Lattice</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815000917322.png\" alt=\"image-20230815000917322\"></p>\n<ul>\n<li>给定一个lattice P和它的任意一个子集S，如果joinS和meet S(S中可能不只两个元素a b)存在，那么P是一个complete lattice</li>\n</ul>\n<p><strong>说人话：一个lattice的所有子集都lub和glb</strong></p>\n<ul>\n<li>lattice是任意两个元素都有glb和lub，complete lattice是任意一个子集</li>\n</ul>\n<p>\t</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815002153942.png\" alt=\"image-20230815002153942\"></p>\n<ul>\n<li>正整数集是无穷的，没有边界，所以不是complete lattice</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815001747514.png\" alt=\"image-20230815001747514\"></p>\n<ul>\n<li>对于这个幂集，它是complete lattice，假设子集是{a,b}，最然glb和lub不在subset中，但是在lattice中</li>\n</ul>\n<p><strong>Bounds可以不在subset中，但是要在lattice</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815002015994.png\" alt=\"image-20230815002015994\"></p>\n<ul>\n<li>每一个complete lattice，都有一个top和bottom</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815002412780.png\" alt=\"image-20230815002412780\"></p>\n<ul>\n<li>每个有穷的lattice都是complete lattice</li>\n</ul>\n<h3 id=\"Product-Lattice\"><a href=\"#Product-Lattice\" class=\"headerlink\" title=\"Product Lattice\"></a>Product Lattice</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815004328353.png\" alt=\"image-20230815004328353\"></p>\n<ul>\n<li>给定一系列lattice，如果对于每一个偏序集，都有最小上界和最大下届，这些所有的偏序集就构成一个product lattice$$L^n &#x3D; (P,\\subseteq)$$</li>\n</ul>\n<p>这个product lattice被定义为：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815004340746.png\" alt=\"image-20230815004340746\"></p>\n<ul>\n<li>一个product lattice是一个lattice</li>\n<li>如果构成product lattice的每一个lattice都是complete lattice，那么这个product lattice也是complete lattice</li>\n</ul>\n<h2 id=\"Data-Flow-Analysis-Framework-via-Lattice\"><a href=\"#Data-Flow-Analysis-Framework-via-Lattice\" class=\"headerlink\" title=\"Data Flow Analysis Framework via Lattice\"></a>Data Flow Analysis Framework via Lattice</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815005117066.png\" alt=\"image-20230815005117066\"></p>\n<ul>\n<li>D：forward还是backward</li>\n<li>L：包括domain和operator</li>\n<li>F：一系列的从V 到V的transfer functions</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815005323828.png\" alt=\"image-20230815005323828\"></p>\n<ul>\n<li>可以看到，右边的图(may analysis)是从bottom往上走的</li>\n</ul>\n<p><strong>data flow analysis可以看成对lattice的值迭代的使用transfer functions和meet&#x2F;join operations</strong></p>\n<h2 id=\"Monotonicity（单调性）\"><a href=\"#Monotonicity（单调性）\" class=\"headerlink\" title=\"Monotonicity（单调性）\"></a>Monotonicity（单调性）</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815010435910.png\" alt=\"image-20230815010435910\"></p>\n<ul>\n<li>L是一个lattice，if 任意的x y属于L, $$x \\subseteq y$$，f(x)$\\subseteq$f(y)</li>\n</ul>\n<h3 id=\"Fixed-Point-Theorem-不动点定理\"><a href=\"#Fixed-Point-Theorem-不动点定理\" class=\"headerlink\" title=\"Fixed-Point Theorem(不动点定理)\"></a>Fixed-Point Theorem(不动点定理)</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815010934815.png\" alt=\"image-20230815010934815\"></p>\n<p>L是单调的，且L是有穷的，那么最小不动点和最大不动点能通过迭代求出来</p>\n<ol>\n<li><p>求最小不动点：第一次用bottom作为输入，得到f(bottom)，再把f(bottom)作为下一次的输入，直到求出一个不动点，这个不动点就是最小不动点</p>\n</li>\n<li><p>求最大不动点：第一次用top作为输入，得到f(top)，再把f(top)作为下一次的输入，直到求出一个不动点，这个不动点就是最大不动点</p>\n</li>\n</ol>\n<h4 id=\"证明不动点\"><a href=\"#证明不动点\" class=\"headerlink\" title=\"证明不动点\"></a>证明不动点</h4><h5 id=\"Existence-of-Fixed-Point\"><a href=\"#Existence-of-Fixed-Point\" class=\"headerlink\" title=\"Existence of Fixed Point\"></a>Existence of Fixed Point</h5><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815024144513.png\" alt=\"image-20230815024144513\"></p>\n<ul>\n<li>首先定义一个bottom，f(bottom）就是对bottom进行transer funtion变换，可以理解为右下的图，从{}走到了{a}</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230815005323828.png\" alt=\"image-20230815005323828\"></p>\n<ul>\n<li>因为f是单调的，所以 f(bottom)$\\sqsubseteq$f(f((bottom))，一直到$f^i(bottom)$</li>\n<li>那由于L是有穷的(程序最终的111…111)，假设最终值是$f^H(bottom)$，此时再对他进行transer function，就不会变了(因为1不会变成0？)</li>\n<li>从下面gitbook的证明看出来，和我想的一样，但是这个ppt上的证明我属实没看懂</li>\n</ul>\n<p><strong>gitbook的证明：</strong></p>\n<p>根据$\\bot$和f的定义，我们可以得到：$\\bot \\sqsubseteq f(\\bot)$。</p>\n<p>由于 L 是有限的，且 f 单调，根据鸽笼原理，必然存在一个 k 使得$\\bot \\sqsubseteq f(\\bot) \\sqsubseteq f^2(\\bot)\\sqsubseteq …\\sqsubseteq f^k(\\bot)\\sqsubseteq f^{k+1}(\\bot) $，且$f^k(\\bot) &#x3D; f^{k+1}(\\bot)$。</p>\n<h5 id=\"Least-Fixed-Point\"><a href=\"#Least-Fixed-Point\" class=\"headerlink\" title=\"Least Fixed Point\"></a>Least Fixed Point</h5><p><strong>gitbook的证明：(通俗易懂，ppt上写的我没看懂)</strong></p>\n<p>假设我们有另一个任意不动点 x，由于 f 是单调的，因此$f(\\bot) \\sqsubseteq f(x), f^2(\\bot) \\sqsubseteq f^2(x),…,f^{Fix} &#x3D; f^k(\\bot)\\sqsubseteq f^k(x) &#x3D; x$</p>\n<p>可知的确$f^{Fix}$是最小不动点。</p>\n<p><strong>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点。</strong></p>\n<h1 id=\"Data-Flow-Analysis-Foundations-II\"><a href=\"#Data-Flow-Analysis-Foundations-II\" class=\"headerlink\" title=\"Data Flow Analysis Foundations II\"></a>Data Flow Analysis Foundations II</h1><h2 id=\"Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\"><a href=\"#Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\" class=\"headerlink\" title=\"Relate Iterative Algorithm to Fix-ed Point Theorem\"></a>Relate Iterative Algorithm to Fix-ed Point Theorem</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816061430910.png\" alt=\"image-20230816061430910\"></p>\n<p><strong>问题1：这两个怎么联系起来呢</strong>？</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816061010705.png\" alt=\"image-20230816061010705\"></p>\n<p><strong>第一步：确定product lattice，且是finite</strong></p>\n<ul>\n<li><p>这里的每一个节点都对应一个Lattice。假设他是reaching definitions，假设有3个变量D1 D2 D3</p>\n</li>\n<li><p>他的domain一定是(0,0,0)  … …. (D1,D2,D3)</p>\n</li>\n<li><p>所以它是lattice</p>\n</li>\n<li><p>每一个lattice都是finite，所以整体也是finite</p>\n</li>\n</ul>\n<p><strong>第二步：确定 f: L -&gt; L 是单调的</strong></p>\n<p>对于iterative algotithm来说，f相当于control flow和transer function</p>\n<ul>\n<li>因为 transer function**(OUT &#x3D; gen U (IN - kill))**的结果一定是从0 到1，不会从1到0 ，所以是单调的</li>\n</ul>\n<p>现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L</p>\n<ul>\n<li>即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $</li>\n</ul>\n<p>单调的定义是：x&lt; y, f(x) &lt; f(y)，这里的meet就相当于f</p>\n<ul>\n<li>根据定义， $y\\sqsubseteq y\\sqcup  z$，因为y meet z是least upper bound </li>\n<li>所以 $x\\sqsubseteq y\\sqcup  z$</li>\n<li>又因为 $x\\sqsubseteq x\\sqcup  z$，且 $x \\sqcup z$是x的least upper bound</li>\n<li>所以 $x \\sqcup z\\sqsubseteq y\\sqcup  z$</li>\n</ul>\n<p>到这里可以把不动点定理应用到iterative algorithm中</p>\n<h2 id=\"Review-the-questions\"><a href=\"#Review-the-questions\" class=\"headerlink\" title=\"Review the questions\"></a>Review the questions</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230814225526811.png\" alt=\"image-20230814225526811\"></p>\n<ul>\n<li><p>这个程序一定会达到不动点么？<strong>会，根据不动点定理</strong></p>\n</li>\n<li><p>如果达到了，只有一个不动点么？如果超过一个，如何确定我们得出的solution就是最好的呢？<strong>greatest or least fixed point</strong></p>\n</li>\n<li><p>我们的算法要经过多少步达到不动点? </p>\n<p><strong>最坏情况是：h*k</strong></p>\n</li>\n</ul>\n<h2 id=\"When-will-the-algorithm-reach-the-fixed-point？\"><a href=\"#When-will-the-algorithm-reach-the-fixed-point？\" class=\"headerlink\" title=\"When will the algorithm reach the fixed point？\"></a>When will the algorithm reach the fixed point？</h2><ul>\n<li>lattice的高度：lattice中从bottom到top最长的path</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816063329661.png\" alt=\"image-20230816063329661\"></p>\n<ul>\n<li>假设 lattice 的高度为 h，而我们的 CFG 节点数为 k，就算每次迭代可以使一个节点在 lattice 上升一个高度，那么最坏情况下，我们的迭代次数也就是 $i &#x3D; h \\times k$</li>\n<li>这也回答了上面最后一个问题</li>\n</ul>\n<h2 id=\"May-and-Must-Analysis-a-Lattice-View\"><a href=\"#May-and-Must-Analysis-a-Lattice-View\" class=\"headerlink\" title=\"May and Must Analysis , a Lattice View\"></a>May and Must Analysis , a Lattice View</h2><ul>\n<li>都是从unsafe 向safe 走，</li>\n</ul>\n<h3 id=\"May-Analysis-View\"><a href=\"#May-Analysis-View\" class=\"headerlink\" title=\"May  Analysis View\"></a>May  Analysis View</h3><p>将lattice抽象成一个视图</p>\n<p>例如，对于到达定值分析，下界代表没有任何可到达的定值，上界代表所有定值都可到达。</p>\n<p>目标：我们的目标是在程序运行后，找到一个可以替换的变量(优化)</p>\n<ul>\n<li>下界代表 unsafe 的情形，即我们认为无到达定值，可对相关变量的存储空间进行替换。</li>\n<li>上界代表 safe but useless 的情绪，即认为定值必然到达，但是这对我们寻找一个可替换掉的存储空间毫无意义。</li>\n</ul>\n<p>而因为我们采用了 join 函数，那么我们必然会从 lattice 的最小下界往上走。而越往上走，我们就会失去更多的精确值。那么，在所有不动点中我们寻找最小不动点，那么就能得到精确值最大的结果。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816071341859.png\" alt=\"image-20230816071341859\"></p>\n<h3 id=\"Must-Analysis-View\"><a href=\"#Must-Analysis-View\" class=\"headerlink\" title=\"Must Analysis View\"></a>Must Analysis View</h3><p>你说所有的expressions都是avaliable，意思就是所有的表达式都没有其中的值被重新定义，也就是所有的表达式都可以用原来的值替换，这肯定是Unsafe的</p>\n<p>反之，所有的表达式都不avaliable,需要重新计算所有的值，肯定是safe，都别优化了</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816073057174.png\" alt=\"image-20230816073057174\"></p>\n<ul>\n<li>下界代表 safe but useless 的情形，因为需要重新计算每个表达式，即确实有表达式可用。而上界代表 unsafe，因为不是所有路径都能使表达式都可用。与 may analysis 一样，通过寻找最大不动点，我们能得到合法的结果中精确值最大的结果</li>\n</ul>\n<p><strong>another view of leaest fixed point</strong></p>\n<p>以may analysis举例</p>\n<ul>\n<li>transer function中 kill 和gen是固定的</li>\n<li>control flow merge 是  union，对于lattice来说union是最小上界</li>\n<li>所以每次都走的是最小的一步，那最后得到的肯定是最小不动点</li>\n</ul>\n<h2 id=\"How-Precise-is-our-Solution\"><a href=\"#How-Precise-is-our-Solution\" class=\"headerlink\" title=\"How Precise is our Solution\"></a>How Precise is our Solution</h2><h3 id=\"Meet-Over-All-Paths-Solution-MOP\"><a href=\"#Meet-Over-All-Paths-Solution-MOP\" class=\"headerlink\" title=\"Meet-Over-All-Paths Solution(MOP)\"></a>Meet-Over-All-Paths Solution(MOP)</h3><ul>\n<li>这里的meet包括(meet&#x2F;join)</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816222855029.png\" alt=\"image-20230816222855029\"></p>\n<ul>\n<li>对所有的out应用transer function，再用meet操作符</li>\n<li>MOP在每条路径的结尾计算所有的data-flow的值，应用应用Meet去找到 lub &#x2F; glb</li>\n</ul>\n<p>但是基于上面的表达式可能有些问题</p>\n<p><strong>问题1：有些路径是不可执行的（not executable）</strong></p>\n<ul>\n<li>上面是考虑了所有的路径，但是有写路径可能永远不会被执行</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">x<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">></span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>问题2：not unbounded(没有边界)</strong></p>\n<ul>\n<li>如果有一条path中有循环，循环中定义s1,s2两个变量,也就是这条path上会包含非常多个s1,s2</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\ns1<span class=\"token punctuation\">;</span>\ns2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>问题3：Not enumerable</strong></p>\n<ul>\n<li>可能程序很大，不可枚举</li>\n</ul>\n<h3 id=\"Ours-iterative-Algorithm-vs-MOP\"><a href=\"#Ours-iterative-Algorithm-vs-MOP\" class=\"headerlink\" title=\"Ours(iterative Algorithm) vs MOP\"></a>Ours(iterative Algorithm) vs MOP</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816223938137.png\" alt=\"image-20230816223938137\"></p>\n<ul>\n<li><p>我们的算法是在每一个merge的时候，join</p>\n</li>\n<li><p>MOP是在最后merge</p>\n</li>\n</ul>\n<p>把黄色的部分用x代替，红色的部分用y代替</p>\n<p>证明一下他俩的关系：</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816230725374.png\" alt=\"image-20230816230725374\"></p>\n<ul>\n<li>这个很好理解，F($x\\sqcup y$)是F(x)和F(y)的upper bound,F(x)和F(y)的最小上界是$F(x)\\sqcup F(y)$</li>\n<li>所以$MOP \\sqsubseteq Ours$</li>\n</ul>\n<p>当F具有可分配性时</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816231036088.png\" alt=\"image-20230816231036088\"></p>\n<p>bit-vector或者Gen&#x2F;kill的transer function(用join &#x2F; meet)都是distributive</p>\n<ul>\n<li>所以我们之前的都和MOP一样准确</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h2 id=\"关于must-analysis-还是-may-analysis的分析\"><a href=\"#关于must-analysis-还是-may-analysis的分析\" class=\"headerlink\" title=\"关于must analysis 还是 may analysis的分析\"></a>关于must analysis 还是 may analysis的分析</h2><h3 id=\"Reaching-definitons\"><a href=\"#Reaching-definitons\" class=\"headerlink\" title=\"Reaching definitons\"></a><strong>Reaching definitons</strong></h3><ul>\n<li>它的目标是：判断在此处定义的D1 … Di是否有意义，如果每意义，就被优化，1代表有意义，0代表无意义。</li>\n<li>也就是如果有一条路径是1，代表可能有意义，就不能被优化</li>\n<li>所以要 把结果并起来，所以是may analysis</li>\n</ul>\n<h3 id=\"live-avaliables\"><a href=\"#live-avaliables\" class=\"headerlink\" title=\"live avaliables\"></a>live avaliables</h3><ul>\n<li>它的目标是判断变量后面是否被用了，如果是无意义的变量，就把它的空间释放掉，用来存储新的寄存器值</li>\n<li>1代表有意义，0代表无意义</li>\n<li>也就是如果有1条路有意义，就不应该被优化</li>\n<li>所以同上</li>\n</ul>\n<h3 id=\"avaliable-expressions\"><a href=\"#avaliable-expressions\" class=\"headerlink\" title=\"avaliable expressions\"></a>avaliable expressions</h3><ul>\n<li>它的定义说要考虑所有的路径，是否在每一条路径都执行了x op y，如果都执行了，就可以把这个结果用一个新的变量替换</li>\n<li>那如果有一条路劲没计算，显然就不能别替换，输出是0</li>\n<li>所以要把所有的结果取 交集</li>\n</ul>\n<h2 id=\"Constant-Propagation\"><a href=\"#Constant-Propagation\" class=\"headerlink\" title=\"Constant Propagation\"></a>Constant Propagation</h2><p>程序的p点有一个变量x,判断在P点是否可以guaranteed x是一个常量</p>\n<ul>\n<li>要考虑所有的路径上是否定义的值都一样，如果有两条路径是x&#x3D;2，有一条是x&#x3D;3，那显然不行</li>\n<li>所以是must analysis</li>\n</ul>\n<p>从top往bottom走，最下面肯定是最安全的，因为你要考虑的问题(优化的目标)是 是否是constant，最下面是所有的都不是constant，所以肯定是safe</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817210307704.png\" alt=\"image-20230817210307704\"></p>\n<p>考虑所有的meet</p>\n<p>nac：Not a constant</p>\n<p>V：value</p>\n<ul>\n<li><p>nac 和 v肯定是nac</p>\n</li>\n<li><p>undef 和 v是 v</p>\n<p>但是这里有一种情况是，假设程序走了Undefined的路径，表示没有这个常量，但是输出结果是有一个常量，那在程序获取undefined三，少了一个值。</p>\n<p>解释：在constant propagation（常量传播）中，只考虑常量传播，不focus于未定义这种情况</p>\n</li>\n</ul>\n<h3 id=\"Transfer-function\"><a href=\"#Transfer-function\" class=\"headerlink\" title=\"Transfer function\"></a>Transfer function</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230816235426102.png\" alt=\"image-20230816235426102\"></p>\n<p> _表示通配符，无论是啥值，都干掉\t</p>\n<ul>\n<li>x如果是常量，生成的就是x和对应的值</li>\n<li>如果x&#x3D;y，y是一个变量，那就去取y的值，如果是常量就是，不是就不是</li>\n<li>x&#x3D; y op z，就进行计算<ul>\n<li>两个都是常量</li>\n<li>有一个不是常量</li>\n<li>其中有一个是undefi，或者两个都是undef</li>\n</ul>\n</li>\n</ul>\n<p>这里提了一句，如果把undef给了一个值，那transfer function就不单调了。</p>\n<p><strong>我的理解：</strong></p>\n<p>回看定义</p>\n<p><strong>现在需要证明：control flow也是单调的，也就是 join&#x2F;meet后的结果是也是单调的  LxL -&gt; L</strong></p>\n<p><strong>即需要证明 任意的x , y, z 属于L，x$\\sqsubseteq $y，需要证明 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $</strong></p>\n<ul>\n<li>假设z是undef，那 $x \\sqcup z \\sqsubseteq  y \\sqcup  z $ 这个表达式不一定成立</li>\n</ul>\n<h3 id=\"为什么是Nondistributivity\"><a href=\"#为什么是Nondistributivity\" class=\"headerlink\" title=\"为什么是Nondistributivity\"></a>为什么是Nondistributivity</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817001140056.png\" alt=\"image-20230817001140056\"></p>\n<ul>\n<li>iterative algorithm的结果是nac</li>\n<li>mop的结果是10</li>\n<li>他俩不相等，所以他就不是distributivity</li>\n<li>实际结果是10，mop准</li>\n</ul>\n<h2 id=\"Worklist-Algorithm\"><a href=\"#Worklist-Algorithm\" class=\"headerlink\" title=\"Worklist Algorithm\"></a>Worklist Algorithm</h2><p>an optimization of iterative algorithm，是iterative algorithm的优化</p>\n<ul>\n<li>实际上用的是Worklist Algorithm</li>\n</ul>\n<p><strong>回顾iterative algorithm</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817001720388.png\" alt=\"image-20230817001720388\"></p>\n<ul>\n<li>有一个变化了，所有的都要重新算，很冗余</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817011427252.png\" alt=\"image-20230817011427252\"></p>\n<h1 id=\"Interprocedural-Analysis\"><a href=\"#Interprocedural-Analysis\" class=\"headerlink\" title=\"Interprocedural Analysis\"></a>Interprocedural Analysis</h1><h2 id=\"Motivation（为什么需要过程间分析呢）\"><a href=\"#Motivation（为什么需要过程间分析呢）\" class=\"headerlink\" title=\"Motivation（为什么需要过程间分析呢）\"></a>Motivation（为什么需要过程间分析呢）</h2><p><strong>问题1：之前学到都是过程内分析，但是肯定会有方法调用，那该怎么办呢？</strong></p>\n<ul>\n<li>之前都是会做最保守的假设，也就是最安全的假设</li>\n<li>对于常量分析而言，就假设不是常量</li>\n</ul>\n<p>下面的 x y n对于过程内分析(inter procedural)而言，都是nac</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817211434068.png\" alt=\"image-20230817211434068\"></p>\n<p>为了更好的精度，就需要过程间分析：也就是需要沿着过程见分析的control - flow edges传递数据流信息。</p>\n<p>对于下面的图，最关键的就是call graph</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817211617439.png\" alt=\"image-20230817211617439\"></p>\n<h2 id=\"Call-Graph-Construction\"><a href=\"#Call-Graph-Construction\" class=\"headerlink\" title=\"Call Graph Construction\"></a>Call Graph Construction</h2><h3 id=\"Call-Graph\"><a href=\"#Call-Graph\" class=\"headerlink\" title=\"Call Graph\"></a>Call Graph</h3><ul>\n<li>call graph就是一系列call edges的集合，从调用点到他们的目标方法</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817212045071.png\" alt=\"image-20230817212045071\"></p>\n<h3 id=\"Call-Graph-Construction-for-OOPLS（focus-on-java）\"><a href=\"#Call-Graph-Construction-for-OOPLS（focus-on-java）\" class=\"headerlink\" title=\"Call Graph Construction for OOPLS（focus on java）\"></a>Call Graph Construction for OOPLS（focus on java）</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817212304829.png\" alt=\"image-20230817212304829\"></p>\n<h3 id=\"Method-Calls-Invocation-in-Java\"><a href=\"#Method-Calls-Invocation-in-Java\" class=\"headerlink\" title=\"Method Calls(Invocation) in Java\"></a>Method Calls(Invocation) in Java</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817230247609.png\" alt=\"image-20230817230247609\"></p>\n<p>Special call处理三种方法： 私有方法、构造函数、父类方法</p>\n<ul>\n<li>static call和special call都是在编译时，就可以确定了，但是像其他的实例方法，需要在运行时候才能确定</li>\n<li>Instruction：指Java的<strong>IR中的指令</strong></li>\n<li>Receiver objects：方法调用对应的实例对象（static方法调用不需要对应实例）。</li>\n<li>Target methods：表达<strong>IR指令到被调用目标方法的映射关系</strong></li>\n<li>Num of target methods：call对应的可能被调用的目标方法的数量。Virtual call与动态绑定和多态实现有关，可以对应多个对象下的重写方法。所以<strong>Virtual call的可能对象可能超过1个</strong>。</li>\n<li>Determinacy：指什么时候能够确定这个call的对应方法。Virtual call与多态有关，只能在运行时决定调用哪一个具体方法的实现。其他两种call都和多态机制不相关，编译时刻就可以确定。</li>\n</ul>\n<p> 意思也就是：在编译时刻，不能确定传给哪个对象，不能确定是调用父类的方法还是子类的方法。</p>\n<h3 id=\"Method-Dispatch-of-Virtual-Calls\"><a href=\"#Method-Dispatch-of-Virtual-Calls\" class=\"headerlink\" title=\"Method Dispatch of Virtual Calls\"></a>Method Dispatch of Virtual Calls</h3><p>在run-time时，一个virtual call取决于以下两点：</p>\n<ul>\n<li>received object的类型(也就是o的类型，应该是Class)</li>\n<li>调用点的method signature</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817231018639.png\" alt=\"image-20230817231018639\"></p>\n<p>一个signature是一个方法的identifier</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817231119367.png\" alt=\"image-20230817231119367\"></p>\n<ul>\n<li>class type：这里是C</li>\n<li>method name：foo</li>\n<li>descriptor：返回类型+参数类型</li>\n</ul>\n<p>这里用C.foo(P,Q,R)简写</p>\n<p>接着定义了一个Dispatch(c,m)模拟运行时的方法调用过程</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817231614531.png\" alt=\"image-20230817231614531\"></p>\n<p><strong>这里的目标是找到m方法并调用</strong></p>\n<ul>\n<li>如果c包含一个和m有同样名字和descriprot的<strong>非抽象</strong>方法 m’(因为只有非抽象的方法才能被调用)</li>\n<li>否则就去c的父类中找</li>\n</ul>\n<h3 id=\"An-Example\"><a href=\"#An-Example\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817234913493.png\" alt=\"image-20230817234913493\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817232030077.png\" alt=\"image-20230817232030077\"></p>\n<ul>\n<li>这里的B表示的是received object的类型</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230817234925578.png\" alt=\"image-20230817234925578\"></p>\n<h3 id=\"Class-Hierarchy-Analysis-CHA\"><a href=\"#Class-Hierarchy-Analysis-CHA\" class=\"headerlink\" title=\"Class Hierarchy Analysis(CHA)\"></a>Class Hierarchy Analysis(CHA)</h3><p>这个算法的目标是在编译时，根据receiver variable来判断它可能调用哪个类的方法</p>\n<ul>\n<li>它需要类的迭代信息</li>\n<li>需要receiver variable的 declared type</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818204856753.png\" alt=\"image-20230818204856753\"></p>\n<h3 id=\"Call-Resolution-of-CHA\"><a href=\"#Call-Resolution-of-CHA\" class=\"headerlink\" title=\"Call Resolution of CHA\"></a>Call Resolution of CHA</h3><p>这里定义了一个函数Resolve(cs)，通过调用点来判断可能的目标方法</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205156276.png\" alt=\"image-20230818205156276\"></p>\n<p>这里分成三类，分别是静态方法，special call(构造器、super、私有方法)，和virtual call</p>\n<h4 id=\"static-call\"><a href=\"#static-call\" class=\"headerlink\" title=\"static call\"></a>static call</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205455206.png\" alt=\"image-20230818205455206\"></p>\n<ul>\n<li>就直接调用就行了</li>\n</ul>\n<h4 id=\"special-call\"><a href=\"#special-call\" class=\"headerlink\" title=\"special call\"></a>special call</h4><p>这里以super方法为例</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205527658.png\" alt=\"image-20230818205527658\"></p>\n<ul>\n<li>首先获得它的类，</li>\n<li>然后用Dispatch，根据前面学的，Dispatch就是先在当前类找同名方法，如果没有，就找它的父类</li>\n</ul>\n<h4 id=\"virtual-call\"><a href=\"#virtual-call\" class=\"headerlink\" title=\"virtual call\"></a>virtual call</h4><ul>\n<li>获得receive variable的类型</li>\n<li>然后对它和它的所有子类应用dispatch</li>\n</ul>\n<h4 id=\"An-example\"><a href=\"#An-example\" class=\"headerlink\" title=\"An example\"></a>An example</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818205846768.png\" alt=\"image-20230818205839605\"></p>\n<p>c.foo()  肯定就是C.foo()</p>\n<p>a.foo()    返回结果是 {A.foo()，C.foo()，D.foo()}</p>\n<p>b.foo() 返回结果：{A.foo()，C.foo()，D.foo()}</p>\n<ul>\n<li><p>先对B应用Dispatch，他没有这个方法，就要去它的父类中找，所以是A.foo()</p>\n</li>\n<li><p>这里我用java测试一下，如果B类中没有这个方法，那是会去找他的父类，<strong>这条性质我忘记了</strong> ，就严格按照Dispatch的定义来就行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">B</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        b<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A的foo调用\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818210830243.png\" alt=\"image-20230818210830243\"></p>\n</li>\n</ul>\n<h3 id=\"Features-of-CHA\"><a href=\"#Features-of-CHA\" class=\"headerlink\" title=\"Features of CHA\"></a>Features of CHA</h3><p>优点：</p>\n<ul>\n<li>快，只考虑receiver variable</li>\n<li>忽略数据流信息</li>\n</ul>\n<p>ide中用的就是CHA </p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818211402699.png\" alt=\"image-20230818211402699\"></p>\n<h3 id=\"Call-Graph-Construction-Algorithm\"><a href=\"#Call-Graph-Construction-Algorithm\" class=\"headerlink\" title=\"Call Graph Construction -&gt; Algorithm\"></a>Call Graph Construction -&gt; Algorithm</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818212105348.png\" alt=\"image-20230818212105348\"></p>\n<h3 id=\"An-Example-1\"><a href=\"#An-Example-1\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818221958372.png\" alt=\"image-20230818221958372\"></p>\n<h2 id=\"Interprocedural-Control-Flow-Graph\"><a href=\"#Interprocedural-Control-Flow-Graph\" class=\"headerlink\" title=\"Interprocedural Control-Flow Graph\"></a>Interprocedural Control-Flow Graph</h2><p>CFG表示一个方法的结构</p>\n<p>ICFG就是表示整个程序的结构</p>\n<p>ICFG包括所有方法的CFG，再加上两种额外的边</p>\n<ul>\n<li>Call edges</li>\n<li>Return edges：</li>\n<li>return sites：紧跟着call site的下一条语句是return site</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818222414975.png\" alt=\"image-20230818222414975\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818222947646.png\" alt=\"image-20230818222947646\"></p>\n<ul>\n<li>从call graph中获取这两种边</li>\n</ul>\n<h3 id=\"An-example-1\"><a href=\"#An-example-1\" class=\"headerlink\" title=\"An example\"></a>An example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818224613267.png\" alt=\"image-20230818224613267\"></p>\n<ul>\n<li>这里的小黄是 call-to-return edges，就是从Call site到return site</li>\n<li>它用来传递Local data-flow，比如 a&#x3D;6</li>\n</ul>\n<h2 id=\"Interprocedural-Data-Flow-Analysis\"><a href=\"#Interprocedural-Data-Flow-Analysis\" class=\"headerlink\" title=\"Interprocedural Data-Flow Analysis\"></a>Interprocedural Data-Flow Analysis</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818223410639.png\" alt=\"image-20230818223410639\"></p>\n<ul>\n<li>现在多了两种边，需要多两种transfer</li>\n</ul>\n<h3 id=\"Interprocedural-Contant-Propagation\"><a href=\"#Interprocedural-Contant-Propagation\" class=\"headerlink\" title=\"Interprocedural Contant Propagation\"></a>Interprocedural Contant Propagation</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818223556449.png\" alt=\"image-20230818223556449\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818231300538.png\" alt=\"image-20230818231300538\"></p>\n<ul>\n<li>这里要保留edge transfer的返回结果，比如返回的是b，原来流到这的也是b，所以要kill 原来的b</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818232053033.png\" alt=\"image-20230818232053033\"></p>\n<p>如果是过程内分析(IntraProcedural)，那就会保证一种safe的情况，正如本节课最开始的时候说的，就会对于有call method这种，假设不是常量。</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818232931811.png\" alt=\"image-20230818232931811\"></p>\n<ul>\n<li>这里就会假设addOne的返回值不是常量，所以一直到最后b c都不是常量</li>\n<li>因此就会unprecise</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818233056081.png\" alt=\"image-20230818233056081\"></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230818233129686.png\" alt=\"image-20230818233129686\"></p>\n<h1 id=\"Pointer-Analysis\"><a href=\"#Pointer-Analysis\" class=\"headerlink\" title=\"Pointer Analysis\"></a>Pointer Analysis</h1><h2 id=\"Problem-of-CHA\"><a href=\"#Problem-of-CHA\" class=\"headerlink\" title=\"Problem of CHA\"></a>Problem of CHA</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819204842348.png\" alt=\"image-20230819204842348\"></p>\n<ul>\n<li>对于CHA来说，n.get只看Number的类型，所以会返回三个call targets，有2个是false postives，这样对于常量分析来说，返回了 0，1，2，所以是NAC</li>\n</ul>\n<p>因此就有了指针分析，可以更准确的找到调用的方法.</p>\n<ul>\n<li>会根据n指向的对象来构造调用图，所以只会调用One的get方法(1 call target)，基于这个做常量传播，就是准确的。</li>\n</ul>\n<h2 id=\"Pointer-Analysis-1\"><a href=\"#Pointer-Analysis-1\" class=\"headerlink\" title=\"Pointer Analysis\"></a>Pointer Analysis</h2><p>分析的是内存中指向哪个地址</p>\n<p>对于oo语言来说</p>\n<ul>\n<li>回答的是一个对象指向哪些对象</li>\n</ul>\n<p>是may analysis</p>\n<ul>\n<li>对于一个指针指向哪些对象，是一个over-approximation，我们问的问题是一个指针可能指向哪个对象</li>\n</ul>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819210045111.png\" alt=\"image-20230819210045111\"></p>\n<p><strong>问题1： 为什么y指向new B</strong></p>\n<ul>\n<li>因为返回的this.b之前被赋值了，变成了指向new B，所以y也指向new B</li>\n</ul>\n<h2 id=\"Pointer-Analysis-and-alias-Analysis（别名分析）\"><a href=\"#Pointer-Analysis-and-alias-Analysis（别名分析）\" class=\"headerlink\" title=\"Pointer Analysis and alias Analysis（别名分析）\"></a>Pointer Analysis and alias Analysis（别名分析）</h2><p><strong>指针分析</strong></p>\n<ul>\n<li>一个指针指向哪个对象</li>\n</ul>\n<p><strong>别名分析</strong></p>\n<ul>\n<li>两个指针指向同一个对象么</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819214030664.png\" alt=\"image-20230819214030664\"></p>\n<p>别名分析的信息可以通过指针分析推导出来</p>\n<h2 id=\"Application-of-Pointer-Analysis\"><a href=\"#Application-of-Pointer-Analysis\" class=\"headerlink\" title=\"Application of Pointer Analysis\"></a>Application of Pointer Analysis</h2><ul>\n<li>Compiler optimization</li>\n<li>Bug detection</li>\n<li>Security Analysisi</li>\n<li>Call graph,aliases</li>\n</ul>\n<h2 id=\"Key-Factors-in-Pointer-Analysis\"><a href=\"#Key-Factors-in-Pointer-Analysis\" class=\"headerlink\" title=\"Key Factors in Pointer Analysis\"></a>Key Factors in Pointer Analysis</h2><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819214951488.png\" alt=\"image-20230819214951488\"></p>\n<h3 id=\"Heap-abstraction\"><a href=\"#Heap-abstraction\" class=\"headerlink\" title=\"Heap abstraction\"></a>Heap abstraction</h3><p><strong>问题：指针分析时，如何对堆的内存进行建模？</strong></p>\n<ul>\n<li>程序动态执行时，如果程序中有循环，就会产生无穷多个对象，这样指针分析就无法终止了？</li>\n</ul>\n<p><strong>那如何终止？</strong></p>\n<ul>\n<li>用堆抽象，把无穷的对象 抽象成 有限的抽象的对象</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819215335308.png\" alt=\"image-20230819215335308\"></p>\n<h4 id=\"Allocation-Site-Abstraction\"><a href=\"#Allocation-Site-Abstraction\" class=\"headerlink\" title=\"Allocation-Site Abstraction\"></a>Allocation-Site Abstraction</h4><ul>\n<li>给具体的对象建模时，抽象成他们的创建点</li>\n<li>用这个抽象点去代表具体的对象</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819215656384.png\" alt=\"image-20230819215656384\"></p>\n<ul>\n<li>把三次循环的结果，抽象成一个创建点o2</li>\n<li>静态分析就只处理o2，也就是程序中有几个new，静态分析就处理几个对象</li>\n</ul>\n<h3 id=\"Context-Sensitivity-上下文敏感\"><a href=\"#Context-Sensitivity-上下文敏感\" class=\"headerlink\" title=\"Context Sensitivity(上下文敏感 )\"></a>Context Sensitivity(上下文敏感 )</h3><p><strong>问题：如何堆调用上下文进行建模?</strong></p>\n<p><strong>Context-sensitive：</strong></p>\n<ul>\n<li>会区分不同方法的上下文</li>\n<li>如果一个方法有多个上下文，就都分析</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819220014991.png\" alt=\"image-20230819220014991\"></p>\n<ul>\n<li>这种就分析2次</li>\n</ul>\n<p><strong>上下文敏感对提升指针分析非常有用。</strong></p>\n<p><strong>Context-insentitive</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819220117482.png\" alt=\"image-20230819220117482\"></p>\n<ul>\n<li>只分析1次</li>\n<li>但是merge data flow，可能会丢失精度</li>\n</ul>\n<h3 id=\"Flow-sensitivity\"><a href=\"#Flow-sensitivity\" class=\"headerlink\" title=\"Flow sensitivity\"></a>Flow sensitivity</h3><p><strong>问题：如何对指针分析中的control flow建模？下面两种方法</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230819235926928.png\" alt=\"image-20230819235926928\"></p>\n<ul>\n<li>该图中，左边是flow-sensitive，右边是flow-insensitive</li>\n</ul>\n<p><strong>flow-sensitive</strong>：</p>\n<ul>\n<li>在每个程序的Location，都维持一个指向关系的map</li>\n<li>下面为什么s指向的值是x 而不是y，我还重新学了一下java的String知识。<ul>\n<li>总结来说开始时c.f指向的是常量池中的x，s也指向的是x</li>\n<li>但是c.f现在指向了y，就是常量池中新建了一个y，但是此时s还指向的是刚才的，所以是x</li>\n</ul>\n</li>\n</ul>\n<p><strong>flow-insensitive</strong></p>\n<ul>\n<li>忽略程序流的控制流信息，维持程序中的所有指向</li>\n<li>所以o1.f的所有可能值就是{x,y}</li>\n<li>s指向c.f，所有s的所有可能值也是{x,y}</li>\n</ul>\n<p><strong>总结</strong>;</p>\n<p>目前java中都使用flow-insensitive</p>\n<h3 id=\"Analysis-Scope\"><a href=\"#Analysis-Scope\" class=\"headerlink\" title=\"Analysis Scope\"></a>Analysis Scope</h3><p><strong>问题：指针分析时应该分析程序中的哪一部分呢？有下面两种方式</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820001012063.png\" alt=\"image-20230820001012063\"></p>\n<ul>\n<li>对于whole-program，左边的蓝色图，分析x&#x3D;o1，，y&#x3D;o1,z&#x3D;o4</li>\n<li>对于Demand-driven，右边的黄图，只需要分析z&#x3D;04就够了</li>\n</ul>\n<p><strong>whole-program</strong></p>\n<ul>\n<li>计算程序中所有pointer的指向信息</li>\n</ul>\n<p><strong>Demand-driven(需求驱动)</strong></p>\n<ul>\n<li>根据specific sites of interest进行分析</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>选择全程序分析</li>\n</ul>\n<h3 id=\"Pointer-Analysis-in-this-course\"><a href=\"#Pointer-Analysis-in-this-course\" class=\"headerlink\" title=\"Pointer Analysis in this course\"></a>Pointer Analysis in this course</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820001351612.png\" alt=\"image-20230820001351612\"></p>\n<p>目前没有研究说 Context-sensitive比Context-insensitive不好</p>\n<p>先学Flow-insensitive，再学Flow-sensitive</p>\n<p>Whole-program可以分析完所有的程序，适用于各种需求</p>\n<h2 id=\"Concerned-Statements\"><a href=\"#Concerned-Statements\" class=\"headerlink\" title=\"Concerned Statements\"></a>Concerned Statements</h2><p>指针分析只关注影响指针指向的语句</p>\n<h3 id=\"Pointers-in-Java\"><a href=\"#Pointers-in-Java\" class=\"headerlink\" title=\"Pointers in Java\"></a>Pointers in Java</h3><p>会local variable，就会Static field</p>\n<p>会Instance field 就会Array element</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820014739396.png\" alt=\"image-20230820014739396\"></p>\n<ul>\n<li><p>本地变量</p>\n</li>\n<li><p>Static field：C.f  \t</p>\n</li>\n<li><p>Instance field：x.f   x指向的对象有一个field f</p>\n</li>\n<li><p>Array element：arrary[i] 用一个field 建模数组，可以指向存储在数组中的任何值</p>\n</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820014701202.png\" alt=\"image-20230820014701202\"></p>\n<h3 id=\"Pointer-Affecting-Statements\"><a href=\"#Pointer-Affecting-Statements\" class=\"headerlink\" title=\"Pointer-Affecting Statements\"></a>Pointer-Affecting Statements</h3><p>只需要关注下面这5种语句，对于很长的语句，简化成3AC</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820015155573.png\" alt=\"image-20230820015155573\"></p>\n<p>focus  virtual call</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820015214325.png\" alt=\"image-20230820015214325\"></p>\n<h1 id=\"Pointer-Analysis-Foundations-（I）\"><a href=\"#Pointer-Analysis-Foundations-（I）\" class=\"headerlink\" title=\"Pointer Analysis Foundations （I）\"></a>Pointer Analysis Foundations （I）</h1><h2 id=\"Point-Analysis-Rules\"><a href=\"#Point-Analysis-Rules\" class=\"headerlink\" title=\"Point Analysis: Rules\"></a>Point Analysis: Rules</h2><h3 id=\"Domains-and-Notations\"><a href=\"#Domains-and-Notations\" class=\"headerlink\" title=\"Domains and Notations\"></a>Domains and Notations</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820020740779.png\" alt=\"image-20230820020740779\"></p>\n<p>Points-to relations：理解为一个map</p>\n<p>Key 就是指针  value是相应指针的指针集</p>\n<h5 id=\"Rules\"><a href=\"#Rules\" class=\"headerlink\" title=\"Rules\"></a>Rules</h5><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820021340002.png\" alt=\"image-20230820021340002\"></p>\n<p>横线上面的是条件，下面的是结论</p>\n<p><strong>New</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820021330728.png\" alt=\"image-20230820021330728\"></p>\n<ul>\n<li>用oi表示创建出来的对象，所以让x指向oi，就是把pi加到x的指针集中</li>\n</ul>\n<p><strong>Assign</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820021826727.png\" alt=\"image-20230820021826727\"></p>\n<ul>\n<li>y指向一个对象，要让x也指向这个</li>\n</ul>\n<p><strong>Store</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820022029401.png\" alt=\"image-20230820022029401\"></p>\n<ul>\n<li>如果x指向oi，y指向oj，就让oi.f指向oj，也就是把oj加到oi.f的指针集中</li>\n</ul>\n<p><strong>Load</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820022635029.png\" alt=\"image-20230820022635029\"></p>\n<p>x指向oi，oi的f执行oj，那就让y也指向oj</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820023242087.png\" alt=\"image-20230820023242087\"></p>\n<h2 id=\"How-to-Implement-Pointer-Analysis\"><a href=\"#How-to-Implement-Pointer-Analysis\" class=\"headerlink\" title=\"How to Implement Pointer Analysis\"></a>How to Implement Pointer Analysis</h2><p>指针分析的关键：当pt(x)变化时，把这种变化传播给x的相关指针</p>\n<p>解决方式：</p>\n<ul>\n<li>用graph去连接相关的指针</li>\n<li>当Pt(x)改变时，把指针变化的部分传播到 x的后继</li>\n</ul>\n<h3 id=\"Pointer-Flow-Graph-PFG\"><a href=\"#Pointer-Flow-Graph-PFG\" class=\"headerlink\" title=\"Pointer Flow Graph(PFG)\"></a>Pointer Flow Graph(PFG)</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820225301480.png\" alt=\"image-20230820225301480\"></p>\n<ul>\n<li>一个节点n代表一个变量，或者是一个抽象对象的field</li>\n<li>一条边x–&gt;y，意味着x的指向可能(may analysis)流到y的指向</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820225511750.png\" alt=\"image-20230820225511750\"></p>\n<p>这个图中PFG Edges中的&lt;-，表示流动，意思是y的指针流到x</p>\n<h3 id=\"PFG-Examples\"><a href=\"#PFG-Examples\" class=\"headerlink\" title=\"PFG Examples\"></a>PFG Examples</h3><p>根据左边的program，得到右边的图</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820230328608.png\" alt=\"image-20230820230328608\"></p>\n<p><strong>问题：下图中蓝色圈中为什么不能是c.f?</strong></p>\n<p>c.f只是一个指针表达式，真正的指针是抽象创建点</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820230556062.png\" alt=\"image-20230820230556062\"></p>\n<p>假设现在有一个新的表达式，创建点是j，那么最终会从b一直流到a和e</p>\n<h3 id=\"Implementing-Pointer-Analysis\"><a href=\"#Implementing-Pointer-Analysis\" class=\"headerlink\" title=\"Implementing Pointer Analysis\"></a>Implementing Pointer Analysis</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820231347283.png\" alt=\"image-20230820231347283\"></p>\n<p>PFG和指针信息相互依存</p>\n<p>指针分析得到的信息越多，PFG中的边也会越多，也会让指针分析的信息更多</p>\n<ul>\n<li>这里我理解会根据左边红色的构建PFG，然后还是假设b点有个指针集pt(b)&#x3D;{oj}，它也需要根据新构建出来的边，继续流动</li>\n</ul>\n<h2 id=\"Pointer-Analysis：Algorithms\"><a href=\"#Pointer-Analysis：Algorithms\" class=\"headerlink\" title=\"Pointer Analysis：Algorithms\"></a>Pointer Analysis：Algorithms</h2><h3 id=\"Algorithms\"><a href=\"#Algorithms\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821020218449.png\" alt=\"image-20230821020218449\"></p>\n<h4 id=\"Worklist\"><a href=\"#Worklist\" class=\"headerlink\" title=\"Worklist\"></a>Worklist</h4><p>WL：work list存储要处理的信息，里面是一个个的pair</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820233036780.png\" alt=\"image-20230820233036780\"></p>\n<ul>\n<li>oi要被加入到x的指针集中</li>\n</ul>\n<h4 id=\"Handling-of-New-and-Assign\"><a href=\"#Handling-of-New-and-Assign\" class=\"headerlink\" title=\"Handling of New and Assign\"></a>Handling of New and Assign</h4><p>先处理 new和 assign</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820234444850.png\" alt=\"image-20230820234444850\"></p>\n<p><strong>第一步：加边</strong></p>\n<p>看红色部分</p>\n<p>首先对于 x &#x3D; new T()</p>\n<p>​\t- 那就是把oi，加入到x的指针集中</p>\n<p>对于 x &#x3D; y</p>\n<ul>\n<li>调用AddEdge函数，如果s -&gt; t不属于PFG，就在PFG上加一条边，注意这里的边是流向，而不是指向</li>\n<li>如果pt(s)不等于空，那也就是会流向t，也就是需要在t中，添加s的指针集，让t指向所有s能指向的地方</li>\n</ul>\n<p><strong>第二步：处理worklist</strong></p>\n<p>看上面算法的第二部分</p>\n<p>首先会做一个减法，也就是本来已经有的就不用动，只添加一些新的</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821000638227.png\" alt=\"image-20230821000638227\"></p>\n<p>然后进行propogate</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230820235905992.png\" alt=\"image-20230820235905992\"></p>\n<p>圆圈1真正对指针集 进行了修改，把去重后的加入到n的指针集合中。</p>\n<p>此时对PFG进行遍历，找出n的所有后继节点s（也就是之后n会流向的地方），同样把&lt;s，pts&gt;加入到worklist中，后续进行处理，修改他们的指针集</p>\n<p>Differential Propagation</p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821002915288.png\" alt=\"image-20230821002915288\"></p>\n<ul>\n<li>减少集合的操作量，如果在c处就算出来了，就不用之后每一步都算了</li>\n</ul>\n<h4 id=\"Handling-of-Store-and-load\"><a href=\"#Handling-of-Store-and-load\" class=\"headerlink\" title=\"Handling of Store and load\"></a>Handling of Store and load</h4><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821013103213.png\" alt=\"image-20230821013103213\"></p>\n<p>if n represents a variable x 这句我没理解</p>\n<p>如果对于每个oi，有x.f &#x3D; y 或者 y &#x3D; x.f的语句，就加对应的边，和上面一样</p>\n<h3 id=\"Algorithms-Review\"><a href=\"#Algorithms-Review\" class=\"headerlink\" title=\"Algorithms Review\"></a>Algorithms Review</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821014443700.png\" alt=\"image-20230821014443700\"></p>\n<ul>\n<li>算法的本质是在修改指针集，和addedge</li>\n<li>两个是相辅相成的，待处理的会放到WL中</li>\n</ul>\n<h3 id=\"An-Example-2\"><a href=\"#An-Example-2\" class=\"headerlink\" title=\"An Example\"></a>An Example</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821020036897.png\" alt=\"image-20230821020036897\"></p>\n<p>用流不敏感来处理</p>\n<ol>\n<li>从new开始处理</li>\n<li>处理 x &#x3D; y的情况</li>\n<li>处理WL</li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821020127052.png\" alt=\"image-20230821020127052\"></p>\n<h2 id=\"Pointer-Analysis-with-Method-Calls\"><a href=\"#Pointer-Analysis-with-Method-Calls\" class=\"headerlink\" title=\"Pointer Analysis with Method Calls\"></a>Pointer Analysis with Method Calls</h2><p>以前是根据CHA建call graph,那是会有假边</p>\n<p>现在根据指针分析来建call graph</p>\n<h3 id=\"Rule\"><a href=\"#Rule\" class=\"headerlink\" title=\"Rule\"></a>Rule</h3><p><strong>jvm在进行方法调用的时候，做的4件事</strong></p>\n<ol>\n<li><p>Dispatch</p>\n</li>\n<li><p>Received Object</p>\n</li>\n<li><p>参数</p>\n</li>\n<li><p>返回值</p>\n</li>\n</ol>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230821215430336.png\" alt=\"image-20230821215430336\"></p>\n<ol>\n<li><p>首先x指向oi 调用点接着对oi和k进行Dispatch，目标是找到要调用的方法</p>\n</li>\n<li><p>找到后，让oi 指向$pt(m_{this})$,也就是传receive object</p>\n</li>\n<li><p>传参数 也就是把形参aj传给 $m_{pj}$（当前变量中的pj参数）</p>\n</li>\n<li><p>传返回值，把$m_{ret}$传递给r</p>\n</li>\n</ol>\n<p><strong>问题：为什么不在x和this之间连一条边？(也就是黑色虚线为啥不是实线)</strong></p>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230822010231414.png\" alt=\"image-20230822010231414\"></p>\n<ul>\n<li>假设x的指针集中  A B C三个调用点，且A B C三个类满足继承关系，那如果存在边，就会流过去，这也就让每个this的指针集中包括了{new A new B new C}，这显然是不合理的，每个类的this应该只有自己的类</li>\n</ul>\n<p>在每次算法执行时，oi是确定的某个对象(唯一的，只有一个)，然后针对这个对象做Dispatch，能够找到唯一的receive object</p>\n<h3 id=\"Interprocedural-Pointer-Analysis\"><a href=\"#Interprocedural-Pointer-Analysis\" class=\"headerlink\" title=\"Interprocedural Pointer Analysis\"></a>Interprocedural Pointer Analysis</h3><h3 id=\"Algorithms-1\"><a href=\"#Algorithms-1\" class=\"headerlink\" title=\"Algorithms\"></a>Algorithms</h3><p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230822055356299.png\" alt=\"image-20230822055356299\"></p>\n<p>RM：reachable methods 可达的方法 </p>\n<p>S: S是RM方法中的语句</p>\n<p>CG：call graph的边</p>\n<p>AddReachable：把新的方法加入到可达的世界中</p>\n<p><strong>AddReachable啥时候被调用？</strong></p>\n<ul>\n<li>entry方法是一开始的，肯定是可达，调用</li>\n<li>发现新的调用边的时候</li>\n</ul>\n<p><img src=\"/../%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/image-20230822055100882.png\" alt=\"image-20230822055100882\"></p>\n<ul>\n<li>前面两行就是把新的方法加入到S集合中</li>\n</ul>\n<p><strong>ProcessCall：就是在做上面那4件事</strong></p>\n","text":"Programming Languages(PL) 在运行程序前，分析程序可能有的问题 静态分析是在编译时，在程序运行之前，判断一个程序是否满足一些性质 对于这些interesting proverties，比如是否有空指针，是不能直接被给出准确的答案的 sound包括truth...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Programming-Languages-PL\"><span class=\"toc-text\">Programming Languages(PL)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#intermediate-representation\"><span class=\"toc-text\">intermediate representation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Compiler\"><span class=\"toc-text\">Compiler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AST-vs-IR\"><span class=\"toc-text\">AST vs IR</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IR-3AC\"><span class=\"toc-text\">IR:3AC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3AC-in-real-static-Analyzer-Soot\"><span class=\"toc-text\">3AC in real static Analyzer Soot</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jvm%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%EF%BC%88PL%EF%BC%89\"><span class=\"toc-text\">jvm中的方法调用:（PL）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Static-Single-Assignment-SSA%EF%BC%89%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">Static Single Assignment(SSA）静态单赋值</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Control-Flow-Analysis\"><span class=\"toc-text\">Control Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Basic-Blocks\"><span class=\"toc-text\">Basic Blocks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BAnode\"><span class=\"toc-text\">构建node</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E8%BE%B9\"><span class=\"toc-text\">构建边</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BACFG\"><span class=\"toc-text\">构建CFG</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analisis\"><span class=\"toc-text\">Data Flow Analisis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Overview-of-Data-Flow-Analysis\"><span class=\"toc-text\">Overview of Data Flow Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Preliminaries-of-Data-Flow-Analysis\"><span class=\"toc-text\">Preliminaries of Data Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Input-and-Output-States\"><span class=\"toc-text\">Input and Output States</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">关于转移方程约束的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">关于控制流约束的概念</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Applications\"><span class=\"toc-text\">Data Flow Analysis Applications</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">不会涉及到的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reaching-Definitions-Analysis\"><span class=\"toc-text\">Reaching Definitions Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Input-and-Output-States-1\"><span class=\"toc-text\">Input and Output States</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function\"><span class=\"toc-text\">Transer function</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3Reaching-Definitions-%E5%88%B0%E8%BE%BE%E5%AE%9A%E5%80%BC\"><span class=\"toc-text\">理解Reaching Definitions(到达定值)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction-%E7%94%A8Di%E8%BF%9B%E8%A1%8C%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">Abstraction(用Di进行抽象)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Control-Flow\"><span class=\"toc-text\">Control Flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Algorithm-of-Reaching-Definition-Analysis\"><span class=\"toc-text\">Algorithm of Reaching Definition Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Live-Variables-Analysis%EF%BC%88%E6%B4%BB%E8%B7%83%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%89\"><span class=\"toc-text\">Live Variables Analysis（活跃变量分析）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction\"><span class=\"toc-text\">Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Control-flow\"><span class=\"toc-text\">Control flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function-1\"><span class=\"toc-text\">Transer function</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Alogrithm-of-live-variables-Analysis\"><span class=\"toc-text\">Alogrithm of live variables Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Available-Expressions-Analysis\"><span class=\"toc-text\">Available Expressions Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Abstraction-1\"><span class=\"toc-text\">Abstraction</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Transer-function-Control-flow\"><span class=\"toc-text\">Transer function &amp; Control flow</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Alogrithm-of-Available-Expressions-Analysis\"><span class=\"toc-text\">Alogrithm of Available Expressions Analysis</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Analysis-Comparison\"><span class=\"toc-text\">Analysis Comparison</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Foundations\"><span class=\"toc-text\">Data Flow Analysis Foundations</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iterative-algorithms%EF%BC%88%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">iterative algorithms（迭代算法）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#view-itrative-algorithm-in-another-way\"><span class=\"toc-text\">view itrative algorithm in another way</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E7%A4%BA%E5%BD%A2%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">图示形式：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%9D%A5%E4%BA%86\"><span class=\"toc-text\">问题来了</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#partial-order%EF%BC%88%E5%81%8F%E5%BA%8F%EF%BC%89\"><span class=\"toc-text\">partial order（偏序）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Upper-and-Lower-Bounds-%E4%B8%8A%E4%B8%8B%E7%95%8C\"><span class=\"toc-text\">Upper and Lower Bounds(上下界)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Some-Properties\"><span class=\"toc-text\">Some  Properties</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lattice\"><span class=\"toc-text\">Lattice</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Complete-Lattice\"><span class=\"toc-text\">Complete Lattice</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Product-Lattice\"><span class=\"toc-text\">Product Lattice</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Framework-via-Lattice\"><span class=\"toc-text\">Data Flow Analysis Framework via Lattice</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Monotonicity%EF%BC%88%E5%8D%95%E8%B0%83%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">Monotonicity（单调性）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fixed-Point-Theorem-%E4%B8%8D%E5%8A%A8%E7%82%B9%E5%AE%9A%E7%90%86\"><span class=\"toc-text\">Fixed-Point Theorem(不动点定理)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%81%E6%98%8E%E4%B8%8D%E5%8A%A8%E7%82%B9\"><span class=\"toc-text\">证明不动点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Existence-of-Fixed-Point\"><span class=\"toc-text\">Existence of Fixed Point</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Least-Fixed-Point\"><span class=\"toc-text\">Least Fixed Point</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Flow-Analysis-Foundations-II\"><span class=\"toc-text\">Data Flow Analysis Foundations II</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Relate-Iterative-Algorithm-to-Fix-ed-Point-Theorem\"><span class=\"toc-text\">Relate Iterative Algorithm to Fix-ed Point Theorem</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Review-the-questions\"><span class=\"toc-text\">Review the questions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#When-will-the-algorithm-reach-the-fixed-point%EF%BC%9F\"><span class=\"toc-text\">When will the algorithm reach the fixed point？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#May-and-Must-Analysis-a-Lattice-View\"><span class=\"toc-text\">May and Must Analysis , a Lattice View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#May-Analysis-View\"><span class=\"toc-text\">May  Analysis View</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Must-Analysis-View\"><span class=\"toc-text\">Must Analysis View</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-Precise-is-our-Solution\"><span class=\"toc-text\">How Precise is our Solution</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Meet-Over-All-Paths-Solution-MOP\"><span class=\"toc-text\">Meet-Over-All-Paths Solution(MOP)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ours-iterative-Algorithm-vs-MOP\"><span class=\"toc-text\">Ours(iterative Algorithm) vs MOP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Emust-analysis-%E8%BF%98%E6%98%AF-may-analysis%E7%9A%84%E5%88%86%E6%9E%90\"><span class=\"toc-text\">关于must analysis 还是 may analysis的分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reaching-definitons\"><span class=\"toc-text\">Reaching definitons</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#live-avaliables\"><span class=\"toc-text\">live avaliables</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#avaliable-expressions\"><span class=\"toc-text\">avaliable expressions</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Constant-Propagation\"><span class=\"toc-text\">Constant Propagation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Transfer-function\"><span class=\"toc-text\">Transfer function</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFNondistributivity\"><span class=\"toc-text\">为什么是Nondistributivity</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Worklist-Algorithm\"><span class=\"toc-text\">Worklist Algorithm</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Interprocedural-Analysis\"><span class=\"toc-text\">Interprocedural Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Motivation%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%87%E7%A8%8B%E9%97%B4%E5%88%86%E6%9E%90%E5%91%A2%EF%BC%89\"><span class=\"toc-text\">Motivation（为什么需要过程间分析呢）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Call-Graph-Construction\"><span class=\"toc-text\">Call Graph Construction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph\"><span class=\"toc-text\">Call Graph</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph-Construction-for-OOPLS%EF%BC%88focus-on-java%EF%BC%89\"><span class=\"toc-text\">Call Graph Construction for OOPLS（focus on java）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Method-Calls-Invocation-in-Java\"><span class=\"toc-text\">Method Calls(Invocation) in Java</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Method-Dispatch-of-Virtual-Calls\"><span class=\"toc-text\">Method Dispatch of Virtual Calls</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example\"><span class=\"toc-text\">An Example</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Class-Hierarchy-Analysis-CHA\"><span class=\"toc-text\">Class Hierarchy Analysis(CHA)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Resolution-of-CHA\"><span class=\"toc-text\">Call Resolution of CHA</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#static-call\"><span class=\"toc-text\">static call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#special-call\"><span class=\"toc-text\">special call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#virtual-call\"><span class=\"toc-text\">virtual call</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#An-example\"><span class=\"toc-text\">An example</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Features-of-CHA\"><span class=\"toc-text\">Features of CHA</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Call-Graph-Construction-Algorithm\"><span class=\"toc-text\">Call Graph Construction -&gt; Algorithm</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-1\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interprocedural-Control-Flow-Graph\"><span class=\"toc-text\">Interprocedural Control-Flow Graph</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-example-1\"><span class=\"toc-text\">An example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Interprocedural-Data-Flow-Analysis\"><span class=\"toc-text\">Interprocedural Data-Flow Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interprocedural-Contant-Propagation\"><span class=\"toc-text\">Interprocedural Contant Propagation</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis\"><span class=\"toc-text\">Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Problem-of-CHA\"><span class=\"toc-text\">Problem of CHA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-1\"><span class=\"toc-text\">Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Example\"><span class=\"toc-text\">Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-and-alias-Analysis%EF%BC%88%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90%EF%BC%89\"><span class=\"toc-text\">Pointer Analysis and alias Analysis（别名分析）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Application-of-Pointer-Analysis\"><span class=\"toc-text\">Application of Pointer Analysis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Key-Factors-in-Pointer-Analysis\"><span class=\"toc-text\">Key Factors in Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Heap-abstraction\"><span class=\"toc-text\">Heap abstraction</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Allocation-Site-Abstraction\"><span class=\"toc-text\">Allocation-Site Abstraction</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Context-Sensitivity-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%95%8F%E6%84%9F\"><span class=\"toc-text\">Context Sensitivity(上下文敏感 )</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Flow-sensitivity\"><span class=\"toc-text\">Flow sensitivity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Analysis-Scope\"><span class=\"toc-text\">Analysis Scope</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Analysis-in-this-course\"><span class=\"toc-text\">Pointer Analysis in this course</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Concerned-Statements\"><span class=\"toc-text\">Concerned Statements</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointers-in-Java\"><span class=\"toc-text\">Pointers in Java</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Affecting-Statements\"><span class=\"toc-text\">Pointer-Affecting Statements</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pointer-Analysis-Foundations-%EF%BC%88I%EF%BC%89\"><span class=\"toc-text\">Pointer Analysis Foundations （I）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Point-Analysis-Rules\"><span class=\"toc-text\">Point Analysis: Rules</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Domains-and-Notations\"><span class=\"toc-text\">Domains and Notations</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Rules\"><span class=\"toc-text\">Rules</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-to-Implement-Pointer-Analysis\"><span class=\"toc-text\">How to Implement Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pointer-Flow-Graph-PFG\"><span class=\"toc-text\">Pointer Flow Graph(PFG)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PFG-Examples\"><span class=\"toc-text\">PFG Examples</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Implementing-Pointer-Analysis\"><span class=\"toc-text\">Implementing Pointer Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis%EF%BC%9AAlgorithms\"><span class=\"toc-text\">Pointer Analysis：Algorithms</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms\"><span class=\"toc-text\">Algorithms</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Worklist\"><span class=\"toc-text\">Worklist</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Handling-of-New-and-Assign\"><span class=\"toc-text\">Handling of New and Assign</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Handling-of-Store-and-load\"><span class=\"toc-text\">Handling of Store and load</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms-Review\"><span class=\"toc-text\">Algorithms Review</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#An-Example-2\"><span class=\"toc-text\">An Example</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pointer-Analysis-with-Method-Calls\"><span class=\"toc-text\">Pointer Analysis with Method Calls</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rule\"><span class=\"toc-text\">Rule</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Interprocedural-Pointer-Analysis\"><span class=\"toc-text\">Interprocedural Pointer Analysis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Algorithms-1\"><span class=\"toc-text\">Algorithms</span></a></li></ol></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"java反序列化","uid":"7873af0b12d3f7cc53b7d970bb6378b1","slug":"java反序列化","date":"2023-08-07T02:18:56.000Z","updated":"2023-09-04T15:00:34.901Z","comments":true,"path":"api/articles/java反序列化.json","keywords":null,"cover":[],"text":"java序列化和反序列化 Click to see more public class Animal &#123; private String color; public Animal() &#123;//没有无参构造将会报错 System.out.println(\"调用 An...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"fuzz","uid":"495070cda26bf6060daf4768027efb5d","slug":"fuzz","date":"2023-08-06T08:25:10.000Z","updated":"2023-08-06T08:25:10.674Z","comments":true,"path":"api/articles/fuzz.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}