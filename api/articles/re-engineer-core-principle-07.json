{"title":"re-engineer-core-principle-07","uid":"ad9b5bba7260fe69f150a16ce9de4386","slug":"re-engineer-core-principle-07","date":"2024-01-30T14:45:03.000Z","updated":"2024-02-28T14:46:10.615Z","comments":true,"path":"api/articles/re-engineer-core-principle-07.json","keywords":null,"cover":[],"content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>终于到第七部分了，快看完了</li>\n</ul>\n<h1 id=\"0x50-反调试技术\"><a href=\"#0x50-反调试技术\" class=\"headerlink\" title=\"0x50 反调试技术\"></a>0x50 反调试技术</h1><h2 id=\"50-1-反调试技术\"><a href=\"#50-1-反调试技术\" class=\"headerlink\" title=\"50.1 反调试技术\"></a>50.1 反调试技术</h2><ul>\n<li>反调试技术有很强的依赖性。有些反调试技术仅在特定版本的os下工作</li>\n<li>本章的大部分技术可以用在Windows XP SP3(32位)和Win7 32位下</li>\n</ul>\n<h2 id=\"50-3-反调试技术分类\"><a href=\"#50-3-反调试技术分类\" class=\"headerlink\" title=\"50.3 反调试技术分类\"></a>50.3 反调试技术分类</h2><ul>\n<li><p>根据破解方法分成静态和动态两组</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126134751365.png\" alt=\"image-20240126134751365\"></p>\n</li>\n</ul>\n<h3 id=\"静态反调试\"><a href=\"#静态反调试\" class=\"headerlink\" title=\"静态反调试\"></a>静态反调试</h3><ul>\n<li>主要就是探测调试器，如果探测到，就让恒旭无法运行</li>\n</ul>\n<h3 id=\"动态反调试\"><a href=\"#动态反调试\" class=\"headerlink\" title=\"动态反调试\"></a>动态反调试</h3><ul>\n<li>在破解了静态反调试之后，想了解程序的工作原理，需要动态调试，查看程序的代码和数据</li>\n<li>但是如果程序中应用了动态反调试，很难再使用调试器的跟踪技术，动态反调试器会扰乱调试器跟踪的功能，让我们无法查看代码和数据</li>\n</ul>\n<h1 id=\"0x51-静态反调试技术\"><a href=\"#0x51-静态反调试技术\" class=\"headerlink\" title=\"0x51 静态反调试技术\"></a>0x51 静态反调试技术</h1><p><strong>Q：为啥要用静态反调试</strong></p>\n<ul>\n<li>就是不让我正常运行代码</li>\n</ul>\n<h2 id=\"51-2-PEB\"><a href=\"#51-2-PEB\" class=\"headerlink\" title=\"51.2 PEB\"></a>51.2 PEB</h2><ul>\n<li>利用PEB结构体信息，可以查看当前进程是否处于被调试状态。这个前面学过，就用它的BeingDebugged</li>\n</ul>\n<p><strong>Q：反调试中用到的PEB结构体成员</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126135340977.png\" alt=\"image-20240126135340977\"></p>\n<h3 id=\"BeingDebugged\"><a href=\"#BeingDebugged\" class=\"headerlink\" title=\"BeingDebugged\"></a>BeingDebugged</h3><ul>\n<li>进程处于被调试状态时，PEB.BeingDebugged的值是1。</li>\n</ul>\n<p><strong>Q：IsDebuggerPresent() API</strong></p>\n<ul>\n<li><p>这个前面也学过，他就是调用了PEB.BeingDebugged</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126135546712.png\" alt=\"image-20240126135546712\"></p>\n</li>\n<li><p>获取TEB，获取PEB，再获取IsDebugged。</p>\n</li>\n</ul>\n<p><strong>Q：破解之法</strong></p>\n<ul>\n<li>借助Ollydbg的调试功能，把IsDebugged设置成0</li>\n</ul>\n<h3 id=\"Ldr-0xC\"><a href=\"#Ldr-0xC\" class=\"headerlink\" title=\"Ldr(+0xC)\"></a>Ldr(+0xC)</h3><ul>\n<li><p>调试进程时，其堆内存区域会出现一些特殊标识，表示它正处在被调试状态。</p>\n<ul>\n<li>未使用的堆内存区域全部填充着0xFEEEFEEE，这证明正在调试进程。</li>\n</ul>\n</li>\n<li><p>PEB.ldr是一个指向_PEB_LDR_DATA结构体的指针， _PEB_LDR_DATA结构体恰好是在堆内存中创建的，所以扫描堆区就可以看到是不是有0xFEEEFEEE</p>\n</li>\n<li><p>PEB的起始地址是2F0000，Ldr的地址是 77E2DB00</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126140305960.png\" alt=\"image-20240126140305960\"></p>\n<p><strong>Q：破解之法</strong></p>\n<ul>\n<li>把0xFEEEFEEE全部变成null</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>这种方法在win11中是没用的</p>\n\n</div>\n<h3 id=\"Process-Heap-0x18\"><a href=\"#Process-Heap-0x18\" class=\"headerlink\" title=\"Process Heap(+0x18)\"></a>Process Heap(+0x18)</h3><ul>\n<li><p>PEB.ProcessHeap是指向HEAP结构体的指针，地址是00490000</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126141451210.png\" alt=\"image-20240126141451210\"></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126141019137.png\" alt=\"image-20240126141019137\"></p>\n</li>\n<li><p>当进程处于被调试状态时，FLags和ForceFlags会被设定为特定值</p>\n</li>\n</ul>\n<p><strong>Q：GetProcessHeap()</strong></p>\n<ul>\n<li>ProcessHeap可以通过PEB直接获取，也可以通过这个API获取</li>\n<li>这个API也和上面的IsDebuggerPresent() API一样<ul>\n<li>TEB —&gt; PEB —&gt; ProcessHeap</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：Flags 0xC &amp; ForceFlags 0x10</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126141636320.png\" alt=\"image-20240126141636320\"></p>\n<ul>\n<li>进程正常运行时，Flags的值为0x2，ForceFlags的值是0x0</li>\n</ul>\n<p><strong>Q：破解</strong></p>\n<ul>\n<li>就改成正常值</li>\n</ul>\n<h3 id=\"NtGlobalFlag-0x68\"><a href=\"#NtGlobalFlag-0x68\" class=\"headerlink\" title=\"NtGlobalFlag(+0x68)\"></a>NtGlobalFlag(+0x68)</h3><ul>\n<li><p>调试进程时，PEB.NtGlobalFlag的值会被设置为0x70。所以可以检测这个值</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126142104232.png\" alt=\"image-20240126142104232\"></p>\n</li>\n<li><p>破解的时候，把它修改成0</p>\n</li>\n<li><p><strong>这个在win11也没用</strong></p>\n</li>\n</ul>\n<h3 id=\"练习-StaAd-PEB-exe\"><a href=\"#练习-StaAd-PEB-exe\" class=\"headerlink\" title=\"练习 StaAd_PEB.exe\"></a>练习 StaAd_PEB.exe</h3><ul>\n<li><p>运行这个进程后，显示</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126142327785.png\" alt=\"image-20240126142327785\"></p>\n</li>\n</ul>\n<p><strong>Q：按照上面学的，逐步破解</strong></p>\n<ul>\n<li><p>在遇到第一个调用IsDebuggerPresent() API后，把参数值改一下，此时函数返回值就是0了</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126143500859.png\" alt=\"image-20240126143500859\"></p>\n</li>\n</ul>\n<p><strong>这个等会调试</strong></p>\n<h2 id=\"51-3-NtQueryInformationProcess\"><a href=\"#51-3-NtQueryInformationProcess\" class=\"headerlink\" title=\"51.3 NtQueryInformationProcess()\"></a>51.3 NtQueryInformationProcess()</h2><ul>\n<li><p>另一种利用NtQueryInformationProcess() API探测调试器。这个API可以获得各种和进程调试相关的信息</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126144042167.png\" alt=\"image-20240126144042167\"></p>\n</li>\n<li><p>给这个函数的第二个参数PROCESSINFOCLASS processInformationClass指定特定值，并调用该函数，相关信息就会设置到第三个参数PVOID ProcessInformation中。</p>\n</li>\n<li><p>PROCESSINFOCLASS 是枚举类型，可以拥有下面这些值，重点看红框中的</p>\n</li>\n</ul>\n<p>  <img src=\"/../re-engineer-core-principle-07/image-20240126144237472.png\" alt=\"image-20240126144237472\"></p>\n<h3 id=\"ProcessDebugPort\"><a href=\"#ProcessDebugPort\" class=\"headerlink\" title=\"ProcessDebugPort\"></a>ProcessDebugPort</h3><ul>\n<li><p>进程处于调试状态时，系统会给它分配一个调试端口(Debug Port)。</p>\n</li>\n<li><p>ProcessInformationClass参数的值设置为ProcessDebugPort时，调用NtQueryInformationProcess()函数可以获取调试端口</p>\n</li>\n<li><p>如果处于非调试状态，那么变量dwDebugPort的值是0。如果处在调试状态，变量的值就是0xFFFFFFFF。</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126144713523.png\" alt=\"image-20240126144713523\"></p>\n</li>\n<li><p>也就是我给第二个枚举类型的参数设置成ProcessDebugPort，运行之后的相关信息就会放到第三个参数dwDebugPort中，以此来观察进程是否在调试状态</p>\n</li>\n</ul>\n<p><strong>Q：CheckRemoteDebuggerPresent()</strong></p>\n<ul>\n<li><p>它和IsDebuggerPresent() API类似，可以检测进程是不是在调试状态，</p>\n</li>\n<li><p>它除了可以检测当前进程，也可以检测其他进程。</p>\n</li>\n<li><p>发现这个进程内部嗲用了NtQueryInformationClass API</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126144935261.png\" alt=\"image-20240126144935261\"></p>\n</li>\n</ul>\n<h3 id=\"ProcessDebugObjectHandle-0x1E\"><a href=\"#ProcessDebugObjectHandle-0x1E\" class=\"headerlink\" title=\"ProcessDebugObjectHandle(0x1E)\"></a>ProcessDebugObjectHandle(0x1E)</h3><ul>\n<li><p>调试进程时会生成调试对象。</p>\n</li>\n<li><p>也就是设置第二个参数的值是0x1E ProcessDebugObjectHandle时，调用后第三个参数就能获得调试对象的句柄。</p>\n</li>\n<li><p>进程处于调试状态时，调试对象句柄的值就存在。如果出于非调试状态，调试对象句柄的值是NULL。</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126145146604.png\" alt=\"image-20240126145146604\"></p>\n</li>\n</ul>\n<h3 id=\"ProcessDebugFlags-0x1F\"><a href=\"#ProcessDebugFlags-0x1F\" class=\"headerlink\" title=\"ProcessDebugFlags(0x1F)\"></a>ProcessDebugFlags(0x1F)</h3><ul>\n<li><p>DebugFLags的值也可以判断进程是不是在被调试状态</p>\n</li>\n<li><p>设置NtQuertInformationProcess()的值是0x1F，调用函数之后通过第三个参数即可获取调试标志的值。</p>\n</li>\n<li><p>如果是0表示处于被调试状态，是1，表示不在调试状态</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126145553390.png\" alt=\"image-20240126145553390\"></p>\n</li>\n</ul>\n<h3 id=\"练习-StaAD-NtQIP-exe\"><a href=\"#练习-StaAD-NtQIP-exe\" class=\"headerlink\" title=\"练习 StaAD_NtQIP.exe\"></a>练习 StaAD_NtQIP.exe</h3><ul>\n<li><p>以管理员运行ollydbg，在ollydbg中打开StaAD_NtQIP.exe，之后f9运行</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126150151378.png\" alt=\"image-20240126150151378\"></p>\n</li>\n</ul>\n<h3 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h3><ul>\n<li>如果只是调用了几次API，那可以手动修改值，如果调用很多次，那就得用API钩取了</li>\n</ul>\n<p><strong>Q：确定钩取函数的位置</strong></p>\n<ul>\n<li><p>ImageBase是0040 0000, Section Alignment是1000</p>\n</li>\n<li><p>所以.text节区就是从00401000，到00407D69，从00407D6A到00408000都是null padding</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126165758574.png\" alt=\"image-20240126165758574\"></p>\n</li>\n<li><p>用dll注入钩取API时，钩取函数位于要注入的DLL文件内部。将钩取代码设置在最后一个null padding区域</p>\n</li>\n</ul>\n<p><strong>Q：使用5字节的代码修改</strong></p>\n<ul>\n<li><p>进入原来的NtQueryInformationProcess() API处，修改成JMP</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126171018900.png\" alt=\"image-20240126171018900\"></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126171105957.png\" alt=\"image-20240126171105957\"></p>\n</li>\n<li><p>正常的5字节代码修改，应该在API的开头修改成JMP，但是这里确在下面的位置修改，原因是：</p>\n<ul>\n<li>有些PE保护器会检测NtQueryInformationProcess()  API起始地址的第一个字节，如果不是B8，就认为这个API会被钩取</li>\n</ul>\n</li>\n</ul>\n<p><strong>Q：编写钩取函数</strong></p>\n<ul>\n<li>这个钩取函数首先调用原来的NtQueryInformationProcess() ，返回值也是原来的</li>\n<li>在中间加上类似于switch case的结构，如果ESp+c是 7，就表明是debugport，把对应的值改成0</li>\n<li>另两个也是同理。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126171942328.png\" alt=\"image-20240126171942328\"></p>\n<h2 id=\"51-4-NtQuerySystemInformation\"><a href=\"#51-4-NtQuerySystemInformation\" class=\"headerlink\" title=\"51.4 NtQuerySystemInformation()\"></a>51.4 NtQuerySystemInformation()</h2><ul>\n<li>基于调试环境检测的反调试技术</li>\n<li>前面是通过探测调试器来判断进程是否处于被调试状态。就说调用API</li>\n<li>也有一些间接探测调试器的方法。</li>\n<li>运用这种反调试技术可以检测当前os是否在调试模式下运行</li>\n</ul>\n<h3 id=\"使用windbg调试系统内核\"><a href=\"#使用windbg调试系统内核\" class=\"headerlink\" title=\"使用windbg调试系统内核\"></a>使用windbg调试系统内核</h3><p><strong>Q：ntdll!NtQuerySystemInformation() API</strong></p>\n<ul>\n<li><p>它是一个系统函数，用来获取当前运行的多种os信息</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126180817954.png\" alt=\"image-20240126180817954\"></p>\n</li>\n<li><p>SYSTEM_INFOAMTION_CLASS SystemInformationClass参数中指定需要的系统信息类型</p>\n</li>\n<li><p>将某结构体的地址传给PVOID SystemInformation参数，API返回时，这个结构体中填充着相关信息。</p>\n</li>\n<li><p>SYSTEM_INFOAMTION_CLASS是枚举类型</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126180936595.png\" alt=\"image-20240126180936595\"></p>\n</li>\n<li><p>像SystemInformationClass参数中传入0x23，就可以判断当前os是不是在调试模式下运行</p>\n</li>\n</ul>\n<h3 id=\"SystemKernelDebuggerInformation-0x23\"><a href=\"#SystemKernelDebuggerInformation-0x23\" class=\"headerlink\" title=\"SystemKernelDebuggerInformation(0x23)\"></a>SystemKernelDebuggerInformation(0x23)</h3><ul>\n<li><p>实际的反调试源代码</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126181044294.png\" alt=\"image-20240126181044294\"></p>\n</li>\n<li><p>这个代码很简单，定义了_SYSTEM_KERNEL_DEBUGGER_INFORMATION结构体，并且把DebuggerEnabled初始化为0</p>\n</li>\n<li><p>在调用NtQuerySystemInformation之后，如果处于调试状态，那么会修改debuggerInfo结构体的值，把DebuggerEnabled设置为1</p>\n</li>\n</ul>\n<h3 id=\"破解之法\"><a href=\"#破解之法\" class=\"headerlink\" title=\"破解之法\"></a>破解之法</h3><ul>\n<li>在Windows XP系统中编辑bootini文件，删除“&#x2F;debugport&#x3D;coml  &#x2F;baudrate&#x3D;115200&#x2F;Debug值。</li>\n<li>在Windows7系统的命令行窗口执行“bcdedit&#x2F;debugoft”命令即可。并且，若重启系统则要以正常模式(Normal Mode)启动。</li>\n</ul>\n<h2 id=\"51-5-NtQueryObject\"><a href=\"#51-5-NtQueryObject\" class=\"headerlink\" title=\"51.5 NtQueryObject()\"></a>51.5 NtQueryObject()</h2><ul>\n<li>系统中的某个调试器调试进程时，会创建一个调试对象类型的内核对象，</li>\n<li>我们可以检测该对象是否存在，就可以判断是否有进程正在调试</li>\n</ul>\n<p><strong>Q：NtQueryObject()  API</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126182206186.png\" alt=\"image-20240126182206186\"></p>\n<ul>\n<li><p>调用这个API时，先向第二个参数 OBJECT_INFORMATION_CLASS objectInformationClass赋予某个特定值，调用API后，包含相关信息的结构体指针就会返回第三个参数PVOID ObjectInformation</p>\n</li>\n<li><p>OBJECT_INFORMATION_CLASS objectInformationClass是枚举类型</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126182326129.png\" alt=\"image-20240126182326129\"></p>\n</li>\n<li><p>使用ObjectAllTypesInformation获取系统中所有对象的信息，检测里面是不是存在调试对象</p>\n</li>\n</ul>\n<p><strong>Q：NtQueryObject() API使用方法</strong></p>\n<ul>\n<li><p>获取内核对象信息链表的大小，传的是ObjectAllTypesInformation，lSize被赋值</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126182437122.png\" alt=\"image-20240126182437122\"></p>\n</li>\n<li><p>分配内存：分配lSize大小的内存</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126182514577.png\" alt=\"image-20240126182514577\"></p>\n</li>\n<li><p>获取内核对象信息链表</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126182547959.png\" alt=\"image-20240126182547959\"></p>\n<ul>\n<li>调用pNtQueryObject之后，获取所有对象的信息，并且存在pbuf中</li>\n<li>把pbuf转成 POBJECT_ALL_INFORMATION类型，OBJECT_ALL_INFORMATION里面包含OBJECT_TYPE_INFORMATION数组</li>\n<li>遍历这个数组，就可以知道是不是存在调试对象</li>\n</ul>\n</li>\n<li><p>确定调试对象的对象类型</p>\n<ul>\n<li>下面这个是整个过程的完整代码</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126183023398.png\" alt=\"image-20240126183023398\"></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126183030861.png\" alt=\"image-20240126183030861\"></p>\n</li>\n</ul>\n<h3 id=\"练习StaAD-NtQO-exe\"><a href=\"#练习StaAD-NtQO-exe\" class=\"headerlink\" title=\"练习StaAD_NtQO.exe\"></a>练习StaAD_NtQO.exe</h3><p><img src=\"/../re-engineer-core-principle-07/image-20240126183325252.png\" alt=\"image-20240126183325252\"></p>\n<ul>\n<li><p>调试StaAD_NtQO.exe，发现在调用ZwQueryObject处，参数是3，也就是要获取alltypesinformation，如果我改成0，让他变成basic information，就无法检测到调试器了</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126183609003.png\" alt=\"image-20240126183609003\"></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126183748897.png\" alt=\"image-20240126183748897\"></p>\n</li>\n</ul>\n<h2 id=\"51-6-ZwSetInformationThread\"><a href=\"#51-6-ZwSetInformationThread\" class=\"headerlink\" title=\"51.6 ZwSetInformationThread()\"></a>51.6 ZwSetInformationThread()</h2><ul>\n<li><p>这部分介绍的是强制分离(Detach）被调试者和调试器的技术。</p>\n</li>\n<li><p>利用ZwSetInformationThread() API，被调试者可以把自身从调试器中分离出来</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126184118790.png\" alt=\"image-20240126184118790\"></p>\n</li>\n<li><p>ZwSetInformationThread()函数是一个系统原生API(System Native API)，它是用来为线程设置信息的</p>\n</li>\n<li><p>这个函数有两个参数，第一个参数ThreadHandle用来接收当前线程的句柄，第二个参数ThreadInformationClass表示线程信息类型。</p>\n</li>\n<li><p>如果第二个参数被设置成了0x11，调用该函数后，调试进程就会被分离出来</p>\n<ul>\n<li>顾名思义，意思就是向debugger隐藏这个线程</li>\n</ul>\n</li>\n<li><p>ZwSetInformationThread()  API不会对正常运行的程序有任何影响，但如果运行的是调试器程序，调用这个API，就会让调试器终止运行，同时终止自身进程</p>\n</li>\n</ul>\n<h3 id=\"练习StaAD-ZwSIT-exe\"><a href=\"#练习StaAD-ZwSIT-exe\" class=\"headerlink\" title=\"练习StaAD_ZwSIT.exe\"></a>练习StaAD_ZwSIT.exe</h3><p><img src=\"/../re-engineer-core-principle-07/image-20240126185235228.png\" alt=\"image-20240126185235228\"></p>\n<h3 id=\"破解-1\"><a href=\"#破解-1\" class=\"headerlink\" title=\"破解\"></a>破解</h3><ul>\n<li>就是把它改成0就行了，当然也可以hook它</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>利用ZwSetInformationThread()进行反调试的工作原理是: 将线程隐藏起来，调试器就接收不到信息，从而无法调试。</p>\n<p>另外，Windows XP 以后新增了 DebugActive-ProcessStop()API。</p>\n</p>\n</div>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126185358134.png\" alt=\"image-20240126185358134\"></p>\n<ul>\n<li>这个API用来分离调试器和被调试进程，从而停止调试。</li>\n<li>前面的ZwSetInformationThread() API是用来隐藏线程的</li>\n</ul>\n<h2 id=\"51-7-TLS回调函数\"><a href=\"#51-7-TLS回调函数\" class=\"headerlink\" title=\"51.7  TLS回调函数\"></a>51.7  TLS回调函数</h2><ul>\n<li>因为TLS回调函数先于EP代码运行，所以可以在里面加API，比如IsDebuggerPresent()来判断是不是在调试</li>\n</ul>\n<h2 id=\"51-8-ETC\"><a href=\"#51-8-ETC\" class=\"headerlink\" title=\"51.8 ETC\"></a>51.8 ETC</h2><ul>\n<li><p>前面介绍的方法都是判断进程是不是在调试状态</p>\n</li>\n<li><p>这里另辟蹊径，可以借助Win32 API来判断是不是逆向分析的专用系统，相当于判断外部的条件</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240126185932068.png\" alt=\"image-20240126185932068\"></p>\n</li>\n</ul>\n<h2 id=\"51-9-小结\"><a href=\"#51-9-小结\" class=\"headerlink\" title=\"51.9 小结\"></a>51.9 小结</h2><ul>\n<li>调试过程中还会遇到更多反调试技术，这些反调试方法你可能之前从未见过，只要认真分析、查找相关资料般都能找到好的破解之道，这是积累经验、不断进步的必经之路。</li>\n<li>这段话送给自己，希望之后真正做题，或者逆向分析的时候，不要着急看wp，一步一步的仔细分析，相信自己可以逐步积累，慢慢的变成逆向分析大佬！</li>\n</ul>\n<h1 id=\"0x52-动态反调试\"><a href=\"#0x52-动态反调试\" class=\"headerlink\" title=\"0x52 动态反调试\"></a>0x52 动态反调试</h1><h2 id=\"52-2-异常\"><a href=\"#52-2-异常\" class=\"headerlink\" title=\"52.2 异常\"></a>52.2 异常</h2><ul>\n<li>异常应用于反调试技术。</li>\n<li>正常运行的进程发生异常时，os会调用进程中注册的SEH处理。</li>\n<li>如果进程在调试状态下，调试器就会处理异常。</li>\n<li>利用这个特征可以判断是正常运行，还是调试运行</li>\n</ul>\n<h3 id=\"SEH\"><a href=\"#SEH\" class=\"headerlink\" title=\"SEH\"></a>SEH</h3><h4 id=\"EXCEPTION-BREAKPOINT\"><a href=\"#EXCEPTION-BREAKPOINT\" class=\"headerlink\" title=\"EXCEPTION_BREAKPOINT\"></a>EXCEPTION_BREAKPOINT</h4><ul>\n<li>发生BREKPOINT异常时，如果正常运行，就会调用已经注册过的SEH<ul>\n<li>SEH中有修改EIP值的代码。</li>\n</ul>\n</li>\n<li>如果处在调试状态，就会交给调试器处理，系统会停止运行。</li>\n<li>之前学过可以用shift + f9，把异常抛给被调试者，然后调用SEH处理</li>\n</ul>\n<p><strong>Q：练习DynAD_SEH.exe</strong></p>\n<ul>\n<li>这里首先是个明显的安装SEH的操作</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240127120203807.png\" alt=\"image-20240127120203807\"></p>\n<ul>\n<li><p>接着出发INT3异常</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240127120306487.png\" alt=\"image-20240127120306487\"></p>\n</li>\n<li><p>现在是调试状态，所以由调试器处理，接着会JMP到FFFFFFFF处，无法处理</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240127120401862.png\" alt=\"image-20240127120401862\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>上面的代码，在遇到调试状态时，会直接终止进程。</p>\n<p>但是一些程序，会让你跳转到垃圾代码，如果你一直跟踪垃圾代码，会非常浪费时间。</p>\n\n</div>\n<ul>\n<li><p>整个代码的执行流是</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129143157307.png\" alt=\"image-20240129143157307\"></p>\n</li>\n</ul>\n<p><strong>Q：如果正常运行上面的程序</strong></p>\n<ul>\n<li><p>那么在遇到异常后，就会调用刚才注册过的SEH，也就是调用40102C处的handler</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129143706531.png\" alt=\"image-20240129143706531\"></p>\n</li>\n<li><p>参考前面的笔记，此时handler的第三个参数是pContext结构体</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129144846185.png\" alt=\"image-20240129144846185\"></p>\n</li>\n<li><p>EAX + B8是eip的值，也就是把401040给eip</p>\n</li>\n<li><p>然后异常处理器返回0</p>\n</li>\n<li><p>接着，发生异常的线程从修改后的eip地址处开始运行</p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>如果不处理异常，那么eip的值就会保持不变，还是会发你回到INT3指令处。同时再次调用40102C处的SEH，最终陷入无限循环，造成栈溢出，导致进程终止。</p>\n</p>\n</div>\n<p><strong>Q：删除SEH</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129145355389.png\" alt=\"image-20240129145355389\"></p>\n<ul>\n<li>根据前面学的，这里是典型的删除SEH的函数。</li>\n<li>把当前栈顶的值给FS:[0]，并pop掉当前栈顶的值</li>\n<li>接着删除handler</li>\n</ul>\n<p><strong>Q：破解之法</strong></p>\n<ul>\n<li>在调试器中让ollydbg忽略INT3 breaks，调试器就会忽略被调试进程中发生的INT3异常。让被调试进程自己处理</li>\n<li>此时在40102D处设置断点，程序是可以运行到这里的</li>\n</ul>\n<h3 id=\"SetUnhandledExceptionFilter\"><a href=\"#SetUnhandledExceptionFilter\" class=\"headerlink\" title=\"SetUnhandledExceptionFilter()\"></a>SetUnhandledExceptionFilter()</h3><ul>\n<li><p>进程中发生异常时，如果SEH未处理或者注册的SEH不存在，此时就会调用执行系统的异常处理函数kernel32!UnhandledExceptionFilter()  API</p>\n</li>\n<li><p>该函数内部会运行系统的最后一个异常处理器。名叫 Top Level Filter 或者 Last Exception Filter</p>\n</li>\n<li><p>这个异常处理器会弹出错误消息提示框，然后终止进程运行。</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129150032215.png\" alt=\"image-20240129150032215\"></p>\n</li>\n<li><p>kernel32!UnhandledExceptionFilter()  API内部调用了ntdll!NtQueryInformationProcess()  API 静态反调试技术，判断是否正在调试进程</p>\n</li>\n<li><p>如果进程正常运行，那么就运行系统最后的异常处理器</p>\n</li>\n<li><p>如果进程正在调试，那就把异常派送给调试器</p>\n</li>\n</ul>\n<p><strong>Q：通过Kernel32!SetUnhandledExceptionFilter() API可以修改系统最后的异常处理器</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129150353660.png\" alt=\"image-20240129150353660\"></p>\n<ul>\n<li><p>如果我调用这个函数修改系统的最后一个异常处理器，只要把新的Top Level Exception Filter的地址传给lpTopLevelExceptionFilter参数</p>\n</li>\n<li><p>它的返回值是上一个Last Exception Filter的函数地址</p>\n</li>\n<li><p>Top Level Exception Filter函数定义是</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129150540916.png\" alt=\"image-20240129150540916\"></p>\n</li>\n<li><p>基于异常的反调试中，会先出发异常，然后在新注册的Last Exception Filter内部判断进程是正常运行还是调试运行</p>\n</li>\n</ul>\n<h4 id=\"打开DynAD-SUEF-exe\"><a href=\"#打开DynAD-SUEF-exe\" class=\"headerlink\" title=\"打开DynAD_SUEF.exe\"></a>打开DynAD_SUEF.exe</h4><ul>\n<li><p>在401030设置断点，然后运行</p>\n</li>\n<li><p>这里首先是调用printf函数输出字符串，401087处是printf函数</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129151128480.png\" alt=\"image-20240129151128480\"></p>\n</li>\n<li><p>接着调用SetUnhandledExceptionFilter注册新的 Top Level Exception Filter</p>\n<ul>\n<li>这里保存旧的top level exception filter的地址</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129151333930.png\" alt=\"image-20240129151333930\"></p>\n</li>\n<li><p>接着这里会触发非法访问异常</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129151443704.png\" alt=\"image-20240129151443704\"></p>\n</li>\n<li><p>在ollydbg中设置忽略memory access 异常，然后在kenel32中search for names，找到UnhandledExceptionFilter()  API，设置断点，此时在发生异常时，按f9程序会运行到此处</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129152709968.png\" alt=\"image-20240129152709968\"></p>\n</li>\n<li><p>在这个API内部，这里通过看dragon的blog发现，正常情况下，EAX的值是1，代码就会跳到77782256处。这里就是反调试代码</p>\n<ul>\n<li><p>如果我把EAX改成0，7778223D处的指令就会调用401000处我设置的UnhandledExceptionFilter</p>\n</li>\n<li><p>但是我不知道是如何发现，修改EAX的值就可以绕过反调试的？</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129213554408.png\" alt=\"image-20240129213554408\"></p>\n</li>\n<li><p>在运行到这里后，可以发现</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129213922216.png\" alt=\"image-20240129213922216\"></p>\n</li>\n</ul>\n</li>\n<li><p>接着这里首先恢复了原来的 old top level exception handler，再次调用SetUnhandledExceptionFilter。恢复她。</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129214317866.png\" alt=\"image-20240129214317866\"></p>\n</li>\n<li><p>我觉得这里可以修改eip的原因是，这个ECX + 4指向的是CONTEXT，然后EAX + 0B8 访问的是eip</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129220158987.png\" alt=\"image-20240129220158987\"></p>\n</li>\n<li><p>这里是给401052 + 4变成了401056</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129214817314.png\" alt=\"image-20240129214817314\"></p>\n</li>\n<li><p>然后eip就会从401056</p>\n</li>\n</ul>\n<p><strong>Q：破解方法</strong></p>\n<ul>\n<li>就是让内部的反调试代码失效</li>\n</ul>\n<h2 id=\"52-3-Timing-Check\"><a href=\"#52-3-Timing-Check\" class=\"headerlink\" title=\"52.3 Timing Check\"></a>52.3 Timing Check</h2><ul>\n<li><p>因为在调试器中逐行跟踪程序肯定是比程序运行耗费的时间多</p>\n</li>\n<li><p>所以Timing Check通过计算运行时间的差异来判断程序是不是处在被调试状态</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129220728750.png\" alt=\"image-20240129220728750\"></p>\n</li>\n</ul>\n<h3 id=\"时间间隔-测量法\"><a href=\"#时间间隔-测量法\" class=\"headerlink\" title=\"时间间隔 测量法\"></a>时间间隔 测量法</h3><ul>\n<li>测量的方法包括下面两类：<ul>\n<li>一类是利用CPU的计数器</li>\n<li>另一类是利用系统的实际时间</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129223144481.png\" alt=\"image-20240129223144481\"></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>RDTSC：Read Time Stamp Counter 读取时间戳计数器</p>\n<p>计数器的准确程度由高到低排列如下:<br>RDTSC&gt;NtQueryPerformanceCounter()&gt;GetTickCount()</p>\n<p>NtQueryPerformanceCounter()与 GetTickCount()使用相同硬件(Performance Counter), 但二者准确程度不同(NtQueryPerformanceCounter()准确度更高)。</p>\n<p>而RDTSC是 CPU 内部的计数器，其准确程度最高。基于时间的方法与基于计数器的方法在实现过程上比较类似，原理也差不多。</p>\n\n</div>\n<h3 id=\"RDTSC\"><a href=\"#RDTSC\" class=\"headerlink\" title=\"RDTSC\"></a>RDTSC</h3><ul>\n<li>x86 CPU中存在一个名为TSC(Time Stamp Counter 时间戳计数器)的64位寄存器</li>\n<li>CPU对每个Clock Cycle 时钟周期计数，然后保存到TSC</li>\n<li>RDTSC是一条汇编指令，用来将TSC值读入EDX:EAX寄存器。</li>\n<li>TSC大小为64位，高32位保存至EDX寄存器，低32位保存至EAX寄存器</li>\n</ul>\n<p><strong>Q：练习DynAD_RDTSC.exe</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240129224239070.png\" alt=\"image-20240129224239070\"></p>\n<ul>\n<li>上述代码通过计算时间差delta，来判断进程是否处在调试状态</li>\n<li>delta值不固定，从40101C到40102A中间代码区域，只要执行一次，时间就会超过0xFFFFFFFF</li>\n</ul>\n<p><strong>Q：破解之法</strong></p>\n<ul>\n<li>不使用跟踪，直接使用run越过相关代码</li>\n<li>操作第二个RDTSC的结果值</li>\n<li>操纵条件分支指令：<ul>\n<li>JA执行跳转动作。只要把CF和ZF之一的值修改为1，JA就失效了。</li>\n</ul>\n</li>\n<li>利用内核模式驱动程序，使RDTSC失效</li>\n</ul>\n<h2 id=\"52-4-陷阱标志\"><a href=\"#52-4-陷阱标志\" class=\"headerlink\" title=\"52.4 陷阱标志\"></a>52.4 陷阱标志</h2><ul>\n<li><p>陷阱标志位指EFLAGS寄存器的第九个比特位</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130134749500.png\" alt=\"image-20240130134749500\"></p>\n</li>\n</ul>\n<h3 id=\"单步执行\"><a href=\"#单步执行\" class=\"headerlink\" title=\"单步执行\"></a>单步执行</h3><ul>\n<li>TF值设置为1时，CPU将进入单步执行模式</li>\n<li>在单步执行模式中，CPU执行1条指令后会触发1个EXCEPTION_SINGLE_STEP异常，然后陷阱标志位会自动清零</li>\n<li>可以把EXCEPTION_SINGLE_STEP 和 SEH结合，用于反调试</li>\n</ul>\n<p><strong>Q：运行DynAD_SingleStep.exe</strong></p>\n<ul>\n<li>这里PUSHFD表示push eflags的值，然后和00000100进行或运算，刚好修改的是第8位的值，也就是把TF变成1</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130135823937.png\" alt=\"image-20240130135823937\"></p>\n<ul>\n<li><p>在运行到40102F处时，显示出现了single step异常。如果正常运行，会运行前面注册过的SEH。如果调试运行，会继续执行下面的MOV代码</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130140408373.png\" alt=\"image-20240130140408373\"></p>\n</li>\n<li><p>从上面可以看出，没有办法直接修改EFLAGS寄存器的值。因此使用PUSHFD&#x2F;POPFD指令和OR运算修改陷阱标志的值。</p>\n</li>\n<li><p>不知道为什么，我的EFLAGS寄存器的值并灭有修改。</p>\n</li>\n</ul>\n<p><strong>Q：程序划分成正常运行和调试运行的原因是</strong></p>\n<ul>\n<li>在修改了EFLAGS寄存器的TF位后，发生异常，此时如果程序是正常运行，那么就会执行SEH处的代码</li>\n<li>如果程序是调试运行，就会继续向下执行，此时EFLAGS会清零。一直向下执行，最后JMP，进程会非正常终止</li>\n</ul>\n<p><strong>Q：破解之法</strong></p>\n<ul>\n<li>就是让ollydbg忽略single step异常</li>\n</ul>\n<h3 id=\"INT-2D\"><a href=\"#INT-2D\" class=\"headerlink\" title=\"INT 2D\"></a>INT 2D</h3><ul>\n<li>它原来是内核模式下触发断点异常的指令，也可以在用户模式下触发异常。</li>\n<li>但是程序调试运行时不会触发异常。</li>\n<li>就是在正常运行和调试运行下，状态不一样，就可以用于反调试。</li>\n</ul>\n<p><strong>Q：调试INT 2D指令</strong></p>\n<ol>\n<li>忽略下条指令的第一个字节</li>\n</ol>\n<ul>\n<li>在执行INT 2D指令之后，下一条指令的第一个字节会被忽略</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130141809697.png\" alt=\"image-20240130141809697\"></p>\n<ul>\n<li><p>也就是把401020地址处的指令重新解析了，忽略第一个字节B8</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130141919291.png\" alt=\"image-20240130141919291\"></p>\n</li>\n<li><p>最终原来401020地址处的指令被解析成了2条指令，和之前完全不一样，这就形成了比较强的代码混淆</p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>改变代码字节顺序(CodeByte Ordering)扰乱程序代码的方法称为代码混淆技术该技术常用于动态反调试技术。</p>\n</p>\n</div>\n<ol start=\"2\">\n<li>一直运行到断点处</li>\n</ol>\n<ul>\n<li>INT 2D指令的另一条特征是使用f7或者f8跟踪INT 2D指令时，程序不会停在下条指令开始的地方，而是一直运行，直到遇到断点，就像用F9运行一样。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>以上只是INT2D 指令在 OllyDbg 调试中表现出的特征，它在其他调试器中的行为略有不同。</p>\n<p>在 OllyDbg 调试中执行INT2D 指令后，程序不会单步暂停，而是一直运行原因在于，<strong>执行完INT2D 指令后，原有的代码字节顺序被打乱了</strong>。</p>\n<p>也就是说，若指令在程序执行过程中改变，则程序不能单步暂停,而是一直执行,可以将其视为一种 Bug</p>\n<p>所以执行完INT2D 指令后，要想停止跟踪代码，需要事先在相应地址处设置断点。</p>\n\n</div>\n<p><strong>Q：练习DynAD_INT2D.exe</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130142428875.png\" alt=\"image-20240130142428875\"></p>\n<ul>\n<li>程序如果正常运行，在遇到INT2D异常后，会转到SEH处，也就是40102A地址处，此时设置EIP为401044，EBP - 4是BOOL类型的变量，用来检测是否存在调试器，设置成FALSE。然后转到401044处继续执行</li>\n<li>程序如果调试运行，执行INT 2D后会跳过一个字节，继续执行401021地址处的MOV指令，将EBP - 4设置为1，也就是存在调试，然后转到401044处，输出正在调试</li>\n</ul>\n<p><strong>Q：破解之法</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130143141209.png\" alt=\"image-20240130143141209\"></p>\n<ul>\n<li><p>401044到40105B处的代码无论正常运行还是调试运行都会执行。所以可以修改代码</p>\n</li>\n<li><p>但是在实际的调试过程中，必须跟踪SEH逐行调试代码。<strong>利用陷阱标志可以使程序进入SEH执行。</strong></p>\n</li>\n<li><p>双击TF，设置他是1，在40102A处设置断点，在ollydbg中设置忽略single step异常。此时再执行一条指令。那么就会触发single step异常，从而转到40102A处的SEH进行处理。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130144147536.png\" alt=\"image-20240130144147536\"></p>\n<p><strong>Q：这里有一个问题，在执行到40101E地址处，此时我设置成TF &#x3D; 1了，为什么程序会在NOP处暂停，并且TF没有变成0，也没有触发异常呢？</strong></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130145140602.png\" alt=\"image-20240130145140602\"></p>\n<ul>\n<li><p>首先INT 2D原是内核指令，只要程序中有，在用户模式的调试器中它就不会被识别为正常指令，就理解成程序会停在它的下一条指令处。</p>\n</li>\n<li><p>在TF正常是0的情况下，INT2D会忽略他的下一条指令。继续执行MOV 和JMP</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130145241080.png\" alt=\"\t\"></p>\n<ul>\n<li><p>在INT 2D处，如果我设置成了TF &#x3D; 1，此时程序还是停在了NOP处，并且TF还是1。原因是，可以理解成会先识别它不是正常指令，停在401021处，再去处理single step异常的事。TF &#x3D; 1时，后面的1个字节就不会被忽略了。此时在single step模式下，再执行NOP，就会发生异常。程序跳转到SEH处</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130145453381.png\" alt=\"image-20240130145453381\"></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130145846044.png\" alt=\"image-20240130145846044\"></p>\n</li>\n</ul>\n<h2 id=\"52-5-0xCC检测\"><a href=\"#52-5-0xCC检测\" class=\"headerlink\" title=\"52.5 0xCC检测\"></a>52.5 0xCC检测</h2><ul>\n<li>程序调试过程中，我们一般会设置许多软件断点</li>\n<li>断点对应的x86指令是0xCC，如果能检测到该指令，就可以判断程序是否处于调试状态。</li>\n<li>基于这一想法的反调试技术就是0xCC探测</li>\n</ul>\n<p><strong>Q：那是要搜索程序中所有的0xCC么？</strong></p>\n<ul>\n<li><p>这样肯定不行，因为0xCC也可以用作操作码，立即数等，所以在进程内存的代码区只扫描0xCC肯定是不行</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130164006053.png\" alt=\"image-20240130164006053\"></p>\n</li>\n</ul>\n<h3 id=\"API断点\"><a href=\"#API断点\" class=\"headerlink\" title=\"API断点\"></a>API断点</h3><ul>\n<li>在正常调试的时候，调试某个API，我们都是在API起始处设置断点</li>\n<li>所以我们可以检测API代码的第一个字节是否为CC判断进程是否处在调试之中</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>代码逆向分析人员常用的API列表如下：</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130164832897.png\" alt=\"image-20240130164832897\"></p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130164853252.png\" alt=\"image-20240130164853252\"></p>\n</p>\n</div>\n<p><strong>Q：练习基于API断点检测的反调试方法</strong></p>\n<ul>\n<li><p>在程序中我们搜索names in all modules，然后双击这个API，之后按f2设置断点</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130165057139.png\" alt=\"image-20240130165057139\"></p>\n</li>\n<li><p>这样此时API代码的第一个字节设置好了断点，API代码开始的第一个字节已经改成了CC</p>\n</li>\n<li><p>然后获取kernel32!CreateFileW() API起始地址的第一个字节即可</p>\n</li>\n</ul>\n<p><strong>Q：破解之法</strong></p>\n<ul>\n<li>就是在设置断点的时候，不设置在起始，设置在中间。</li>\n<li>硬件断点也可以绕过</li>\n</ul>\n<h3 id=\"比较检验和\"><a href=\"#比较检验和\" class=\"headerlink\" title=\"比较检验和\"></a>比较检验和</h3><ul>\n<li><p>检测代码中设置的软件断点的另一个方法是，比较特定代码区域的校验和 Checksum</p>\n</li>\n<li><p>比如程序中401000 ~ 401070地址区域的校验和值是0x12345678，那么在这个代码区域中调试时，会设置一些断点0xCC，这样新校验和和之前的就不一样了</p>\n<p><img src=\"/../re-engineer-core-principle-07/image-20240130165351628.png\" alt=\"image-20240130165351628\"></p>\n</li>\n</ul>\n","feature":true,"text":"引言 终于到第七部分了，快看完了 0x50 反调试技术50.1 反调试技术 反调试技术有很强的依赖性。有些反调试技术仅在特定版本的os下工作 本章的大部分技术可以用在Windows XP SP3(32位)和Win7 32位下 50.3 反调试技术分类 根据破解方法分成静态和动态两...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x50-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">0x50 反调试技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#50-1-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">50.1 反调试技术</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#50-3-%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">50.3 反调试技术分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">静态反调试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">动态反调试</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x51-%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">0x51 静态反调试技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-2-PEB\"><span class=\"toc-text\">51.2 PEB</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BeingDebugged\"><span class=\"toc-text\">BeingDebugged</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Ldr-0xC\"><span class=\"toc-text\">Ldr(+0xC)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Process-Heap-0x18\"><span class=\"toc-text\">Process Heap(+0x18)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#NtGlobalFlag-0x68\"><span class=\"toc-text\">NtGlobalFlag(+0x68)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0-StaAd-PEB-exe\"><span class=\"toc-text\">练习 StaAd_PEB.exe</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-3-NtQueryInformationProcess\"><span class=\"toc-text\">51.3 NtQueryInformationProcess()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ProcessDebugPort\"><span class=\"toc-text\">ProcessDebugPort</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ProcessDebugObjectHandle-0x1E\"><span class=\"toc-text\">ProcessDebugObjectHandle(0x1E)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ProcessDebugFlags-0x1F\"><span class=\"toc-text\">ProcessDebugFlags(0x1F)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0-StaAD-NtQIP-exe\"><span class=\"toc-text\">练习 StaAD_NtQIP.exe</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A0%B4%E8%A7%A3\"><span class=\"toc-text\">破解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-4-NtQuerySystemInformation\"><span class=\"toc-text\">51.4 NtQuerySystemInformation()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8windbg%E8%B0%83%E8%AF%95%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8\"><span class=\"toc-text\">使用windbg调试系统内核</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SystemKernelDebuggerInformation-0x23\"><span class=\"toc-text\">SystemKernelDebuggerInformation(0x23)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A0%B4%E8%A7%A3%E4%B9%8B%E6%B3%95\"><span class=\"toc-text\">破解之法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-5-NtQueryObject\"><span class=\"toc-text\">51.5 NtQueryObject()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0StaAD-NtQO-exe\"><span class=\"toc-text\">练习StaAD_NtQO.exe</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-6-ZwSetInformationThread\"><span class=\"toc-text\">51.6 ZwSetInformationThread()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0StaAD-ZwSIT-exe\"><span class=\"toc-text\">练习StaAD_ZwSIT.exe</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A0%B4%E8%A7%A3-1\"><span class=\"toc-text\">破解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-7-TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">51.7  TLS回调函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-8-ETC\"><span class=\"toc-text\">51.8 ETC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-9-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">51.9 小结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x52-%E5%8A%A8%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">0x52 动态反调试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#52-2-%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">52.2 异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SEH\"><span class=\"toc-text\">SEH</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#EXCEPTION-BREAKPOINT\"><span class=\"toc-text\">EXCEPTION_BREAKPOINT</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SetUnhandledExceptionFilter\"><span class=\"toc-text\">SetUnhandledExceptionFilter()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%BC%80DynAD-SUEF-exe\"><span class=\"toc-text\">打开DynAD_SUEF.exe</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#52-3-Timing-Check\"><span class=\"toc-text\">52.3 Timing Check</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94-%E6%B5%8B%E9%87%8F%E6%B3%95\"><span class=\"toc-text\">时间间隔 测量法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RDTSC\"><span class=\"toc-text\">RDTSC</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#52-4-%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">52.4 陷阱标志</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">单步执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#INT-2D\"><span class=\"toc-text\">INT 2D</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#52-5-0xCC%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">52.5 0xCC检测</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#API%E6%96%AD%E7%82%B9\"><span class=\"toc-text\">API断点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83%E6%A3%80%E9%AA%8C%E5%92%8C\"><span class=\"toc-text\">比较检验和</span></a></li></ol></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"re-engineer-core-principle-06","uid":"080514f34f3fd257fa211ebeac34b223","slug":"re-engineer-core-principle-06","date":"2024-01-23T03:31:18.000Z","updated":"2024-02-28T14:44:30.192Z","comments":true,"path":"api/articles/re-engineer-core-principle-06.json","keywords":null,"cover":[],"text":"引言 快看完了，加油冲冲冲！希望回家前看完 0x45 TLS回调函数 TLS(Thread Local Storage 线程局部存储)回调函数(Callback function)常用于反调试。 TLS回调函数的运行要先于EP代码的执行，因此它可以作为一种反调试技术使用 45.1...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}