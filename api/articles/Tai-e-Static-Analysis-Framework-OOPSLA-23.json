{"title":"Tai-e-Static-Analysis-Framework-OOPSLA'23","uid":"e225c813c8f4b0b48846cd97578ebb48","slug":"Tai-e-Static-Analysis-Framework-OOPSLA-23","date":"2023-10-17T01:44:12.000Z","updated":"2023-10-18T09:35:53.722Z","comments":true,"path":"api/articles/Tai-e-Static-Analysis-Framework-OOPSLA-23.json","keywords":null,"cover":[],"content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>这篇论文是我看谭老师课题组的第二篇文章，因为对于静态分析一直停留在理论，想着要看看代码，自己试试</li>\n</ul>\n<h1 id=\"ABSTRACT\"><a href=\"#ABSTRACT\" class=\"headerlink\" title=\"ABSTRACT\"></a>ABSTRACT</h1><p>静态分析在Bug detection、安全分析、程序解释、优化等方面已经非常成熟。</p>\n<p>静态分析在IR生成、confrol flow graph、control flow graph构建、指针和别名分析的计算等方面都有应用。</p>\n<p>作者设计这个静态分析框架遵循HGDC的原则(Harnessing the Good Designs of Classics)：</p>\n<ul>\n<li>for each crucial component of a static analysis framework, we compare the design choices made for it (possibly) by different classic frameworks such as Soot, Wala, Doop, SpotBugs and Checker</li>\n<li>choose arguably a more appropriate one; but if none is good enough, we then propose a better design</li>\n</ul>\n<h1 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1 Introduction\"></a>1 Introduction</h1><p>对于设计一个静态分析的框架来说，重要的是平衡simplicity、usability、effciency。</p>\n<p>我们缺乏一个systematic view去检查静态分析框架的质量，从依赖这些框架去创建新的分析的开发人员来说。</p>\n<p>作者讨论了对于Java静态分析框架一些关键组件的trade-off：</p>\n<ul>\n<li>Program Abstraction：需要一个抽象的模型，去取代所有各种静态分析中的元素</li>\n<li>Fundamental Analysis：它应该支持基本的facilities，允许分析开发人员使用分析友好的结构，使用control flow 和 call graph去实现经典的graph-based algorithms</li>\n<li>New Analysis Development：应该提供一种机制，开发和分析 new analysis，包括bug detectors security analyzers客户端，以及像<strong>异常和反射分析</strong>等。(最后一节课里的内容)</li>\n<li>Multiple Analysis：它应该提供一个标准化的方法来管理多个分析</li>\n</ul>\n<p>doop、SpootBugs、FindBugs、Checker</p>\n<p>本文的贡献：</p>\n<ul>\n<li>Tai-e是一个 usage-friendly IR对于开发指针分析来说</li>\n<li>Tai-e是一个高效的指针分析系统，很容易用它创建新的指针分析算法</li>\n<li>Tai-e也提供了一个插件，用于&#x3D;&#x3D;taint analysis和exception analysis&#x3D;&#x3D;</li>\n</ul>\n<p>作者列举了一些人对Tai-e框架的使用反馈。</p>\n<h1 id=\"2-Program-Abstraction\"><a href=\"#2-Program-Abstraction\" class=\"headerlink\" title=\"2 Program Abstraction\"></a>2 Program Abstraction</h1><p>静态分析框架需要提供程序的abstraction model,包括IR，type system， class  hierachy等。</p>\n<p>Soot和Wala都有特殊的IR，Tai-e的IR受到了这两个框架的启发而来的。</p>\n<ul>\n<li>它可以implement more concise analysis</li>\n<li>better understand  intents of IR</li>\n</ul>\n<p>tai-e是developer-friendliness，从以下几个方面：</p>\n<ul>\n<li>和soot相比，Tai-e区分了不同类型的assign statement</li>\n<li>对于Api的设计，使用了具体的return type对于expression retrival,避免使用integer进行索引去represent variables，这和Soot Wala不一样</li>\n<li>程序元素的组织和可访问性例如values tyoes namse，不像wala，Tai-e集中所有变量相关的信息到一个single interface，没有把他们分到不同的interface。</li>\n</ul>\n<p>由于(1)和（2）,Tai-e能让Developers写更简洁的代码。避免不必要的条件检查，在写各种变量和表达式时，进行向下转换。</p>\n<p>(3)可以让开发者更容易了解Tai-e的功能，</p>\n<p>用下面的例子来说迷宫上述的设计。</p>\n<p><strong>1. 对于Soot</strong></p>\n<p>Soot把内部所有带有 &#x3D; 操作符的语句表示为AssignStmt，不区分具体的类型，到底是load store new unary binary statement。但是wala和Tai-e区分。这就可能引起类型检查。</p>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231017154623449.png\" alt=\"image-20231017154623449\"></p>\n<ul>\n<li>这里line 2的Declared type 是AssignStmt，AssignStmt是Soot的类结构中代表binary statement 的 lowest-level interface<ul>\n<li>我理解这里的Low就是最底层的接口，也就是它是一个很大的范围，像object一样，所以就需要类型检查，因为它太大了</li>\n</ul>\n</li>\n</ul>\n<p>Soot总是返回Value(the highest-level interface in the class hierarchy)去代表数据，因此需要类型转换去决定数据的具体类型。</p>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231017155531102.png\" alt=\"image-20231017155531102\"></p>\n<ul>\n<li>已知一个binary statement的左操作数是local variable</li>\n<li>但是soot返回的是Value，这就需要再转成Local</li>\n</ul>\n<p><strong>2. Wala</strong></p>\n<p>Wala没有上面的问题，它采用不同的策略去代表local variables。</p>\n<p>使用int-index的方式。</p>\n<ul>\n<li>getUse会返回一个int值，它作为一个索引去访问操作数的信息。</li>\n<li>之后在这个Symbol表中，用这个索引去获取值</li>\n</ul>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231017160540952.png\" alt=\"image-20231017160540952\"></p>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231017160548104.png\" alt=\"image-20231017160548104\"></p>\n<p>这种的缺点就是不直接，当变量的信息多的时候，就很困难。</p>\n<p><strong>3. Tai-e</strong></p>\n<p>避免了上述提到的所有问题，因为程序经常会有很多不同的statement和expressions，用Tai-e更方便。</p>\n<p>此外，对于指针分析，Tai-e把每个变量v和它相关的statement关联起来，一旦v的值改变了，开发者可以直接通过IR获得所有的相关的 statement。</p>\n<h1 id=\"3-Fundamental-Analysis\"><a href=\"#3-Fundamental-Analysis\" class=\"headerlink\" title=\"3 Fundamental Analysis\"></a>3 Fundamental Analysis</h1><p>静态分析是对于抽象的数据是如何沿着程序的控制结构流动的，根据程序的语义和运行时环境。</p>\n<p>一个静态分析的框架应该提供基本的产生控制结构的能力，像control flow and call graph</p>\n<p>此外，需要一个指针分析去计算程序中指针相关的变量的可能的值</p>\n<h2 id=\"3-1-Pointer-Analysis\"><a href=\"#3-1-Pointer-Analysis\" class=\"headerlink\" title=\"3.1 Pointer Analysis\"></a>3.1 Pointer Analysis</h2><p>Soot提供了一个<strong>context-insensitivity</strong>的指针分析系统，Spark，这个运行非常快。</p>\n<p>Wala实现了一个<strong>context-sensitivity</strong>的指针分析系统。</p>\n<p>Doop是另一个指针分析框架，is full of clever and useful design</p>\n<p>不像Soot，wala和Tai-e是imperative，因为是用Java实现的</p>\n<p>Doop是Declative，是用Datalog实现的，他被认为是一个主流的平台去实现和比较指针分析算法。</p>\n<p>对于Java来说，设计一个指针分析系统，需要考虑下面这些key points：</p>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231017164536850.png\" alt=\"image-20231017164536850\"></p>\n<ul>\n<li>指针相关的信息如何表示，这也是指针分析算法的核心</li>\n<li>一个context manager，处理上下文敏感问题</li>\n<li>Heap manager，处理heap object</li>\n<li>解决指针相关信息的传播问题</li>\n</ul>\n<h4 id=\"Representation-of-Points-to-Information\"><a href=\"#Representation-of-Points-to-Information\" class=\"headerlink\" title=\"Representation of Points-to Information\"></a>Representation of Points-to Information</h4><ul>\n<li>指针分析需要一个统一的结构去代表和每个变量相关的指针集</li>\n<li>Spark和Wala都采用一种混合的方式<ul>\n<li>当set的尺寸小于某些值时，使用array去存储指向的对象</li>\n<li>否则，当set的尺寸大于某些值时，用一个bit  set去代表指针集</li>\n</ul>\n</li>\n<li>Tai-e也用这种方式</li>\n</ul>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231017165313964.png\" alt=\"image-20231017165313964\"></p>\n<p>&#x3D;&#x3D;<strong>这里dragon之前给我讲的那个zpoline是啥来着？？</strong>&#x3D;&#x3D;</p>\n<p>但是他改进了，上图左边的是spark wala采用的方式，就用0-4096来设置，但是有很多空间浪费了。</p>\n<p>作者的方式是右图，采取了类似于 virtual memory的方式，用sparse bit set(稀疏点集)去代表指针集。</p>\n<p>16个Integer，每个是32bits，指向16个256的set，总共是4096。</p>\n<p>但是因为这里就用了4个object，所以总共就是256x2 + 16 x 32，</p>\n<p>&#x3D;&#x3D;但是这里为什么是32bits呢？&#x3D;&#x3D;</p>\n<p><strong>实际上，作者用two-level的page table去节约更多的空间</strong></p>\n<ul>\n<li>table的size根据对象的指针集动态决定</li>\n<li>与常规的bit set比，对于context-sensitivity的指针分析，节省了很多内存。</li>\n<li>许多对于C language的work，设计了 new bit sets，这也可以同样应用于java</li>\n<li>Doop 是Declartive，它的指向集合是开发人员无法访问的.</li>\n<li>&#x3D;&#x3D;(就像数据库一样,是受保护的??)&#x3D;&#x3D;</li>\n</ul>\n<h4 id=\"Context-Manager\"><a href=\"#Context-Manager\" class=\"headerlink\" title=\"Context Manager\"></a>Context Manager</h4><p>对于各种上下文敏感 variants 有不同的context length method call heap object,因此需要一种方法来管理.</p>\n<p><strong>Q1:现有的指针分析框架对于上下文敏感的问题</strong></p>\n<ul>\n<li>Soot没有上下文敏感,</li>\n<li>Sprak是C.I.</li>\n<li>Paddle是一个基于BDD的C.S.指针分析,它的效率不如Doop</li>\n<li>Doop是有许多rules来实现C.S.,但是对于不同的C.S.分析,需要写不同的实现,让代码很冗余</li>\n</ul>\n<p><strong>Q2:Tai-e的C.S.</strong></p>\n<ul>\n<li>Tai-e是imperative,对于同样的C.S.分析,它把context length作为输入的参数</li>\n<li>Wala只提供了context management对于方法调用,它的heap context直接继承于方法的上下文</li>\n<li>和Wala相比,Tai-e提供了更灵活的context management,可以具体的定义上下文,是 method call还是 heap object,比如可以给method call 用3-call-site,给heap object 用1-call-site</li>\n</ul>\n<p><strong>Q3:selective context sensitivity</strong></p>\n<ul>\n<li>之前的论文也提到,他是一个很state-of-the-art的技术</li>\n<li>目前现有的selective C.S.都已经被Tai-e实现了</li>\n</ul>\n<h2 id=\"3-2-Control-Data-Flow-Analysis\"><a href=\"#3-2-Control-Data-Flow-Analysis\" class=\"headerlink\" title=\"3.2 Control&#x2F;Data Flow Analysis\"></a>3.2 Control&#x2F;Data Flow Analysis</h2><p>对于data flow analysis,作者列举了不同的框架,可以简化control&#x2F;flow analysis分析的实现</p>\n<p><strong>Control Flow Analysis</strong></p>\n<p>它的主要任务是构建CFG,但是用不同的框架,效率不一样</p>\n<p><em>Edge categories</em></p>\n<ul>\n<li>Soot Wala  Checker不对边进行分类,例如 IF_true IF_false caugt_exception<ul>\n<li>如果分类了,会对 path  sensitive and branch-correlated analysis  exceptionspecic handling 有很好的处理</li>\n</ul>\n</li>\n<li>Tai-e和SpotBugs对边进行分类,但是Tai-e提供了额外的有用的边信息.<ul>\n<li>label  switch edge用case value</li>\n<li>给exception edge加上具体的异常类型</li>\n</ul>\n</li>\n<li>开发者也能在Soot Wala中获得边的信息,通过解析相关的node,但是这不方便</li>\n<li>Check不对边进行分类,但是对CFG node进行分类,例如 ConditionalBlock ExceptionBlock,可以通过API从block中获得edge 的信息</li>\n</ul>\n<p><em>Exception handling</em></p>\n<p>对于Java来说,一个关键的影响构建CFG的有效性的因素是如何解决Java的一场,被认为是control flow analysis中不完整的一个关键因素</p>\n<p>有显式和隐式异常, 如果catch 到的异常类型匹配,就通过throw statement抛出相应的异常,之后由JVM隐式执行.</p>\n<p>一个完整的CFG应该考虑异常,但是很多隐式的异常和正常的flow是没有交互的,因此考虑他们可能会降低分析的精度.</p>\n<p>和Wala SpotBugs Check不同,Tai-e Soot区分控制流的显式和隐式异常,允许用户决定在CFG上添加哪个.</p>\n<p>Tai-e也实现了最先进的异常分析,比其他的解决异常的精度更高,提供一个选项在构建CFG的时候.</p>\n<p><strong>data flow analysis</strong></p>\n<p>为了实现数据流分析,开发者可以使用数据流分析系统提供的接口,去做一些具体的操作,让这个分析满足monotonic 和safe0approximated</p>\n<ul>\n<li><p>data facts抽象和初始化</p>\n</li>\n<li><p>对于不同的statement的transfer function </p>\n</li>\n<li><p>对于Merge的数据,是join 或者meet的操作</p>\n</li>\n</ul>\n<p><em>data facts initialization</em></p>\n<ul>\n<li>Soot Wala不允许initialize data facts,他们在solver中实现了相关的API,因此每次对于一个new analysis需要不同的initialization,都必须实现一个new solver去实现API</li>\n<li>一个优秀的设计应该只有一个solver去驱动多个数据流分析,以便开发者只需要集中于analysis的实现,而不需要集中于solver的实现</li>\n</ul>\n<p><em>Edge transfer functions</em></p>\n<p>SpotBugs Wala. Soot Check 都不显示的支持edge transfer function</p>\n<p>Edge Transfer function 和 node transfer function不同,对于一个node的后继节点,他们沿着边把data facts发送给各种后继节点,这些node使用分支信息(当expressions E是有效的,fact D就被传播);来做更有效的analysis.</p>\n<p>当edge的transfer function里面没有内容的时候,就把source node 的Out fact当成target node 的In fact,这也就是常的Node transfer function的分析.</p>\n<p>但是在Soot中,为了利用branch information,开发者需要extend一个特殊的分析 <strong>BranchedFlowAnalysis</strong>并且实现edges 和nodes的相关逻辑在node的transfer function中,这很不方便且冗余.</p>\n<p>Checker不直接支持edge transfer function,它把node transfer的结果分成不同的类,<strong>例如then或者else</strong>分支.Solve可以传播then的结果给相应的successor沿着then branch,让开发者可以有相同的功能像edge transfer function一样.</p>\n<p>这可能需要处理edge相关的facts在node transfer function中,耦合了node 和 edge transfer function的逻辑</p>\n<p>Checker的标准和其他的框架各不一样,它加强了Java的 type system,通过让开发者给types写qualifiers(本质上是Java的注解,<strong>就是@Autofired的这种</strong>),通过type qualifier inference来进行分析.这种机制事实上是很有效的,未来在Tai-e中可能用annotations去辅助静态分析&#x2F;</p>\n<p>&#x3D;&#x3D;<strong>来自gpt:</strong>&#x3D;&#x3D;</p>\n<p><em>类型修饰符</em></p>\n<p>在某些编程语言中，类型修饰符可能需要显式地指定，以明确表达变量或参数的特性。然而，对于某些情况，编译器可以根据上下文自动推断出适当的类型修饰符，而无需显式指定.</p>\n<p>具体来说，类型修饰符推断可以根据以下情况进行推断：</p>\n<ol>\n<li>变量初始化：当变量被初始化时，编译器可以根据右侧表达式的类型推断出变量的类型修饰符。</li>\n<li>方法调用：当调用带有类型修饰符参数的方法时，编译器可以推断出传递给方法的参数的类型修饰符。</li>\n<li>返回值推断：当方法具有明确的返回表达式时，编译器可以根据返回表达式的类型推断出方法的返回值的类型修饰符。</li>\n</ol>\n<p>（type qualifier inference）可以优化程序的主要原因是它可以减少代码中显式类型修饰符的冗余，从而简化代码并提高可读性。</p>\n<p><em>类型修饰符推断如何优化程序的一些方面</em>：</p>\n<ol>\n<li>减少冗余的代码：通过自动推断类型修饰符，开发人员不需要显式地为每个变量、参数或返回值指定类型修饰符。这减少了冗余的类型修饰符声明，使代码更加简洁和清晰。</li>\n<li>提高可读性：通过省略显式的类型修饰符，代码变得更加简洁和易读。开发人员可以专注于核心逻辑而不是类型修饰符的繁杂声明，使代码更易于理解和维护。</li>\n<li>提升开发效率：类型修饰符推断减少了开发人员编写和维护代码中的冗余类型修饰符的工作量。这样，开发人员可以更快速地编写代码，减少了错误的可能性，并提高了开发效率。</li>\n<li>更好的可扩展性：类型修饰符推断使代码更具灵活性和可扩展性。当引入新的类型修饰符或修改现有的类型修饰符时，开发人员不需要手动更改整个代码库中的每个类型修饰符声明。编译器可以根据上下文自动推断类型修饰符，从而使代码库的维护更加容易。</li>\n</ol>\n<h1 id=\"4-New-Analysis-Development\"><a href=\"#4-New-Analysis-Development\" class=\"headerlink\" title=\"4 New Analysis Development\"></a>4 New Analysis Development</h1><p>一个静态分析框架应该提供整合new analysis的能力，从intraprocedural 到interprocedural</p>\n<p>这里介绍了指针分析过程中可能用到的类，像reflection analysis和exception analysis的基本原理，Bug finders和security analyzers client</p>\n<p><strong>对于Doop</strong></p>\n<p>这里省略</p>\n<p><strong>对于Wala</strong></p>\n<p>wala提供一种机制在添加new analysis时，和pointer analysis进行交互</p>\n<ul>\n<li>首先，devlopers需要实现一个ContextSelector 的接口，来指定相关的call site，</li>\n<li>在call site处，new analysis 基于pointed-to results 进行model</li>\n</ul>\n<p>例如：分析reflective call <code>v = c newInstance()</code></p>\n<ul>\n<li><p>developers encode ContextSelector to <strong>identify this call site</strong> and retrieve the Class objects,<strong>CO</strong>，</p>\n<ul>\n<li>就是找到对应的类，和call site</li>\n</ul>\n</li>\n<li><p>根据pointed-to results，<strong>c指向co</strong> </p>\n</li>\n<li><p>developers 需要实现 ContextInterpreter，生成fictitious but effect-equivalent IRS(e.g., v &#x3D; new T(); v.&lt; init &gt;()) according to the resolved types of CO (say T)</p>\n<ul>\n<li>因为newInstance本身也是在new一个对象，分析的时候要把它当成new一个对象</li>\n<li>根据之前CO所属的类，去分配一个对象</li>\n</ul>\n</li>\n<li><p>Then these generated IRs are fed back to pointer analysis to continue the resolution for this reective call.</p>\n</li>\n</ul>\n<p>上述就是一个Java反射创建对象的过程，正常我们也是这样理解的，把我们理解的转换成IR，并反馈给pointer analysis.</p>\n<p>上面的scheme很容易理解，但是对于Pointer analysis来说，有一些限制</p>\n<p>(这部分先不看了，我觉得主要还是理解代码)</p>\n<p>tai-e引进了一个analysis plugin system</p>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231018161244283.png\" alt=\"image-20231018161244283\"></p>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231018163554809.png\" alt=\"image-20231018163554809\"></p>\n<p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231018162438027.png\" alt=\"image-20231018162438027\"></p>\n<p>对于call site 1来说，</p>\n<ul>\n<li>edge的source就是call site1，target是目标方法source。</li>\n<li>进入if，如果目标放是source，创建一个污点对象o，</li>\n<li>然后更新这个solver，call site的 left-hand side variable，也就是s1，指向一个五点对象o</li>\n</ul>\n<p>对于call site2来说，</p>\n<ul>\n<li><p>edge的source是call site2，target是目标方法concat。</p>\n</li>\n<li><p>此时的concat是一个transfer，在这行Transfer中，污点对象从参数s1，流到了s3中</p>\n</li>\n<li><p>对于tansfer，应该把from指向的污点对象，也加到to的指针集中。也就是把o也加到s2的指针集中</p>\n</li>\n<li><p>现在s3也指向了污点对象，transfer from s1</p>\n</li>\n<li><p>这个transfer relatin也被添加到  <em>transferVars</em>中，用于记录来自transfer metho的污点相关的数据流edge</p>\n</li>\n</ul>\n<p><em>OnNewPointesToSet</em></p>\n<ul>\n<li>这个就很好理解了，相当于污点数据的传播，把污点数据传给其他边。</li>\n</ul>\n<p><em>OnFinish</em></p>\n<ul>\n<li>当达到fixed point时，solver就会调用Onfinish</li>\n<li>对于每个sink method和他的敏感参数param_i,onFinish识别他的call site cs，并且检查是否有污点数据流到param_i，如果有，就报告污点信息。</li>\n</ul>\n<h1 id=\"5-Multiple-Analysis-management\"><a href=\"#5-Multiple-Analysis-management\" class=\"headerlink\" title=\"5 Multiple Analysis management\"></a>5 Multiple Analysis management</h1><p>在很多情况下，一个分析依赖于其他分析的结果。</p>\n<p>因此：</p>\n<ul>\n<li>如何配置一个analysis 和它的dependencies？</li>\n<li>如何保存一个分析的结果并在其他分析中访问？</li>\n</ul>\n<p><strong>Configure Analysis and its Dependencies</strong></p>\n<p>可以通过配置文件来记录所有新的分析。</p>\n<p><strong>Store&#x2F;Access Analysis Results</strong></p>\n<h1 id=\"6-Evaluation\"><a href=\"#6-Evaluation\" class=\"headerlink\" title=\"6 Evaluation\"></a>6 Evaluation</h1><p><img src=\"/../Tai-e-Static-Analysis-Framework-OOPSLA-23/image-20231018170852676.png\" alt=\"image-20231018170852676\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>这篇文章看下来，目前还有很多不懂的地方，因为我没有真的用过Soot、Wala</li>\n<li>下来要自己尝试一下实现的代码，同时跑一下上一篇论文的实验</li>\n<li>感觉静态分析很难，自己只是刚刚入门。</li>\n</ul>\n","text":"引言 这篇论文是我看谭老师课题组的第二篇文章，因为对于静态分析一直停留在理论，想着要看看代码，自己试试 ABSTRACT静态分析在Bug detection、安全分析、程序解释、优化等方面已经非常成熟。 静态分析在IR生成、confrol flow graph、control f...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":3,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":2,"path":"api/tags/论文.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ABSTRACT\"><span class=\"toc-text\">ABSTRACT</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Introduction\"><span class=\"toc-text\">1 Introduction</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Program-Abstraction\"><span class=\"toc-text\">2 Program Abstraction</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Fundamental-Analysis\"><span class=\"toc-text\">3 Fundamental Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Pointer-Analysis\"><span class=\"toc-text\">3.1 Pointer Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Representation-of-Points-to-Information\"><span class=\"toc-text\">Representation of Points-to Information</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Context-Manager\"><span class=\"toc-text\">Context Manager</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Control-Data-Flow-Analysis\"><span class=\"toc-text\">3.2 Control&#x2F;Data Flow Analysis</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-New-Analysis-Development\"><span class=\"toc-text\">4 New Analysis Development</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Multiple-Analysis-management\"><span class=\"toc-text\">5 Multiple Analysis management</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-Evaluation\"><span class=\"toc-text\">6 Evaluation</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"巅峰极客","uid":"cdb488d648a90943d7354784532a6374","slug":"巅峰极客","date":"2023-07-31T12:38:30.000Z","updated":"2023-08-01T09:17:46.710Z","comments":true,"path":"api/articles/巅峰极客.json","keywords":null,"cover":[],"text":"巅峰极客hellosql 这个题我知道是时间延迟注入，也知道用笛卡尔积，但是我当时的方法就是测不出来 过滤了* if 空格 时间延迟我当时用的是 SELECT A.table_name FROM information_schema.columns A, information_...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"CTF","slug":"CTF","count":4,"path":"api/tags/CTF.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Context-Sensitivity-without-Contexts-PLDI23","uid":"39f6a6f9864fa629c2ab8230b6f47fbc","slug":"Context-Sensitivity-without-Contexts-PLDI23","date":"2023-10-08T05:40:18.000Z","updated":"2023-10-18T09:35:51.585Z","comments":true,"path":"api/articles/Context-Sensitivity-without-Contexts-PLDI23.json","keywords":null,"cover":[],"text":"引言 学完了南大软件分析的课程，关注了谭老师的个人主页。 想着看一篇论文，能对学的内容有更好的理解。 AbstractQ1：首先说上下文敏感的做法 在不同上下文中分析，分离方法变量，和堆对象，也就是同时应用上下文敏感和堆上下文敏感 Q2：但是这种方法带来了问题： 因为需要clon...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Program Analysis","slug":"Program-Analysis","count":3,"path":"api/tags/Program-Analysis.json"},{"name":"论文","slug":"论文","count":2,"path":"api/tags/论文.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}