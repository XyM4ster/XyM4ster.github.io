{"title":"re-engineer-core-principle-02","uid":"1e07b60d2029aa2ea6483727894829df","slug":"re-engineer-core-principle-02","date":"2023-10-22T08:39:11.000Z","updated":"2024-02-29T10:45:26.276Z","comments":true,"path":"api/articles/re-engineer-core-principle-02.json","keywords":null,"cover":"/medias/pexels-luis-gomes-546819.jpg","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>开启《逆向工程核心原理》的第二部分，冲冲冲！</li>\n</ul>\n<h1 id=\"0x13-PE文件格式\"><a href=\"#0x13-PE文件格式\" class=\"headerlink\" title=\"0x13 PE文件格式\"></a>0x13 PE文件格式</h1><h2 id=\"13-1-介绍\"><a href=\"#13-1-介绍\" class=\"headerlink\" title=\"13.1 介绍\"></a>13.1 介绍</h2><p>PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。</p>\n<p>PE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE文件的扩展形式。</p>\n<h2 id=\"13-2-PE文件格式\"><a href=\"#13-2-PE文件格式\" class=\"headerlink\" title=\"13.2 PE文件格式\"></a>13.2 PE文件格式</h2><p><img src=\"/../re-engineer-core-principle-02/image-20231022165245769.png\" alt=\"image-20231022165245769\"></p>\n<p><strong>Q1：notpad头</strong></p>\n<p>严格地说，OBJ(对象)文件之外的所有文件都是可执行的。</p>\n<p>DLL、SYS文件等虽然不能直接在Shell(Explorer.exe)中运行，但可以使用其他方法(调试器、服务等)执行。</p>\n<p>图13-1是notepad.exe文件的起始部分也是PE文件的头部分(PE header)。notepad.exe文件运行需要的所有信息就存储在这个PE头中，<strong>如何加载到内存、从何处开始运行、运行中需要的DLL有哪些、需要多大的栈&#x2F;堆内存等，大量信息以结构体形式存储在PE头中</strong>。换言之，学习PE文件格式就是学习PE头中的结构体。</p>\n<p><strong>Q2：PE加载到内存</strong></p>\n<ul>\n<li><p>从DOS头(DOS header)到节区头(Section header)是PE头部分，其下的节区合称PE体。</p>\n</li>\n<li><p><strong>文件中使用偏移 (offset)，内存中使用VA ( Virtual Address，虚拟地址)来表示位置</strong>。</p>\n</li>\n<li><p>文件加载到内存时，情况就会发生变化(节区的大小、位置等)。文件的内容一般可分为代码(.text)、数据(.data)、资源(.rsrc)节，分别保存。</p>\n</li>\n<li><p>各节区头定义了各节区在文件或内存中的大小、位置、属性等.PE头与各节区的尾部存在一个区域，称为NULL填充(NULL padding)。计算机中，为了提高处理文件、内存、网络包的效率，使用<strong>最小基本单位</strong>这一概念，PE文件中也类似。</p>\n</li>\n<li><p>文件&#x2F;内存中节区的<strong>起始位置应该在各文件&#x2F;内存最小单位的倍数位置上</strong>，空白区域将用NULL填充(看图13-2，可以看到各节区起始地址的截断都遵循一定规则)。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022165721636.png\" alt=\"image-20231022165721636\"></p>\n<h3 id=\"13-2-2-VA-RVA\"><a href=\"#13-2-2-VA-RVA\" class=\"headerlink\" title=\"13.2.2 VA&amp;RVA\"></a>13.2.2 VA&amp;RVA</h3><p>VA指的是进程虚拟内存的绝对地址，RVA(Relative Virtual Address，相对虚拟地址)指从某个基准位置(Image Base)开始的相对地址。</p>\n<p>VA与RVA满足下面的换算关系：<br>                                            <code>RVA+ImageBase=VA</code><br>PE头内部信息大多以RVA形式存在。原因在于:（就是修改位置用相对地址会比较简单）</p>\n<ul>\n<li>PE文件(主要是DLL)加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件(DLL)。此时必须通过重定位(Relocation将其加载到其他空白的位置，若PE头信息使用的是VA，则无法正常访问。</li>\n<li>因此使用RVA来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息不会出现任何问题。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>32位WindowsOS中各进程分配有4GB的虚拟内存，因此进程中VA值的范围是00000000~FFFFFFFF。</p>\n<p>1 字节（Byte）&#x3D; 8 位（Bit）<br>1 千字节（KB）&#x3D; 1024 字节<br>1 兆字节（MB）&#x3D; 1024 KB<br>1 吉字节（GB）&#x3D; 1024 MB<br>1 太字节（TB）&#x3D; 1024 GB</p>\n</p>\n</div>\n<h2 id=\"13-3-PE头\"><a href=\"#13-3-PE头\" class=\"headerlink\" title=\"13.3 PE头\"></a>13.3 PE头</h2><p>PE头中有许多结构体，主要学的是这些结构体</p>\n<h3 id=\"13-3-1-DOS头\"><a href=\"#13-3-1-DOS头\" class=\"headerlink\" title=\"13.3.1 DOS头\"></a>13.3.1 DOS头</h3><p><strong>Q1：为什么会有DOS头</strong></p>\n<ul>\n<li>微软创建PE文件格式时，人们正广泛使用DOS文件，所以微软充分考虑了PE文件对DOS文件的兼容性。</li>\n<li>其结果是在PE头的最前面添加了个IMAGE DOS HEADER结构体，用来扩展已有的DOS EXE头。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022171456586.png\" alt=\"image-20231022171456586\"></p>\n<p><code>WORD</code> 是一个用于表示无符号的16位整数类型。</p>\n<p>在结构体中两个重要的成员：</p>\n<ul>\n<li>e_magic：DOS签名(signature，4D5A&#x3D;&gt;ASCII值“MZ”)。</li>\n<li>e_lfanew：指示NT头的偏移(根据不同文件拥有可变值)。</li>\n</ul>\n<p>所有PE文件在开始部分(e_magic)都有DOS签名(“MZ”)。e_lfanew值指向NT头所在位置NT头的名称为IMAGE_NT_HEADERS，后面将会介绍)。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>签名叫MZ的原因是DOS可执行文件是一个叫MZ的人开发的。</p>\n\n</div>\n<p>打开上面的notpad.exe，查看IMAGE_DOS_HEADER结构体</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022174436849.png\" alt=\"image-20231022174436849\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107113111950.png\" alt=\"image-20231107113111950\"></p>\n<ul>\n<li>开始是<code>4D5A</code></li>\n<li>e_lfanew的值是000000E0</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>Intel系列的CPU采用小端序，因此是逆序存储</p>\n</p>\n</div>\n<h3 id=\"13-3-2-DOS存根\"><a href=\"#13-3-2-DOS存根\" class=\"headerlink\" title=\"13.3.2 DOS存根\"></a>13.3.2 DOS存根</h3><p>DOS存根(stub)在DOS头下方，是个可选项，且大小不固定(即使没有DOS存根，文件也能正常运行)。</p>\n<p>DOS存根由代码与数据混合而成，图13-4显示的就是notepad.exe的DOS存根。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022175051080.png\" alt=\"image-20231022175051080\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107112738826.png\" alt=\"image-20231107112738826\"></p>\n<ul>\n<li>上图中文件偏移40~4D区域为16位的汇编指令。</li>\n<li>32位的Windows OS中不会运行该命令(由于被识别为PE文件，所以完全忽视该代码)。</li>\n<li>在DOS环境中运行Notepad.exe文件，或者使用DOS调试器(debug.exe)运行它，可使其执行该代码(在dos环境中，不认识PE文件格式，所以被识别为DOS EXE文件)</li>\n</ul>\n<p>把40~4D区域在dos中转换为汇编代码</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022175222862.png\" alt=\"image-20231022175222862\"></p>\n<ul>\n<li>代码非常简单，在画面中输出字符串“This program cannot be run in DOS mode”后就退出。</li>\n<li>换言之，notepad.exe文件虽然是32位的PE文件，但是带有MS-DOS兼容模式，可以在DOS环境中运行，执行DOS EXE代码，输出“This program cannot be run in DOS mode”后终止。</li>\n<li>灵活使用该特性可以在一个可执行文件(EXE)中创建出另一个文件，它在DOS与Widows中都能运行(在DOS环境中运行16位DOS代码，在Windows环境中运行32位Windows代码)。</li>\n<li>如前所述，DOS存根是可选项，开发工具应该支持它(VB、VC+、Dephi等默认支持DOS存根)。</li>\n</ul>\n<h3 id=\"13-3-3-NT头（IMAGE-NT-HEADERS）\"><a href=\"#13-3-3-NT头（IMAGE-NT-HEADERS）\" class=\"headerlink\" title=\"13.3.3 NT头（IMAGE_NT_HEADERS）\"></a>13.3.3 NT头（IMAGE_NT_HEADERS）</h3><p><img src=\"/../re-engineer-core-principle-02/image-20231022175401610.png\" alt=\"image-20231022175401610\"></p>\n<p>IMAGE_NT_HEADERS结构体由3个成员组成，</p>\n<ul>\n<li>第一个成员为PE签名(Signature)结构体，其值为50450000h(“PE”00)</li>\n<li>另外两个成员分别为文件头(FileHeader)与可选头(OptionalHeader)结构体。</li>\n</ul>\n<p>该结构体的大小为F8</p>\n<h4 id=\"PE-Signature\"><a href=\"#PE-Signature\" class=\"headerlink\" title=\"PE Signature\"></a>PE Signature</h4><ul>\n<li>pe签名</li>\n</ul>\n<h4 id=\"NT头：文件头（FileHeader）\"><a href=\"#NT头：文件头（FileHeader）\" class=\"headerlink\" title=\"NT头：文件头（FileHeader）\"></a>NT头：文件头（FileHeader）</h4><p>文件头是表现文件大致属性的IMAGE_FILE_HEADER结构体。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022180014442.png\" alt=\"image-20231022180014442\"></p>\n<p>IMAGE_FILE_HEADER结构体有4种重要成员：</p>\n<p><strong>Machine</strong></p>\n<p>每个CPU都拥有唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C。</p>\n<p><strong>NumberOfSections</strong></p>\n<p>前面提到过，PE文件把代码、数据、资源等依据属性分类到各节区中存储。</p>\n<p>NumberOfSections用来指出文件中存在的节区数量。</p>\n<p>该值一定要大于0，且当定义的节区数量与实际节区不同时，将发生运行错误。</p>\n<p><strong>SizeOfOptionalHeader</strong><br>IMAGE_NT_HEADER结构体的最后一个成员为IMAGE_OPTIONAL_HEADER32结构体。</p>\n<ul>\n<li>SizeOfOptionalHeader成员用来指出IMAGE OPTIONAL HEADER32结构体的长度。</li>\n<li>IMAGE_OPTIONAL_HEADER32结构体由C语言编写而成，故其大小已经确定。</li>\n<li>但是Windows的PE装载器需要查看IMAGE_FILE_HEADER的SizeOfOptionalHeader值，从而识别出IMAGE_OPTIONAL_HEADER32结构体的大小。</li>\n</ul>\n<p>PE32+格式的文件中使用的是IMAGE OPTIONAL HEADER64结构体，而不是IMAGE_OPTIONAL_HEADER32结构体。2个结构体的尺寸是不同的，所以需要在SizeOfOptionalHeader成员中明确指出结构体的大小。<br>:::tip<br>借助IMAGE_DOS_HEADER的elfanew 成员和IMAGE_FILE_HEADER的SizeOfOptionalHeader 成员，可以创建出一种脱离常规的 PE文件(PE Patch)(也有人称之为“麻花”PE文件)。</p>\n<p>:::</p>\n<p><strong>Characteristics</strong></p>\n<p>该字段用于标识文件的属性，文件是否是可运行的形态、是否为DLL文件等信息，以bit OR形式组合起来。<br>以下是定义在winnt.h文件中的Characteristics值(请记住0002h与2000h这两个值)。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022203550509.png\" alt=\"image-20231022203550509\"></p>\n<p><strong>Q：另外，PE文件中Characteristics的值有可能不是0002h吗(不可执行)?</strong></p>\n<ul>\n<li>是的，确实存在这种情况。比如类似*.obj的object文件及resource DLL文件等。</li>\n</ul>\n<p><strong>TimeDateStamp</strong></p>\n<p>最后讲一下IMAGE_FILE_HEADER的TimeDateStamp成员。该成员的值不影响文件运行，用来记录编译器创建此文件的时间。但是有些开发工具(VB、VC++)提供了设置该值的工具，而有此开发工具(Delphi)则未提供(随所用选项的不同而不同)。</p>\n<p><em>Image_File_Header</em></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022203847388.png\" alt=\"image-20231022203847388\"></p>\n<h4 id=\"OptionalHeader\"><a href=\"#OptionalHeader\" class=\"headerlink\" title=\"OptionalHeader\"></a>OptionalHeader</h4><p>IMAGE_OPTIONAL_HEADER32是PE头结构体中最大的。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023220120698.png\" alt=\"image-20231023220120698\"></p>\n<p>重点关注上图中红点标记的</p>\n<p><strong>Magic</strong></p>\n<ul>\n<li>为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为10B;</li>\n<li>为IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B。</li>\n</ul>\n<p><strong>AddressOfEntryPoint</strong></p>\n<ul>\n<li>AddressOfEntryPoint持有EP的RVA值。该值指出程序最先执行的代码起始地址，相当重要</li>\n</ul>\n<p><strong>ImageBase</strong></p>\n<ul>\n<li><p>进程虚拟内存的范围是O~FFFFFFFF(32位系统)。PE文件被加载到如此大的内存中时,ImageBase指出文件的优先装入地址。</p>\n</li>\n<li><p>EXE、DLL文件被装载到用户内存的0 -  7FFFFFFF中</p>\n</li>\n<li><p>SYS文件被载入内核内存的80000000~FFFFFFFF中。</p>\n</li>\n<li><p>一般而言，使用开发工具(VB&#x2F;VC++&#x2F;Delphi)创建好EXE文件后，其ImageBase的值为00400000，DLL文件的ImageBase值为10000000(当然也可以指定为其他值)。</p>\n</li>\n<li><p>执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint。</p>\n</li>\n</ul>\n<p><strong>SectionAlignment</strong>，<strong>FileAlignment</strong></p>\n<ul>\n<li>PE文件的Body部分划分为若干节区，这些节存储着不同类别的数据。</li>\n<li>FileAlignment指定了节区在磁盘文件中的最小单位，而SectionAlignment则指定了节区在内存中的最小单位(一个文件中FileAlignment与SectionAlignment可能相同，也可能不同)。</li>\n<li>磁盘文件或内存的节区大小中必定为FileAlignment与SectionAlignment的值整数倍。</li>\n</ul>\n<p><strong>SizeOflmage</strong></p>\n<ul>\n<li><p>加载PE文件到内存时，SizeOfImage指定了PE Image在虚拟内存中所占空间的大小。</p>\n</li>\n<li><p>一般而言，文件的大小与加载到内存中的大小是不后的(节区头中定义了各节装载的位置与占有内存的大小，后面会讲到)。</p>\n</li>\n</ul>\n<p><strong>SizeOfHeader</strong></p>\n<ul>\n<li>SizeOfHeader用来指出整个PE头的大小。该值也必须是FileAlignment的整数倍。第一节区所在位置与SizeOfHeader距文件开始偏移的量相同。</li>\n</ul>\n<p><strong>Subsystem</strong></p>\n<ul>\n<li>该Subsystem值用来区分系统驱动文件(<code>*.sys</code>)与普通的可执行文件(<code>*exe,*dll</code>)。Subsystem成员可拥有的值如表13-2所示</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022205035130.png\" alt=\"image-20231022205035130\"></p>\n<p><strong>NumberOfRvaAndSizes</strong></p>\n<ul>\n<li><p>NumberOfRvaAndSizes用来指定DataDirectory(IMAGE_OPTIONAL_HEADER32结构体的最后一个成员)数组的个数。</p>\n</li>\n<li><p>虽然结构体定义中明确指出了数组个数为IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16)，但是PE装载器通过看</p>\n<p>NumberOfRvaAndSizes值来识别数组大小</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231201172853285.png\" alt=\"image-20231201172853285\"></p>\n</li>\n<li><p>换言之，数组大小也可能不是16。</p>\n</li>\n</ul>\n<p><strong>DataDirectory</strong></p>\n<p>DataDirectory是由IMAGE_DATA_DIRECTORY结构体组成的数组，数组的每项都有被定义的值。代码13-7列出了各数组项。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022205433760.png\" alt=\"image-20231022205433760\"></p>\n<ul>\n<li><p>将此处所说的Directory想成某个结构体数组即可。希望各位重点关注标红的EXPORT&#x2F;IMPORT&#x2F;RESOURCE、TLS Direction。</p>\n</li>\n<li><p>特别需要注意的是IMPORT与EXPORT Directory，它们是PE头中非常重要的部分，后面会单独讲解。</p>\n</li>\n<li><p>其余部分不怎么重要，大致了解一下即可。</p>\n</li>\n</ul>\n<p><em>IMAGE_OPTIONAL_HEADER</em></p>\n<h3 id=\"13-3-6-节区头\"><a href=\"#13-3-6-节区头\" class=\"headerlink\" title=\"13.3.6 节区头\"></a>13.3.6 节区头</h3><p>节区头中定义了各节区属性。</p>\n<p><strong>Q1：前面提到过，PE文件中的code(代码)data(数据)resource(资源)等按照属性分类储在不同节区，这是为什么？</strong></p>\n<p>把PE文件创建成多个节区结构的好处是，这样可以保证程序的安全性。</p>\n<ul>\n<li>若把code与data放在一个节区中相互纠缠(实际上完全可以这样做)很容易引发安全问题，即使忽略过程的烦琐。</li>\n<li>假如向字符串data写数据时，由于某个原因导致溢出(输入超过缓冲区大小时)那么其下的code(指令)就会被覆盖，应用程序就会崩溃。</li>\n<li>因此PE文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为“节区”的地方，然后需要把各节区属性记录在节区头中。</li>\n<li>节区属性中有文件&#x2F;内存的起始位置、大小、访问权限等。</li>\n<li>换言之，需要为每个code&#x2F;data&#x2F;resource分别设置不同的特性、访问权限等，如表13-3所示。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210220054.png\" alt=\"image-20231022210220054\"></p>\n<p><em>IMAGE_SECTION_HEADER</em></p>\n<p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210410897.png\" alt=\"image-20231022210410897\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210527217.png\" alt=\"image-20231022210527217\"></p>\n<p>VirtualAddress与PointerToRawData不带有任何值，分别由(定义在IMAGE_OPTIONAL_HEADER32中的)SectionAlignment与FileAlignment确定。</p>\n<p>VirtualSize与SizeOfRawData一般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。</p>\n<p>Characterisitics由代码13-10中显示的值组合(bitOR)而成</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210716607.png\" alt=\"image-20231022210716607\"></p>\n<p>最后谈谈Name字段。Name成员不像C语言中的字符串一样以NULL结束，并且没有“必须使用ASCII值”的限制。PE规范未明确规定节区的Name，所以可以向其中放入任何值，甚至可以填充NULL值。所以节区的Name仅供参考，不能保证其百分之百地被用作某种信息(数据节区的名称也可叫做code)。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>讲解 PE 文件时经常出现“映像”(Image)这一术语，希望各位牢记。PE 文件加载到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的 PE与内存中的 PE具有不同形态。<strong>将装载到内存中的形态称为“映像”以示区别</strong>，使用这一术语能够很好地区分二者。</p>\n\n</div>\n<h2 id=\"13-4-RVA-to-RAW\"><a href=\"#13-4-RVA-to-RAW\" class=\"headerlink\" title=\"13.4 RVA to RAW\"></a>13.4 RVA to RAW</h2><p>理解了节区后，下面讲解有关PE文件从磁盘到内存映射的内容。PE文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的别这种映射一般称为RVA to RAW，方法如下。</p>\n<ul>\n<li>查找RVA所在节区。</li>\n<li>使用简单的公式计算文件偏移(RAW)</li>\n</ul>\n<p>根据IMAGES_SECTION_HEADER结构体，换算公式如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">RAW- PointerToRawData &#x3D; RVA- VirtualAddress\n&#x2F;&#x2F;RVA 内存地址\n&#x2F;&#x2F;RAW 文件偏移\n&#x2F;&#x2F;PointerToRawData 磁盘文件节区的起始位置\n&#x2F;&#x2F;virtualAddress 内存中节区起始地址<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Quiz</strong></p>\n<ol>\n<li><p>RVA&#x3D;5000时，File Offset&#x3D;？</p>\n<p>根据前面的图，5000在.text节区，所以5000-1000+0400&#x3D;4400</p>\n</li>\n<li><p>RVA&#x3D;ABA8时，FIle Offset&#x3D;？</p>\n<p>由内存图可知，在.data区。ABA8-9000+7C00&#x3D;97A8</p>\n<p>但是97A8已经在.rsrc区了，所以无法定义。</p>\n</li>\n</ol>\n<h2 id=\"13-5-IAT\"><a href=\"#13-5-IAT\" class=\"headerlink\" title=\"13.5 IAT\"></a>13.5 IAT</h2><p>刚开始学习PE头时，最难过的一关就是IAT (Import Address Table，导人地址表)。</p>\n<p>IAT保存的内容与Windows操作系统的核心进程、内存、DLL结构等有关。</p>\n<p><strong>IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数</strong>。</p>\n<ul>\n<li>IAT和INT都是IMAGE_IMPORT_DESRIPTOR结构体的属性</li>\n</ul>\n<h3 id=\"13-5-1-DLL\"><a href=\"#13-5-1-DLL\" class=\"headerlink\" title=\"13.5.1 DLL\"></a>13.5.1 DLL</h3><p>DLL：Dynamic Linked Library 动态链接库</p>\n<p>16位的操作系统中没有DLL。</p>\n<p><strong>Q1：在16位操作系统中使用Printf()函数，编译器怎么做？</strong></p>\n<ul>\n<li>编译器会先从C库中读取相应函数的二进制代码，然后插人(包含到)应用程序。</li>\n<li>也就是可执行文件中包含着printf()函数的二进制代码。</li>\n</ul>\n<p><strong>Q2：但是这样显然有问题</strong></p>\n<ul>\n<li>Windows OS支持多任务，若仍<strong>采用这种包含库的方式</strong>，会非常没有效率。</li>\n<li>Windows操作系统使用了数量庞大的库函数(进程、内存、窗口、消息等)来支持32位的Windows环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费(当然磁盘空间的浪费也不容小觑)。</li>\n</ul>\n<p><strong>Q3：WindowsOS设计者们根据需要引人了DLL这一概念</strong></p>\n<ul>\n<li>不要把库包含到程序中，单独组成DLL文件，需要时调用即可。</li>\n<li>内存映射技术使加载后的DLL代码、资源在多个进程中实现共享。</li>\n<li>更新库时只要替换相关DLL文件即可，简便易行。</li>\n</ul>\n<p><strong>Q4：加载DLL的方式</strong></p>\n<ul>\n<li>显式链接(EXplicit Linking)：程序使用DLL时加载，使用完毕释放内存</li>\n<li>隐式链接(Implicit Linking)：程序开始时一同加载DLL，程序终止时再释放占用的内存</li>\n</ul>\n<p>使用Ollydbg打开notepad.exe来查看IAT</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023213104827.png\" alt=\"image-20231023213104827\"></p>\n<p>这里看到了调用CreateFileW的代码，该函数位于kernel32.dll中</p>\n<p>这里发现使用CreateFileW时，并没有直接调用，而是先调用01001104这个地址。<strong>所有API都采用这种方式</strong></p>\n<p><strong>Q5：为什么不直接调用？</strong></p>\n<p>原因1：</p>\n<ul>\n<li>事实上，notepad.exe程序的制作者编译(生成)程序时，并不知道该notepad.exe序要运行在哪种Windows(9X\\2K、XP、Vista 7)、哪种语言(ENG、JPN、KOR等)、哪种服务包( ServicePack)下。</li>\n<li>上面列举出的所有环境中，kernel32.dl的版本各不相同，CreateFilew()函数的位置(地址)也不相同。</li>\n<li>为了确保在所有环境中都能正常调用CreateFilew()函数，编译器准备了要保存CreateFilew()函数实际地址的位置(01001104)并仅记下CALL DWORD PTR DS:1004404形式的指令。</li>\n<li>执行文件时，PE装载器将CreateFilew()函数的地写到01001104位置。</li>\n</ul>\n<p>原因2：</p>\n<ul>\n<li>DLL文件的ImageBase值一般为10000000。</li>\n<li>当某个程序使用a.dll与b.dll时，PE装载器先把a.dll装载到内存的1000000 (ImageBase)处</li>\n<li>然后尝试把b.dll也装载到该处。但是由于该地址处已经装载了a.dll，所以PE装载器查找其他空白的内存空间 (ex:3E000000)，然后将b.dll装载进去。</li>\n<li>这就是所谓的<em><strong>DLL重定位</strong></em>，它使我们无法对实际地址硬编码。</li>\n<li>另一个原因在于，PE头中表示地址时不使用绝对地址(VA)，而是相对地址RVA。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>实际操作中无法保证DLL一定会被加载到PE头内指定的ImageBase处。但是EXE文件(生成进程的主体)却能准确加载到自身的 ImageBase 中，因为它拥有自己的虚拟空间。</p>\n</p>\n</div>\n<h3 id=\"13-5-2-IMAGE-IMPORT-DESCRIPTOR\"><a href=\"#13-5-2-IMAGE-IMPORT-DESCRIPTOR\" class=\"headerlink\" title=\"13.5.2 IMAGE_IMPORT_DESCRIPTOR\"></a>13.5.2 IMAGE_IMPORT_DESCRIPTOR</h3><p>IMAGE_IMPORT_DESCRIPTOR结构体中记录着PE文件要导人哪些库文件。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>Import:导入，向库提供服务(函数)。<br>Export:导出，从库向其他PE文件提供服务(函数)。</p>\n\n</div>\n<p><strong>Q1：IMAGE_IMPORT_DESCRIPTOR结构体</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023214322180.png\" alt=\"image-20231023214322180\"></p>\n<ul>\n<li><p>执行一个普通程序时往往需要导入多个库，导人多少库就存在多少个IMAGE_IMPORT_DESCRIPTOR结构体</p>\n</li>\n<li><p>这些结构体形成了数组，且结构体数组最后以NULL结构体结束。</p>\n</li>\n<li><p>IMAGE IMPORTDESCRIPTOR中的重要成员如表13-5所示(拥有全部RVA值)。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023214429358.png\" alt=\"image-20231023214429358\"></p>\n</li>\n<li><p>PE头中提到的“Table”即指数组。</p>\n</li>\n<li><p>INT与IAT是长整型(4个字节数据类型)数组，以NULL结束(未另外明确指出大小)。</p>\n</li>\n<li><p>INT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针(有时IAT也拥有相同的值 )。</p>\n</li>\n<li><p>INT与IAT的大小应相同。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023215150684.png\" alt=\"image-20231023215150684\"></p>\n<p>上图中，INT与IAT的各元素同时指向相同地址，但是也有很多情况下不一样。</p>\n<p><strong>Q2：PE装载器把导入函数输入至IAT的顺序</strong></p>\n<ol>\n<li>读取IID的Name成员，获取库名称字符串”kernel32.dll”</li>\n<li>装载相应库。LoadLibrary(“kernel32.dll”）</li>\n<li>读取IID的OriginalFirstThunk成员，获取INT地址</li>\n<li>逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址(RVA)</li>\n<li>使用IMAGE_IMPORT_BY_NAME的Hint(ordinal)或Name项，获取相应函数的起始地址GetProcAddress(“GetCurrentThreadld”)</li>\n<li>读取IID的FirstThunk(IAT)成员，获得IAT地址</li>\n<li>将上面获得的函数地址输入相应IAT数组值。</li>\n<li>重复以上步骤4~7，直到INT结束(遇到NULL时)。</li>\n</ol>\n<h3 id=\"13-5-3-使用notepad-exe练习\"><a href=\"#13-5-3-使用notepad-exe练习\" class=\"headerlink\" title=\"13.5.3 使用notepad.exe练习\"></a>13.5.3 使用notepad.exe练习</h3><p><strong>Q1：IMAGE_IMPORT_DESCRIPTOR结构体数字在PE文件中的哪个部分？</strong></p>\n<ul>\n<li>它不在PE头而在PE体中，但查找其位置的信息在PE头中。</li>\n<li>IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress的值即是IMAGE_IMPORT_DESCRIPTOR结构体数组的起始地址(RVA值)。</li>\n<li><strong>IMAGE_IMPORT_DESCRIPTOR结构体数组也被称为IMPORT Directory Table</strong></li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>这是前面optionalHeader中关于DataDirectory的笔记。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023215856399.png\" alt=\"image-20231023215856399\"></p>\n</p>\n</div>\n<p><strong>Q2：IMAGE_OPTIONAAL_HEADER32.DataDirectory结构体数组</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023223710913.png\" alt=\"image-20231023223710913\"></p>\n<ul>\n<li>由于RVA是7604，可以计算得到文件偏移位6A04</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023223756765.png\" alt=\"image-20231023223756765\"></p>\n<ul>\n<li>粗线框是数组的第一个元素，也就是IMAGE_IMPORT_DESCRIPTOR</li>\n<li>数组的最后是NULL结构体</li>\n</ul>\n<p><strong>Q3：粗线框中IMAGE_IMPORT_DESCRIPTOR结构体的各个成员</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023223921819.png\" alt=\"image-20231023223921819\"></p>\n<ol>\n<li><em><strong>库名称Name</strong></em></li>\n</ol>\n<ul>\n<li><p>Name是一个字符串指针，它指向导入函数所属的库文件名称。在图13-14的文件偏移6EAC(RVA:7AAC-&gt;RAW:6EAC)处看到字符串comdlg32.dIl</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224052826.png\" alt=\"image-20231023224052826\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><em><strong>OriginalFirstThunk–(INT)</strong></em></li>\n</ol>\n<ul>\n<li><p>INT是一个包含导人函数信息 (Ordinal，Name)的结构体指针数组。</p>\n</li>\n<li><p>只有获得了这些信息,才能在加载到进程内存的库中准确求得相应函数的起始地址(请参考后面EAT的讲解)。</p>\n</li>\n<li><p>跟踪OriginalFirstThunk成员(RVA:7990—&gt;RAW:6D90)。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224215873.png\" alt=\"image-20231023224215873\"></p>\n</li>\n<li><p>图13-15是INT，由地址数组形式组成(数组尾部以NULL结束 )。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224336711.png\" alt=\"image-20231023224336711\"></p>\n</li>\n<li><p><strong>每个地址值分别指向IMAGE_IMPORT_BY_NAME结构体</strong>(参考图13-11)。</p>\n</li>\n<li><p>跟踪数组的第一个值7A7A(RVA)进入该地址，可以看到导入的API函数的名称字符串。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><em><strong>IMAGE_IMPORT_BY_NAME</strong></em></li>\n</ol>\n<ul>\n<li>RVA:7A7A即为RAW:6E7A。</li>\n<li>文件偏移6E7A最初的2个字节值(000F)为Ordinal，是库中函数的固有编号。</li>\n<li>Ordinal的后面为函数名称字符串PageSetupDlgW</li>\n<li>同C语言一样，字符串末尾以TerminatingNULL[‘\\0’]结束)</li>\n</ul>\n<p><strong>Q：这个值是干啥用的？</strong></p>\n<ul>\n<li><p>也就是上面INT数组的每个指针，都指向了一个IMAGE_IMPORT_BY_NAME结构体</p>\n</li>\n<li><p>参考下图，数组的第一个元素指向函数的Ordinal值000F后面函数的名称为PageSetupDlgW。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224546789.png\" alt=\"image-20231023224546789\"></p>\n<ol start=\"4\">\n<li><em><strong>FirstThunk-IAT（Import Access Table）</strong></em></li>\n</ol>\n<ul>\n<li>根据上表，IAT的RVA：12C4也就是RAW：6C4</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024141550654.png\" alt=\"image-20231024141550654\"></p>\n<ul>\n<li>图13-17中文件偏移6C4~6EB区域即为IAT数组区域，对应于comdlg32.dll库。</li>\n<li>它与INT类似由结构体指针数组组成，且以NULL结尾。</li>\n<li>IAT的第一个元素值被硬编码为<code>76324906</code>，该值无实际意义，notepad.exe文件加载到内存时准确的地址值会取代该值。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024142227720.png\" alt=\"image-20231024142227720\"></p>\n<p>由于notepad.exe的ImageBase值为01000000，所以config32.dll.PageSetypDlgW是实际地址就是010012C4</p>\n<h2 id=\"13-6-EAT\"><a href=\"#13-6-EAT\" class=\"headerlink\" title=\"13.6 EAT\"></a>13.6 EAT</h2><p><strong>Q1：为什么有这个呢？</strong></p>\n<ul>\n<li>前面的IAT是为了记录程序中使用了哪些库的哪些函数，也就是一个程序内部的事</li>\n<li>但是如果多个程序要使用库呢？</li>\n</ul>\n<p>Windows操作系统中，“库”是为了方便其他程序调用而集中包含相关函数的文件(DLL&#x2F;SYS)。</p>\n<p>Win32API是最具代表性的库，其中的kernel32.dll文件被称为最核心的库文件。</p>\n<p><strong>EAT是一种核心机制它使不同的应用程序可以调用库文件中提供的函数。</strong></p>\n<p>也就是说，只有<strong>通过EAT才能准确求得从相应库中导出函数的起始地址</strong>。</p>\n<p>与前面讲解的IAT一样，PE文件内的特定结构体(IMAGE_EXPORT_DIRECTORY)保存导出信息，且PE文件中仅有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>用来说明IAT的IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且拥有多个成员。这样是因为PE文件可以同时导入多个库。</p>\n\n</div>\n<p><strong>Q2：IMAGE_EXPORT_DIRECTORY在PE中的哪个位置？</strong></p>\n<ul>\n<li><p>可以在PE文件的PE头中查找到IMAGE_EXPORT_DIRECTORY结构体的位置。</p>\n</li>\n<li><p>IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress值即是IMAGE_EXPORT_DIRECTORY结构体数组的起始地址(也是RVA的值)。<br>图13-20显示的是kernel32dll文件的IMAGE_OPTIONAL_HEADER32.DataDirectory[0]</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143316972.png\" alt=\"image-20231024143316972\"></p>\n</li>\n<li><p>这个深色框中的内容是DataDirectory[0]，也就是IMAGE_EXPORY_DIRECTORY</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143459178.png\" alt=\"image-20231024143459178\"></p>\n</li>\n<li><p>由于RVA值为262C，文件偏移为1A2C。</p>\n</li>\n</ul>\n<h3 id=\"13-6-1-IMAGE-EXPORT-DIRECTORY\"><a href=\"#13-6-1-IMAGE-EXPORT-DIRECTORY\" class=\"headerlink\" title=\"13.6.1 IMAGE_EXPORT_DIRECTORY\"></a>13.6.1 IMAGE_EXPORT_DIRECTORY</h3><p> IMAGE_EXPORT_DIRECTORY的结构体如下：</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143752225.png\" alt=\"image-20231024143752225\"></p>\n<p>其中的重要成员就是上图中的红框</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143704255.png\" alt=\"image-20231024143704255\"></p>\n<p> IMAGE_EXPORT_DIRECTORY的结构体和整个EAT结构：</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143831948.png\" alt=\"image-20231024143831948\"></p>\n<p><strong>Q：上面PE导入函数至IAT中提到了<em>获取函数的地址</em></strong></p>\n<hr>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024144501442.png\" alt=\"image-20231024144501442\"></p>\n<hr>\n<p>这个API GetProcAddress()就是使用EAT来获取指定函数的地址</p>\n<p><strong>Q：那如何获取？</strong></p>\n<p>GetProcAddress()操作原理</p>\n<ul>\n<li>利用AddressOfNames成员转到函数名称数组</li>\n<li>在·</li>\n<li>利用AddressOfNameOrdinals成员，转到orinal数组</li>\n<li>在ordinal数组中通过name_index查找相应ordinal值。</li>\n<li>利用AddressOfFunctions成员转到“函数地址数组”(EAT)。</li>\n<li>在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址。</li>\n</ul>\n<h3 id=\"13-6-2-使用kernel32-dll练习\"><a href=\"#13-6-2-使用kernel32-dll练习\" class=\"headerlink\" title=\"13.6.2 使用kernel32.dll练习\"></a>13.6.2 使用kernel32.dll练习</h3><p><strong>目标：从kernel32.dll文件中查找AddAtomW函数</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024150238015.png\" alt=\"image-20231024150238015\"></p>\n<p>深色部分就是IMAGE_EXPORT_DIRECTORY</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024150427544.png\" alt=\"image-20231024150427544\"></p>\n<ol>\n<li><strong>函数名称数组</strong></li>\n</ol>\n<ul>\n<li>AddressOfNames成员的值为RVA&#x3D;353C，即RAW&#x3D;293C。使用Hex Editor查看该地址</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024150625450.png\" alt=\"image-20231024150625450\"></p>\n<ul>\n<li>数组元素个数为NumberOfNames，3BA</li>\n</ul>\n<ol start=\"2\">\n<li><strong>查找指定函数名称</strong></li>\n</ol>\n<ul>\n<li><p>要查找的函数名称字符串为AddAtomW。</p>\n</li>\n<li><p>只要在图13-23中找到RVA数组第三个元素的值(RVA:4BBD-&gt;RAW:3FBD) 即可。也就是粗线框中的</p>\n</li>\n<li><p>进入相应地址就会看到“AddAtomw”字符串，如图13-24所示。</p>\n</li>\n<li><p>此时“AddAtomw”函数名即是图13-23数组的第三个元素，数组索引为2。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024151618743.png\" alt=\"image-20231024151618743\"></p>\n</li>\n</ul>\n<p>我理解这个过程应该就是字符串匹配。</p>\n<ol start=\"3\">\n<li><strong>Ordinal数组</strong></li>\n</ol>\n<ul>\n<li><p>通过上面的数组索引获得ordinal的值。</p>\n</li>\n<li><p>AddressOfNameOrdinal的值是3824。深色部分是由多个2字节组成的数组，<strong>ordinal数组的各元素大小为2bytes</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024152259346.png\" alt=\"image-20231024152259346\"></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><strong>ordinal</strong></li>\n</ol>\n<ul>\n<li>根据索引是2，获取<code>0002</code></li>\n</ul>\n<ol start=\"5\">\n<li><strong>函数地址数组EAT</strong></li>\n</ol>\n<ul>\n<li><p>查找函数的实际地址，AddressOfFunctions成员的值是1A54</p>\n</li>\n<li><p>通过ordinal的值2，找到实际的函数地址，<code>000326F1</code></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024152630389.png\" alt=\"image-20231024152630389\"></p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>AddAtomW函数地址</strong></li>\n</ol>\n<ul>\n<li><p>此时已经得到<code>Orinal=2 AddressOfFunctions=00326F1 </code></p>\n</li>\n<li><p>kernel32.dll的<code>lmageBase=7C7D0000</code>。因此AddAtomw函数的实际地址(VA)为<code>ImageBase+AddressOfFunctions(RVA)=7C8026F1</code></p>\n</li>\n<li><p>使用OllyDbg查看地址，即可发现该函数</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024153021278.png\" alt=\"image-20231024153021278\"></p>\n</li>\n</ul>\n<p><strong>上述的整个过程就是GetProcAddress() API获取函数地址的方法</strong></p>\n<h2 id=\"关于IAT-import-和EAT-export\"><a href=\"#关于IAT-import-和EAT-export\" class=\"headerlink\" title=\"关于IAT(import)和EAT(export)\"></a>关于IAT(import)和EAT(export)</h2><p>Import：记录导入当前程序中的函数，相对于当前程序而言</p>\n<p>Export：导出，从库中导出，相对于库而言，记录了从库中导出函数实际的地址。</p>\n<h2 id=\"13-7-高级PE\"><a href=\"#13-7-高级PE\" class=\"headerlink\" title=\"13.7 高级PE\"></a>13.7 高级PE</h2><h3 id=\"13-7-1-PEView-exe\"><a href=\"#13-7-1-PEView-exe\" class=\"headerlink\" title=\"13.7.1 PEView.exe\"></a>13.7.1 PEView.exe</h3><p><a href=\"http://www.magma.ca/~wjr/PEView.zip\">http://www.magma.ca/~wjr/PEView.zip</a></p>\n<p>好像失效了</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024153338466.png\" alt=\"image-20231024153338466\"></p>\n<ul>\n<li>在这里可以看到各种PE头的信息，很直观</li>\n</ul>\n<h3 id=\"13-7-2-Patched-PE\"><a href=\"#13-7-2-Patched-PE\" class=\"headerlink\" title=\"13.7.2 Patched PE\"></a>13.7.2 Patched PE</h3><p>只要文件符合PE规范就是PE文件，因此可以做出一些很有创意的PE文件。</p>\n<p><a href=\"http://www.phreedom.org/solar/code/tinype\">http://www.phreedom.org/solar/code/tinype</a></p>\n<p>这个网站记录了PE头和tiny pe的制作过程，下载下来分析对提高逆向很有帮助。</p>\n<h2 id=\"13-8-小结\"><a href=\"#13-8-小结\" class=\"headerlink\" title=\"13.8 小结\"></a>13.8 小结</h2><ul>\n<li>PE规范只是一种标准规范(许多东西都没使用)</li>\n</ul>\n<p><strong>Q：前面的讲解中提到,执行文件加载到内存时会根据Imagebase确定地址,那么2个notepad程序同时运行时Imagebase都是10000000，它们会侵占彼此的空间区域，不是这样吗?</strong></p>\n<ul>\n<li>生成进程(加载到内存)时，OS会单独为它分配4GB大小的虚拟内存。</li>\n<li>虚拟内存与实际物理内存是不同的。同时运行2个notepad时，各进程分别在自身独有的虚拟内存空间中。</li>\n<li>所以它们彼此不会重叠。这是由OS来保障的。因此，即使它们的Imagebase一样也完全没问题。</li>\n</ul>\n<p><strong>Q：如何只用HexEditor识别出DOS存根、IMAGE_FILE_HEADER等部分呢?</strong></p>\n<ul>\n<li>根据PE规范，<strong>IMAGE_DOS_HEADER的大小为40个字节，DOS存根区域为40~DE签名区域</strong>。</li>\n<li>紧接在PE签名后的是IMAGE_FILE_HEADER，且该结构体的大小是已知的，所以也可以在Hex Editor中表示出来</li>\n<li>也就是说，解析PE规范中定义的结构体及其成员的含义即可区分出各组成部分(多看几次就熟悉了)。</li>\n</ul>\n<p><strong>Q：IMAGE_FILE_HEADER的TimeDateStamp值为0x47918EA2，在PEView中显示为2008&#x2F;01&#x2F;19,05:46:10 UTC，如何才能这样解析出来呢?</strong></p>\n<ul>\n<li>使用C语言标准库中提供的ctime()函数,即可把4个字节的数字转换为实际的日期字符串。</li>\n</ul>\n<p><strong>Q：PE映像是什么?</strong></p>\n<ul>\n<li>PE映像这一术语是微软创建PE结构时开始使用的。一般是指PE文件运行时加载到内存中的形态。</li>\n<li>PE头信息中有一个SizeOflmage项，该项指出了PE映像所占内存的大小。</li>\n<li>当然这个大小与文件的大小不一样。PE文件格式妙处之一就在于，其文件形态与内存形态是不同的。</li>\n</ul>\n<p><strong>Q：不太明白EP这一概念</strong></p>\n<ul>\n<li>EP地址是程序中最早被执行的代码地址。CPU会最先到EP地址处，并从该处开始依次执行指令。</li>\n</ul>\n<p><strong>Q：用PEView打开记事本程序(notepad.exe)后，发现各节区的起始地址、大小等与示例中的不同，为什么会这样呢?</strong></p>\n<ul>\n<li>notepad.exe文件随OS版本的不同而不同(其他所有系统文件也如此)。</li>\n<li>换言之，不同版本的OS下，系统文件的版本也是不同的。</li>\n<li>微软可能修改了代码、更改了编译选项，重新编译后再发布。</li>\n</ul>\n<p><strong>Q：对图13-9及其下面的Quiz不是很理解。如何知道RVA 5000包含在哪个节区呢?</strong></p>\n<ul>\n<li>图13-9是以节区头信息为基础绘制的。图(或节区头信息)中的.text节区是指VA 01001000~01009000区域</li>\n<li>转换为RVA形式后对应于RVA 1000~9000区域(即减去Imagebase值的01000000)。</li>\n<li>由此可知，RVA5000包含在text节区中。</li>\n</ul>\n<p><strong>Q：查看某个文件时，发现其IMAGE_IMPORT_DESCRIPTOR结构体的OriginalFirstThunk成员为NULL，跟踪FirstFThunk成员，看到一个实际使用的API的名称字符串数组(INT)。跟踪FirstThunk应该看到的是IAT而不是INT，这是怎么回事呢?</strong></p>\n<ul>\n<li>PE装载器无法根据OriginalFirstThunk查找到API名称字符串数组(INT)时，就会尝试用FirstThunk查找。</li>\n<li>本来FirstThunk含义为IAT，但在实际内存中被实际的API函数地址覆盖掉了(此时INT与IAT虽然是相同区域，但仍然能够正常工作)。</li>\n</ul>\n<p><strong>Q：EAT讲解中提到的Ordinal究竟是什么?</strong></p>\n<ul>\n<li><p>把Ordinal想成导出函数的固有编号就可以了。</p>\n</li>\n<li><p>有时候某些函数对外不会公开函数名，仅公开函数的固有编号(Ordinal)。导入并使用这类函数时，要先用Ordinal查找到相应函数的地址后再调用。</p>\n</li>\n<li><p>比如下面(1)通过函数名称来获取函数地址，(2)则使用函数的Ordinal来取得函数地址。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(1)pFunc&#x3D;GetProcAddress(“TestFunc”);\n(2)pFunc&#x3D;GetProcAddress(5);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>这一章学的内容一定要反复看，反复理解。</li>\n<li>虚拟内存的概念，好久之前学的操作系统，已经完全忘记了。</li>\n</ul>\n<h1 id=\"0x14-运行时压缩\"><a href=\"#0x14-运行时压缩\" class=\"headerlink\" title=\"0x14 运行时压缩\"></a>0x14 运行时压缩</h1><p>运行时压缩器(Run-Time Packer)</p>\n<h2 id=\"14-1-数据压缩\"><a href=\"#14-1-数据压缩\" class=\"headerlink\" title=\"14.1 数据压缩\"></a>14.1 数据压缩</h2><p>经过压缩的文件若能100%恢复，则称该压缩为<strong>无损压缩(Lossless Data Compression)</strong></p>\n<p>若不能恢复原状，则称该压缩为<strong>有损压缩(Loss Data Compression)</strong></p>\n<h3 id=\"14-1-2-有损压缩\"><a href=\"#14-1-2-有损压缩\" class=\"headerlink\" title=\"14.1.2 有损压缩\"></a>14.1.2 有损压缩</h3><p>有损压缩允许压缩文件(数据)时损失一定信息，以此换取高压缩率。</p>\n<p>压缩多媒体文件(jpg、mp3、mp4)时，大部分都使用这种有损压缩方式。</p>\n<p>从压缩特性来看，有损压缩的数据解压缩后不能完全恢复原始数据。人类的肉眼与听觉几乎无法察觉到这些多媒体文件在压缩中损失的数据。经过有损压缩后，虽然压缩文件与原文件(从数据层面上看存在差异，但重要的是人们几乎区分不出这种微小的差别。</p>\n<p>以mp3文件为例，mp3的核心算法通过删除超越人类听觉范围(20~20000Hz)的波长区段来缩减(不需要的)数据大小。</p>\n<h2 id=\"14-2-运行时压缩器\"><a href=\"#14-2-运行时压缩器\" class=\"headerlink\" title=\"14.2 运行时压缩器\"></a>14.2 运行时压缩器</h2><p>运行时压缩器是针对可执行(PE Portable Executable)文件而言的。</p>\n<p>可执行文件内部含有解压缩代码，文件在运行瞬间于内存中解压缩后执行。</p>\n<p>运行时压缩文件也是PE文件，<strong>内部含有原PE文件与解码程序</strong>。</p>\n<p>在程序的EP代码中执行解码程序，同时在内存中解压缩后执行。</p>\n<p><strong>我个人觉得这句话有点问题，这里的解码应该就是解压缩。</strong></p>\n<p><strong>Q：表14-1列出了运行时压缩与普通ZIP压缩的不同点。</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172119574.png\" alt=\"image-20231024172119574\"></p>\n<ul>\n<li>与普通压缩器相比，运行时压缩器的一个明显不同是<strong>PE文件的可运行性</strong>。</li>\n</ul>\n<p><strong>Q：压缩器和保护器</strong></p>\n<ul>\n<li>把普通PE文件创建成运行时压缩文件的实用程序称为“压缩器”(Packer)，经反逆向(Anti-Reversing)技术特别处理的压缩器称为保护器(Protector)。</li>\n</ul>\n<h3 id=\"14-2-1-压缩器\"><a href=\"#14-2-1-压缩器\" class=\"headerlink\" title=\"14.2.1 压缩器\"></a>14.2.1 压缩器</h3><p>PE压缩器是指可执行文件的压缩器，准确一点应该称为“运行时压缩器”，它是PE文件的专用压缩器。</p>\n<p><strong>Q：使用压缩器的目的</strong></p>\n<ul>\n<li>便于传输</li>\n<li>隐藏代码</li>\n</ul>\n<p><strong>Q：压缩器种类</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172315794.png\" alt=\"image-20231024172315794\"></p>\n<h3 id=\"14-2-2-保护器\"><a href=\"#14-2-2-保护器\" class=\"headerlink\" title=\"14.2.2 保护器\"></a>14.2.2 保护器</h3><p><strong>Q：保护器的概念和作用</strong></p>\n<ul>\n<li>PE保护器是一类保护PE文件免受代码逆向分析的实用程序。</li>\n<li>它们不像普通的压缩器一样仅对PE文件进行运行时压缩，而应用了多种防止代码逆向分析的技术(反调试、反模拟、代码混乱、多态代码、垃圾代码、调试器监视）等。</li>\n<li>这类保护器使压缩后的PE文件尺寸反而比源文件要大一些，调试起来非常难。</li>\n<li>分析保护器的关键是<strong>OEP(OrigialEntry Point，原始人口点)</strong></li>\n</ul>\n<p><strong>Q：保护器种类</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172624533.png\" alt=\"image-20231024172624533\"></p>\n<h2 id=\"14-3-运行时压缩测试\"><a href=\"#14-3-运行时压缩测试\" class=\"headerlink\" title=\"14.3 运行时压缩测试\"></a>14.3 运行时压缩测试</h2><p>可以用upx压缩notepad.exe</p>\n<p><strong>Q：运行时压缩的特点</strong></p>\n<ul>\n<li>运行时压缩后的文件尺寸明显减小了(67584-&gt;48128)。若使用ZIP压缩，则文件大小缩减为35231。</li>\n<li>也就是说，运行时的压缩率要比普通的ZIP压缩低。</li>\n<li>这是<strong>由于其压缩后得到的是PE文件，需要添加PE头，并且还要放入解压缩代码</strong></li>\n</ul>\n<p><strong>Q：比较notepad.exe和notepad_upx.exe文件</strong></p>\n<p>该图是从PE视角进行比较</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172855851.png\" alt=\"image-20231024172855851\"></p>\n<ul>\n<li>PE头的大小一样(0~400h)。h表示16进制</li>\n<li>节区名称改变(“text”一&gt;“UPX0”，“.data”一&gt;“UPX1”)</li>\n<li>第一个节区的RawDataSize&#x3D;0(文件中的大小为0)。</li>\n<li>EP位于第二个节区(原notepad.exe的EP在第一个节区)</li>\n<li>资源节区(.rsrc)大小几乎无变化。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>右边这个notepad_upx展示的地址是Pointer to Raw Data，也就是在磁盘中的地址，用PEview查看如下所示。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101211924505.png\" alt=\"image-20231101211924505\"></p>\n<p><strong>Q：upx0的RawDataSize为0，upx为何要创建这个空的节区呢？</strong></p>\n<p>使用PEview查看notepad_upx.exe</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024173157434.png\" alt=\"image-20231024173157434\"></p>\n<ul>\n<li>这里发现Virtual Size，也就是内存中的大小是106000，而Size of Raw Data，磁盘中的大小是00000000</li>\n<li>也就是说在内存中解压缩时，会把文件中压缩状态的源代码解压到(内存中的)第一个节区。</li>\n<li>也就是在文件状态下，最开始解压缩代码和压缩的源代码都在第二个节区，文件运行时首先执行解压缩代码，把处于压缩状态的源代码解压到第一个节区。</li>\n<li>解压过程结束后即运行源文件的EP代码。</li>\n</ul>\n<h1 id=\"0x15-调试upx压缩的notepad程序\"><a href=\"#0x15-调试upx压缩的notepad程序\" class=\"headerlink\" title=\"0x15 调试upx压缩的notepad程序\"></a>0x15 调试upx压缩的notepad程序</h1><p>原notepad.exe的源码</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101211336143.png\" alt=\"image-20231101211336143\"></p>\n<p>在<code>010073B2</code>地址处调用了GetModuleHandleA()API，获取notepadexe程序的ImageBase。</p>\n<p>在010073B4与010073C0地址处比较MZ与PE签名。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101212319459.png\" alt=\"image-20231101212319459\"></p>\n<h2 id=\"15-2-notepad-upx-exe的EP代码\"><a href=\"#15-2-notepad-upx-exe的EP代码\" class=\"headerlink\" title=\"15.2 notepad_upx.exe的EP代码\"></a>15.2 notepad_upx.exe的EP代码</h2><p>因为UPX1的RVA是11000，ImageBase是01000000。</p>\n<p>此时打开后,EP地址为<code>01015330</code>，该处就是第二个节区的末端部分。实际压缩的notepad源代码在EP地址上方</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101212448083.png\" alt=\"image-20231101212448083\"></p>\n<p><strong>Q：首先看开始时候的指令</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101212544677.png\" alt=\"image-20231101212544677\"></p>\n<p>汇编指令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">PUSHAD  &#x2F;&#x2F;是一个x86汇编指令，用于将通用寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI）的值依次压入堆栈中。该指令的作用\t\t  \n\t\t&#x2F;&#x2F;是保存这些寄存器的值，以便在稍后的代码中使用或恢复。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>首先使用PUSHAD命令将EAX~EDI寄存器的值保存到栈</li>\n<li>然后分别把第二个节区的起始地址(01011000)与第一个节区的起始地址(01001000)设置到ESI与EDI寄存器。</li>\n</ul>\n<p>汇编指令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">LEA EDI, DWORD PTR DS:[ESI+FFFF0000]\n加载有效地址（Load Effective Address）指令，用于将指定内存地址的有效地址计算结果存储到目标寄存器 EDI 中\n\n&quot;LEA&quot; 是加载有效地址的指令。\n&quot;EDI&quot; 是目标寄存器，表示要将有效地址计算结果存储到 EDI 寄存器中。\n&quot;DWORD PTR&quot; 是一个操作数大小指示符，表示要操作的是一个双字（32位）数据。\n&quot;DS:[ESI+FFFF0000]&quot; 是指定的内存地址，表示要对 DS:ESI+FFFF0000 指向的内存地址进行有效地址计算。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<ul>\n<li>UPX文件第一个节区仅存在于内存。该处即是解压缩后保存源文件代码的地方。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101212813402.png\" alt=\"image-20231101212813402\"></p>\n<ul>\n<li>调试时像这样同时设置ESI与EDI，<strong>就能预见从ESI所指缓冲区到EDI所指缓冲区的内存发生了复制。</strong></li>\n<li>此时从Source( ESI)读取数据，解压缩后保存到Destination EDI</li>\n<li><strong>我们的目标是跟踪全部UPX EP代码，并最终找到原notepad的EP代码，也就是OEP</strong></li>\n</ul>\n<h2 id=\"15-3-跟踪UPX文件\"><a href=\"#15-3-跟踪UPX文件\" class=\"headerlink\" title=\"15.3 跟踪UPX文件\"></a>15.3 跟踪UPX文件</h2><p>当跟踪数量很多的代码时，遵循的法则是<code>遇到循环(Loop)时，先了解作用再跳出</code></p>\n<h3 id=\"15-3-1-Ollydbg的跟踪命令\"><a href=\"#15-3-1-Ollydbg的跟踪命令\" class=\"headerlink\" title=\"15.3.1 Ollydbg的跟踪命令\"></a>15.3.1 Ollydbg的跟踪命令</h3><p><img src=\"/../re-engineer-core-principle-02/image-20231101213104026.png\" alt=\"image-20231101213104026\"></p>\n<h3 id=\"15-3-2-循环-1\"><a href=\"#15-3-2-循环-1\" class=\"headerlink\" title=\"15.3.2 循环#1\"></a>15.3.2 循环#1</h3><ul>\n<li>在EP代码处执行AnimateOver(Ctrl+F8)命令，开始跟踪代码。可以看到光标快速上下移动</li>\n</ul>\n<p>汇编指令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MOV AL,BYTE PTR DS:[EDX] &#x2F;&#x2F;类型转换为BYTE，是8位，AL是AX(16位寄存器)的低8位\nINC EDX &#x2F;&#x2F;给EDX加1\nDEC EDX &#x2F;&#x2F;给EDX减1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Q：开始跟踪后，会遇到一个短循环，暂停(F7)查看</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101213823172.png\" alt=\"image-20231101213823172\"></p>\n<ul>\n<li><p>红框内是循环，ECX记录了循环次数,表明这个循环会执行36B次</p>\n</li>\n<li><p>该循环的作用是把EDX的值给EDI，EDX从<code>01001001</code>开始，也就是upx0的起始位置</p>\n</li>\n<li><p>这个节区只在内存中存在，反正内容都是Null</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101214030357.png\" alt=\"image-20231101214030357\"></p>\n</li>\n<li><p>遇到这样的循环应该跳出来，在<code>010153E6</code>地址处按F2设置断点，之后F9跳出循环</p>\n</li>\n</ul>\n<h3 id=\"15-3-3-循环-2\"><a href=\"#15-3-3-循环-2\" class=\"headerlink\" title=\"15.3.3 循环#2\"></a>15.3.3 循环#2</h3><hr>\n<p><strong>Q：此时又遇到了一个很大的循环，该怎么办？</strong></p>\n<ul>\n<li>看这个循环的起始地址和结束地址，起始地址为<code>534E</code>，结束地址为<code>53FD</code></li>\n</ul>\n<p>汇编代码</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">JB SHORT 01015348\n    \n&quot;Jump if Below&quot; 的缩写，它是一条条件跳转指令。这意味着该指令会根据标志寄存器中的条件进行跳转<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<ul>\n<li>该循环是正式的解压缩循环，先从ESI所指的第二个节区(UPX1)地址中依次读取值，经过适当的运算解压缩后，将值写入EDI所指的第一个节区(UPX0)地址</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101215446433.png\" alt=\"image-20231101215446433\"></p>\n<ul>\n<li><p>观察循环的最大地址的指令是<code>010153FD</code>，那就在它的下一条指令<code>01015402</code>处设置断点此时让程序运行到该处</p>\n</li>\n<li><p>此时在转储窗口中可以看到解压缩后的代码已经被写入第一个节区(UPX0)区域，原来这些区域是用null填充的</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101220623939.png\" alt=\"image-20231101220623939\"></p>\n</li>\n</ul>\n<h3 id=\"15-3-4-循环-3\"><a href=\"#15-3-4-循环-3\" class=\"headerlink\" title=\"15.3.4 循环#3\"></a>15.3.4 循环#3</h3><p><img src=\"/../re-engineer-core-principle-02/image-20231101221116790.png\" alt=\"image-20231101221116790\"></p>\n<ul>\n<li>这里是遇到的第三个循环</li>\n<li><strong>该段循环代码用于恢复源代码的CALL&#x2F;JMP指令(操作码:E8&#x2F;E9)</strong></li>\n<li>只要再设置好IAT,UPX解压缩就结束了</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">JNZ是x86汇编指令中的条件跳转指令，它的全称是&quot;Jump if Not Zero&quot;，表示在某个条件下，如果结果不为0，也就是零标志位不被设置时，则执行跳转操作。\n\n具体解释如下：\n\nJNZ：是条件跳转指令的助记符，它用于根据零标志位（ZF）的值来进行有条件的跳转。\n零标志位（ZF）：是一个标志位寄存器中的一个标志位，用于指示上一次运算结果是否为零。如果上一次运算结果为零，ZF被设置为1，否则为0。\nJNZ指令的操作步骤如下：\n\n如果ZF为0（上一次运算结果不为零），则执行跳转到指定的目标地址。\n如果ZF为1（上一次运算结果为零），则不执行跳转，继续顺序执行下一条指令。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>:::tip</p>\n<p>普通的运行时压缩，源文件将源文件代码、数据、资源解压缩之后，先设置好IAT再转到OEP。</p>\n</p>\n</div>\n<h3 id=\"15-3-5-循环-4\"><a href=\"#15-3-5-循环-4\" class=\"headerlink\" title=\"15.3.5 循环#4\"></a>15.3.5 循环#4</h3><p><img src=\"/../re-engineer-core-principle-02/image-20231101221343182.png\" alt=\"image-20231101221343182\"></p>\n<ul>\n<li>该部分是设置IAT的循环。在<code>01015436</code>地址处设置<code>EDI=01014000</code>，它指向upx1区域，该区域中保存着原notepad.exe调用的API函数名称的字符串</li>\n</ul>\n<p><strong>Q：是如何设置IAT的呢？</strong></p>\n<ul>\n<li>UPX压缩原notepad.exe文件时，它会分析其IAT，提取出程序中调用的API名称列表，形成API名称字符串。</li>\n<li>用这些API名称字符串调用上图中<code>01015467</code>地址处的GetProcAddress()函数，获取API的起始地址</li>\n<li>然后把API地址输入EBX寄存器所指的原notepad.exe的IAT区域。</li>\n<li>该过程会反复进行至API名称字符串结束，最终恢复原notepad.exe的IAT。</li>\n<li>notepad.exe全部解压缩完成后，应该将程序的控制返回到OEP处。图15-9显示的就是跳转到OEP的代码。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>总结一下：upx在压缩时候，会形成一个API列表。恢复的时候，会逐个取出，取出一个调用GetProcAddress()函数获取它的地址，再放到IAT区域，依次对每个API执行这个操作。</p>\n<p>感觉这个过程和PE装载器加载IAT差不多</p>\n\n</div>\n<p><strong>Q：程序执行到最后</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101223051804.png\" alt=\"image-20231101223051804\"></p>\n<ul>\n<li>在<code>010154B8</code>处跳转到<code>0100739D</code>指令处，就是开头<code>0x15</code>中打开notepad.exe的EP地址</li>\n<li><code>01054AD</code>处的<code>POPAD</code>用于把寄存器恢复成原来的状态</li>\n</ul>\n<h2 id=\"15-4-快速查找UPX-OEP的方法\"><a href=\"#15-4-快速查找UPX-OEP的方法\" class=\"headerlink\" title=\"15.4 快速查找UPX OEP的方法\"></a>15.4 快速查找UPX OEP的方法</h2><h3 id=\"15-4-1-在POPAD指令后的JMP指令处设置断点\"><a href=\"#15-4-1-在POPAD指令后的JMP指令处设置断点\" class=\"headerlink\" title=\"15.4.1 在POPAD指令后的JMP指令处设置断点\"></a>15.4.1 在POPAD指令后的JMP指令处设置断点</h3><ul>\n<li>UPX压缩器的特征之一是,其EP代码被包含在<code>PUSHAD POPAD</code>指令之间。</li>\n<li>并且，跳转到OEP代码的JMP指令紧接着出现在<code>POPAD</code>指令之后。</li>\n<li>只要在JMP指令处设置好断点，运行后就能直接找到OEP</li>\n</ul>\n<h3 id=\"15-4-2-在栈中设置硬件断点\"><a href=\"#15-4-2-在栈中设置硬件断点\" class=\"headerlink\" title=\"15.4.2 在栈中设置硬件断点\"></a>15.4.2 在栈中设置硬件断点</h3><p><img src=\"/../re-engineer-core-principle-02/image-20231101225345903.png\" alt=\"image-20231101225345903\"></p>\n<ul>\n<li><p>在执行完<code>PUSHAD</code>指令后，此时栈的状态是，当前地址是<code>000DFF58</code></p>\n</li>\n<li><p>在左侧找到<code>000DFF58</code>这个地址，选中Hex dump的第一块，右键</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101225755624.png\" alt=\"image-20231101225755624\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101225646562.png\" alt=\"image-20231101225646562\"></p>\n</li>\n<li><p>然后运行程序，程序就会停在<code>JMP OEP  </code>附近</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231101230025944.png\" alt=\"image-20231101230025944\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><ul>\n<li>硬件断点是CPU支持的断点，最多可以设置4个。</li>\n<li>与普通断点不同的是，设置断点的指令执行完成后才暂停调试</li>\n<li>在这种状态下运行，程序就会边解压缩边执行代码，在执行<code>POPAD</code>的瞬间访问设置有硬件断点的<code>000DFF58</code>地址，然后暂停调试。其下方即是跳转到OEP的JMP指令</li>\n</ul>\n</p>\n</div>\n<h2 id=\"15-5-小结\"><a href=\"#15-5-小结\" class=\"headerlink\" title=\"15.5 小结\"></a>15.5 小结</h2><p><strong>Q：解压缩(Unpacking)过程中打开Dump窗口，若不重新设置IAT就会出现初始化错误。这到底是怎么一回事?</strong></p>\n<ul>\n<li>比如，运行UPX文件后转储时，IAT中存在(对应于当前系统的)准确的API地址。但是INT却处于损坏状态。</li>\n<li>PE装载器使用INT中的API名称字符串(LoadLibrary()&#x2F;GetProcAddress())来获取实际API地址，并将它们记录到IAT。</li>\n<li>由于INT已经损坏，该过程中自然会发生错误。</li>\n</ul>\n<p><strong>Q：如何知道ESI、EDI所指的地址对应于哪个节区的地址呢?我想知道该如何才能识别出恢复IAT的代码以及解码循环。</strong></p>\n<ul>\n<li>内存复制命令中，ESI指Source，EDI指Destination。</li>\n<li>所以使用PEView(或者OllyDbg的内存映射窗口)查看ESI EDI所指的地址，即可知道它们对应的节区。</li>\n<li>从反复调用GetProcAddress()函数可知正在恢复IAT</li>\n</ul>\n<h1 id=\"0x16-基址重定位表\"><a href=\"#0x16-基址重定位表\" class=\"headerlink\" title=\"0x16 基址重定位表\"></a>0x16 基址重定位表</h1><p>PE文件在重定位时会用到基址重定位表</p>\n<h2 id=\"16-1-PE重定位\"><a href=\"#16-1-PE重定位\" class=\"headerlink\" title=\"16.1 PE重定位\"></a>16.1 PE重定位</h2><p><strong>Q：为什么会有PE重定位？</strong></p>\n<ul>\n<li>向进程的虚拟内存加载PE文件(EXE&#x2F;DLL&#x2F;SYS)时文件会被加载到PE头的ImageBase所指的地址处。</li>\n<li>若加载的是DLL(SYS)文件，且在ImageBase位置处已经加载了其他DLL(SYS)文件，那么PE装载器就会将其加载到其他未被占用的空间。</li>\n<li>这就涉及PE文件重定位的问题，PE重定位是<strong>指PE文件无法加载到ImageBase所指位置,而是被加载到其他地址时发生的一系列的处理行为。</strong></li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231029212544299.png\" alt=\"image-20231029212544299\"></p>\n<h3 id=\"16-1-2-EXE\"><a href=\"#16-1-2-EXE\" class=\"headerlink\" title=\"16.1.2 EXE\"></a>16.1.2 EXE</h3><p><strong>Q：EXE加载的优先级</strong></p>\n<ul>\n<li>创建好进程后，EXE文件会首先加载到内存，所以在EXE中无须考虑重定位的问题。</li>\n<li>但是Windows Vista之后的版本引人了ASLR安全机制，每次运行EXE文件都会被加载到随机地址，这样大大增强了系统安全性。</li>\n</ul>\n<p><strong>Q：DLL不会重定位</strong></p>\n<ul>\n<li>ASLR(Address Space Layout Randomization)机制也适用于DLL&#x2F;SYS文件。</li>\n<li>对于各OS的主要系统DLL，微软会根据不同版本分别赋予不同的ImageBase 地址。</li>\n<li><strong>同一系统的 kerel32dl、user32.dll等会被加载到自身固有的ImageBase</strong>，所以，系统的DLL实际不会发生重定位问题。<ul>\n<li>在P207有一个表，详细说明了这个问题</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"16-2-PE重定位时执行的操作\"><a href=\"#16-2-PE重定位时执行的操作\" class=\"headerlink\" title=\"16.2 PE重定位时执行的操作\"></a>16.2 PE重定位时执行的操作</h2><p>使用Ollydbg运行notepad.exe程序</p>\n<p><strong>Q：这里是程序刚打开时的位置，也就是EP代码部分？</strong></p>\n<ul>\n<li><p>在Windows7的ASLR机制下，程序被加载到<code>00A23000</code>地址处。</p>\n</li>\n<li><p>每次在Ollydbg中重启notepad.exe，地址值就会随加载地址的不同而改变。</p>\n</li>\n<li><p>像这样<strong>硬编码在程序中的内存地址随当前加载地址变化而改变的处理过程就是PE重定位</strong>。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204152233249.png\" alt=\"image-20231204152233249\"></p>\n</li>\n</ul>\n<ol>\n<li><p>用PE View打开notepad.exe，可以看到Image Base是<code>01000000</code></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231029222526599.png\" alt=\"image-20231029222526599\"></p>\n</li>\n<li><p>该文件(不是指磁盘中的文件)中与实际显示的硬编码地址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">文件：(ImageBase:01000000)    进程内存(加载地址: 00A20000)\n\t010010FC\t\t\t\t\t00A210FC<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>PEView打开的Notepad.exe中硬编码的地址以ImageBase(01000000)为基准。生成notepad.exe文件时，由于无法预测程序被实际加载到哪个地址，所以记录硬编码地址时以ImageBase为基准。但在运行的瞬间，经过 PE重定位后，<strong>这些地址全部以加载地址为基准变换</strong>，最后程序得以正常执行。</p>\n\n</div>\n<h2 id=\"16-3-PE重定位操作\"><a href=\"#16-3-PE重定位操作\" class=\"headerlink\" title=\"16.3 PE重定位操作\"></a>16.3 PE重定位操作</h2><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>这一部分截图的地址可能和上一部分不一样，换电脑运行的</p>\n</p>\n</div>\n<p><strong>Q：windows的PE装载器进行PE重定位时的操作基本原理</strong></p>\n<ul>\n<li>在应用程序中查找硬编码的地址位置。读</li>\n<li>取值后，减去ImageBase(VA-&gt;RVA)</li>\n<li>加上实际加载地址(RVA-&gt;VA)</li>\n</ul>\n<p><strong>Q：上个Q中最关键的是查找硬编码地址的位置</strong></p>\n<ul>\n<li>查找过程中会用到PE文件内部的Relocation Table(重定位表)</li>\n<li>它是记录硬编码地址偏移(位置)的列表，(重定位表是在PE文件构建过程(编译&#x2F;链接)中提供的)。</li>\n<li>通过重定位表查找，其实就是指根据PE头的“<strong>基址重定位表</strong>”项进行的查找</li>\n</ul>\n<h3 id=\"16-3-1-基址重定位表\"><a href=\"#16-3-1-基址重定位表\" class=\"headerlink\" title=\"16.3.1 基址重定位表\"></a>16.3.1 基址重定位表</h3><p><strong>Q：基址重定位表的位置</strong></p>\n<ul>\n<li>基址重定位表地址位于PE头的DataDirectory数组的第六个元素(数组索引为5)</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106143046267.png\" alt=\"image-20231106143046267\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106145454972.png\" alt=\"image-20231106145454972\"></p>\n<h3 id=\"16-3-2-IMAGE-BASE-RELOACTION结构体\"><a href=\"#16-3-2-IMAGE-BASE-RELOACTION结构体\" class=\"headerlink\" title=\"16.3.2 IMAGE_BASE_RELOACTION结构体\"></a>16.3.2 IMAGE_BASE_RELOACTION结构体</h3><p><strong>Q：基址重定位表的含义</strong></p>\n<ul>\n<li>上图的的基址重定位表中罗列了硬编码地址的偏移(位置)。</li>\n<li>读取这张表就能获得准确的硬编码地址偏移。</li>\n<li>基址重定位表是IMAGE_BASE_RELOCATION结构体数组。</li>\n</ul>\n<p><strong>Q：IMAGE_BASE_RELOCATION结构体定义</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106143901216.png\" alt=\"image-20231106143901216\"></p>\n<ul>\n<li>IMAGE_ BASE_RELOCATION结构体的第一个成员为VirtualAddress，它是一个基准地址(BaseAddress)，实际是RVA值。</li>\n<li>第二个成员为SizeOfBlock，指重定位块的大小。</li>\n<li>最后一项TypeOffset数组不是结构体成员，而是以注释形式存在的，表示在该结构体之下会出现WORD类型的数组，并且该数组元素的值就是硬编码在程序中的地址偏移。</li>\n</ul>\n<h3 id=\"16-3-3-基址重定位表的分析方法\"><a href=\"#16-3-3-基址重定位表的分析方法\" class=\"headerlink\" title=\"16.3.3 基址重定位表的分析方法\"></a>16.3.3 基址重定位表的分析方法</h3><p><strong>Q：基址重定位表</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106144348957.png\" alt=\"image-20231106144348957\"></p>\n<ul>\n<li>由IMAGE_BASE_RELOCATION结构体的定义可知，VirtualAddress成员(基准地址)的值为1000，SizeOfBlock成员的值为150。</li>\n<li>表16-2中显示的TypeOffest数组的基准地址(起始地址)为RVA 1000，块的总大小为150(这些块按照基准地址分类，以数组形式存在)。块的末端显示为0。</li>\n<li>TypeOffset值为2个字节(16位)大小，是由4位的Type与12位的Offset合成的。</li>\n</ul>\n<p><strong>Q：比如TypeOffset值为3420，解析如下表所示。</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106144641791.png\" alt=\"image-20231106144641791\"></p>\n<ul>\n<li>高4位用作Type<ul>\n<li>PE文件中常见的值为3(IMAGE_REL_BASED_HIGHLOW)</li>\n<li>64位的PE+文件中常见值为A(IMAGE_REL_BASED_DIR64)</li>\n</ul>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>在恶意代码中正常修改文件代码后，有时要修改指向相应区域的重定位表(<strong>为了略去PE装载器的重定位过程，常常把Type值修改为0</strong>(IMAGE_REL BASED_ABSOLUTE))。</p>\n\n</div>\n<ul>\n<li><p>低4位是真正的位移，该位移值基于Virtual Address的偏移。程序中硬编码地址的偏移使用下面的等式换算：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">VirtualSize(1000) + Offset(420)&#x3D;1420(RVA)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<p><strong>Q：看一下RVA 1420处是否存在执行PE重定位操作的硬编码地址</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106145139976.png\" alt=\"image-20231106145139976\"></p>\n<ul>\n<li>这里notepad.exe被记载到<code>00AF0000</code>，</li>\n<li>该地址处存储着IAT地址(VA，AF10C4)。并且该值经过PE重定位而发生了变化。</li>\n<li>使用相同原理AF142D、AF1436地址的内容也都是硬编码到程序中的地址值，该偏移可以在表16-2中求得。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>TypeOffset项中指向位移的低12位拥有的最大地址值为 1000。为了表示更大的地址，要添加1个与其对应的块，由于这些块以数组形式罗列，故称为重定位表。</p>\n<p><strong>说人话</strong></p>\n<ul>\n<li>相当于这个表里存的是映射，原来只能是从000-999，现在我可以扩展地址范围了，映射到其他地方去了</li>\n</ul>\n</p>\n</div>\n<h3 id=\"16-3-4-练习\"><a href=\"#16-3-4-练习\" class=\"headerlink\" title=\"16.3.4 练习\"></a>16.3.4 练习</h3><p><strong>Q：前提假设</strong></p>\n<ul>\n<li>运行Notepad.exe时，被加载到<code>00AF0000</code>，而不是ImageBase地址(01000000)那PE重定位是如何进行的呢？</li>\n</ul>\n<p><strong>Q：分析</strong></p>\n<ol>\n<li><p>查找程序中硬编码地址的位置</p>\n<ul>\n<li><p>程序中使用的硬编码地址的偏移(位置)可以通过基址重定位表查找到(此处使用上面求得的RVA1420)。</p>\n</li>\n<li><p>使用PEView查看RVA1420地址中的内容，如图16-9所示。</p>\n</li>\n<li><p>1420中存着的硬编码的值<code>010010C4</code></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106151400119.png\" alt=\"image-20231106151400119\"></p>\n</li>\n</ul>\n</li>\n<li><p>减去ImageBase</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">010010C4 - 01000000 &#x3D; 000010C4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>加上实际的地址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">000010C4 + 00AF0000 &#x3D; 00AF10C4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<ul>\n<li><p>对于程序内硬编码的地址(010010C4)PE装载器都做如上处理，根据实际加载的内存地址修正后，将得到的值(00AF10C4)覆盖到同一位置。</p>\n</li>\n<li><p>对一个IMAGE_BASE_RELOCATION结构体的所有TypeOffset都重复上述过程，且对与RVA1000~2000地址区域对应的所有硬编码地址都要进行PE重定位处理</p>\n</li>\n<li><p>若TypeOffset值为0，则表明一个IMAGE_BASE_RELOCATION结构体结束。</p>\n<ul>\n<li>也就是这个表中有很多个IMAGE_BASE_RELOCATION结构体，当有0的时候，表明这个IMAGE_BASE_RELOCATION结构体结束了，该下一个IMAGE_BASE_RELOCATION结构体了。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106152334577.png\" alt=\"image-20231106152334577\"></p>\n</li>\n<li><p>对重定位表中出现的所有IMAGE_BASE_RELOCATION结构体都重复上述处理后，就完成了对进程内存区域相应的所有硬编码地址的PE重定位。</p>\n</li>\n<li><p>重定位表以NULL结构体结束(即IMAGE_BASE_RELOCATION结构体成员的值全部为NULL)。</p>\n</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>我在基址重定位表中记录了virtualaddress，和typefileoffset</li>\n<li>每一个fileoffset的RVA都有一个硬编码的地址，对应一个文件，也就是按照ImageBase加载的时候，他应该的地址值<ul>\n<li>这个RVA通过virtualaddress + fileoffset后3位得到</li>\n</ul>\n</li>\n<li>那在重定位的时候，我用这个<code>存着的硬编码值-ImageBase+实际加载的地址</code>，就是重定位后的地址</li>\n</ul>\n<h1 id=\"0x17-从可执行文件中删除-reloc节区\"><a href=\"#0x17-从可执行文件中删除-reloc节区\" class=\"headerlink\" title=\"0x17 从可执行文件中删除.reloc节区\"></a>0x17 从可执行文件中删除.reloc节区</h1><h2 id=\"17-1-reloc节区\"><a href=\"#17-1-reloc节区\" class=\"headerlink\" title=\"17.1 .reloc节区\"></a>17.1 .reloc节区</h2><p><strong>Q：删除.exe文件的基址重定位表项</strong>。</p>\n<ul>\n<li><p>EXE形式的PE文件中，“基址重定位表”项对运行没什么影响。</p>\n</li>\n<li><p>实际上，将其删除后程序仍然正常运行(基址重定位表对DLL&#x2F;SYS形式的文件来说几乎是必需的)。</p>\n</li>\n<li><p>因为之前提到过，<code>.exe</code>是率先被加载的，不会存在重定位的情况</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106153253460.png\" alt=\"image-20231106153253460\"></p>\n</li>\n</ul>\n<p><strong>Q：.reloc节区</strong></p>\n<ul>\n<li><p>VC++中生成的PE文件的重定位节区名为.reloc，删除该节区后文件照常运行，且文件大小将缩减(实际上存在这种实用小程序)。</p>\n</li>\n<li><p>.reloc节区一般位于所有节区的最后</p>\n</li>\n<li><p>只使用PEView与Hex Editor(手动删除)就足够了。</p>\n</li>\n</ul>\n<h2 id=\"17-2-reloc-exe\"><a href=\"#17-2-reloc-exe\" class=\"headerlink\" title=\"17.2 reloc.exe\"></a>17.2 reloc.exe</h2><p><strong>Q：删除.reloc节区的步骤</strong></p>\n<ul>\n<li>整理.reloc节区头;</li>\n<li>删除.reloc节区</li>\n<li>修改IMAGE_FILE_HEADER</li>\n<li>修改IMAGE_OPTIONAL_HEADER</li>\n</ul>\n<h3 id=\"17-2-1-用0覆盖-reloc节区头\"><a href=\"#17-2-1-用0覆盖-reloc节区头\" class=\"headerlink\" title=\"17.2.1 用0覆盖.reloc节区头\"></a>17.2.1 用0覆盖.reloc节区头</h3><p><code>hex editor下载 https://blog.csdn.net/2301_77485708/article/details/132368259</code></p>\n<ul>\n<li>可以看到从RVA 270开始到297，<strong>为什么是297?</strong></li>\n<li>全部用0覆盖填充</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106155123603.png\" alt=\"image-20231106155123603\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231106155715829.png\" alt=\"image-20231106155715829\"></p>\n<ul>\n<li>现在用Ollydbg是无法打开的</li>\n</ul>\n<h3 id=\"17-2-2-删除-reloc节区\"><a href=\"#17-2-2-删除-reloc节区\" class=\"headerlink\" title=\"17.2.2 删除.reloc节区\"></a>17.2.2 删除.reloc节区</h3><p>从上图可以看出，文件中.reloc节区的起始偏移位<code>C000</code>，从这到末尾就是这个节区</p>\n<p>直接用Hex Editor的delete删除所有的数据</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107104947509.png\" alt=\"image-20231107104947509\"></p>\n<p>.reloc节区即被物理删除。但是由于尚未修改其他PE头信息，文件仍无法正常运行。</p>\n<p>下面开始修改相关PE头信息，使文件最终能够正常运行。</p>\n<h3 id=\"17-2-3-修改IMAGE-FILE-HEADER\"><a href=\"#17-2-3-修改IMAGE-FILE-HEADER\" class=\"headerlink\" title=\"17.2.3 修改IMAGE_FILE_HEADER\"></a>17.2.3 修改IMAGE_FILE_HEADER</h3><p><strong>Q：修改流程</strong></p>\n<ul>\n<li>首先要修改Number Of Sections，这个数字表示节区数量</li>\n<li>把5修改成4</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107105149196.png\" alt=\"image-20231107105149196\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107105307960.png\" alt=\"image-20231107105307960\"></p>\n<h3 id=\"17-2-4-修改IMAGE-OPTIONAL-HEADER\"><a href=\"#17-2-4-修改IMAGE-OPTIONAL-HEADER\" class=\"headerlink\" title=\"17.2.4 修改IMAGE_OPTIONAL_HEADER\"></a>17.2.4 修改IMAGE_OPTIONAL_HEADER</h3><p><strong>Q：修改整个映像的大小</strong></p>\n<ul>\n<li><p>删除.reloc节区后，(进程虚拟内存中)整个映像就随之减少相应大小。</p>\n</li>\n<li><p>映像大小值存储在IMAGE_OPTIONAL_HEADER-sizeofImage中，需要对其修改。</p>\n</li>\n<li><p>从图17-6可以看出，当前Size ofmage的值为11000。</p>\n</li>\n<li><p>要减去刚才删除的<code>.reloc</code>节区的值，才能让程序常运行。</p>\n</li>\n<li><p>从17.2.1的图可知，reloc节区的VirtualSize值为<code>E40</code>，将其根据Section Alignment扩展后变为1000。所以应该从Size ofImage减去1000</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107105629705.png\" alt=\"image-20231107105629705\"></p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107110345178.png\" alt=\"image-20231107110345178\"></p>\n<ul>\n<li>修改后的文件可以在ollydbg中打开</li>\n</ul>\n<p><strong>Q：关于数值选择内存还是磁盘中的问题</strong></p>\n<ul>\n<li>当文件在电脑桌面上时，是存储在磁盘上的</li>\n<li>当双击这个文件，操作系统会把文件加载到内存中。加载到内存中意味着文件的内容被读取到计算机的随机存取内存（RAM）中，以便应用程序可以更快地访问和处理文件的数据。</li>\n<li>所以上述我用peview打开.exe文件时，会把它读到内存中</li>\n</ul>\n<h1 id=\"0x18-Upack-PE文件头详细分析\"><a href=\"#0x18-Upack-PE文件头详细分析\" class=\"headerlink\" title=\"0x18 Upack PE文件头详细分析\"></a>0x18 Upack PE文件头详细分析</h1><p>UPack是一款PE文件的运行时压缩器。</p>\n<h2 id=\"18-2-使用UPack压缩notepad-exe\"><a href=\"#18-2-使用UPack压缩notepad-exe\" class=\"headerlink\" title=\"18.2 使用UPack压缩notepad.exe\"></a>18.2 使用UPack压缩notepad.exe</h2><p><strong>Q：打开upack压缩后的文件</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107111155145.png\" alt=\"image-20231107111155145\"></p>\n<ul>\n<li>发现无法正常读取PE头，并没有optional_header、section_header等信息</li>\n</ul>\n<h2 id=\"18-3-使用Stud-PE工具\"><a href=\"#18-3-使用Stud-PE工具\" class=\"headerlink\" title=\"18.3 使用Stud_PE工具\"></a>18.3 使用Stud_PE工具</h2><ul>\n<li><p>它可以分析Upack文件的PE头</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107111933224.png\" alt=\"image-20231107111933224\"></p>\n</li>\n</ul>\n<h2 id=\"18-4-比较PE文件头\"><a href=\"#18-4-比较PE文件头\" class=\"headerlink\" title=\"18.4 比较PE文件头\"></a>18.4 比较PE文件头</h2><p><strong>Q：这是notepad.exe的文件头</strong></p>\n<ul>\n<li>5A4D是MZ签名，前40个字节是dos头</li>\n<li>40-DE是DOS存根</li>\n<li>40-D0是汇编代码</li>\n<li>E0-E3是PE签名</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107114614542.png\" alt=\"image-20231107114614542\"></p>\n<p><strong>Q：这是notepad_unpack.exe运行时压缩的PE文件头</strong></p>\n<ul>\n<li>PE签名离MZ非常近</li>\n<li>没有DOS存根</li>\n<li>有很多不知道的字符串</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107113920068.png\" alt=\"image-20231107113920068\"></p>\n<h2 id=\"18-5-分析UPack的PE文件头\"><a href=\"#18-5-分析UPack的PE文件头\" class=\"headerlink\" title=\"18.5 分析UPack的PE文件头\"></a>18.5 分析UPack的PE文件头</h2><h3 id=\"18-5-1-重叠文件头\"><a href=\"#18-5-1-重叠文件头\" class=\"headerlink\" title=\"18.5.1 重叠文件头\"></a>18.5.1 重叠文件头</h3><p><strong>Q：啥是重叠文件头</strong></p>\n<ul>\n<li>重叠文件头也是其他压缩器经常使用的技法，借助该方法可以把MZ文件头(IMAGE_DOS_HEADER)与PE文件头(IMAGE_NT_HEADERS)巧妙重叠在一起</li>\n<li>可以有效节约文件头空间</li>\n<li>但是这会额外增加文件头的复杂性，给分析带来很大困难(很难再使用PE相关工具)。</li>\n</ul>\n<p><strong>Q：使用Stud PE看一下MZ文件头部分</strong></p>\n<ul>\n<li>请按Headers选项卡的Basic HEADERS tree view in hexeditor按钮，如图18-8所示。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107115909834.png\" alt=\"image-20231107115909834\"></p>\n<ul>\n<li><p>MZ文件头(DOS头)中两个重要成员是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">e_magic ： 说明MZ，通常是4D5A\ne_flanew： file address of new exe header(文件头的起始地址，也就是NT头的起始地址)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>根据PE规范，IMAGE_NT_HEADERS是可变的，起始位置由e_flanew的值决定。一般在一个正常程序中，e_flanew值按照下面计算</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">e_lfanew &#x3D; MZ文件头大小+ DOS存根大小 &#x3D; E0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>但是根据上图，upack中设置的<code>e_lfanew</code>的值为<code>00000010</code>，说明他把MZ文件头设置在了<code>00000010</code>处，刚好在DOS头里面，此时两个文件头重叠，看下面的图也可以看出来</p>\n<p>DOS header：</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107120520727.png\" alt=\"image-20231107120520727\"></p>\n</li>\n</ul>\n<p>​\t\tFile header：</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107120533066.png\" alt=\"image-20231107120533066\"></p>\n<h3 id=\"18-5-2-IMAGE-FILE-HEADER-SizeOfOptionalHeader\"><a href=\"#18-5-2-IMAGE-FILE-HEADER-SizeOfOptionalHeader\" class=\"headerlink\" title=\"18.5.2 IMAGE_FILE_HEADER.SizeOfOptionalHeader\"></a>18.5.2 IMAGE_FILE_HEADER.SizeOfOptionalHeader</h3><p><strong>Q：upack的作者把IMAGE_FILE_HEADER.SizeOfOptionalHeader的值修改了，为啥？</strong></p>\n<ul>\n<li>从下图可知，正常情况下这个值是E0，根据13.3中的笔记，这部分是用来指定IMAGE_OPTIONAL_HEADER32结构体的大小</li>\n<li>为了可以空出一段空间，向其中插入解码代码</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107121120708.png\" alt=\"image-20231107121120708\"></p>\n<p><strong>Q：根据前面的知识，IMAGE_OPTIONAL_HEADER32结构体是由C语言写的，固定的，为什么还要单独设置一个属性说明它的值呢？</strong></p>\n<ul>\n<li><p>根据前面的知识</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107122353423.png\" alt=\"image-20231107122353423\"></p>\n</li>\n</ul>\n<p><strong>Q：为什么upack把SizeOfOptionalHeader的值设置为148</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">IMAGE_SECTION_HEADER的起始地址 &#x3D; IMAGE_OPTIONAL_HEADER起始地址 + SizeofoptionalHeaders<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<ul>\n<li>这个其实已经解释过了，无论是header32对应的E0，还是32+对应的F0，都比148小</li>\n<li>这样我增大了sizeofoptionalheaders的值，就会在optional_header和section_header之间留出来了一块地方</li>\n<li>这样就可以像这个区域插入解码代码了</li>\n</ul>\n<p>optional header的起始位置是28，所以section_header的起始位置是，<code>148+28=170 （16进制计算）</code></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231107123814708.png\" alt=\"image-20231107123814708\"></p>\n<p><strong>但是为什么image_optional_header结束的位置是D7呢？为什么是D7后面会解释</strong></p>\n<ul>\n<li>所以从image_optional_header结束的位置到170中间放着的就是解码代码。</li>\n</ul>\n<h3 id=\"18-5-3-IMAGE-OPTIONAL-HEADER-NumberOfRvaAndSizes\"><a href=\"#18-5-3-IMAGE-OPTIONAL-HEADER-NumberOfRvaAndSizes\" class=\"headerlink\" title=\"18.5.3 IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes\"></a>18.5.3 IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes</h3><p><strong>Q：NumberOfRvaAndSizes的值也发生了变化，为什么？</strong></p>\n<ul>\n<li>目的是向文件头中插入自身代码</li>\n<li>这个值的作用是指定datadirectory数组的大小，正常是10，但是在Upack中改为了A</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231201173038275.png\" alt=\"image-20231201173038275\"></p>\n<ul>\n<li><p>所以Upack中，IMAGE_DATA_DIRECTORY数组的后6个元素会被忽略</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231201214554544.png\" alt=\"image-20231201214554544\"></p>\n</li>\n<li><p>也就是这个表索引A后面的会被忽略</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231201214451902.png\" alt=\"image-20231201214451902\"></p>\n</li>\n<li><p>上面蓝色的区域(D8- 107区域)，Load_config之后是Upack忽视的部分。</p>\n<ul>\n<li>这部分是Upack自身的解码代码</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"18-5-4-IMAGE-SECTION-HEADER\"><a href=\"#18-5-4-IMAGE-SECTION-HEADER\" class=\"headerlink\" title=\"18.5.4 IMAGE_SECTION_HEADER\"></a>18.5.4 IMAGE_SECTION_HEADER</h3><ul>\n<li>从NT头中可以知道节区数量是3个</li>\n</ul>\n<p><strong>Q：使用Hexeditor查看IMAGE_SECTION_HEADER结构体。？</strong></p>\n<ul>\n<li>&#x3D;&#x3D;为什么是170 - 1E7&#x3D;&#x3D;</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231201220321198.png\" alt=\"image-20231201220321198\"></p>\n<h3 id=\"18-5-5-重叠节区\"><a href=\"#18-5-5-重叠节区\" class=\"headerlink\" title=\"18.5.5 重叠节区\"></a>18.5.5 重叠节区</h3><p><strong>Q：Upack的一个主要特征</strong></p>\n<ul>\n<li>随意重叠PE节区与文件头</li>\n</ul>\n<p><strong>Q：通过Stud_PE查看UPack的IMAGE_SECTION_HEADER结构体</strong></p>\n<ul>\n<li>可以看到第一个节区和第三个节区在文件中的起始偏移和文件大小完全一致，<strong>说明这两个节区在文件中是重叠的</strong>。</li>\n<li>但是在内存中确是不一样的</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231201221303553.png\" alt=\"image-20231201221303553\"></p>\n<p><strong>Q：看下面这个图</strong></p>\n<ul>\n<li>PE装载器用相同的文件映像创造出了不同的内存映像\t</li>\n<li>第一（三）个节区的文件大小很小</li>\n<li>第二个节区的文件大小为<code>AE28</code>，非常大，<strong>这里存储着压缩后的原文件</strong></li>\n<li>内存中的第一个节区的大小为14000，和原文件Size of Image的大小一样，也就是压缩后的第一个文件会被解压缩到第一个节区</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231201221442197.png\" alt=\"image-20231201221442197\"></p>\n<p><strong>Q：总结</strong></p>\n<ul>\n<li>压缩的notepad在内存的第二个节区解压缩的同时被记录到第一个节区</li>\n<li>notepad.exe(原文件)的内存映像会被整体解压，所以程序能够正常运行(地址变得准确而一致)。</li>\n</ul>\n<h3 id=\"18-5-6-RVA-to-RAW\"><a href=\"#18-5-6-RVA-to-RAW\" class=\"headerlink\" title=\"18.5.6 RVA to RAW\"></a>18.5.6 RVA to RAW</h3><p>各种PE实用程序对Upack束手无策的原因就是无法正确进行RVA一&gt;RAW的变换</p>\n<p><strong>Q：计算EP的RAW</strong></p>\n<ul>\n<li><p><code>RVA = 1018</code>位于第一个节区，算一下RAW &#x3D; <code>1018 - 1000 + 10 = 28</code></p>\n</li>\n<li><p>但是28并不是EP代码区</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202124434510.png\" alt=\"image-20231202124434510\"></p>\n</li>\n<li><p>一般来说指向节区开始的<code>PointerToRawData</code>的值应该是FileAlignment的整数倍，Upack的FileAlignment是200，所以PointerToRawData的值应该是0、200、400、600</p>\n</li>\n<li><p>PE装载器发现第一个节区的<code>PointerToRawData</code>是10，会强制转换为整数倍，在现在也就是0。</p>\n</li>\n<li><p>因此，实际位置应该是<code>1018 - 1000 + 0</code> &#x3D; 18</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202124836355.png\" alt=\"image-20231202124836355\"></p>\n</li>\n</ul>\n<h3 id=\"18-5-7-导入表\"><a href=\"#18-5-7-导入表\" class=\"headerlink\" title=\"18.5.7 导入表\"></a>18.5.7 导入表</h3><p><strong>Q：查看IMAGE_IMPORT_DESCRIPTOR结构体。</strong></p>\n<ul>\n<li><p>首先从datadirectory数组中获得IDT（IMAGE_IMPORT_DESCRIPTOR）</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202125233343.png\" alt=\"image-20231202125233343\"></p>\n</li>\n<li><p>前面四个字节<code>000271EE</code>为导入表的地址(RVA)，后面四个字节<code>00000014</code>是导入表的大小</p>\n</li>\n</ul>\n<p><strong>Q：进行RVA-&gt;RAW的变换</strong></p>\n<ul>\n<li><code>271EE - 27000 + 0 = 1EE </code><strong>注意这里是加0 ，不是加10</strong></li>\n<li>用hex editor查看位置</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202130436002.png\" alt=\"image-20231202130436002\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202130457260.png\" alt=\"image-20231202130457260\"></p>\n<ul>\n<li>根据PE规范，导入表是一系列IMAGE_IMPORT_DESCRIPTOR数组，每有一个导入的库，就有一个结构体</li>\n<li>所以上面偏移的1EE~201为第一个结构体，但是后面不是第二个结构体，也不是导入表结束的Null结构体</li>\n</ul>\n<p><strong>Q：为什么呢？</strong></p>\n<ul>\n<li><p>因为在文件中，第三节区到200就结束了，所以后面的不会映射到第三节区</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202130717484.png\" alt=\"image-20231202130717484\"></p>\n</li>\n<li><p>第三节区加载到内存时，只映射0<del>1FF到27000</del>271FF，剩下的全部填充为null</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202131135464.png\" alt=\"image-20231202131135464\"></p>\n</li>\n</ul>\n<p><strong>Q: 综上</strong></p>\n<ul>\n<li>虽然Upack文件并没有真正的以Null表示IMAGE_IMPORT_DESCRIPTOR的结束，但是200之后的内容并不会映射到第三个节区，相当于以null结束了</li>\n</ul>\n<h3 id=\"18-5-8-导入地址表\"><a href=\"#18-5-8-导入地址表\" class=\"headerlink\" title=\"18.5.8 导入地址表\"></a>18.5.8 导入地址表</h3><p><strong>Q：把上面的结构体映射一下</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202131750323.png\" alt=\"image-20231202131750323\"></p>\n<ul>\n<li><p>Name的RVA值为2，属于Header区域，第一个节区从1000开始，<strong>Header区域的RVA和RAW一样</strong></p>\n</li>\n<li><p>在偏移为2的区域，看到了字符串<code>KERNEL32.DLL</code></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202132218794.png\" alt=\"image-20231202132218794\"></p>\n</li>\n<li><p>正常情况下，这个区啥也没干，属于DOS头部分，属于不使用的部分，UPack把导入的DLL名称写到了这</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202132407476.png\" alt=\"image-20231202132407476\"></p>\n</li>\n</ul>\n<p><strong>Q：跟踪INT或者IAT</strong></p>\n<ul>\n<li><p>由于INT为0，那就跟踪一下IAT，只要能找到函数名称就行，计算RAW</p>\n<p><code>11E8 - 1000 + 0 = 1E8 </code></p>\n</li>\n<li><p>这里有两个API名称，<strong>分别是RVA <code>28</code>和<code>BE</code>，</strong>结束是null</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202133035830.png\" alt=\"image-20231202133035830\"></p>\n</li>\n<li><p>28处对应的函数</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202133212611.png\" alt=\"image-20231202133212611\"></p>\n<ul>\n<li><p>BE处对应的函数</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202133242142.png\" alt=\"image-20231202133242142\"></p>\n</li>\n</ul>\n<h1 id=\"0x19-Upack调试-查找OEP\"><a href=\"#0x19-Upack调试-查找OEP\" class=\"headerlink\" title=\"0x19 Upack调试 - 查找OEP\"></a>0x19 Upack调试 - 查找OEP</h1><h2 id=\"19-1-Ollydbg运行错误\"><a href=\"#19-1-Ollydbg运行错误\" class=\"headerlink\" title=\"19.1 Ollydbg运行错误\"></a>19.1 Ollydbg运行错误</h2><p><strong>Q：由于Upack把NumberOfRvaAndSizes的值设置为A，在用Ollydbg打开时，程序会停留在ntdll.dll处，无法正常调试</strong></p>\n<ul>\n<li><p>因此需要找到EP的位置，让程序从Ep处开始运行</p>\n</li>\n<li><p>通过Study_PE找到Ep的位置</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202140405724.png\" alt=\"image-20231202140405724\"></p>\n</li>\n<li><p>在Ollydbg中定位到<code>01001018</code>，New origin here会创建一个新的起始点，程序从这开始执行</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202140511506.png\" alt=\"image-20231202140511506\"></p>\n</li>\n<li><p>此时就可以正常调试了</p>\n</li>\n</ul>\n<h2 id=\"19-2-解码循环\"><a href=\"#19-2-解码循环\" class=\"headerlink\" title=\"19.2 解码循环\"></a>19.2 解码循环</h2><ul>\n<li><p>所有的压缩器中都存在解码循环</p>\n</li>\n<li><p>Upack把压缩后的代码放到第二个节区，再运行解码循环把解压缩后的放到第一个节区</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MOV ESI,10011B0\nLODS DWORD PTR DS:[ESI]  \n\n&#x2F;&#x2F;&quot;LODS&quot; 指令是 &quot;Load String&quot; 的缩写，用于加载字符串或数据块\nDWORD PTR&quot; 用于指定操作数的大小，这里表示操作数是一个双字（32位）\n&quot;DS:[ESI]&quot; 是一个内存引用，表示从段寄存器 DS 所指向的段中，以 ESI 寄存器中的值作为偏移地址来访问内存<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>这两条指令的意思是从10011B0中<strong>加载4字节的数据，保存到EAX中</strong></p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202141703023.png\" alt=\"image-20231202141703023\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202142231910.png\" alt=\"image-20231202142231910\"></p>\n<ul>\n<li><p>汇编指令,它会重复执行复制字符串，直到ECX计数器为0</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">REP MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]\n\nREP&quot; 是一个前缀指令，用于指示指令重复执行。\n&quot;MOVS&quot; 是 &quot;Move String&quot; 的缩写，用于将字符串或数据块从一个内存位置复制到另一个内存位置。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示每次传送的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据复制到 ES:EDI 指向的内存位置。\n&quot;DS:[ESI]&quot; 是源地址，表示要从 DS:ESI 指向的内存位置读取数据。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>汇编指令:会把累加器中的数据存储到EDI中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">STOS BYTE PTR ES:[EDI]\n\n&quot;STOS&quot; 是 &quot;Store String&quot; 的缩写，用于将字符串或数据块存储到内存中。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示要存储的是一个字节（8位）数据。\n&quot;ES:[EDI]&quot; 是目标地址，表示要将数据存储到 ES:EDI 指向的内存位置<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p><strong>&#x3D;&#x3D;问题：为什么已经有了MOVS，还需要LODS和STOPS呢&#x3D;&#x3D;</strong></p>\n<h3 id=\"19-3-设置IAT\"><a href=\"#19-3-设置IAT\" class=\"headerlink\" title=\"19.3 设置IAT\"></a>19.3 设置IAT</h3><ul>\n<li>压缩器执行完解码循环后，就会根据原文件重新组织IAT</li>\n</ul>\n<h1 id=\"0x20-内嵌补丁练习\"><a href=\"#0x20-内嵌补丁练习\" class=\"headerlink\" title=\"0x20 内嵌补丁练习\"></a>0x20 内嵌补丁练习</h1><p><strong>对加密文件、运行时解压缩文件“打补丁”时，经常使用 内嵌补丁 (Inline Patch)</strong></p>\n<h2 id=\"20-1-内嵌补丁\"><a href=\"#20-1-内嵌补丁\" class=\"headerlink\" title=\"20.1 内嵌补丁\"></a>20.1 内嵌补丁</h2><p>“内嵌补丁”是“内嵌代码补丁(Inline Code Patch)的简称。</p>\n<p><strong>Q：难以直接修改指定代码时，插“洞穴代码”(CodeCave)的补丁代码后，对程序打补丁。</strong></p>\n<ul>\n<li><p>常用于对象程序经过运行时压缩(或加密处理)而难以直接修改的情况。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202164500865.png\" alt=\"image-20231202164500865\"></p>\n</li>\n<li><p>如果直接在原来的加密代码上打补丁，在运行解码过程时，可能会解出完全不同的结果</p>\n<ul>\n<li>EP代码先将加密的OEP代码解密，再跳转到OEP处</li>\n</ul>\n</li>\n<li><p>现在EP代码解密后，修改JMP指令，让它跳转到洞穴代码处。</p>\n<ul>\n<li>也就是每次运行时，都需要对进程的代码打补丁，这种方式是内嵌代码补丁法</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231202165520254.png\" alt=\"image-20231202165520254\"></p>\n</li>\n</ul>\n<h3 id=\"20-2-Patchme\"><a href=\"#20-2-Patchme\" class=\"headerlink\" title=\"20.2 Patchme\"></a>20.2 Patchme</h3><p><img src=\"/../re-engineer-core-principle-02/image-20231204155301011.png\" alt=\"image-20231204155301011\"></p>\n<ul>\n<li>需要修改字符串</li>\n</ul>\n<h2 id=\"20-3-调试：-查看代码流\"><a href=\"#20-3-调试：-查看代码流\" class=\"headerlink\" title=\"20.3 调试： 查看代码流\"></a>20.3 调试： 查看代码流</h2><ul>\n<li><p>Ollydbg打开后，可以看到加密代码</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204155450665.png\" alt=\"image-20231204155450665\"></p>\n</li>\n<li><p>继续调试，可以看到三个解密循环</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204160512285.png\" alt=\"image-20231204160512285\"></p>\n</li>\n<li><p>第一个解密循环：会从<code>4010F5 ~  4010F5+154 -1 = 401248 </code>进行解密</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204160828357.png\" alt=\"image-20231204160828357\"></p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">XOR BYTE PTR DS:[EBX],44\n也就是把DS:[EBX]位置的数据和44异或\n&quot;XOR&quot; 是异或操作的指令。\n&quot;BYTE PTR&quot; 是一个操作数大小指示符，表示要操作的是一个字节（8位）数据。\n&quot;DS:[EBX]&quot; 是指定的内存位置，表示要对 DS:EBX 指向的内存位置中的字节数据进行操作。\n&quot;44&quot; 是一个立即数，表示要与内存位置中的字节数据进行异或运算的值。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>第二个解密循环：会从<code>401007~401085</code>区域进行解密</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204161104021.png\" alt=\"image-20231204161104021\"></p>\n<ul>\n<li><p>第三个解密循环：还是会从<code>4010F5 ~  4010F5+154 -1 = 401248 </code>进行解密，也就是说该区域加密2次</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204161235090.png\" alt=\"image-20231204161235090\"></p>\n</li>\n<li><p>接着进入<code>401039</code>处，下面是计算校验和，取<code>4010F5 ~  401248</code>处的数据计算校验和，也就是把所有的数据都加起来，加到EDX中。</p>\n<ul>\n<li>循环结束时，EDX存储的就是校验和值，用这个值判断是否修改了双重加密区域</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204161638135.png\" alt=\"image-20231204161638135\"></p>\n</li>\n<li><p>&#x3D;&#x3D;这里我觉得是猜出来的&#x3D;&#x3D;</p>\n<ul>\n<li>不</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204171824721.png\" alt=\"image-20231204171824721\"></p>\n</li>\n</ul>\n<p>汇编指令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">XCHG DL, BH\n\n&quot;XCHG&quot; 是 &quot;Exchange&quot; 的缩写，它用于交换两个操作数的值。在这种情况下，指令将 DL 寄存器和 BH 寄存器的值进行交换。\n\n具体执行的步骤如下：\n\n将 DL 寄存器的值存储到临时存储区。\n将 BH 寄存器的值复制到 DL 寄存器中。\n最后，将之前存储在临时存储区的值复制到 BH 寄存器中。\n这条指令可以用于在汇编语言中交换两个寄存器的值，以实现数据的重新排列或交换。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"20-4-代码结构\"><a href=\"#20-4-代码结构\" class=\"headerlink\" title=\"20.4 代码结构\"></a>20.4 代码结构</h2><p><img src=\"/../re-engineer-core-principle-02/image-20231204172805377.png\" alt=\"image-20231204172805377\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204173544198.png\" alt=\"image-20231204173544198\"></p>\n<ul>\n<li>[EPCode]只是用来调用[Decoding Code]的，实际的解密处理是由[Decoding Code]完成的。</li>\n<li>按照[B]-[AJ-[B]的顺序解码(XOR)，运行解密后的[A]区代码。</li>\n<li>在[A]区代码中会求得B]区的校验和，并据此判断[B]区代码是否发生过更改。</li>\n<li>然后对C区解码(XOR)最后跳到EP处(40121E)</li>\n</ul>\n<p><strong>Q：总结</strong></p>\n<ul>\n<li>整个的流程是对所有部分进行解密，然后对B区用校验和验证</li>\n<li>最后会跳转到OEP</li>\n</ul>\n<h2 id=\"20-5-内嵌补丁练习\"><a href=\"#20-5-内嵌补丁练习\" class=\"headerlink\" title=\"20.5 内嵌补丁练习\"></a>20.5 内嵌补丁练习</h2><ul>\n<li>可以看到要修改的字符串都在B区</li>\n<li>但是B区加密了，所以需要通过内嵌补丁。</li>\n</ul>\n<p><strong>Q：具体操作</strong></p>\n<ul>\n<li>首先向文件合适位置插入用于修改字符串的代码，然后在图20-11的[A]区域将JMP OEP命令修改为JMP补丁代码(当然修改时要充分考虑文件中的[A]区域处于加密状态)。</li>\n<li>若运行程序时到[A]区中的JMP补丁代码语句，(此时所有代码均处于解密状态且通过校验和验证)。</li>\n<li>就在补丁代码中更改字符串，通过JMP命令跳转到OEP处，这样整个内嵌补丁过程就完成了。</li>\n</ul>\n<h3 id=\"20-5-1-补丁代码的位置\"><a href=\"#20-5-1-补丁代码的位置\" class=\"headerlink\" title=\"20.5.1 补丁代码的位置\"></a>20.5.1 补丁代码的位置</h3><p><strong>Q：有3种设置位置的方法</strong></p>\n<ul>\n<li>方法1：设置到文件的空白区域。</li>\n<li>方法2：扩展最后节区后设置</li>\n<li>方法3：添加新节区后设置。</li>\n</ul>\n<p>补丁代码较少时，使用方法1，其他情况使用方法2或3。</p>\n<p><strong>Q：首先尝试方法1：设置到文件的空白区域</strong></p>\n<ul>\n<li>使用PEView查看示例文件的第一个节区(.text)头.</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204174846371.png\" alt=\"image-20231204174846371\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204174900067.png\" alt=\"image-20231204174900067\"></p>\n<ul>\n<li><p>它的virtual size是280，但是因为要以Section Alignment扩展，所以最小是1000，看下一个节区的起始位置也能看出来，是2000</p>\n</li>\n<li><p>那么我们就可以用空白区域(null-padding)</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204175117329.png\" alt=\"image-20231204175117329\"></p>\n</li>\n<li><p>使用Hex Editor打开，发现都是null</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204175542153.png\" alt=\"image-20231204175542153\"></p>\n</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231204175713245.png\" alt=\"image-20231204175713245\"></p>\n<ul>\n<li><p>.text节区中1E4的属性值中添加的IMAGE SCN MEM WRITE(可写属性)。</p>\n</li>\n<li><p>为了在程序中进行解密处理，一定要在节区头添加可写属性，获得相应内存的可写权限(当对无写权限的内存进行“写”操作时，会引发非法访问异常 )。</p>\n</li>\n<li><p>对于一个普通的 PE文件，其代码节是无写权限的，但是包含上面示例在内的压缩工具、Crypter 等文件的代码节都有可写权限<strong>，请各位以后分析文件时注意这一点</strong></p>\n</li>\n</ul>\n\n</div>\n<h3 id=\"20-5-2-制作补丁代码\"><a href=\"#20-5-2-制作补丁代码\" class=\"headerlink\" title=\"20.5.2 制作补丁代码\"></a>20.5.2 制作补丁代码</h3><p>&#x3D;&#x3D;这里有问题&#x3D;&#x3D;</p>\n<p>后面的目前我没看太懂</p>\n<h1 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>学完这部分，感觉自己调试的能力非常欠缺，逐行看代码的耐心和能力还没有</li>\n<li>感觉这部分涉及的基础知识非常多，应该经常回看。</li>\n</ul>\n","text":"引言 开启《逆向工程核心原理》的第二部分，冲冲冲！ 0x13 PE文件格式13.1 介绍PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。 PE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x13-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">0x13 PE文件格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-1-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">13.1 介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-2-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">13.2 PE文件格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-2-2-VA-RVA\"><span class=\"toc-text\">13.2.2 VA&amp;RVA</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-3-PE%E5%A4%B4\"><span class=\"toc-text\">13.3 PE头</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-1-DOS%E5%A4%B4\"><span class=\"toc-text\">13.3.1 DOS头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-2-DOS%E5%AD%98%E6%A0%B9\"><span class=\"toc-text\">13.3.2 DOS存根</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-3-NT%E5%A4%B4%EF%BC%88IMAGE-NT-HEADERS%EF%BC%89\"><span class=\"toc-text\">13.3.3 NT头（IMAGE_NT_HEADERS）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#PE-Signature\"><span class=\"toc-text\">PE Signature</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#NT%E5%A4%B4%EF%BC%9A%E6%96%87%E4%BB%B6%E5%A4%B4%EF%BC%88FileHeader%EF%BC%89\"><span class=\"toc-text\">NT头：文件头（FileHeader）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#OptionalHeader\"><span class=\"toc-text\">OptionalHeader</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-6-%E8%8A%82%E5%8C%BA%E5%A4%B4\"><span class=\"toc-text\">13.3.6 节区头</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-4-RVA-to-RAW\"><span class=\"toc-text\">13.4 RVA to RAW</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-5-IAT\"><span class=\"toc-text\">13.5 IAT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-5-1-DLL\"><span class=\"toc-text\">13.5.1 DLL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-5-2-IMAGE-IMPORT-DESCRIPTOR\"><span class=\"toc-text\">13.5.2 IMAGE_IMPORT_DESCRIPTOR</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-5-3-%E4%BD%BF%E7%94%A8notepad-exe%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">13.5.3 使用notepad.exe练习</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-6-EAT\"><span class=\"toc-text\">13.6 EAT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-6-1-IMAGE-EXPORT-DIRECTORY\"><span class=\"toc-text\">13.6.1 IMAGE_EXPORT_DIRECTORY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-6-2-%E4%BD%BF%E7%94%A8kernel32-dll%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">13.6.2 使用kernel32.dll练习</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8EIAT-import-%E5%92%8CEAT-export\"><span class=\"toc-text\">关于IAT(import)和EAT(export)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-7-%E9%AB%98%E7%BA%A7PE\"><span class=\"toc-text\">13.7 高级PE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-7-1-PEView-exe\"><span class=\"toc-text\">13.7.1 PEView.exe</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-7-2-Patched-PE\"><span class=\"toc-text\">13.7.2 Patched PE</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-8-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">13.8 小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x14-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">0x14 运行时压缩</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-1-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">14.1 数据压缩</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-1-2-%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">14.1.2 有损压缩</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9%E5%99%A8\"><span class=\"toc-text\">14.2 运行时压缩器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-2-1-%E5%8E%8B%E7%BC%A9%E5%99%A8\"><span class=\"toc-text\">14.2.1 压缩器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-2-2-%E4%BF%9D%E6%8A%A4%E5%99%A8\"><span class=\"toc-text\">14.2.2 保护器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-3-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">14.3 运行时压缩测试</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x15-%E8%B0%83%E8%AF%95upx%E5%8E%8B%E7%BC%A9%E7%9A%84notepad%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">0x15 调试upx压缩的notepad程序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-2-notepad-upx-exe%E7%9A%84EP%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">15.2 notepad_upx.exe的EP代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-3-%E8%B7%9F%E8%B8%AAUPX%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">15.3 跟踪UPX文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-1-Ollydbg%E7%9A%84%E8%B7%9F%E8%B8%AA%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">15.3.1 Ollydbg的跟踪命令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-2-%E5%BE%AA%E7%8E%AF-1\"><span class=\"toc-text\">15.3.2 循环#1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-3-%E5%BE%AA%E7%8E%AF-2\"><span class=\"toc-text\">15.3.3 循环#2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-4-%E5%BE%AA%E7%8E%AF-3\"><span class=\"toc-text\">15.3.4 循环#3</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-3-5-%E5%BE%AA%E7%8E%AF-4\"><span class=\"toc-text\">15.3.5 循环#4</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-4-%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BEUPX-OEP%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">15.4 快速查找UPX OEP的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-4-1-%E5%9C%A8POPAD%E6%8C%87%E4%BB%A4%E5%90%8E%E7%9A%84JMP%E6%8C%87%E4%BB%A4%E5%A4%84%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9\"><span class=\"toc-text\">15.4.1 在POPAD指令后的JMP指令处设置断点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-4-2-%E5%9C%A8%E6%A0%88%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9\"><span class=\"toc-text\">15.4.2 在栈中设置硬件断点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-5-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">15.5 小结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x16-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8\"><span class=\"toc-text\">0x16 基址重定位表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-1-PE%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">16.1 PE重定位</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-1-2-EXE\"><span class=\"toc-text\">16.1.2 EXE</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-2-PE%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%97%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">16.2 PE重定位时执行的操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-3-PE%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">16.3 PE重定位操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-3-1-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8\"><span class=\"toc-text\">16.3.1 基址重定位表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-3-2-IMAGE-BASE-RELOACTION%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">16.3.2 IMAGE_BASE_RELOACTION结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-3-3-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">16.3.3 基址重定位表的分析方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-3-4-%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">16.3.4 练习</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x17-%E4%BB%8E%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E5%88%A0%E9%99%A4-reloc%E8%8A%82%E5%8C%BA\"><span class=\"toc-text\">0x17 从可执行文件中删除.reloc节区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-1-reloc%E8%8A%82%E5%8C%BA\"><span class=\"toc-text\">17.1 .reloc节区</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-2-reloc-exe\"><span class=\"toc-text\">17.2 reloc.exe</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-2-1-%E7%94%A80%E8%A6%86%E7%9B%96-reloc%E8%8A%82%E5%8C%BA%E5%A4%B4\"><span class=\"toc-text\">17.2.1 用0覆盖.reloc节区头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-2-2-%E5%88%A0%E9%99%A4-reloc%E8%8A%82%E5%8C%BA\"><span class=\"toc-text\">17.2.2 删除.reloc节区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-2-3-%E4%BF%AE%E6%94%B9IMAGE-FILE-HEADER\"><span class=\"toc-text\">17.2.3 修改IMAGE_FILE_HEADER</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-2-4-%E4%BF%AE%E6%94%B9IMAGE-OPTIONAL-HEADER\"><span class=\"toc-text\">17.2.4 修改IMAGE_OPTIONAL_HEADER</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x18-Upack-PE%E6%96%87%E4%BB%B6%E5%A4%B4%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">0x18 Upack PE文件头详细分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-2-%E4%BD%BF%E7%94%A8UPack%E5%8E%8B%E7%BC%A9notepad-exe\"><span class=\"toc-text\">18.2 使用UPack压缩notepad.exe</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-3-%E4%BD%BF%E7%94%A8Stud-PE%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">18.3 使用Stud_PE工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-4-%E6%AF%94%E8%BE%83PE%E6%96%87%E4%BB%B6%E5%A4%B4\"><span class=\"toc-text\">18.4 比较PE文件头</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-5-%E5%88%86%E6%9E%90UPack%E7%9A%84PE%E6%96%87%E4%BB%B6%E5%A4%B4\"><span class=\"toc-text\">18.5 分析UPack的PE文件头</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-1-%E9%87%8D%E5%8F%A0%E6%96%87%E4%BB%B6%E5%A4%B4\"><span class=\"toc-text\">18.5.1 重叠文件头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-2-IMAGE-FILE-HEADER-SizeOfOptionalHeader\"><span class=\"toc-text\">18.5.2 IMAGE_FILE_HEADER.SizeOfOptionalHeader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-3-IMAGE-OPTIONAL-HEADER-NumberOfRvaAndSizes\"><span class=\"toc-text\">18.5.3 IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-4-IMAGE-SECTION-HEADER\"><span class=\"toc-text\">18.5.4 IMAGE_SECTION_HEADER</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-5-%E9%87%8D%E5%8F%A0%E8%8A%82%E5%8C%BA\"><span class=\"toc-text\">18.5.5 重叠节区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-6-RVA-to-RAW\"><span class=\"toc-text\">18.5.6 RVA to RAW</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-7-%E5%AF%BC%E5%85%A5%E8%A1%A8\"><span class=\"toc-text\">18.5.7 导入表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-5-8-%E5%AF%BC%E5%85%A5%E5%9C%B0%E5%9D%80%E8%A1%A8\"><span class=\"toc-text\">18.5.8 导入地址表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x19-Upack%E8%B0%83%E8%AF%95-%E6%9F%A5%E6%89%BEOEP\"><span class=\"toc-text\">0x19 Upack调试 - 查找OEP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-1-Ollydbg%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">19.1 Ollydbg运行错误</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-2-%E8%A7%A3%E7%A0%81%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">19.2 解码循环</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-3-%E8%AE%BE%E7%BD%AEIAT\"><span class=\"toc-text\">19.3 设置IAT</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x20-%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">0x20 内嵌补丁练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-1-%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81\"><span class=\"toc-text\">20.1 内嵌补丁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-2-Patchme\"><span class=\"toc-text\">20.2 Patchme</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-3-%E8%B0%83%E8%AF%95%EF%BC%9A-%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E6%B5%81\"><span class=\"toc-text\">20.3 调试： 查看代码流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-4-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">20.4 代码结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-5-%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">20.5 内嵌补丁练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-5-1-%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">20.5.1 补丁代码的位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-5-2-%E5%88%B6%E4%BD%9C%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">20.5.2 制作补丁代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-1\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ODDFUZZ","uid":"9b08663ab6515ce746fcfc5eb13ac547","slug":"ODDFUZZ-SP-2023","date":"2023-11-07T02:18:56.000Z","updated":"2023-11-14T02:05:35.644Z","comments":true,"path":"api/articles/ODDFUZZ-SP-2023.json","keywords":null,"cover":[],"text":"ABSTRACTQ：对于Java反序列化漏洞，现有的解决方式 static analysis和fuzz生成POC，用序列化的对象触发漏洞 但是存在有效性和效率的问题 Q：本文方法 提出一个轻量级的static taint analysis去识别调用链 ODDFUZZ尽力locat...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"论文","slug":"论文","count":4,"path":"api/tags/论文.json"},{"name":"Fuzz","slug":"Fuzz","count":1,"path":"api/tags/Fuzz.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"re-engineer-core-principle-01","uid":"e67072c96c2129e60add5b77588d8afa","slug":"re-engineer-core-principle-01","date":"2023-10-22T08:36:19.000Z","updated":"2024-02-29T10:45:32.693Z","comments":true,"path":"api/articles/re-engineer-core-principle-01.json","keywords":null,"cover":"/medias/pexels-luis-gomes-546819.jpg","text":"引言看《逆向工程核心原理》这本书 好久之前看了这本书的一部分，现在决定重新学一下。 感觉逆向十分重要，且我的hxd wd-2711 (https://wd-2711.tech/) ，一直在学逆向，在他的感染下，我也开始学。 0x01 关于逆向工程 静态分析法：并不执行代码，观察代...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":7,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}