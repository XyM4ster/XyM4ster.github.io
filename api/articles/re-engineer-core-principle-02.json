{"title":"re-engineer-core-principle-02","uid":"1e07b60d2029aa2ea6483727894829df","slug":"re-engineer-core-principle-02","date":"2023-10-22T08:39:11.000Z","updated":"2023-10-24T09:36:30.450Z","comments":true,"path":"api/articles/re-engineer-core-principle-02.json","keywords":null,"cover":[],"content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ul>\n<li>开启《逆向工程核心原理》的第二部分，冲冲冲！</li>\n</ul>\n<h1 id=\"0x13-PE文件格式\"><a href=\"#0x13-PE文件格式\" class=\"headerlink\" title=\"0x13 PE文件格式\"></a>0x13 PE文件格式</h1><h2 id=\"13-1-介绍\"><a href=\"#13-1-介绍\" class=\"headerlink\" title=\"13.1 介绍\"></a>13.1 介绍</h2><p>PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。</p>\n<p>PE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE文件的扩展形式。</p>\n<h2 id=\"13-2-PE文件格式\"><a href=\"#13-2-PE文件格式\" class=\"headerlink\" title=\"13.2 PE文件格式\"></a>13.2 PE文件格式</h2><p><img src=\"/../re-engineer-core-principle-02/image-20231022165245769.png\" alt=\"image-20231022165245769\"></p>\n<p><strong>Q1：notpad头</strong></p>\n<p>严格地说，OBJ(对象)文件之外的所有文件都是可执行的。</p>\n<p>DLL、SYS文件等虽然不能直接在Shell(Explorer.exe)中运行，但可以使用其他方法(调试器、服务等)执行。</p>\n<p>图13-1是notepad.exe文件的起始部分也是PE文件的头部分(PE header)。notepad.exe文件运行需要的所有信息就存储在这个PE头中，<strong>如何加载到内存、从何处开始运行、运行中需要的DLL有哪些、需要多大的栈&#x2F;堆内存等，大量信息以结构体形式存储在PE头中</strong>。换言之，学习PE文件格式就是学习PE头中的结构体。</p>\n<p><strong>Q2：PE加载到内存</strong></p>\n<ul>\n<li><p>从DOS头(DOS header)到节区头(Section header)是PE头部分，其下的节区合称PE体。</p>\n</li>\n<li><p>文件中使用偏移 (offset)，内存中使用VA ( Virtual Address，虚拟地址)来表示位置。</p>\n</li>\n<li><p>文件加载到内存时，情况就会发生变化(节区的大小、位置等)。文件的内容一般可分为代码(.text)、数据(.data)、资源(.rsrc)节，分别保存。</p>\n</li>\n<li><p>各节区头定义了各节区在文件或内存中的大小、位置、属性等.PE头与各节区的尾部存在一个区域，称为NULL填充(NULL padding)。计算机中，为了提高处理文件、内存、网络包的效率，使用<strong>最小基本单位</strong>这一概念，PE文件中也类似。</p>\n</li>\n<li><p>文件&#x2F;内存中节区的<strong>起始位置应该在各文件&#x2F;内存最小单位的倍数位置上</strong>，空白区域将用NULL填充(看图13-2，可以看到各节区起始地址的截断都遵循一定规则)。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022165721636.png\" alt=\"image-20231022165721636\"></p>\n<h3 id=\"13-2-2-VA-RVA\"><a href=\"#13-2-2-VA-RVA\" class=\"headerlink\" title=\"13.2.2 VA&amp;RVA\"></a>13.2.2 VA&amp;RVA</h3><p>VA指的是进程虚拟内存的绝对地址，RVA(Relative Virtual Address，相对虚拟地址)指从某个基准位置(Image Base)开始的相对地址。</p>\n<p>VA与RVA满足下面的换算关系：<br>                                            <code>RVA+ImageBase=VA</code><br>PE头内部信息大多以RVA形式存在。原因在于:（就是修改位置用相对地址会比较简单）</p>\n<ul>\n<li>PE文件(主要是DLL)加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件(DLL)。此时必须通过重定位(Relocation将其加载到其他空白的位置，若PE头信息使用的是VA，则无法正常访问。</li>\n<li>因此使用RVA来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息不会出现任何问题。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>32位WindowsOS中各进程分配有4GB的虚拟内存，因此进程中VA值的范围是00000000~FFFFFFFF。</p>\n<p>1 字节（Byte）&#x3D; 8 位（Bit）<br>1 千字节（KB）&#x3D; 1024 字节<br>1 兆字节（MB）&#x3D; 1024 KB<br>1 吉字节（GB）&#x3D; 1024 MB<br>1 太字节（TB）&#x3D; 1024 GB</p>\n</p>\n</div>\n<h2 id=\"13-3-PE头\"><a href=\"#13-3-PE头\" class=\"headerlink\" title=\"13.3 PE头\"></a>13.3 PE头</h2><p>PE头中有许多结构体，主要学的是这些结构体</p>\n<h3 id=\"13-3-1-DOS头\"><a href=\"#13-3-1-DOS头\" class=\"headerlink\" title=\"13.3.1 DOS头\"></a>13.3.1 DOS头</h3><p><strong>Q1：为什么会有DOS头</strong></p>\n<ul>\n<li>微软创建PE文件格式时，人们正广泛使用DOS文件，所以微软充分考虑了PE文件对DOS文件的兼容性。</li>\n<li>其结果是在PE头的最前面添加了个IMAGE DOS HEADER结构体，用来扩展已有的DOS EXE头。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022171456586.png\" alt=\"image-20231022171456586\"></p>\n<p><code>WORD</code> 是一个用于表示无符号的16位整数类型。</p>\n<p>在结构体中两个重要的成员：</p>\n<ul>\n<li>e_magic：DOS签名(signature，4D5A&#x3D;&gt;ASCII值“MZ”)。</li>\n<li>e_lfanew：指示NT头的偏移(根据不同文件拥有可变值)。</li>\n</ul>\n<p>所有PE文件在开始部分(e_magic)都有DOS签名(“MZ”)。e_lfanew值指向NT头所在位置NT头的名称为IMAGE_NT_HEADERS，后面将会介绍)。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>签名叫MZ的原因是DOS可执行文件是一个叫MZ的人开发的。</p>\n\n</div>\n<p>打开上面的notpad.exe，查看IMAGE_DOS_HEADER结构体</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022174436849.png\" alt=\"image-20231022174436849\"></p>\n<ul>\n<li>开始是<code>4D5A</code></li>\n<li>e_lfanew的值是000000E0</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>Intel系列的CPU采用小端序，因此是逆序存储</p>\n</p>\n</div>\n<h3 id=\"13-3-2-DOS存根\"><a href=\"#13-3-2-DOS存根\" class=\"headerlink\" title=\"13.3.2 DOS存根\"></a>13.3.2 DOS存根</h3><p>DOS存根(stub)在DOS头下方，是个可选项，且大小不固定(即使没有DOS存根，文件也能正常运行)。</p>\n<p>DOS存根由代码与数据混合而成，图13-4显示的就是notepad.exe的DOS存根。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022175051080.png\" alt=\"image-20231022175051080\"></p>\n<ul>\n<li>上图中文件偏移40~4D区域为16位的汇编指令。</li>\n<li>32位的Windows OS中不会运行该命令(由于被识别为PE文件，所以完全忽视该代码)。</li>\n<li>在DOS环境中运行Notepad.exe文件，或者使用DOS调试器(debug.exe)运行它，可使其执行该代码(在dos环境中，不认识PE文件格式，所以被识别为DOS EXE文件)</li>\n</ul>\n<p>把40~4D区域在dos中转换为汇编代码</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022175222862.png\" alt=\"image-20231022175222862\"></p>\n<ul>\n<li>代码非常简单，在画面中输出字符串“This program cannot be run in DOS mode”后就退出。</li>\n<li>换言之，notepad.exe文件虽然是32位的PE文件，但是带有MS-DOS兼容模式，可以在DOS环境中运行，执行DOS EXE代码，输出“This program cannot be run in DOS mode”后终止。</li>\n<li>灵活使用该特性可以在一个可执行文件(EXE)中创建出另一个文件，它在DOS与Widows中都能运行(在DOS环境中运行16位DOS代码，在Windows环境中运行32位Windows代码)。</li>\n<li>如前所述，DOS存根是可选项，开发工具应该支持它(VB、VC+、Dephi等默认支持DOS存根)。</li>\n</ul>\n<h3 id=\"13-3-3-NT头（IMAGE-NT-HEADERS）\"><a href=\"#13-3-3-NT头（IMAGE-NT-HEADERS）\" class=\"headerlink\" title=\"13.3.3 NT头（IMAGE_NT_HEADERS）\"></a>13.3.3 NT头（IMAGE_NT_HEADERS）</h3><p><img src=\"/../re-engineer-core-principle-02/image-20231022175401610.png\" alt=\"image-20231022175401610\"></p>\n<p>IMAGE_NT_HEADERS结构体由3个成员组成，</p>\n<ul>\n<li>第一个成员为签名(Signature)结构体，其值为50450000h(“PE”00)</li>\n<li>另外两个成员分别为文件头(FileHeader)与可选头(OptionalHeader)结构体。</li>\n</ul>\n<p>该结构体的大小为F8</p>\n<h4 id=\"NT头：文件头（FileHeader）\"><a href=\"#NT头：文件头（FileHeader）\" class=\"headerlink\" title=\"NT头：文件头（FileHeader）\"></a>NT头：文件头（FileHeader）</h4><p>文件头是表现文件大致属性的IMAGE_FILE_HEADER结构体。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022180014442.png\" alt=\"image-20231022180014442\"></p>\n<p>IMAGE_FILE_HEADER结构体有4种重要成员：</p>\n<p><strong>Machine</strong></p>\n<p>每个CPU都拥有唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C。以下是定义在winnt.h文件中的Machine码。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022180124427.png\" alt=\"image-20231022180124427\"></p>\n<p><strong>NumberOfSections</strong></p>\n<p>前面提到过，PE文件把代码、数据、资源等依据属性分类到各节区中存储。</p>\n<p>NumberOfSections用来指出文件中存在的节区数量。</p>\n<p>该值一定要大于0，且当定义的节区数量与实际节区不同时，将发生运行错误。</p>\n<p><strong>SizeOfOptionalHeader</strong><br>IMAGE_NT_HEADER结构体的最后一个成员为IMAGE_OPTIONAL_HEADER32结构体。</p>\n<p>SizeOfOptionalHeader成员用来指出IMAGE OPTIONAL HEADER32结构体的长度。IMAGE OPTIONAL HEADER32结构体由C语言编写而成，故其大小已经确定。但是Windows的PE装载器需要查看IMAGE FILE HEADER的SizeOfOptionalHeader值，从而识别出IMAGE OPTIONAL HEADER32结构体的大小。</p>\n<p>PE32+格式的文件中使用的是IMAGE OPTIONAL HEADER64结构体，而不是IMAGE_OPTIONAL_HEADER32结构体。2个结构体的尺寸是不同的，所以需要在SizeOfOptiomalHeader成员中明确指出结构体的大小。<br>:::tip<br>借助IMAGE_DOS_HEADER的elfanew 成员和IMAGE_FILE_HEADER的SizeOfOptionalHeader 成员，可以创建出一种脱离常规的 PE文件(PE Patch)(也有人称之为“麻花”PE文件)。</p>\n<p>:::</p>\n<p><strong>Characteristics</strong></p>\n<p>该字段用于标识文件的属性，文件是否是可运行的形态、是否为DLL文件等信息，以bit OR形式组合起来。<br>以下是定义在winnt.h文件中的Characteristics值(请记住0002h与2000h这两个值)。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022203550509.png\" alt=\"image-20231022203550509\"></p>\n<p><strong>Q：另外，PE文件中Characteristics的值有可能不是0002h吗(不可执行)?</strong></p>\n<ul>\n<li>是的，确实存在这种情况。比如类似*.obj的object文件及resource DLL文件等。</li>\n</ul>\n<p><strong>TimeDateStamp</strong></p>\n<p>最后讲一下IMAGE_FILE_HEADER的TimeDateStamp成员。该成员的值不影响文件运行，用来记录编译器创建此文件的时间。但是有些开发工具(VB、VC++)提供了设置该值的工具，而有此开发工具(Delphi)则未提供(随所用选项的不同而不同)。</p>\n<p><em>Image_File_Header</em></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022203847388.png\" alt=\"image-20231022203847388\"></p>\n<h4 id=\"OptionalHeader\"><a href=\"#OptionalHeader\" class=\"headerlink\" title=\"OptionalHeader\"></a>OptionalHeader</h4><p>IMAGE_OPTIONAL_HEADER32是PE头结构体中最大的。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023220120698.png\" alt=\"image-20231023220120698\"></p>\n<p>重点关注上图中红点标记的</p>\n<p><strong>Magic</strong></p>\n<ul>\n<li>为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为10B;</li>\n<li>为IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B。</li>\n</ul>\n<p><strong>AddressOfEntryPoint</strong></p>\n<ul>\n<li>AddressOfEntryPoint持有EP的RVA值。该值指出程序最先执行的代码起始地址，相当重要</li>\n</ul>\n<p><strong>ImageBase</strong></p>\n<ul>\n<li>进程虚拟内存的范围是O~FFFFFFFF(32位系统)。PE文件被加载到如此大的内存中时,ImageBase指出文件的优先装入地址。</li>\n</ul>\n<p>EXE、DLL文件被装载到用户内存的0<del>7FFFFFFF中，SYS文件被载入内核内存的80000000</del>FFFFFFFF中。一般而言，使用开发工具(VB&#x2F;VC++&#x2F;Delphi)创建好EXE文件后，其ImageBase的值为00400000，DLL文件的ImageBase值为10000000(当然也可以指定为其他值)。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint。</p>\n<p><strong>SectionAlignment</strong>，<strong>FileAlignment</strong></p>\n<ul>\n<li>PE文件的Body部分划分为若干节区，这些节存储着不同类别的数据。</li>\n<li>FileAlignment指定了节区在磁盘文件中的最小单位，而SectionAlignment则指定了节区在内存中的最小单位(一个文件中FileAlignment与SectionAlignment可能相同，也可能不同)。</li>\n<li>磁盘文件或内存的节区大小中必定为FileAlignment与SectionAlignment的值整数倍。</li>\n</ul>\n<p><strong>SizeOflmage</strong></p>\n<ul>\n<li><p>加载PE文件到内存时，SizeOfImage指定了PE Image在虚拟内存中所占空间的大小。</p>\n</li>\n<li><p>一般而言，文件的大小与加载到内存中的大小是不后的(节区头中定义了各节装载的位置与占有内存的大小，后面会讲到)。</p>\n</li>\n</ul>\n<p><strong>SizeOfHeader</strong></p>\n<ul>\n<li>SizeOfHeader用来指出整个PE头的大小。该值也必须是FileAlignment的整数倍。第一节区所在位置与SizeOfHeader距文件开始偏移的量相同。</li>\n</ul>\n<p><strong>Subsystem</strong></p>\n<ul>\n<li>该Subsystem值用来区分系统驱动文件(<code>*.sys</code>)与普通的可执行文件(<code>*exe,*dll</code>)。Subsystem成员可拥有的值如表13-2所示</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022205035130.png\" alt=\"image-20231022205035130\"></p>\n<p><strong>NumberOfRvaAndSizes</strong></p>\n<ul>\n<li>NumberOfRvaAndSizes用来指定DataDirectory(IMAGE_OPTIONAL_HEADER32结构体的最后一个成员)数组的个数。</li>\n<li>虽然结构体定义中明确指出了数组个数为IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16)但是PE装载器通过看NumberOfRvaAndSizes值来识别数组大小</li>\n<li>换言之，数组大小也可能不是16。</li>\n</ul>\n<p><strong>DataDirectory</strong></p>\n<p>DataDirectory是由IMAGE_DATA_DIRECTORY结构体组成的数组，数组的每项都有被定义的值。代码13-7列出了各数组项。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022205433760.png\" alt=\"image-20231022205433760\"></p>\n<ul>\n<li><p>将此处所说的Directory想成某个结构体数组即可。希望各位重点关注标红的EXPORT&#x2F;IMPORT&#x2F;RESOURCE、TLS Direction。</p>\n</li>\n<li><p>特别需要注意的是IMPORT与EXPORT Directory，它们是PE头中非常重要的部分，后面会单独讲解。</p>\n</li>\n<li><p>其余部分不怎么重要，大致了解一下即可。</p>\n</li>\n</ul>\n<p><em>IMAGE_OPTIONAL_HEADER</em></p>\n<h3 id=\"13-3-6-节区头\"><a href=\"#13-3-6-节区头\" class=\"headerlink\" title=\"13.3.6 节区头\"></a>13.3.6 节区头</h3><p>节区头中定义了各节区属性。</p>\n<p><strong>Q1：前面提到过，PE文件中的code(代码)data(数据)resource(资源)等按照属性分类储在不同节区，这是为什么？</strong></p>\n<p>把PE文件创建成多个节区结构的好处是，这样可以保证程序的安全性。</p>\n<ul>\n<li>若把code与data放在一个节区中相互纠缠(实际上完全可以这样做)很容易引发安全问题，即使忽略过程的烦琐。</li>\n<li>假如向字符串data写数据时，由于某个原因导致溢出(输入超过缓冲区大小时)那么其下的code(指令)就会被覆盖，应用程序就会崩溃。</li>\n<li>因此PE文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为“节区”的地方，然后需要把各节区属性记录在节区头中。</li>\n<li>节区属性中有文件&#x2F;内存的起始位置、大小、访问权限等。</li>\n<li>换言之，需要为每个code&#x2F;data&#x2F;resource分别设置不同的特性、访问权限等，如表13-3所示。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210220054.png\" alt=\"image-20231022210220054\"></p>\n<p><em>IMAGE_SECTION_HEADER</em></p>\n<p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210410897.png\" alt=\"image-20231022210410897\"></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210527217.png\" alt=\"image-20231022210527217\"></p>\n<p>VirtualAddress与PointerToRawData不带有任何值，分别由(定义在IMAGE_OPTIONAL_HEADER32中的)SectionAlignment与FileAlignment确定。</p>\n<p>VirtualSize与SizeOfRawData一般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。</p>\n<p>Characterisitics由代码13-10中显示的值组合(bitOR)而成</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231022210716607.png\" alt=\"image-20231022210716607\"></p>\n<p>最后谈谈Name字段。Name成员不像C语言中的字符串一样以NULL结束，并且没有“必须使用ASCII值”的限制。PE规范未明确规定节区的Name，所以可以向其中放入任何值，甚至可以填充NULL值。所以节区的Name仅供参考，不能保证其百分之百地被用作某种信息(数据节区的名称也可叫做code)。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>讲解 PE 文件时经常出现“映像”(Image)这一术语，希望各位牢记。PE 文件加载到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的 PE与内存中的 PE具有不同形态。<strong>将装载到内存中的形态称为“映像”以示区别</strong>，使用这一术语能够很好地区分二者。</p>\n\n</div>\n<h2 id=\"13-4-RVA-to-RAW\"><a href=\"#13-4-RVA-to-RAW\" class=\"headerlink\" title=\"13.4 RVA to RAW\"></a>13.4 RVA to RAW</h2><p>理解了节区后，下面讲解有关PE文件从磁盘到内存映射的内容。PE文件加载到内存时，每个节区都要能准确完成内存地址与文件偏移间的别这种映射一般称为RVA to RAW，方法如下。</p>\n<ul>\n<li>查找RVA所在节区。</li>\n<li>使用简单的公式计算文件偏移(RAW)</li>\n</ul>\n<p>根据IMAGES_SECTION_HEADER结构体，换算公式如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">RAW- PointerToRawData &#x3D; RVA- VirtualAddress\n&#x2F;&#x2F;RVA 内存地址\n&#x2F;&#x2F;RAW 文件偏移\n&#x2F;&#x2F;PointerToRawData 磁盘文件节区的起始位置\n&#x2F;&#x2F;virtualAddress 内存中节区起始地址<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Quiz</strong></p>\n<ol>\n<li><p>RVA&#x3D;5000时，File Offset&#x3D;？</p>\n<p>根据前面的图，5000在.text节区，所以5000-1000+0400&#x3D;4400</p>\n</li>\n<li><p>RVA&#x3D;ABA8时，FIle Offset&#x3D;？</p>\n<p>由内存图可知，在.data区。ABA8-9000+7C00&#x3D;97A8</p>\n<p>但是97A8已经在.rsrc区了，所以无法定义。</p>\n</li>\n</ol>\n<h2 id=\"13-5-IAT\"><a href=\"#13-5-IAT\" class=\"headerlink\" title=\"13.5 IAT\"></a>13.5 IAT</h2><p>刚开始学习PE头时，最难过的一关就是IAT (Import Address Table，导人地址表)。</p>\n<p>IAT保存的内容与Windows操作系统的核心进程、内存、DLL结构等有关。</p>\n<p><strong>IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数</strong>。</p>\n<h3 id=\"13-5-1-DLL\"><a href=\"#13-5-1-DLL\" class=\"headerlink\" title=\"13.5.1 DLL\"></a>13.5.1 DLL</h3><p>DLL：Dynamic Linked Library 动态链接库</p>\n<p>16位的操作系统中没有DLL。</p>\n<p><strong>Q1：在16位操作系统中使用Printf()函数，编译器怎么做？</strong></p>\n<ul>\n<li>编译器会先从C库中读取相应函数的二进制代码，然后插人(包含到)应用程序。</li>\n<li>也就是可执行文件中包含着printf()函数的二进制代码。</li>\n</ul>\n<p><strong>Q2：但是这样显然有问题</strong></p>\n<ul>\n<li>Windows OS支持多任务，若仍<strong>采用这种包含库的方式</strong>，会非常没有效率。</li>\n<li>Windows操作系统使用了数量庞大的库函数(进程、内存、窗口、消息等)来支持32位的Widows环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费(当然磁盘空间的浪费也不容小觑)。</li>\n</ul>\n<p><strong>Q3：WindowsOS设计者们根据需要引人了DLL这一概念</strong></p>\n<ul>\n<li>不要把库包含到程序中，单独组成DLL文件，需要时调用即可。</li>\n<li>内存映射技术使加载后的DLL代码、资源在多个进程中实现共享。</li>\n<li>更新库时只要替换相关DLL文件即可，简便易行。</li>\n</ul>\n<p><strong>Q4：加载DLL的方式</strong></p>\n<ul>\n<li>显式链接(EXplicit Linking)：程序使用DLL时加载，使用完毕释放内存</li>\n<li>隐式链接(Implicit Linking)：程序开始时一同加载DLL，程序终止时再释放占用的内存</li>\n</ul>\n<p>使用Ollydbg打开notepad.exe来查看IAT</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023213104827.png\" alt=\"image-20231023213104827\"></p>\n<p>这里看到了调用CreateFileW的代码，该函数位于kernel32.dll中</p>\n<p>这里发现使用CreateFileW时，并没有直接调用，而是先调用01001104这个地址。<strong>所有API都采用这种方式</strong></p>\n<p><strong>Q5：为什么不直接调用？</strong></p>\n<p>原因1：</p>\n<ul>\n<li>事实上，notepad.exe程序的制作者编译(生成)程序时，并不知道该notepad.exe序要运行在哪种Windows(9X\\2K、XP、Vista 7)、哪种语言(ENG、JPN、KOR等)、哪种服务包( ServicePack)下。</li>\n<li>上面列举出的所有环境中，kernel32.dl的版本各不相同，CreateFilew()函数的位置(地址)也不相同。</li>\n<li>为了确保在所有环境中都能正常调用CreateFilew()函数，编译器准备了要保存CreateFilew()函数实际地址的位置(01001104)并仅记下CALL DWORD PTR DS:1004404形式的指令。</li>\n<li>执行文件时，PE装载器将CreateFilew()函数的地写到01001104位置。</li>\n</ul>\n<p>原因2：</p>\n<ul>\n<li>DLL文件的ImageBase值一般为10000000。</li>\n<li>当某个程序使用a.dll与b.dll时，PE装载器先把d装载到内存的1000000 (ImageBase)处</li>\n<li>然后尝试把b.dll也装载到该处。但是由于该地址处已经装载了a.dll，所以PE装载器查找其他空白的内存空间 (ex:3E000000)，然后将bdll装载进去。</li>\n<li>这就是所谓的<em><strong>DLL重定位</strong></em>，它使我们无法对实际地址硬编码。</li>\n<li>另一个原因在于，PE头中表示地址时不使用绝对地址(VA)，而是相对地址RVA。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>实际操作中无法保证DLL一定会被加载到PE头内指定的ImageBase处。但是EXE文件(生成进程的主体)却能准确加载到自身的 ImageBase 中，因为它拥有自己的虚拟空间。</p>\n</p>\n</div>\n<h3 id=\"13-5-2-IMAGE-IMPORT-DESCRIPTOR\"><a href=\"#13-5-2-IMAGE-IMPORT-DESCRIPTOR\" class=\"headerlink\" title=\"13.5.2 IMAGE_IMPORT_DESCRIPTOR\"></a>13.5.2 IMAGE_IMPORT_DESCRIPTOR</h3><p>IMAGE_IMPORT_DESCRIPTOR结构体中记录着PE文件要导人哪些库文件。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>Import:导入，向库提供服务(函数)。<br>Export:导出，从库向其他PE文件提供服务(函数)。</p>\n\n</div>\n<p><strong>Q1：IMAGE_IMPORT_DESCRIPTOR结构体</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023214322180.png\" alt=\"image-20231023214322180\"></p>\n<ul>\n<li><p>执行一个普通程序时往往需要导入多个库，导人多少库就存在多少个IMAGE_IMPORT_DESCRIPTOR结构体</p>\n</li>\n<li><p>这些结构体形成了数组，且结构体数组最后以NULL结构体结束。</p>\n</li>\n<li><p>IMAGE IMPORTDESCRIPTOR中的重要成员如表13-5所示(拥有全部RVA值)。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023214429358.png\" alt=\"image-20231023214429358\"></p>\n</li>\n<li><p>PE头中提到的“Table”即指数组。</p>\n</li>\n<li><p>INT与IAT是长整型(4个字节数据类型)数组，以NULL结束(未另外明确指出大小)。</p>\n</li>\n<li><p>INT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针(有时IAT也拥有相同的值 )。</p>\n</li>\n<li><p>INT与IAT的大小应相同。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023215150684.png\" alt=\"image-20231023215150684\"></p>\n<p>上图中，INT与IAT的各元素同时指向相同地址，但是也有很多情况下不一样。</p>\n<p><strong>Q2：PE装载器把导入函数输入至IAT的顺序</strong></p>\n<ol>\n<li>读取IID的Name成员，获取库名称字符串”kernel32.dll”</li>\n<li>装载相应库。LoadLibrary(“kernel32.dll”）</li>\n<li>读取IID的OriginalFirstThunk成员，获取INT地址</li>\n<li>逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址(RVA)</li>\n<li>使用IMAGE_IMPORT_BY_NAME的Hint(ordinal)或Name项，获取相应函数的起始地址GetProcAddress(“GetCurrentThreadld”)</li>\n<li>读取IID的FirstThunk(IAT)成员，获得IAT地址</li>\n<li>将上面获得的函数地址输入相应IAT数组值。</li>\n<li>重复以上步骤4~7，直到INT结束(遇到NULL时)。</li>\n</ol>\n<h3 id=\"13-5-3-使用notepad-exe练习\"><a href=\"#13-5-3-使用notepad-exe练习\" class=\"headerlink\" title=\"13.5.3 使用notepad.exe练习\"></a>13.5.3 使用notepad.exe练习</h3><p><strong>Q1：IMAGE_IMPORT_DESCRIPTOR结构体数字在PE文件中的哪个部分？</strong></p>\n<ul>\n<li>它不在PE头而在PE体中，但查找其位置的信息在PE头中。</li>\n<li>IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress的值即是IMAGE_IMPORT_DESCRIPTOR结构体数组的起始地址(RVA值)。</li>\n<li>IMAGE_IMPORT_DESCRIPTOR结构体数组也被称为IMPORT Directory Table</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>这是前面optionalHeader中关于DataDirectory的笔记。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023215856399.png\" alt=\"image-20231023215856399\"></p>\n</p>\n</div>\n<p><strong>Q2：IMAGE_OPTIONAAL_HEADER32.DataDirectory结构体数组</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023223710913.png\" alt=\"image-20231023223710913\"></p>\n<ul>\n<li>由于RVA是7604，可以计算得到文件偏移位6A04</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023223756765.png\" alt=\"image-20231023223756765\"></p>\n<ul>\n<li>粗线框是数组的第一个元素，也就是IMAGE_IMPORT_DESCRIPTOR</li>\n<li>数组的最后是NULL结构体</li>\n</ul>\n<p><strong>Q3：粗线框中IMAGE_IMPORT_DESCRIPTOR结构体的各个成员</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023223921819.png\" alt=\"image-20231023223921819\"></p>\n<ol>\n<li><em><strong>库名称Name</strong></em></li>\n</ol>\n<ul>\n<li><p>Name是一个字符串指针，它指向导入函数所属的库文件名称。在图13-14的文件偏移6EAC(RVA:7AAC-&gt;RAW:6EAC)处看到字符串comdlg32.dIl</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224052826.png\" alt=\"image-20231023224052826\"></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><em><strong>OriginalFirstThunk–(INT)</strong></em></li>\n</ol>\n<ul>\n<li><p>INT是一个包含导人函数信息 (Ordinal，Name)的结构体指针数组。</p>\n</li>\n<li><p>只有获得了这些信息,才能在加载到进程内存的库中准确求得相应函数的起始地址(请参考后面EAT的讲解)。</p>\n</li>\n<li><p>跟踪OriginalFirstThunk成员(RVA:7990—&gt;RAW:6D90)。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224215873.png\" alt=\"image-20231023224215873\"></p>\n</li>\n<li><p>图13-15是INT，由地址数组形式组成(数组尾部以NULL结束 )。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224336711.png\" alt=\"image-20231023224336711\"></p>\n</li>\n<li><p><strong>每个地址值分别指向IMAGE_IMPORT_BY_NAME结构体</strong>(参考图13-11)。</p>\n</li>\n<li><p>跟踪数组的第一个值7A7A(RVA)进入该地址，可以看到导入的API函数的名称字符串。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li><em><strong>IMAGE_IMPORT_BY_NAME</strong></em></li>\n</ol>\n<ul>\n<li>RVA:7A7A即为RAW:6E7A。</li>\n<li>文件偏移6E7A最初的2个字节值(000F)为Ordinal，是库中函数的固有编号。</li>\n<li>Ordinal的后面为函数名称字符串PageSetupDlgW</li>\n<li>同C语言一样，字符串末尾以TerminatingNULL[‘\\0’]结束)</li>\n</ul>\n<p><strong>Q：这个值是干啥用的？</strong></p>\n<ul>\n<li><p>也就是上面INT数组的每个指针，都指向了一个IMAGE_IMPORT_BY_NAME结构体</p>\n</li>\n<li><p>参考下图，数组的第一个元素指向函数的Ordinal值000F后面函数的名称为PageSetupDlgW。</p>\n</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231023224546789.png\" alt=\"image-20231023224546789\"></p>\n<ol start=\"4\">\n<li><em><strong>FirstThunk-IAT（Import Access Table）</strong></em></li>\n</ol>\n<ul>\n<li>根据上表，IAT的RVA：12C4也就是RAW：6C4</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024141550654.png\" alt=\"image-20231024141550654\"></p>\n<ul>\n<li>图13-17中文件偏移6C4~6EB区域即为IAT数组区域，对应于comdlg32.dll库。</li>\n<li>它与INT类似由结构体指针数组组成，且以NULL结尾。</li>\n<li>IAT的第一个元素值被硬编码为<code>76324906</code>，该值无实际意义，notepad.exe文件加载到内存时准确的地址值会取代该值。</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024142227720.png\" alt=\"image-20231024142227720\"></p>\n<p>由于notepad.exe的ImageBase值为01000000，所以config32.dll.PageSetypDlgW是实际地址就是010012C4</p>\n<h2 id=\"13-6-EAT\"><a href=\"#13-6-EAT\" class=\"headerlink\" title=\"13.6 EAT\"></a>13.6 EAT</h2><p><strong>Q1：为什么有这个呢？</strong></p>\n<ul>\n<li>前面的IAT是为了记录程序中使用了哪些库的哪些函数，也就是一个程序内部的事</li>\n<li>但是如果多个程序要使用库呢？</li>\n</ul>\n<p>Windows操作系统中，“库”是为了方便其他程序调用而集中包含相关函数的文件(DLL&#x2F;SYS)。</p>\n<p>Win32API是最具代表性的库，其中的kernel32.dll文件被称为最核心的库文件。</p>\n<p>EAT是一种核心机制它使不同的应用程序可以调用库文件中提供的函数。</p>\n<p>也就是说，只有通过EAT才能准确求得从相应库中导出函数的起始地址。</p>\n<p>与前面讲解的IAT一样，PE文件内的特定结构体(IMAGE_EXPORT_DIRECTORY)保存导出信息，且PE文件中仅有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>用来说明IAT的IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且拥有多个成员。这样是因为PE文件可以同时导入多个库。</p>\n\n</div>\n<p><strong>Q2：IMAGE_EXPORT_DIRECTORY在PE中的哪个位置？</strong></p>\n<ul>\n<li><p>可以在PE文件的PE头中查找到IMAGE_EXPORT_DIRECTORY结构体的位置。</p>\n</li>\n<li><p>IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress值即是IMAGE_EXPORT_DIRECTORY结构体数组的起始地址(也是RVA的值)。<br>图13-20显示的是kernel32dll文件的IMAGE_OPTIONAL_HEADER32.DataDirectory[0]</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143316972.png\" alt=\"image-20231024143316972\"></p>\n</li>\n<li><p>这个深色框中的内容是DataDirectory[0]，也就是IMAGE_EXPORY_DIRECTORY</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143459178.png\" alt=\"image-20231024143459178\"></p>\n</li>\n<li><p>由于RVA值为262C，文件偏移为1A2C。</p>\n</li>\n</ul>\n<h3 id=\"13-6-1-IMAGE-EXPORT-DIRECTORY\"><a href=\"#13-6-1-IMAGE-EXPORT-DIRECTORY\" class=\"headerlink\" title=\"13.6.1 IMAGE_EXPORT_DIRECTORY\"></a>13.6.1 IMAGE_EXPORT_DIRECTORY</h3><p> IMAGE_EXPORT_DIRECTORY的结构体如下：</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143752225.png\" alt=\"image-20231024143752225\"></p>\n<p>其中的重要成员就是上图中的红框</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143704255.png\" alt=\"image-20231024143704255\"></p>\n<p> IMAGE_EXPORT_DIRECTORY的结构体和整个EAT结构：</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024143831948.png\" alt=\"image-20231024143831948\"></p>\n<p><strong>Q：上面PE导入函数至IAT中提到了<em>获取函数的地址</em></strong></p>\n<hr>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024144501442.png\" alt=\"image-20231024144501442\"></p>\n<hr>\n<p>这个API GetProcAddress()就是使用EAT来获取指定函数的地址</p>\n<p><strong>Q：那如何获取？</strong></p>\n<p>GetProcAddress()操作原理</p>\n<ul>\n<li>利用AddressOfNames成员转到函数名称数组</li>\n<li>函数名称数组中存储着字符串地址。通过比较(strcmp)字符串，查找指定的函数名称(此时数组的索引称为name_index)。</li>\n<li>利用AddressOfNameOrdinals成员，转到orinal数组</li>\n<li>在ordinal数组中通过name_index查找相应ordinal值。</li>\n<li>利用AddressOfFunctions成员转到“函数地址数组”(EAT)。</li>\n<li>在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址。</li>\n</ul>\n<h3 id=\"13-6-2-使用kernel32-dll练习\"><a href=\"#13-6-2-使用kernel32-dll练习\" class=\"headerlink\" title=\"13.6.2 使用kernel32.dll练习\"></a>13.6.2 使用kernel32.dll练习</h3><p><strong>目标：从kernel32.dll文件中查找AddAtomW函数</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024150238015.png\" alt=\"image-20231024150238015\"></p>\n<p>深色部分就是IMAGE_EXPORT_DIRECTORY</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024150427544.png\" alt=\"image-20231024150427544\"></p>\n<ol>\n<li><strong>函数名称数组</strong></li>\n</ol>\n<ul>\n<li>AddressOfNames成员的值为RVA&#x3D;353C，即RAW&#x3D;293C。使用Hex Editor查看该地址</li>\n</ul>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024150625450.png\" alt=\"image-20231024150625450\"></p>\n<ul>\n<li>数组元素个数为NumberOfNames，3BA</li>\n</ul>\n<ol start=\"2\">\n<li><strong>查找指定函数名称</strong></li>\n</ol>\n<ul>\n<li><p>要查找的函数名称字符串为AddAtomW。</p>\n</li>\n<li><p>只要在图13-23中找到RVA数组第三个元素的值(RVA:4BBD-&gt;RAW:3FBD) 即可。也就是粗线框中的</p>\n</li>\n<li><p>进入相应地址就会看到“AddAtomw”字符串，如图13-24所示。</p>\n</li>\n<li><p>此时“AddAtomw”函数名即是图13-23数组的第三个元素，数组索引为2。</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024151618743.png\" alt=\"image-20231024151618743\"></p>\n</li>\n</ul>\n<p>我理解这个过程应该就是字符串匹配。</p>\n<ol start=\"3\">\n<li><strong>Ordinal数组</strong></li>\n</ol>\n<ul>\n<li><p>通过上面的数组索引获得ordinal的值。</p>\n</li>\n<li><p>AddressOfNameOrdinal的值是3824。深色部分是由多个2字节组成的数组，ordinal数组的各元素大小为2bytes</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024152259346.png\" alt=\"image-20231024152259346\"></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li><strong>ordinal</strong></li>\n</ol>\n<ul>\n<li>根据索引是2，获取<code>0002</code></li>\n</ul>\n<ol start=\"5\">\n<li><strong>函数地址数组EAT</strong></li>\n</ol>\n<ul>\n<li><p>查找函数的实际地址，AddressOfFunctions成员的值是1A54</p>\n</li>\n<li><p>通过ordinal的值2，找到实际的函数地址，<code>000326F1</code></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024152630389.png\" alt=\"image-20231024152630389\"></p>\n</li>\n</ul>\n<ol start=\"6\">\n<li><strong>AddAtomW函数地址</strong></li>\n</ol>\n<ul>\n<li><p>此时已经得到<code>Orinal=2 AddressOfFunctions=00326F1 </code></p>\n</li>\n<li><p>kernel32.dll的<code>lmageBase=7C7D0000</code>。因此AddAtomw函数的实际地址(VA)为<code>ImageBase+AddressOfFunctions(RVA)=7C8026F1</code></p>\n</li>\n<li><p>使用OllyDbg查看地址，即可发现该函数</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024153021278.png\" alt=\"image-20231024153021278\"></p>\n</li>\n</ul>\n<p><strong>上述的整个过程就是GetProcAddress() API获取函数地址的方法</strong></p>\n<h2 id=\"关于IAT-import-和EAT-export\"><a href=\"#关于IAT-import-和EAT-export\" class=\"headerlink\" title=\"关于IAT(import)和EAT(export)\"></a>关于IAT(import)和EAT(export)</h2><p>Import：记录导入当前程序中的函数，相对于当前程序而言</p>\n<p>Export：导出，从库中导出，相对于库而言，记录了从库中导出函数实际的地址。</p>\n<h2 id=\"13-7-高级PE\"><a href=\"#13-7-高级PE\" class=\"headerlink\" title=\"13.7 高级PE\"></a>13.7 高级PE</h2><h3 id=\"13-7-1-PEView-exe\"><a href=\"#13-7-1-PEView-exe\" class=\"headerlink\" title=\"13.7.1 PEView.exe\"></a>13.7.1 PEView.exe</h3><p><a href=\"http://www.magma.ca/~wjr/PEView.zip\">http://www.magma.ca/~wjr/PEView.zip</a></p>\n<p>好像失效了</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024153338466.png\" alt=\"image-20231024153338466\"></p>\n<ul>\n<li>在这里可以看到各种PE头的信息，很直观</li>\n</ul>\n<h3 id=\"13-7-2-Patched-PE\"><a href=\"#13-7-2-Patched-PE\" class=\"headerlink\" title=\"13.7.2 Patched PE\"></a>13.7.2 Patched PE</h3><p>只要文件符合PE规范就是PE文件，因此可以做出一些很有创意的PE文件。</p>\n<p><a href=\"http://www.phreedom.org/solar/code/tinype\">http://www.phreedom.org/solar/code/tinype</a></p>\n<p>这个网站记录了PE头和tiny pe的制作过程，下载下来分析对提高逆向很有帮助。</p>\n<h2 id=\"13-8-小结\"><a href=\"#13-8-小结\" class=\"headerlink\" title=\"13.8 小结\"></a>13.8 小结</h2><ul>\n<li>PE规范只是一种标准规范(许多东西都没使用)</li>\n</ul>\n<p><strong>Q：前面的讲解中提到,执行文件加载到内存时会根据Imagebase确定地址,那么2个notepad程序同时运行时Imagebase都是10000000，它们会侵占彼此的空间区域，不是这样吗?</strong></p>\n<ul>\n<li>生成进程(加载到内存)时，OS会单独为它分配4GB大小的虚拟内存。</li>\n<li>虚拟内存与实际物理内存是不同的。同时运行2个notepad时，各进程分别在自身独有的虚拟内存空间中。</li>\n<li>所以它们彼此不会重叠。这是由OS来保障的。因此，即使它们的Imagebase一样也完全没问题。</li>\n</ul>\n<p><strong>Q：如何只用HexEditor识别出DOS存根、IMAGE_FILE_HEADER等部分呢?</strong></p>\n<ul>\n<li>根据PE规范，IMAGE DOSHEADER的大小为40个字节，DOS存根区域为40~PE签名区域。</li>\n<li>紧接在PE签名后的是IMAGE_FILE_HEADER，且该结构体的大小是已知的，所以也可以在Hex Editor中表示出来</li>\n<li>也就是说，解析PE规范中定义的结构体及其成员的含义即可区分出各组成部分(多看几次就熟悉了)。</li>\n</ul>\n<p><strong>Q：IMAGE_FILE_HEADER的TimeDateStamp值为0x47918EA2，在PEView中显示为2008&#x2F;01&#x2F;19,05:46:10 UTC，如何才能这样解析出来呢?</strong></p>\n<ul>\n<li>使用C语言标准库中提供的ctime()函数,即可把4个字节的数字转换为实际的日期字符串。</li>\n</ul>\n<p><strong>Q：PE映像是什么?</strong></p>\n<ul>\n<li>PE映像这一术语是微软创建PE结构时开始使用的。一般是指PE文件运行时加载到内存中的形态。</li>\n<li>PE头信息中有一个SizeOflmage项，该项指出了PE映像所占内存的大小。</li>\n<li>当然这个大小与文件的大小不一样。PE文件格式妙处之一就在于，其文件形态与内存形态是不同的。</li>\n</ul>\n<p><strong>Q：不太明白EP这一概念</strong></p>\n<ul>\n<li>EP地址是程序中最早被执行的代码地址。CPU会最先到EP地址处，并从该处开始依次执行指令。</li>\n</ul>\n<p><strong>Q：用PEView打开记事本程序(notepad.exe)后，发现各节区的起始地址、大小等与示例中的不同，为什么会这样呢?</strong></p>\n<ul>\n<li>notepad.exe文件随OS版本的不同而不同(其他所有系统文件也如此)。</li>\n<li>换言之，不同版本的OS下，系统文件的版本也是不同的。</li>\n<li>微软可能修改了代码、更改了编译选项，重新编译后再发布。</li>\n</ul>\n<p><strong>Q：对图13-9及其下面的Quiz不是很理解。如何知道RVA 5000包含在哪个节区呢?</strong></p>\n<ul>\n<li>图13-9是以节区头信息为基础绘制的。图(或节区头信息)中的.text节区是指VA 01001000~01009000区域</li>\n<li>转换为RVA形式后对应于RVA 1000~9000区域(即减去Imagebase值的01000000)。</li>\n<li>由此可知，RVA5000包含在text节区中。</li>\n</ul>\n<p><strong>Q：查看某个文件时，发现其IMAGE_IMPORT_DESCRIPTOR结构体的OriginalFirstThunk成员为NULL，跟踪FirstFThunk成员，看到一个实际使用的API的名称字符串数组(INT)。跟踪FirstThunk应该看到的是IAT而不是INT，这是怎么回事呢?</strong></p>\n<ul>\n<li>PE装载器无法根据OriginalFirstThunk查找到API名称字符串数组(INT)时，就会尝试用FirstThunk查找。</li>\n<li>本来FirstThunk含义为IAT，但在实际内存中被实际的API函数地址覆盖掉了(此时INT与IAT虽然是相同区域，但仍然能够正常工作)。</li>\n</ul>\n<p><strong>Q：EAT讲解中提到的Ordinal究竟是什么?</strong></p>\n<ul>\n<li><p>把Ordinal想成导出函数的固有编号就可以了。</p>\n</li>\n<li><p>有时候某些函数对外不会公开函数名，仅公开函数的固有编号(Ordinal)。导入并使用这类函数时，要先用Ordinal查找到相应函数的地址后再调用。</p>\n</li>\n<li><p>比如下面(1)通过函数名称来获取函数地址，(2)则使用函数的Ordinal来取得函数地址。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(1)pFunc&#x3D;GetProcAddress(“TestFunc”);\n(2)pFunc&#x3D;GetProcAddress(5);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>这一章学的内容一定要反复看，反复理解。</li>\n<li>虚拟内存的概念，好久之前学的操作系统，已经完全忘记了。</li>\n</ul>\n<h1 id=\"0x14-运行时压缩\"><a href=\"#0x14-运行时压缩\" class=\"headerlink\" title=\"0x14 运行时压缩\"></a>0x14 运行时压缩</h1><p>运行时压缩器(Run-Time Packer)</p>\n<h2 id=\"14-1-数据压缩\"><a href=\"#14-1-数据压缩\" class=\"headerlink\" title=\"14.1 数据压缩\"></a>14.1 数据压缩</h2><p>经过压缩的文件若能100%恢复，则称该压缩为<strong>无损压缩(Lossless Data Compression)</strong></p>\n<p>若不能恢复原状，则称该压缩为<strong>有损压缩(Loss Data Compression)</strong></p>\n<h3 id=\"14-1-2-有损压缩\"><a href=\"#14-1-2-有损压缩\" class=\"headerlink\" title=\"14.1.2 有损压缩\"></a>14.1.2 有损压缩</h3><p>有损压缩允许压缩文件(数据)时损失一定信息，以此换取高压缩率。</p>\n<p>压缩多媒体文件(jpg、mp3、mp4)时，大部分都使用这种有损压缩方式。</p>\n<p>从压缩特性来看，有损压缩的数据解压缩后不能完全恢复原始数据。人类的肉眼与听觉几乎无法察觉到这些多媒体文件在压缩中损失的数据。经过有损压缩后，虽然压缩文件与原文件(从数据层面上看存在差异，但重要的是人们几乎区分不出这种微小的差别。</p>\n<p>以mp3文件为例，mp3的核心算法通过删除超越人类听觉范围(20~20000Hz)的波长区段来缩减(不需要的)数据大小。</p>\n<h2 id=\"14-2-运行时压缩器\"><a href=\"#14-2-运行时压缩器\" class=\"headerlink\" title=\"14.2 运行时压缩器\"></a>14.2 运行时压缩器</h2><p>运行时压缩器是针对可执行(PE Portable Executable)文件而言的。</p>\n<p>可执行文件内部含有解压缩代码，文件在运行瞬间于内存中解压缩后执行。</p>\n<p>运行时压缩文件也是PE文件，<strong>内部含有原PE文件与解码程序</strong>。在程序的EP代码中执行解码程序，同时在内存中解压缩后执行。</p>\n<p><strong>Q：表14-1列出了运行时压缩与普通ZIP压缩的不同点。</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172119574.png\" alt=\"image-20231024172119574\"></p>\n<ul>\n<li>与普通压缩器相比，运行时压缩器的一个明显不同是<strong>PE文件的可运行性</strong>。</li>\n</ul>\n<p><strong>Q：压缩器和保护器</strong></p>\n<ul>\n<li>把普通PE文件创建成运行时压缩文件的实用程序称为“压缩器”(Packer)，经反逆向(Anti-Reversing)技术特别处理的压缩器称为保护器(Protector)。</li>\n</ul>\n<h3 id=\"14-2-1-压缩器\"><a href=\"#14-2-1-压缩器\" class=\"headerlink\" title=\"14.2.1 压缩器\"></a>14.2.1 压缩器</h3><p>PE压缩器是指可执行文件的压缩器，准确一点应该称为“运行时压缩器”，它是PE文件的专用压缩器。</p>\n<p><strong>Q：使用压缩器的目的</strong></p>\n<ul>\n<li>便于传输</li>\n<li>隐藏代码</li>\n</ul>\n<p><strong>Q：压缩器种类</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172315794.png\" alt=\"image-20231024172315794\"></p>\n<h3 id=\"14-2-2-保护器\"><a href=\"#14-2-2-保护器\" class=\"headerlink\" title=\"14.2.2 保护器\"></a>14.2.2 保护器</h3><p><strong>Q：保护器的概念和作用</strong></p>\n<ul>\n<li>PE保护器是一类保护PE文件免受代码逆向分析的实用程序。</li>\n<li>它们不像普通的压缩器一样仅对PE文件进行运行时压缩，而应用了多种防止代码逆向分析的技术(反调试、反模拟、代码混乱、多态代码、垃圾代码、调试器监视）等。</li>\n<li>这类保护器使压缩后的PE文件尺寸反而比源文件要大一些，调试起来非常难。</li>\n<li>分析保护器的关键是<strong>OEP(OrigialEntry Point，原始人口点)</strong></li>\n</ul>\n<p><strong>Q：保护器种类</strong></p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172624533.png\" alt=\"image-20231024172624533\"></p>\n<h2 id=\"14-3-运行时压缩测试\"><a href=\"#14-3-运行时压缩测试\" class=\"headerlink\" title=\"14.3 运行时压缩测试\"></a>14.3 运行时压缩测试</h2><p>可以用upx压缩notepad.exe</p>\n<p><strong>Q：运行时压缩的特点</strong></p>\n<ul>\n<li>运行时压缩后的文件尺寸明显减小了(67584-&gt;48128)。若使用ZIP压缩，则文件大小缩减为35231。</li>\n<li>也就是说，运行时的压缩率要比普通的ZIP压缩低。</li>\n<li>这是<strong>由于其压缩后得到的是PE文件，需要添加PE头，并且还要放入解压缩代码</strong></li>\n</ul>\n<p><strong>Q：比较notepad.exe和notepad_upx.exe文件</strong></p>\n<p>该图是从PE视角进行比较</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024172855851.png\" alt=\"image-20231024172855851\"></p>\n<ul>\n<li>PE头的大小一样(0~400h)。h表示16进制</li>\n<li>节区名称改变(“text”一&gt;“UPX0”，“.data”一&gt;“UPX1”)</li>\n<li>第一个节区的RawDataSize&#x3D;0(文件中的大小为0)。</li>\n<li>EP位于第二个节区(原notepad.exe的EP在第一个节区)</li>\n<li>资源节区(.rsrc)大小几乎无变化。</li>\n</ul>\n<p><strong>Q：upx0的RawDataSize为0，upx为何要创建这个空的节区呢？</strong></p>\n<p>使用PEview查看notepad_upx.exe</p>\n<p><img src=\"/../re-engineer-core-principle-02/image-20231024173157434.png\" alt=\"image-20231024173157434\"></p>\n<ul>\n<li>这里发现Virtual Size，也就是内存中的大小是106000，而Size of Raw Data，磁盘中的大小是00000000</li>\n<li>也就是说在内存中解压缩时，会把文件中压缩状态的源代码解压到(内存中的)第一个节区。</li>\n<li>也就是在文件状态下，最开始解压缩代码和压缩的源代码都在第二个节区，文件运行时首先执行解压缩代码，把处于压缩状态的源代码解压到第一个节区。</li>\n<li>解压过程结束后即运行源文件的EP代码。</li>\n</ul>\n","feature":true,"text":"引言 开启《逆向工程核心原理》的第二部分，冲冲冲！ 0x13 PE文件格式13.1 介绍PE(Portable excutable)是Windows操作系统下使用的可执行文件格式。 PE文件指的是32位的可执行文件，也成为PE32。64位的可执行文件称为PE+或PE32+，是PE...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":2,"path":"api/tags/re.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x13-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">0x13 PE文件格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-1-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">13.1 介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-2-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">13.2 PE文件格式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-2-2-VA-RVA\"><span class=\"toc-text\">13.2.2 VA&amp;RVA</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-3-PE%E5%A4%B4\"><span class=\"toc-text\">13.3 PE头</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-1-DOS%E5%A4%B4\"><span class=\"toc-text\">13.3.1 DOS头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-2-DOS%E5%AD%98%E6%A0%B9\"><span class=\"toc-text\">13.3.2 DOS存根</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-3-NT%E5%A4%B4%EF%BC%88IMAGE-NT-HEADERS%EF%BC%89\"><span class=\"toc-text\">13.3.3 NT头（IMAGE_NT_HEADERS）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#NT%E5%A4%B4%EF%BC%9A%E6%96%87%E4%BB%B6%E5%A4%B4%EF%BC%88FileHeader%EF%BC%89\"><span class=\"toc-text\">NT头：文件头（FileHeader）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#OptionalHeader\"><span class=\"toc-text\">OptionalHeader</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3-6-%E8%8A%82%E5%8C%BA%E5%A4%B4\"><span class=\"toc-text\">13.3.6 节区头</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-4-RVA-to-RAW\"><span class=\"toc-text\">13.4 RVA to RAW</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-5-IAT\"><span class=\"toc-text\">13.5 IAT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-5-1-DLL\"><span class=\"toc-text\">13.5.1 DLL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-5-2-IMAGE-IMPORT-DESCRIPTOR\"><span class=\"toc-text\">13.5.2 IMAGE_IMPORT_DESCRIPTOR</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-5-3-%E4%BD%BF%E7%94%A8notepad-exe%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">13.5.3 使用notepad.exe练习</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-6-EAT\"><span class=\"toc-text\">13.6 EAT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-6-1-IMAGE-EXPORT-DIRECTORY\"><span class=\"toc-text\">13.6.1 IMAGE_EXPORT_DIRECTORY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-6-2-%E4%BD%BF%E7%94%A8kernel32-dll%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">13.6.2 使用kernel32.dll练习</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8EIAT-import-%E5%92%8CEAT-export\"><span class=\"toc-text\">关于IAT(import)和EAT(export)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-7-%E9%AB%98%E7%BA%A7PE\"><span class=\"toc-text\">13.7 高级PE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-7-1-PEView-exe\"><span class=\"toc-text\">13.7.1 PEView.exe</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-7-2-Patched-PE\"><span class=\"toc-text\">13.7.2 Patched PE</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-8-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">13.8 小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0x14-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">0x14 运行时压缩</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-1-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">14.1 数据压缩</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-1-2-%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">14.1.2 有损压缩</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9%E5%99%A8\"><span class=\"toc-text\">14.2 运行时压缩器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-2-1-%E5%8E%8B%E7%BC%A9%E5%99%A8\"><span class=\"toc-text\">14.2.1 压缩器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-2-2-%E4%BF%9D%E6%8A%A4%E5%99%A8\"><span class=\"toc-text\">14.2.2 保护器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-3-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">14.3 运行时压缩测试</span></a></li></ol></li></ol>","author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"re-engineer-core-principle-01","uid":"e67072c96c2129e60add5b77588d8afa","slug":"re-engineer-core-principle-01","date":"2023-10-22T08:36:19.000Z","updated":"2023-10-22T08:36:50.636Z","comments":true,"path":"api/articles/re-engineer-core-principle-01.json","keywords":null,"cover":[],"text":"引言看《逆向工程核心原理》这本书 好久之前看了这本书的一部分，现在决定重新学一下。 感觉逆向十分重要，且我的hxd wd-2711 (https://wd-2711.tech/) ，一直在学逆向，在他的感染下，我也开始学。 0x01 关于逆向工程 静态分析法：并不执行代码，观察代...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"re","slug":"re","count":2,"path":"api/tags/re.json"}],"author":{"name":"XyM4ster","slug":"blog-author","avatar":"/images/picture.jpg","link":"/","description":"热爱网络安全的BITer","socials":{"github":"https://github.com/XyM4ster","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}